#include "search_space.h"
#include "state.h"
#include "operator.h"

#include <cassert>
#include <ext/hash_map>
using namespace std;
using namespace __gnu_cxx;


class SearchNodeInfo {
    friend class SearchNode;
    friend class SearchSpace;

    enum NodeStatus {NEW = 0, OPEN = 1, CLOSED = 2, DEAD_END = 3};

    /*
      NodeStatus status;
      int g;
      int h;
    */

    unsigned int status: 2;
    int h: 30;
    int g;
    const unsigned char *parent_state;
    const Operator *creating_operator;

    SearchNodeInfo()
	: status(NEW), g(-1), h(-1), parent_state(0), creating_operator(0) {
    }

};


class StateProxy {
    // This class is basically a pointer that can be reassigned even
    // though it is const. This is needed for the hash table below,
    // where a node may first be inserted with a pointer to a
    // temporary object as the key, which will then later be replaced
    // with a pointer to a heap-allocated object generated by
    // make_permanent below.
    // Despite the const-ness, mutating the key of a hash_map in place
    // is fine as long as the mutation does not affect the hash value
    // (which this one does not, as it only changes the address of the
    // state, whereas the contents of the state are used for hashing).

    // Update: This was changed from a State* to an unsigned char*
    //         that points "inside" the state to shave off some memory.
public:
    mutable unsigned char *state_data;

    StateProxy() {
        state_data = 0;
    }

    StateProxy(unsigned char *state_data_) {
        state_data = state_data_;
    }

    explicit StateProxy(const State *state) {
        state_data = const_cast<unsigned char *>(state->get_buffer());
    }

    const StateProxy &operator=(const StateProxy &other) const {
	state_data = other.state_data;
	return *this;
    }
    bool operator==(const StateProxy &other) const {
        return State(state_data) == State(other.state_data);
    }
    void make_permanent() const {
        unsigned char *new_buffer = new unsigned char[g_variable_domain.size()];
	for(int i = 0; i < g_variable_domain.size(); i++)
	  new_buffer[i] = state_data[i];
	state_data = new_buffer;
    }
};

namespace __gnu_cxx {
    template<>
    struct hash<StateProxy> {
        size_t operator()(const StateProxy &state_proxy) const {
	    return State(state_proxy.state_data).hash();
	}
    };
}


SearchNode::SearchNode(unsigned char *state_buffer_, SearchNodeInfo &info_)
    : state_buffer(state_buffer_), info(info_) {
}

State SearchNode::get_state() const {
    return State(state_buffer);
}

bool SearchNode::is_goal() const {
    State s = State(state_buffer);
    for(int i = 0; i < g_goal.size(); i++)
	if(s[g_goal[i].first] != g_goal[i].second)
	    return false;
    return true;
}

bool SearchNode::is_open() const {
    return info.status == SearchNodeInfo::OPEN;
}

bool SearchNode::is_closed() const {
    return info.status == SearchNodeInfo::CLOSED;
}

bool SearchNode::is_dead_end() const {
    return info.status == SearchNodeInfo::DEAD_END;
}

int SearchNode::get_f() const {
    return info.g + info.h;
}

int SearchNode::get_g() const {
    return info.g;
}

int SearchNode::get_h() const {
    return info.h;
}

void SearchNode::open_initial(int h) {
    assert(info.status == SearchNodeInfo::NEW);
    info.status = SearchNodeInfo::OPEN;
    info.g = 0;
    info.h = h;
    info.parent_state = 0;
    info.creating_operator = 0;
}

void SearchNode::open(int h, const SearchNode &parent_node,
		      const Operator *parent_op) {
    assert(info.status == SearchNodeInfo::NEW);
    info.status = SearchNodeInfo::OPEN;
    info.g = parent_node.info.g + parent_op->get_cost();
    info.h = h;
    info.parent_state = parent_node.state_buffer;
    info.creating_operator = parent_op;
}

void SearchNode::reopen(const SearchNode &parent_node,
			const Operator *parent_op) {
    // Must never reopen closed nodes with consistent heuristics.
    assert(info.status == SearchNodeInfo::OPEN);
    info.status = SearchNodeInfo::OPEN;
    info.g = parent_node.info.g + parent_op->get_cost();
    info.parent_state = parent_node.state_buffer;
    info.creating_operator = parent_op;
}

void SearchNode::close() {
    assert(info.status == SearchNodeInfo::OPEN);
    info.status = SearchNodeInfo::CLOSED;
}

void SearchNode::mark_as_dead_end() {
    assert(info.status == SearchNodeInfo::NEW);
    info.status = SearchNodeInfo::DEAD_END;
}

void SearchNode::dump()
{
  cout << state_buffer << ": ";
  State(state_buffer).dump();
  cout << " created by " << info.creating_operator->get_name()
       << " from " << info.parent_state << endl;
}

class SearchSpace::HashTable
    : public __gnu_cxx::hash_map<StateProxy, SearchNodeInfo> {
    // This is more like a typedef really, but we need a proper class
    // so that we can hide the information in the header file by using
    // a forward declaration. This is also the reason why the hash
    // table is allocated dynamically in the constructor.
};


SearchSpace::SearchSpace() {
    nodes = new HashTable;
}

SearchSpace::~SearchSpace() {
    delete nodes;
}

int SearchSpace::size() const {
    return nodes->size();
}

SearchNode SearchSpace::get_node(const State &state) {
    static SearchNodeInfo default_info;
    pair<HashTable::iterator, bool> result = nodes->insert(
        make_pair(StateProxy(&state), default_info));
    if(result.second) {
        // This is a new entry: Must give the state permanent lifetime.
        result.first->first.make_permanent();
    }
    HashTable::iterator iter = result.first;
    return SearchNode(iter->first.state_data, iter->second);
}

void SearchSpace::trace_path(const State &goal_state,
                             vector<const Operator *> &path) const {
    StateProxy current_state(&goal_state);
    assert(path.empty());
    for(;;) {
	HashTable::const_iterator iter = nodes->find(current_state);
	assert(iter != nodes->end());
	const SearchNodeInfo &info = iter->second;
        const Operator *op = info.creating_operator;
	if(op == 0)
	    break;
	path.push_back(op);
        current_state = StateProxy(const_cast<unsigned char *>(info.parent_state));
    }
    reverse(path.begin(), path.end());
}

void SearchSpace::dump()
{
  int i = 0;
  for (HashTable::iterator iter = nodes->begin(); iter != nodes->end(); iter++) {
    cout << "#" << i++ << " (" << iter->first.state_data << "): ";
    State(iter->first.state_data).dump();
    if (iter->second.creating_operator &&
	iter->second.parent_state) {
      cout << " created by " << iter->second.creating_operator->get_name()
	   << " from " << iter->second.parent_state << endl;
    }
    else {
      cout << "has no parent" << endl;
    }
  }
}

void SearchSpace::statistics() const {
  cout << "search space hash size: " << nodes->size() << endl;
  cout << "search space hash bucket count: " << nodes->bucket_count() << endl;
}
