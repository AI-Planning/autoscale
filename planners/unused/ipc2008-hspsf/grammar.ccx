#include <stdio.h>
#include <stdlib.h>
#include <string.h>
inline char* strndup(char* s, unsigned int n)
{
  char* d = new char[n+1];
  strncpy(s, d, n);
  return d;
}
#include <assert.h>
#include <limits.h>
#include <vector>
#include <utility>
#include <iostream>
namespace hsps {
typedef unsigned int index_type;
const index_type index_type_max = (UINT_MAX - 1);
const index_type LARGE_PRIME = 2147483629U;
const index_type no_such_index = UINT_MAX;
typedef unsigned long count_type;
const count_type count_type_max = ULONG_MAX;

template<class T> class swapable_pair : public std::pair<T, T>
{
 public:
  swapable_pair()
    : std::pair<T, T>() { };
  swapable_pair(const T& v1, const T& v2)
    : std::pair<T, T>(v1, v2) { };
  swapable_pair(const T& v)
    : std::pair<T, T>(v, v) { };
  swapable_pair(const swapable_pair& p)
    : std::pair<T, T>(p) { };

  void swap();
};

template<class T> class comparable_pair : public swapable_pair<T>
{
 public:
  comparable_pair()
    : swapable_pair<T>() { };
  comparable_pair(const T& v1, const T& v2)
    : swapable_pair<T>(v1, v2) { };
  comparable_pair(const T& v)
    : swapable_pair<T>(v) { };
  comparable_pair(const comparable_pair& p)
    : swapable_pair<T>(p) { };

  void sort_ascending();
  void sort_descending();
};

typedef comparable_pair<index_type> index_pair;

template<class T> class zero_init_pair : public comparable_pair<T>
{
 public:
  zero_init_pair()
    : comparable_pair<T>(0) { };
  zero_init_pair(const T& v1, const T& v2)
    : comparable_pair<T>(v1, v2) { };
  zero_init_pair(const T& v)
    : comparable_pair<T>(v) { };
  zero_init_pair(const zero_init_pair& p)
    : comparable_pair<T>(p) { };
};




class index_set;
class bool_vec;

template<class T> class lvector : public std::vector<T>
{
 public:
  lvector() : std::vector<T>() { };
  lvector(const T& v, index_type l) : std::vector<T>(l, v) { };
  lvector(const lvector<T>& vec) : std::vector<T>(vec) { };




  class element_reference {
    lvector* _vec;
    index_type _pos;
  public:
    element_reference() : _vec(0), _pos(no_such_index) { };
    element_reference(lvector& v, index_type p) : _vec(&v), _pos(p) { };
    operator T*() const {
      if (_vec == 0) return 0;
      return &((*_vec)[_pos]);
    };
  };

  class order {
   public:
    virtual bool operator()(const T& v0, const T& v1) const = 0;
  };

  index_type length() const;
  bool contains(const T& v) const;
  index_type first(const T& v) const;
  index_type next(const T& v, index_type i) const;
  index_type find(const T& v, bool_vec& s) const;
  index_type count(const T& v) const;
  index_type arg_max() const;
  index_type arg_min() const;
  index_type arg_first(const order& o) const;
  index_type arg_last(const order& o) const;
  index_pair first_common(const lvector<T>& vec) const;
  index_pair next_common(const lvector<T>& vec, index_pair p) const;
  void difference(const lvector& v1, lvector& d0, lvector& d1);
  bool operator==(const lvector& _vec) const;
  bool operator!=(const lvector& _vec) const;
  bool operator<(const lvector& vec) const;
  bool operator>(const lvector& vec) const;
  bool operator<=(const lvector& vec) const;
  bool operator>=(const lvector& vec) const;
  void assign_copy(const lvector& _vec);
  void assign_copy(const T* _arr, index_type n);
  void assign_value(const T& val);
  void assign_value(const T& val, index_type l);
  void assign_remap(const lvector& vec, const lvector<index_type>& map);
  void remap(const lvector<index_type>& map);
  void assign_select(const lvector& _vec, const index_set& s);
  void assign_select(const lvector& _vec, const bool_vec& s);
  const lvector& operator=(const lvector& _vec);
  void set_length(index_type l);
  void set_length(index_type l, const T& v);
  void inc_length_to(index_type l);
  void inc_length_to(index_type l, const T& v);
  index_type inc_length() { return inc_length(1); };
  index_type inc_length(index_type d);
  index_type inc_length(index_type d, const T& v);
  index_type dec_length() { return dec_length(1); };
  index_type dec_length(index_type d);
  void clear();
  void append(const T& v);
  void append(const lvector& v);
  T& append();
  void insert(const T& v, index_type p);
  index_type insert_ordered(const T& v, const order& o, index_type f = 0);
  index_type insert_ordered(const lvector& vec, const order& o);
  void remove(index_type p);
  void remove(index_type p0, index_type p1);
  void remove(const index_set& s);
  void remove(const index_set& s, lvector<index_type>& map);
  void remove(const bool_vec& s);
  void remove(const bool_vec& s, lvector<index_type>& map);
  void remove_duplicate_elements();
  void swap(index_type i, index_type j);
};
template<class T> class auto_expanding_vector : public lvector<T>
{
  T _default;
 public:
  auto_expanding_vector() : lvector<T>() { };
  auto_expanding_vector(const T& v, index_type l)
    : lvector<T>(v, l), _default(v) { };
  auto_expanding_vector(const lvector<T>& vec)
    : lvector<T>(vec) { };
  auto_expanding_vector(const auto_expanding_vector<T>& vec)
    : lvector<T>(vec), _default(vec._default) { };
  typename std::vector<T>::reference
  operator[](typename std::vector<T>::size_type k)
  {
    this->inc_length_to(k + 1, _default);
    return lvector<T>::operator[](k);
  };
  typename std::vector<T>::const_reference
  operator[](typename std::vector<T>::size_type k) const
  {
    if (k >= std::vector<T>::size())
      return _default;
    else
      return lvector<T>::operator[](k);
  };
  void assign_value(const T& val)
  {
    _default = val;
    lvector<T>::assign_value(val);
  };
  void assign_value(const T& val, index_type l)
  {
    _default = val;
    lvector<T>::assign_value(val, l);
  };
};
typedef lvector<index_type> index_vec;
typedef lvector<index_pair> pair_vec;
class index_vec_util : public index_vec
{
 public:
  class decreasing_index_order : public index_vec::order {
  public:
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      { return (v0 > v1); };
  };
  class increasing_index_order : public index_vec::order {
  public:
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      { return (v0 < v1); };
  };
  class increasing_value_order : public index_vec::order {
    const index_vec& value;
  public:
    increasing_value_order(const index_vec& v) : value(v) { };
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      {
 assert(v0 < value.length());
 assert(v1 < value.length());
 return (value[v0] < value[v1]);
      };
  };
  static class decreasing_index_order decreasing;
  static class increasing_index_order increasing;
  static void fill(index_vec& vec, index_type max);
  static index_type min(const index_vec& vec, index_type def = no_such_index);
  static index_type max(const index_vec& vec, index_type def = no_such_index);
  static int compare(const index_vec& v0, const index_vec& v1);
  static index_type hash(const index_vec& vec);
  void fill(index_type max);
  int compare(const index_vec& v1) const;
  index_type hash() const;
};
void factors(index_type n, index_vec& f);
template<class T> class svector : public lvector<T>
{
 public:
  svector() : lvector<T>() { };
  svector(const svector<T>& _svec) : lvector<T>(_svec) { };
  svector(const lvector<T>& _lvec) : lvector<T>() {
    for (index_type k = 0; k < _lvec.size(); k++) insert(_lvec[k]);
  };
  bool contains(const T& v) const;
  bool contains(const svector& vec) const;
  bool subset(const svector& vec) const;
  index_pair first_common(const lvector<T>& vec) const;
  index_pair next_common(const lvector<T>& vec, index_pair p) const;
  index_pair first_common(const svector<T>& vec) const;
  index_pair next_common(const svector<T>& vec, index_pair p) const;
  index_type count_common(const svector& vec) const;
  void assign_singleton(const T& _val);
  void assign_values(const lvector<T>& vec);
  void insert(const T& v);
  void insert(const lvector<T>& vec);
  void intersect(const svector& vec);
  void difference(const svector& vec);
  void subtract(const svector& vec);
  void subtract(const T& v);
};
class index_set : public svector<index_type>
{
 public:
  index_set()
    : svector<index_type>() { };
  index_set(const index_set& _svec)
    : svector<index_type>(_svec) { };
  index_set(const lvector<index_type>& _lvec)
    : svector<index_type>(_lvec) { };
  index_set(const bool* _arr, index_type n);
  index_set(const bool_vec& _vec);
  index_set(const index_set& s0, const index_set& s);
  index_set(const index_set& s0, const bool_vec& s);
  index_set(const index_set& s0, const index_vec& map);
  index_type first_common_element(const index_set& set) const;
  index_type first_common_element(const index_vec& vec) const;
  index_type first_common_element(const bool_vec vec) const;
  index_type first_common_element(const bool* vec, index_type n) const;
  index_type count_common(const index_set& set) const;
  index_type count_common(const bool_vec& set) const;
  bool have_common_element(const index_set& set) const;
  bool have_common_element(const bool_vec& set) const;
  void insert(const index_type& v);
  void insert(const index_vec& vec);
  void insert(const bool_vec& set);
  void intersect(const index_set& vec);
  void intersect(const bool_vec& set);
  void subtract(const index_vec& vec);
  void subtract(const bool_vec& set);
  void subtract(const index_type& v);
  bool* copy_to(bool* s, index_type n) const;
  void fill(index_type to);
  void assign_remap(const index_set& set, const index_vec& map);
  void remap(const index_vec& map);
};
extern const index_set EMPTYSET;
typedef svector<index_pair> pair_set;
class bool_vec : public lvector<bool>
{
 public:
  bool_vec() : lvector<bool>() { };
  bool_vec(bool _val, index_type l) : lvector<bool>(_val, l) { };
  bool_vec(const bool_vec& _vec) : lvector<bool>(_vec) { };
  bool_vec(const bool* _arr, index_type n) : lvector<bool>(false, n) {
    for (index_type k = 0; k < n; k++) {
      if (_arr[k])
 (*this)[k] = true;
      else
 (*this)[k] = false;
    }
  };
  bool_vec(const index_set& set, index_type l);
  void complement();
  void insert(const bool_vec& vec);
  void insert(const index_set& set);
  void intersect(const bool_vec& vec);
  void intersect(const index_set& set);
  void subtract(const bool_vec& vec);
  void subtract(const index_set& set);
  bool subset(const bool_vec& vec) const;
  bool strict_subset(const bool_vec& vec) const;
  bool superset(const bool_vec& vec) const;
  bool strict_superset(const bool_vec& vec) const;
  bool contains(const bool& v) const;
  bool contains(const bool_vec& set) const;
  bool contains(const index_set& set) const;
  bool contains_any(const index_set& set) const;
  index_type first_common_element(const index_set& vec) const;
  index_type first_common_element(const bool_vec vec) const;
  index_type count_common(const bool_vec& vec) const;
  index_type count_common(const index_set& set) const;
  index_set& copy_to(index_set& set) const;
  index_set& insert_into(index_set& set) const;
  index_set& subtract_from(index_set& set) const;
  bool* copy_to(bool* s, index_type n) const;
  int compare(const bool_vec& vec) const;
  index_type hash() const;
};
class index_set_vec : public lvector<index_set>
{
 public:
  index_set_vec()
    : lvector<index_set>() { };
  index_set_vec(const index_set& set, index_type l)
    : lvector<index_set>(set, l) { };
  index_set_vec(index_type l)
    : lvector<index_set>(EMPTYSET, l) { };
  index_set_vec(const index_set_vec& vec)
    : lvector<index_set>(vec) { };
  class decreasing_cardinality_order : public index_set_vec::order {
  public:
    virtual bool operator()
      (const index_set& v0, const index_set& v1) const
      { return (v0.size() > v1.size()); };
  };
  decreasing_cardinality_order decreasing_cardinality;
  index_type minimum_cardinality() const;
  index_type maxmimum_cardinality() const;
  index_type selected_minimum_cardinality(const index_set& sel) const;
  index_type selected_maximum_cardinality(const index_set& sel) const;
  index_type first_minimum_cardinality_set() const;
  index_type first_maxmimum_cardinality_set() const;
  index_type first_superset(const index_set& set) const;
  index_type first_strict_superset(const index_set& set) const;
  index_type first_subset(const index_set& set) const;
  index_type first_strict_subset(const index_set& set) const;
  index_set& union_set(index_set& set) const;
  index_set& selected_union_set(const index_set& sel, index_set& set) const;
  index_set& intersection_set(index_set& set) const;
  void insert_maximal(const index_set& set);
  void insert_minimal(const index_set& set);
  void reduce_to_maximal();
  void reduce_to_minimal();
  void append_if_not_subset(const index_set& set);
  void append_if_not_superset(const index_set& set);
  void append_if_new(const index_set& set);
  void remove_sets_size_le(index_type l);
  void remove_empty_sets();
  void insert_in_all(index_type i);
  void insert_in_all(const index_set& set);
  void subtract_from_all(index_type i);
  void subtract_from_all(const index_set& set);
  void combinations_by_union(const index_set_vec& sv);
  void combinations_by_union(const index_set_vec& sv1,
        const index_set_vec& sv2);
};
template<class T> class matrix : public lvector< lvector<T> >
{
 public:
  typedef lvector<T> row_type;
  matrix()
    : lvector<row_type>() { };
  matrix(const T& _val, index_type r, index_type c)
    : lvector<row_type>(row_type(_val, c), r) { };
  matrix(const matrix& _mat)
    : lvector<row_type>(_mat) { };
  index_type rows() const
  {
    return lvector<row_type>::length();
  };
  index_type columns() const
  {
    if (lvector<row_type>::length() == 0) return 0;
    else return (*this)[0].length();
  };
  void set_size(index_type r, index_type c);
  void assign_value(const T& _val);
  void assign_value(const T& _val, index_type r, index_type c);
};
class bool_matrix : public matrix<bool> {
 public:
  bool_matrix()
    : matrix<bool>() { };
  bool_matrix(const bool& v, index_type r, index_type c)
    : matrix<bool>(v, c, r) { };
  bool_matrix(const bool_matrix& m)
    : matrix<bool>(m) { };
  void complement();
  void insert(const bool_matrix& m);
  void intersect(const bool_matrix& m);
  void subtract(const bool_matrix& m);
  void multiply(const bool_matrix& m0, const bool_matrix& m1);
  void transitive_closure();
};
typedef matrix<index_type> index_matrix;
class mapping : public index_vec
{
 public:
  static void identity_map
    (index_type n, index_vec& map)
    { index_vec_util::fill(map, n); };
  static bool invert_map
    (const index_vec& map, index_vec& inv, index_type m = 0);
  static void delete_index_map
    (index_type n, index_type i, index_vec& map);
  static void compose
    (const index_vec& m0, const index_vec& m1, index_vec& cm);
  static void map_image
    (const index_vec& map, const index_vec& vec, index_vec& img);
  static void inverse_map_image
    (const index_vec& map, index_type x, index_set& img);
  static void inverse_map_image
    (const index_vec& map, const index_set& x, index_set& img);
  static index_type range(const index_vec& map, index_type d);
  mapping()
    : index_vec() { };
  mapping(index_type n)
    : index_vec() { identity_map(n, *this); };
  mapping(index_type n, index_type i, bool out) : index_vec() {
    if (out) delete_index_map(n, i, *this); else assign_value(i, n);
  };
  mapping(const mapping& map)
    : index_vec(map) { };
  void assign_identity(index_type n)
    { identity_map(n, *this); };
  index_type operator()(index_type x) const
    { assert(x < size()); return (*this)[x]; };
  index_vec operator()(const index_vec& vec) const
    { index_vec res; map_image(*this, vec, res); return res; };
  index_vec& inverse(index_type x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  index_vec& inverse(const index_set& x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  bool invert(index_vec& rmap) const
    { return invert_map(*this, rmap); };
  bool invert()
    { index_vec tmp(*this); return invert_map(tmp, *this); };
  index_type range() const
    { return range(*this, length()); };
};
class sparse_mapping : public pair_vec
{
 public:
  static void dense_to_sparse(const index_vec& dm, pair_vec sm);
  static void sparse_to_dense(const pair_vec& sm, index_vec dm);
  static index_type map_image
    (const pair_vec& map, index_type x);
  static void map_image
    (const pair_vec& map, const index_vec& vec, index_vec& img);
  static void inverse_map_image
    (const pair_vec& map, index_type x, index_set& img);
  static void inverse_map_image
    (const pair_vec& map, const index_set& x, index_set& img);
  sparse_mapping()
    : pair_vec() { };
  sparse_mapping(const pair_vec& m)
    : pair_vec(m) { };
  sparse_mapping(const index_vec& m)
    : pair_vec() { dense_to_sparse(m, *this); };
  index_type operator()(index_type x) const
    { return map_image(*this, x); };
  index_vec operator()(const index_vec& vec) const
    { index_vec res; map_image(*this, vec, res); return res; };
  index_set& inverse(index_type x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  index_set& inverse(const index_set& x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
};
class equivalence : public index_vec
{
 public:
  equivalence()
    : index_vec() { };
  equivalence(index_type n)
    : index_vec(no_such_index, n) { index_vec_util::fill(*this, n); };
  equivalence(const equivalence& eq)
    : index_vec(eq) { };
  bool operator()(index_type a, index_type b) const;
  index_type canonical(index_type a) const;
  void extend(index_type a);
  void merge(index_type a, index_type b);
  void merge(const equivalence& eq);
  void merge(const index_set& set);
  void merge(const index_set& sa, const index_set& sb);
  void reset();
  void reset(index_type n);
  void canonical_set(index_set& set) const;
  void canonical_elements(index_set& set) const;
  void class_elements(index_type rep, index_set& set) const;
  index_type n_class_elements(index_type rep) const;
  void classes(index_set_vec& sets) const;
  void make_map(index_vec& map) const;
  index_type n_classes() const;
  index_type n_squeezed() const;
};
class set_hash_function : index_vec
{
 public:
  set_hash_function(index_type n)
    : index_vec() { init(n); };
  void init(index_type n);
  index_type operator()(index_type& i, index_type v) const;
  index_type operator()(const index_set& set) const;
  index_type operator()(const bool_vec& set) const;
  index_type operator()(const bool* set, index_type n) const;
};
template<class T, class N> struct weighted
{
  T value;
  N weight;
  weighted() : weight(0) { };
  weighted(const T& v) : value(v), weight(0) { };
  weighted(const T& v, const N& w) : value(v), weight(w) { };
  weighted(const weighted& w) : value(w.value), weight(w.weight) { };
  ~weighted() { };
  weighted& operator=(const T& v)
  {
    value = v;
    weight = 0;
    return *this;
  };
  weighted& operator=(const weighted& w)
  {
    value = w.value;
    weight = w.weight;
    return *this;
  };
  bool operator==(const weighted& w) const
  {
    return (value == w.value);
  };
  bool operator!=(const weighted& w) const
  {
    return (value != w.value);
  };
  bool operator<(const weighted& w) const
  {
    return (value < w.value);
  };
  bool operator<=(const weighted& w) const
  {
    return (value <= w.value);
  };
  bool operator>(const weighted& w) const
  {
    return (value > w.value);
  };
  bool operator>=(const weighted& w) const
  {
    return (value >= w.value);
  };
};
template<class T, class N> class weighted_vec
: public lvector< weighted<T, N> >
{
 public:
  class decreasing_weight_order : public lvector< weighted<T,N> >::order {
  public:
    virtual bool operator()
      (const weighted<T,N>& v0, const weighted<T,N>& v1) const
      { return (v0.weight > v1.weight); };
  };
  class increasing_weight_order : public lvector< weighted<T,N> >::order {
  public:
    virtual bool operator()
      (const weighted<T,N>& v0, const weighted<T,N>& v1) const
      { return (v0.weight < v1.weight); };
  };
  static class decreasing_weight_order decreasing;
  static class increasing_weight_order increasing;
  void insert_increasing(const weighted<T,N>& v);
  void insert_decreasing(const weighted<T,N>& v);
  void insert_increasing(const T& v, const N& w);
  void insert_decreasing(const T& v, const N& w);
};
template<class T, class N> class weighted_set
: public svector< weighted<T,N> >
{
 public:
  void insert(const T& v, const N& w);
  void insert(const T& v);
  index_type arg_max();
  index_type arg_min();
};
template<class T>
bool lvector<T>::operator==(const lvector& _vec) const
{
  if (lvector<T>::size() != _vec.size()) return false;
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if (!((*this)[k] == _vec[k])) return false;
  return true;
}
template<class T>
bool lvector<T>::operator!=(const lvector& _vec) const
{
  if (*this == _vec) return false;
  else return true;
}
template<class T>
bool lvector<T>::operator<(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return true;
  else if (lvector<T>::size() > vec.size()) return false;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return true;
      else if ((*this)[k] > vec[k]) return false;
    }
    return false;
  }
}
template<class T>
bool lvector<T>::operator<=(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return true;
  else if (lvector<T>::size() > vec.size()) return false;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return true;
      else if ((*this)[k] > vec[k]) return false;
    }
    return true;
  }
}
template<class T>
bool lvector<T>::operator>(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return false;
  else if (lvector<T>::size() > vec.size()) return true;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return false;
      else if ((*this)[k] > vec[k]) return true;
    }
    return false;
  }
}
template<class T>
bool lvector<T>::operator>=(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return false;
  else if (lvector<T>::size() > vec.size()) return true;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return false;
      else if ((*this)[k] > vec[k]) return true;
    }
    return true;
  }
}
template<class T>
bool lvector<T>::contains(const T& v) const
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return true;
  return false;
}
template<class T>
index_type lvector<T>::first(const T& v) const
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return k;
  return no_such_index;
}
template<class T>
index_type lvector<T>::next(const T& v, index_type p) const
{
  for (index_type k = p + 1; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return k;
  return no_such_index;
}
template<class T>
index_type lvector<T>::find(const T& v, bool_vec& s) const
{
  index_type n = 0;
  s.assign_value(false, lvector<T>::size());
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) {
      s[k] = true;
      n += 1;
    }
  return n;
}
template<class T>
index_type lvector<T>::count(const T& v) const
{
  index_type c = 0;
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) c += 1;
  return c;
}
template<class T>
index_type lvector<T>::length() const
{
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::arg_max() const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if ((*this)[k] > (*this)[m]) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_min() const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if ((*this)[k] < (*this)[m]) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_first(const order& o) const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if (o((*this)[k], (*this)[m])) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_last(const order& o) const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if (o((*this)[m], (*this)[k])) m = k;
  return m;
}
template<class T>
index_pair lvector<T>::first_common(const lvector<T>& vec) const
{
  for (index_type i = 0; i < lvector<T>::size(); i++) {
    for (index_type j = 0; j < vec.size(); j++)
      if ((*this)[i] == vec[j]) return index_pair(i, j);
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_pair lvector<T>::next_common(const lvector<T>& vec, index_pair p) const
{
  index_type i = p.first;
  index_type j = p.second + 1;
  while (j < vec.size()) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    j += 1;
  }
  i += 1;
  while (i < lvector<T>::size()) {
    j = 0;
    while (j < vec.size()) {
      if ((*this)[i] == vec[j])
 return index_pair(i, j);
      j += 1;
    }
    i += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
void lvector<T>::difference
(const lvector& v1, lvector& d0, lvector& d1)
{
  d0.assign_copy(*this);
  d1.assign_copy(v1);
  index_type i0 = 0;
  while (i0 < d0.size()) {
    index_type i1 = d1.first(d0[i0]);
    if (i1 != no_such_index) {
      d0.remove(i0);
      d1.remove(i1);
    }
    else {
      i0 += 1;
    }
  }
}
template<class T>
void lvector<T>::assign_copy(const lvector& _vec)
{
  std::vector<T>::resize(_vec.size());
  for (index_type k = 0; k < _vec.size(); k++)
    (*this)[k] = _vec[k];
}
template<class T>
void lvector<T>::assign_copy(const T* _arr, index_type n)
{
  std::vector<T>::resize(n);
  for (index_type k = 0; k < n; k++)
    (*this)[k] = _arr[k];
}
template<class T>
void lvector<T>::assign_value(const T& _val)
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    (*this)[k] = _val;
}
template<class T>
void lvector<T>::assign_value(const T& _val, index_type l)
{
  std::vector<T>::resize(l);
  for (index_type k = 0; k < lvector<T>::size(); k++)
    (*this)[k] = _val;
}
template<class T>
void lvector<T>::assign_remap(const lvector<T>& vec, const index_vec& map)
{
  assert(map.length() == vec.length());
  index_type m = 0;
  for (index_type k = 0; k < vec.length(); k++)
    if (map[k] != no_such_index)
      if (map[k] > m) m = map[k];
  set_length(m + 1);
  for (index_type k = 0; k < vec.length(); k++)
    if (map[k] != no_such_index)
      (*this)[map[k]] = vec[k];
}
template<class T>
void lvector<T>::remap(const index_vec& map)
{
  lvector v0(*this);
  assign_remap(v0, map);
}
template<class T>
void lvector<T>::assign_select(const lvector& _vec, const index_set& s)
{
  set_length(s.length());
  for (index_type k = 0; k < s.length(); k++)
    (*this)[k] = _vec[s[k]];
}
template<class T>
void lvector<T>::assign_select(const lvector& _vec, const bool_vec& s)
{
  clear();
  for (index_type k = 0; k < _vec.length(); k++)
    if (s[k]) append(_vec[k]);
}
template<class T>
const lvector<T>& lvector<T>::operator=(const lvector<T>& _vec)
{
  assign_copy(_vec);
  return _vec;
}
template<class T>
void lvector<T>::set_length(index_type l)
{
  std::vector<T>::resize(l);
}
template<class T>
void lvector<T>::set_length(index_type l, const T& v)
{
  std::vector<T>::resize(l, v);
}
template<class T>
void lvector<T>::inc_length_to(index_type l)
{
  if (std::vector<T>::size() < l)
    std::vector<T>::resize(l);
}
template<class T>
void lvector<T>::inc_length_to(index_type l, const T& v)
{
  if (std::vector<T>::size() < l)
    std::vector<T>::resize(l, v);
}
template<class T>
index_type lvector<T>::inc_length(index_type d)
{
  std::vector<T>::resize(std::vector<T>::size() + d);
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::inc_length(index_type d, const T& v)
{
  std::vector<T>::resize(std::vector<T>::size() + d, v);
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::dec_length(index_type d)
{
  assert(std::vector<T>::size() >= d);
  std::vector<T>::resize(std::vector<T>::size() - d);
  return std::vector<T>::size();
}
template<class T>
void lvector<T>::clear()
{
  std::vector<T>::clear();
}
template<class T>
void lvector<T>::append(const T& v)
{
  std::vector<T>::push_back(v);
}
template<class T>
void lvector<T>::append(const lvector<T>& v)
{
  for (index_type k = 0; k < v.size(); k++) append(v[k]);
}
template<class T>
T& lvector<T>::append()
{
  T v;
  std::vector<T>::push_back(v);
  return (*this)[std::vector<T>::size() - 1];
}
template<class T>
void lvector<T>::insert(const T& v, index_type p)
{
  if (p < lvector<T>::size()) {
    std::vector<T>::insert(std::vector<T>::begin() + p, v);
  }
  else {
    std::vector<T>::resize(p + 1);
    (*this)[p] = v;
  }
}
template<class T>
index_type lvector<T>::insert_ordered(const T& v, const order& o, index_type f)
{
  assert(f <= lvector<T>::size());
  for (index_type k = f; k < lvector<T>::size(); k++) {
    if (o(v, (*this)[k])) {
      insert(v, k);
      return k;
    }
  }
  append(v);
  return (lvector<T>::size() - 1);
}
template<class T>
index_type lvector<T>::insert_ordered(const lvector& vec, const order& o)
{
  if (vec.empty()) return no_such_index;
  index_type p0 = insert_ordered(vec[0], o);
  for (index_type k = 1; k < vec.size(); k++) {
    index_type p1 = insert_ordered(vec[k], o);
    if (p1 < p0) p0 = p1;
  }
  return p0;
}
template<class T>
void lvector<T>::remove(index_type p)
{
  if (p < lvector<T>::size())
    std::vector<T>::erase(std::vector<T>::begin() + p);
}
template<class T>
void lvector<T>::remove(index_type p0, index_type p1)
{
  assert(p0 < p1);
  if (p1 < lvector<T>::size())
    std::vector<T>::erase(std::vector<T>::begin() + p0,
     std::vector<T>::begin() + p1);
  else
    std::vector<T>::erase(std::vector<T>::begin() + p0,
     std::vector<T>::end());
}
template<class T>
void lvector<T>::remove(const bool_vec& s, index_vec& map)
{
  assert(s.size() >= lvector<T>::size());
  index_type scan_p = 0;
  index_type put_p = 0;
  index_vec rm_map(no_such_index, lvector<T>::size());
  while (scan_p < lvector<T>::size()) {
    if (!s[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      rm_map[scan_p] = put_p;
      put_p += 1;
    }
    else {
      rm_map[scan_p] = no_such_index;
    }
    scan_p += 1;
  }
  std::vector<T>::resize(put_p);
  for (index_type k = 0; k < map.size(); k++)
    if (map[k] != no_such_index) {
      assert(map[k] < rm_map.size());
      map[k] = rm_map[map[k]];
    }
}
template<class T>
void lvector<T>::remove(const bool_vec& s)
{
  assert(s.size() >= lvector<T>::size());
  index_type scan_p = 0;
  index_type put_p = 0;
  while (scan_p < lvector<T>::size()) {
    if (!s[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      put_p += 1;
    }
    scan_p += 1;
  }
  std::vector<T>::resize(put_p);
}
template<class T>
void lvector<T>::remove(const index_set& s)
{
  bool_vec s1(s, lvector<T>::size());
  remove(s1);
}
template<class T>
void lvector<T>::remove(const index_set& s, index_vec& map)
{
  bool_vec s1(s, std::vector<T>::size());
  lvector<T>::remove(s1, map);
}
template<class T>
void lvector<T>::remove_duplicate_elements()
{
  equivalence eq(lvector<T>::size());
  for (index_type i = 0; i < lvector<T>::size(); i++)
    for (index_type j = i+1; j < lvector<T>::size(); j++)
      if ((*this)[i] == (*this)[j])
 eq.merge(i, j);
  bool_vec s(false, lvector<T>::size());
  for (index_type i = 0; i < lvector<T>::size(); i++)
    if (eq.canonical(i) != i)
      s[i] = true;
  remove(s);
}
template<class T>
void lvector<T>::swap(index_type i, index_type j)
{
  T tmp = (*this)[i];
  (*this)[i] = (*this)[j];
  (*this)[j] = tmp;
}
template<class T>
void svector<T>::assign_singleton(const T& _val)
{
  lvector<T>::set_length(1);
  (*this)[0] = _val;
}
template<class T>
void svector<T>::assign_values(const lvector<T>& vec)
{
  lvector<T>::clear();
  for (index_type k = 0; k < vec.size(); k++)
    insert(vec[k]);
}
template<class T>
void svector<T>::insert(const T& v) {
  index_type i = 0;
  bool seeking = (i < std::vector<T>::size());
  while (seeking) {
    if ((*this)[i] < v) {
      i += 1;
      if (i >= std::vector<T>::size())
 seeking = false;
    }
    else {
      seeking = false;
    }
  }
  if (i < lvector<T>::size()) {
    if ((*this)[i] == v)
      return;
    else
      lvector<T>::insert(v, i);
  }
  else {
    lvector<T>::append(v);
  }
}
template<class T>
void svector<T>::insert(const lvector<T>& vec)
{
  for (index_type k = 0; k < vec.size(); k++) insert(vec[k]);
}
template<class T>
bool svector<T>::contains(const T& v) const
{
  index_type i = 0;
  while ((i < lvector<T>::size()) &&
  ((*this)[i] < v)) i += 1;
  if (i < lvector<T>::size())
    if ((*this)[i] == v) return true;
  return false;
}
template<class T>
bool svector<T>::contains(const svector& vec) const
{
  index_type v_i = 0;
  index_type i = 0;
  while (v_i < vec.size()) {
    if (i >= lvector<T>::size()) return false;
    if ((*this)[i] == vec[v_i]) {
      v_i += 1;
      i += 1;
    }
    else if ((*this)[i] > vec[v_i]) {
      return false;
    }
    else {
      while ((i < lvector<T>::size()) && ((*this)[i] < vec[v_i]))
 i += 1;
    }
  }
  return true;
}
template<class T>
bool svector<T>::subset(const svector& vec) const
{
  return vec.contains(*this);
}
template<class T>
void svector<T>::intersect(const svector& vec)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if (!vec.contains((*this)[i]))
      lvector<T>::remove(i);
    else
      i += 1;
  }
}
template<class T>
void svector<T>::difference(const svector& vec)
{
  svector d(vec);
  d.subtract(*this);
  subtract(vec);
  insert(d);
}
template<class T>
index_pair svector<T>::first_common(const lvector<T>& vec) const
{
  return lvector<T>::first_common(vec);
}
template<class T>
index_pair svector<T>::next_common(const lvector<T>& vec, index_pair p) const
{
  return lvector<T>::next_common(vec, p);
}
template<class T>
index_pair svector<T>::first_common(const svector<T>& vec) const
{
  index_type i = 0;
  index_type j = 0;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    else if
      ((*this)[i] < vec[j]) i += 1;
    else
      j += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_pair svector<T>::next_common(const svector<T>& vec, index_pair p) const
{
  index_type i = p.first + 1;
  index_type j = p.second + 1;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    else if ((*this)[i] < vec[j])
      i += 1;
    else
      j += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_type svector<T>::count_common(const svector& vec) const
{
  index_type i = 0;
  index_type j = 0;
  index_type c = 0;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j]) {
      c += 1;
      i += 1;
      j += 1;
    }
    else if ((*this)[i] < vec[j])
      i += 1;
    else
      j += 1;
  }
  return c;
}
template<class T>
void svector<T>::subtract(const svector& vec)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if (vec.contains((*this)[i]))
      lvector<T>::remove(i);
    else
      i += 1;
  }
}
template<class T>
void svector<T>::subtract(const T& v)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if ((*this)[i] == v) {
      lvector<T>::remove(i);
      return;
    }
    else {
      i += 1;
    }
  }
}
template<class T>
void matrix<T>::set_size(index_type r, index_type c)
{
  lvector<row_type>::set_length(r);
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].set_length(c);
}
template<class T>
void matrix<T>::assign_value(const T& _val)
{
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].assign_value(_val);
}
template<class T>
void matrix<T>::assign_value(const T& _val, index_type r, index_type c)
{
  lvector<row_type>::set_length(r);
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].assign_value(_val, c);
}
template<class T>
void swapable_pair<T>::swap()
{
  T tmp = this->first;
  this->first = this->second;
  this->second = tmp;
}
template<class T>
void comparable_pair<T>::sort_ascending()
{
  if (this->first > this->second) swapable_pair<T>::swap();
}
template<class T>
void comparable_pair<T>::sort_descending()
{
  if (this->first < this->second) swapable_pair<T>::swap();
}
template<class T, class N>
class weighted_vec<T,N>::decreasing_weight_order
  weighted_vec<T,N>::decreasing;
template<class T, class N>
class weighted_vec<T,N>::increasing_weight_order
  weighted_vec<T,N>::increasing;
template<class T, class N>
void weighted_vec<T,N>::insert_increasing(const weighted<T,N>& v)
{
  insert_ordered(v, increasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_decreasing(const weighted<T,N>& v)
{
  insert_ordered(v, decreasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_increasing(const T& v, const N& w)
{
  insert_ordered(weighted<T,N>(v, w), increasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_decreasing(const T& v, const N& w)
{
  insert_ordered(weighted<T,N>(v, w), decreasing);
}
template<class T, class N>
void weighted_set<T,N>::insert(const T& v, const N& w)
{
  index_type p = svector< weighted<T,N> >::first(v);
  if (p == no_such_index) {
    svector< weighted<T,N> >::insert(weighted<T,N>(v, w));
  }
  else {
    (*this)[p].weight += w;
  }
}
template<class T, class N>
void weighted_set<T,N>::insert(const T& v)
{
  index_type p = svector< weighted<T,N> >::first(v);
  if (p == no_such_index) {
    svector< weighted<T,N> >::insert(weighted<T,N>(v, 1));
  }
  else {
    (*this)[p].weight += 1;
  }
}
template<class T, class N>
index_type weighted_set<T,N>::arg_max()
{
  if (weighted_set<T,N>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < weighted_set<T,N>::size(); k++)
    if ((*this)[k].weight > (*this)[m].weight) m = k;
  return m;
}
template<class T, class N>
index_type weighted_set<T,N>::arg_min()
{
  if (weighted_set<T,N>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < weighted_set<T,N>::size(); k++)
    if ((*this)[k].weight < (*this)[m].weight) m = k;
  return m;
}
template<class T>
inline std::ostream& operator<<(std::ostream& s, const swapable_pair<T>& p)
{
  return s << '(' << p.first << ',' << p.second << ')';
}
template<class T>
::std::ostream& operator<<(::std::ostream& s, const lvector<T>& _vec)
{
  s << '[';
  for (index_type k = 0; k < _vec.size(); k++) {
    if (k > 0) s << ',';
    s << _vec[k];
  }
  s << ']';
  return s;
}
inline std::ostream& operator<<(std::ostream& s, const mapping& m)
{
  s << '{';
  for (index_type k = 0; k < m.length(); k++) {
    if (k > 0) s << ',';
    s << k << '-' << '>';
    if (m[k] == no_such_index)
      s << '_';
    else
      s << m[k];
  }
  return s << '}';
}
inline std::ostream& operator<<(std::ostream& s, const equivalence& eq)
{
  s << '{';
  bool first = true;
  for (index_type k = 0; k < eq.length(); k++) {
    index_type c = eq.canonical(k);
    if (!first) {
      s << ',';
    }
    else {
      first = false;
    }
    s << k << '=' << c;
  }
  return s << '}';
}
template<class T, class N>
std::ostream& operator<<(::std::ostream& s, const weighted<T,N>& w)
{
  s << '<' << w.value << ':' << w.weight << '>';
}
}
namespace hsps {
typedef zero_init_pair<void*> ptr_pair;
class ptr_table {
  void* _key;
  ptr_table* _left;
  ptr_table* _right;
  ptr_table* _up;
  ptr_table* _prev;
  ptr_table* _next;
  index_type _count;
 public:
  void* val;
 private:
  ptr_table(void* k, ptr_table* u, ptr_table* p)
    : _key(k), _left(0), _right(0), _up(u), _prev(p), _next(0),
    _count(1), val(0) { };
 public:
  typedef lvector<void*> key_vec;
  typedef lvector<void*> value_vec;
  typedef lvector<ptr_table*> cell_vec;
  ptr_table()
    : _key(0), _left(0), _right(0), _up(0), _prev(0), _next(0),
    _count(0), val(0) { };
  ~ptr_table();
  void* key() { return _key; };
  ptr_table* enum_key_first();
  ptr_table* enum_key_next();
  void key_sequence(key_vec&);
  key_vec* key_sequence();
  ptr_table* root();
  ptr_table* next() { return _next; };
  ptr_table* insert(void* k);
  ptr_table* insert_next(void* k);
  ptr_table* insert(void** k, index_type l);
  ptr_table* insert(key_vec& k);
  ptr_table* find(void* k);
  ptr_table* find_next(void* k);
  ptr_table* find(void** k, index_type l);
  ptr_table* find(key_vec& k);
  bool contains(void* k);
  bool contains(void** k, index_type l);
  bool contains(key_vec& k);
  void set(void* k, void* v);
  void set(void** k, index_type l, void* v);
  void set(key_vec& k, void* v);
  void* find_val(void** k, index_type l);
  void* find_val(key_vec& k);
  void*& operator[](void* k);
  void*& operator[](key_vec& k);
  void dump(cell_vec& vec);
  index_type count_keys();
  void dump_keys(key_vec& vec);
  key_vec* keys();
  index_type count_values();
  void dump_values(value_vec& vec);
  value_vec* values();
};
inline bool ptr_table::contains(void* k) {
  return (find(k) != 0);
}
inline bool ptr_table::contains(void** k, index_type l) {
  return (find(k) != 0);
}
inline bool ptr_table::contains(key_vec& k) {
  return (find(k) != 0);
}
inline void ptr_table::set(void* k, void* v) {
  insert(k)->val = v;
}
inline void ptr_table::set(void** k, index_type l, void* v) {
  insert(k)->val = v;
}
inline void ptr_table::set(key_vec& k, void* v) {
  insert(k)->val = v;
}
inline void*& ptr_table::operator[](void* k) {
  ptr_table* a = insert(k);
  return a->val;
}
inline void*& ptr_table::operator[](key_vec& k) {
  ptr_table* a = insert(k);
  return a->val;
}
inline void* ptr_table::find_val(void** k, index_type l) {
  ptr_table* a = find(k, l);
  if (a) return a->val;
  else return 0;
}
inline void* ptr_table::find_val(key_vec& k) {
  ptr_table* a = find(k);
  if (a) return a->val;
  else return 0;
}
}
namespace hsps {
class char_map {
 public:
  static const unsigned int _CHAR_COUNT = 256;
 private:
  char _map[_CHAR_COUNT];
 public:
  char_map();
  char_map(const char in[_CHAR_COUNT]);
  void identify(const char _c0, const char _c1);
  char operator[](const char _in) const
    { return _map[(unsigned char)_in]; };
  void apply(char* s) const;
  void apply(char* s, index_type len) const;
  int strcmp(const char *s0, const char *s1) const;
  int strcmp(const char *s0, const char *s1, index_type len) const;
  const char* strchr(const char* s, char c) const;
  const char* strchr(const char* s, index_type len, char c) const;
  char* strcpy(const char *s0, char *s1) const;
  char* strcpy(const char *s0, index_type len, char *s1) const;
  char* strdup(const char *s0) const;
  char* strdup(const char *s0, index_type len) const;
  index_type hash(const char *s) const;
  index_type hash(const char *s, index_type len) const;
};
extern const char lowercase[char_map::_CHAR_COUNT];
extern const char rot13[char_map::_CHAR_COUNT];
extern char_map lowercase_map;
extern char_map rot13_map;
}
namespace hsps {
typedef lvector<char*> string_vec;
typedef lvector<void*> element_vec;
inline ::std::ostream& operator<<(::std::ostream& s, const string_vec& vec) {
  s << '[';
  for (index_type k = 0; k < vec.length(); k++) {
    if (k > 0) s << ',';
    s << '"' << vec[k] << '"';
  }
  s << ']';
  return s;
}
class StringTable {
 public:
  struct Cell {
    index_type bin;
    char* text;
    void* val;
    Cell* next;
    Cell(const char* s, char_map& map, index_type b, Cell* n)
      : bin(b), text(map.strdup(s)), val(0), next(n) { };
    Cell(const char* s, index_type len, char_map& map, index_type b, Cell* n)
      : bin(b), text(map.strdup(s, len)), val(0), next(n) { };
    Cell(const char* s, char_map& map, void* v, index_type b, Cell* n)
      : bin(b), text(map.strdup(s)), val(v), next(n) { };
    Cell(const char* s, index_type len, char_map& map, void* v, index_type b, Cell* n)
      : bin(b), text(map.strdup(s, len)), val(v), next(n) { };
    ~Cell() { delete text; if (next) delete next; };
  };
 private:
  index_type n_bin;
  char_map& map;
  Cell** table;
  index_type n_entries;
 public:
  StringTable(index_type b, char_map& cm);
  ~StringTable();
  StringTable::Cell* inserta(const char* str);
  StringTable::Cell* inserta(const char* str, index_type len);
  StringTable::Cell* gensym(const char* str);
  char* insert(const char* str);
  char* insert(const char* str, index_type len);
  char* set(const char* str, void* val);
  char* set(const char* str, index_type len, void* val);
  char* set(const char* str)
    { return set(str, (void*)0); };
  char* set(const char* str, index_type len)
    { return set(str, len, (void*)0); };
  const StringTable::Cell* find(const char* str) const;
  const StringTable::Cell* find(const char* str, index_type len) const;
  void* find_val(const char* str) const;
  void* find_val(const char* str, index_type len) const;
  const StringTable::Cell* first() const;
  const StringTable::Cell* next(const StringTable::Cell* c) const;
  string_vec* keys();
  element_vec* values();
  index_type table_bins() { return n_bin; };
  index_type table_entries() { return n_entries; };
  char_map& table_char_map() { return map; };
  void apply_map(const char_map& map);
};
}
#include <iostream>
#include <limits.h>
namespace hsps {
long euclid(long n, long k, long& a, long& b);
long gcd(long n, long k);
long lcm(long n, long k);
unsigned long ilog(unsigned long n);
long imag(long n);
class rational {
  long nm;
  long dv;
 public:
  rational();
  rational(long n);
  rational(long n, long d);
  rational(const rational& r);
  struct XR {
    long x_nm;
    long x_dv;
    XR& operator=(const rational r);
  };
  rational(const XR& x);
  long numerator() const;
  long divisor() const;
  long sign() const;
  bool zero() const;
  bool finite() const;
  bool infinite() const;
  bool integral() const;
  static rational reduce(rational r);
  static rational invert(const rational r);
  static rational infinity(const rational r);
  static rational infinity(const long s);
  static rational floor(const rational r);
  static rational floor_to(const rational r, long div);
  static rational ceil(const rational r);
  static rational ceil_to(const rational r, long div);
  static rational frac(const rational r);
  static rational round(const rational r, long div_max);
  static rational min(const rational r0, const rational r1);
  static rational max(const rational r0, const rational r1);
  static rational rgcd(const rational r0, const rational r1);
  static rational dtor(double v);
  static rational ator(const char* s);
  rational reduce() const;
  rational invert() const;
  rational floor() const;
  rational floor_to(long d) const;
  rational ceil() const;
  rational frac() const;
  rational round(long div_max) const;
  rational round() const;
  rational operator=(const rational r);
  rational operator=(long n);
  rational operator+=(const rational r);
  rational operator-=(const rational r);
  rational operator*=(const rational r);
  rational operator/=(const rational r);
  rational operator+=(long n);
  rational operator-=(long n);
  rational operator*=(long n);
  rational operator/=(long n);
  double decimal() const;
};
bool operator==(const rational r0, const rational r1);
bool operator==(const rational r0, long n1);
bool operator==(long n0, const rational r1);
bool operator!=(const rational r0, const rational r1);
bool operator!=(const rational r0, long n1);
bool operator!=(long n0, const rational r1);
bool operator<(const rational r0, const rational r1);
bool operator<=(const rational r0, const rational r1);
bool operator>(const rational r0, const rational r1);
bool operator>=(const rational r0, const rational r1);
rational operator+(const rational r0, const rational r1);
rational operator-(const rational r0, const rational r1);
rational operator*(const rational r0, const rational r1);
rational operator/(const rational r0, const rational r1);
rational operator+(const rational r0, long n1);
rational operator-(const rational r0, long n1);
rational operator*(const rational r0, long n1);
rational operator/(const rational r0, long n1);
rational operator+(long n0, const rational r1);
rational operator-(long n0, const rational r1);
rational operator*(long n0, const rational r1);
rational operator/(long n0, const rational r1);
rational safeadd(const rational r0, const rational r1);
rational safemul(const rational r0, const rational r1);
::std::ostream& operator<<(::std::ostream& s, const rational r);
inline rational::XR& rational::XR::operator=(const rational r)
{
  x_nm = r.numerator();
  x_dv = r.divisor();
  return *this;
}
inline rational::rational()
  : nm(0), dv(1) { }
inline rational::rational(long n)
  : nm(n), dv(1) { }
inline rational::rational(long n, long d)
  : nm(d < 0 ? -1*n : n), dv(d < 0 ? -1*d : d) { }
inline rational::rational(const rational& r)
  : nm(r.nm), dv(r.dv) { }
inline rational::rational(const rational::XR& x)
  : nm(x.x_nm), dv(x.x_dv) { };
inline long rational::numerator() const { return nm; }
inline long rational::divisor() const { return dv; }
inline long rational::sign() const
{
  return (nm < 0 ? -1 : (nm > 0 ? 1 : 0));
}
inline bool rational::zero() const
{
  return nm == 0;
}
inline bool rational::finite() const
{
  return dv != 0;
}
inline bool rational::infinite() const
{
  return dv == 0;
}
inline bool rational::integral() const
{
  return dv == 1;
}
inline rational rational::reduce(rational r)
{
  if (r.infinite()) return infinity(r.sign());
  if (r.sign() == 0) return rational(0,1);
  long c = gcd(r.nm, r.dv);
  return rational(r.nm / c, r.dv / c);
}
inline rational rational::invert(const rational r)
{
  return rational(r.dv, r.nm);
}
inline rational rational::infinity(const long s)
{
  return rational((s < 0 ? -1 : (s > 0 ? 1 : 0)), 0);
}
inline rational rational::infinity(const rational r)
{
  return rational(r.sign(),0);
}
inline rational rational::floor(const rational r)
{
  if (r.infinite()) return r;
  return rational(r.nm / r.dv);
}
inline rational rational::floor_to(const rational r, long d)
{
  if (r.infinite()) return r;
  return rational((r.nm * d) / r.dv, d);
}
inline rational rational::ceil(const rational r)
{
  if (r.infinite()) return r;
  if (r.dv == 1) return r;
  return rational((r.nm / r.dv) + 1, 1);
}
inline rational rational::ceil_to(const rational r, long d)
{
  if (r.infinite()) return r;
  long x = (r.nm * d);
  long y = x / r.dv;
  if ((y * r.dv) == x)
    return rational(y, d);
  else
    return rational(y + 1, d);
}
inline rational rational::frac(const rational r) {
  if (r.infinite()) return r;
  return reduce(rational(r.nm % r.dv, r.dv));
}
inline rational rational::round(const rational r, long d_max)
{
  if (r.infinite()) return r;
  rational s(r);
  while (s.dv > d_max) {
    s.dv = (s.dv / 2);
    s.nm = (s.nm / 2);
    s.reduce();
  }
  return s;
}
inline rational rational::rgcd(const rational r0, const rational r1)
{
  long c = gcd(r0.divisor(), r1.divisor());
  long a0 = r0.numerator() * (r1.divisor() / c);
  long a1 = r1.numerator() * (r0.divisor() / c);
  long d = gcd(a0, a1);
  return rational(d, (r0.divisor() / c) * (r1.divisor() / c) * c).reduce();
}
inline rational rational::min(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    if (r0.sign() < 0) return r0;
    else return r1;
  }
  else if (r1.infinite()) {
    if (r1.sign() < 0) return r1;
    else return r0;
  }
  else if (r0 < r1) return r0;
  else return r1;
}
inline rational rational::max(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    if (r0.sign() > 0) return r0;
    else return r1;
  }
  else if (r1.infinite()) {
    if (r1.sign() > 0) return r1;
    else return r0;
  }
  else if (r0 < r1) return r1;
  else return r0;
}
inline rational rational::reduce() const
{
  return reduce(*this);
}
inline rational rational::invert() const
{
  return invert(*this);
}
inline rational rational::floor() const
{
  return floor(*this);
}
inline rational rational::floor_to(long d) const
{
  return floor_to(*this, d);
}
inline rational rational::ceil() const
{
  return ceil(*this);
}
inline rational rational::frac() const
{
  return frac(*this);
}
inline rational rational::round(long d_max) const
{
  return round(*this, d_max);
}
inline rational rational::round() const
{
  return round(*this, (LONG_MAX/16));
}
inline rational rational::operator=(const rational r)
{
  nm = r.nm;
  dv = r.dv;
  return *this;
}
inline rational rational::operator=(long n)
{
  nm = n;
  dv = 1;
  return *this;
}
inline rational rational::operator+=(const rational r)
{
  return *this = (*this + r);
}
inline rational rational::operator-=(const rational r)
{
  return *this = (*this - r);
}
inline rational rational::operator*=(const rational r)
{
  return *this = (*this * r);
}
inline rational rational::operator/=(const rational r)
{
  return *this = (*this / r);
}
inline rational rational::operator+=(long n)
{
  return *this = (*this + n);
}
inline rational rational::operator-=(long n)
{
  return *this = (*this - n);
}
inline rational rational::operator*=(long n)
{
  return *this = (*this * n);
}
inline rational rational::operator/=(long n)
{
  return *this = (*this / n);
}
inline double rational::decimal() const { return nm/(double)dv; };
inline bool operator==(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite()) return r0.sign() == r1.sign();
  else return ((r0.numerator() == r1.numerator()) &&
        (r0.divisor() == r1.divisor()));
}
inline bool operator==(const rational r0, long n1)
{
  return ((r0.numerator() == n1) && (r0.divisor() == 1));
}
inline bool operator==(long n0, const rational r1)
{
  return ((r1.numerator() == n0) && (r1.divisor() == 1));
}
inline bool operator!=(const rational r0, const rational r1)
{
  return !(r0 == r1);
}
inline bool operator!=(const rational r0, long n1)
{
  return !(r0 == n1);
}
inline bool operator!=(long n0, const rational r1)
{
  return !(n0 == r1);
}
inline bool operator<(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return false;
  else return (r0 - r1).sign() < 0;
}
inline bool operator<=(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return true;
  else return (r0 - r1).sign() <= 0;
}
inline bool operator>(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return false;
  else return (r0 - r1).sign() > 0;
}
inline bool operator>=(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return true;
  else return (r0 - r1).sign() >= 0;
}
inline rational operator+(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() == r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " + " << r1 << " not defined"
           << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() + r1.numerator(), 1);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n = (r0.numerator() * (r1.divisor() / c) +
       r1.numerator() * (r0.divisor() / c));
    long d = ((r0.divisor() / c) * r1.divisor());
    return rational(n, d).reduce();
  }
}
inline rational operator-(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() != r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " - " << r1 << " not defined"
      << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1.sign() * -1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() - r1.numerator(), 1);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n = (r0.numerator() * (r1.divisor() / c) -
       r1.numerator() * (r0.divisor() / c));
    long d = ((r0.divisor() / c) * r1.divisor());
    return rational(n, d).reduce();
  }
}
inline rational operator*(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else if (r1.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() * r1.numerator(), 1);
  }
  else {
    long c0 = gcd(r0.numerator(), r1.divisor());
    long c1 = gcd(r1.numerator(), r0.divisor());
    return rational((r0.numerator() / c0) * (r1.numerator() / c1),
      (r0.divisor() / c1) * (r1.divisor() / c0)).reduce();
  }
}
inline rational operator/(const rational r0, const rational r1)
{
  return (r0 * r1.invert());
}
inline rational operator+(const rational r0, long n1)
{
  return rational(r0.numerator() + (n1 * r0.divisor()), r0.divisor()).reduce();
}
inline rational operator-(const rational r0, long n1)
{
  return rational(r0.numerator() - (n1 * r0.divisor()), r0.divisor()).reduce();
}
inline rational operator*(const rational r0, long n1)
{
  return rational(r0.numerator() * n1, r0.divisor()).reduce();
}
inline rational operator/(const rational r0, long n1)
{
  return rational((n1 < 0 ? r0.numerator() * -1 : r0.numerator()),
    r0.divisor() * (n1 < 0 ? n1 * -1 : n1)).reduce();
}
inline rational operator+(long n0, const rational r1)
{
  return rational(r1.numerator() + (n0 * r1.divisor()), r1.divisor()).reduce();
}
inline rational operator-(long n0, const rational r1)
{
  return rational((n0 * r1.divisor()) - r1.numerator(), r1.divisor()).reduce();
}
inline rational operator*(long n0, const rational r1)
{
  return rational(r1.numerator() * n0, r1.divisor()).reduce();
}
inline rational operator/(long n0, const rational r1)
{
  return (n0 * r1.invert());
}
inline rational safeadd(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() == r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " + " << r1 << " not defined"
      << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n0 = r0.numerator();
    long d0 = r0.divisor() / c;
    long n1 = r1.numerator();
    long d1 = r1.divisor() / c;
    assert(d0 > 0);
    assert(d1 > 0);
    while (((LONG_MAX / (2*d1)) < (imag(n0) + 1)) ||
    ((LONG_MAX / (2*d0)) < (imag(n1) + 1)) ||
    ((LONG_MAX / (d0 * c)) < (d1 + 1))) {
      if ((d1 < 2) && (d0 < 2)) {
 std::cerr << "error: overflow in safeadd(" << r0 << ", " << r1 << ")"
    << std::endl;
 abort();
      }
      if (d0 < 2) {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
      else if (d1 < 2) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else if ((imag(n0) - d0) > (imag(n1) - d1)) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
    }
    long f0 = n0 * d1;
    long f1 = n1 * d0;
    long n = f0 + f1;
    long d = d0 * d1 * c;
    return rational(n, d).reduce();
  }
}
inline rational safemul(const rational r0, const rational r1)
{
  if (r0.infinite() || r1.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else {
    long c0 = gcd(r0.numerator(), r1.divisor());
    long c1 = gcd(r1.numerator(), r0.divisor());
    long n0 = r0.numerator() / c0;
    long n1 = r1.numerator() / c1;
    long d0 = r0.divisor() / c1;
    long d1 = r1.divisor() / c0;
    while (((LONG_MAX / imag(n0)) < (imag(n1) + 1)) ||
    ((LONG_MAX / d0) < (d1 + 1))) {
      if ((d1 < 2) && (d0 < 2)) {
 std::cerr << "error: overflow in safeadd(" << r0 << ", " << r1 << ")"
    << std::endl;
 abort();
      }
      if (d0 < 2) {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
      else if (d1 < 2) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else if ((imag(n0) - d0) > (imag(n1) - d1)) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
    }
    return rational(n0 * n1, d0 * d1).reduce();
  }
}
inline ::std::ostream& operator<<(::std::ostream& s, const rational r)
{
  if (r.infinite()) {
    if (r.sign() < 0) return s << "-INF";
    else return s << "INF";
  }
  else if (r.integral()) {
    return s << r.numerator();
  }
  else {
    return s << r.numerator() << '/' << r.divisor();
  }
}
}
namespace hsps {
class RNG {
 public:
  virtual ~RNG() { };
  virtual void seed(unsigned long s) = 0;
  virtual unsigned long seed_value() = 0;
  virtual unsigned long random() = 0;
  void seed_with_pid();
  void seed_with_time();
  unsigned long random_in_range(unsigned long range);
  unsigned long random_in_range(unsigned long range, unsigned long except);
  double random_double(unsigned long div);
  double normal_sample(double mean, double var);
  unsigned long binomial_sample(unsigned long n, double p);
  index_type select_one_of(const bool_vec& sel);
  index_type select_one_of(const index_vec& sel);
  void select_fixed_set(index_set& s, index_type m, index_type n);
  void select_variable_set(index_set& s, index_type m, index_type n);
  void select_non_empty_variable_set(index_set& s, index_type m, index_type n);
  virtual unsigned long max() = 0;
};
class LC_RNG : public RNG {
  unsigned long a;
  unsigned long b;
  unsigned long mod;
  unsigned long x;
 public:
  LC_RNG()
    : a(23), b(0), mod(100000001), x(100000001 - 1) { };
  LC_RNG(unsigned long _a, unsigned long _b, unsigned long m)
    : a(_a), b(_b), mod(m), x(m - 1) { };
  LC_RNG(unsigned long s)
    : a(23), b(0), mod(100000001), x(s) { };
  LC_RNG(unsigned long _a, unsigned long _b, unsigned long m, unsigned long s)
    : a(_a), b(_b), mod(m), x(s) { };
  virtual ~LC_RNG() { };
  virtual void seed(unsigned long s);
  virtual unsigned long seed_value();
  virtual unsigned long random();
  virtual unsigned long max();
};
}
#include <iostream>
#include <iomanip>
const hsps::rational POS_INF(1,0);
const hsps::rational NEG_INF(-1,0);
const hsps::rational ZERO(0,1);
namespace hsps {
inline hsps::rational random_numeric
(hsps::rational min, hsps::rational max, unsigned long prec, RNG& rng)
{
  hsps::rational d = (max - min);
  hsps::rational s = (d / prec);
  unsigned long r = rng.random_in_range(prec + 1);
  return ((r*s) + min);
}
class amt_vec : public auto_expanding_vector<hsps::rational> {
 public:
  amt_vec()
    : auto_expanding_vector<hsps::rational>() { };
  amt_vec(const hsps::rational& v, index_type l)
    : auto_expanding_vector<hsps::rational>(v, l) { };
  amt_vec(const amt_vec& vec)
    : auto_expanding_vector<hsps::rational>(vec) { };
  int compare(const amt_vec& vec, index_type n);
  int dcompare(const amt_vec& vec, index_type n);
  index_type hash(index_type n);
  void write(std::ostream& s, index_type n);
};
inline int amt_vec::compare(const amt_vec& vec, index_type n)
{
  for (index_type k = 0; k < n; k++) {
    if ((*this)[k] < vec[k]) return -1;
    else if ((*this)[k] > vec[k]) return 1;
  }
  return 0;
}
inline int amt_vec::dcompare(const amt_vec& vec, index_type n)
{
  bool this_less_than_vec = false;
  bool vec_less_than_this = false;
  for (index_type k = 0; k < n; k++) {
    if ((*this)[k] < vec[k]) this_less_than_vec = true;
    else if ((*this)[k] > vec[k]) vec_less_than_this = true;
  }
  if (this_less_than_vec && !vec_less_than_this) return -1;
  else if (!this_less_than_vec && vec_less_than_this) return 1;
  else return 0;
}
inline index_type amt_vec::hash(index_type n)
{
  if (n == 0) return 0;
  if (n == 1) return ((index_type)(((*this)[0]).numerator() - ((*this)[0]).divisor()));
  index_type h = 0;
  for (index_type k = 0; k < n - 1; k++) {
    h += ((index_type)(((((*this)[k]) + 1) * (((*this)[k + 1]) + 1)).numerator() - ((((*this)[k]) + 1) * (((*this)[k + 1]) + 1)).divisor()));
  }
  return h;
}
inline void amt_vec::write(std::ostream& s, index_type n)
{
  s << '[';
  for (index_type k = 0; k < n; k++) {
    if (k > 0) s << ',';
    s << std::resetiosflags(std::ios::scientific) << (((*this)[k]).decimal());
  }
  s << ']';
}
typedef lvector<hsps::rational> cost_vec;
typedef svector<hsps::rational> cost_set;
typedef matrix<hsps::rational> cost_matrix;
class cost_vec_util : public cost_vec
{
 public:
  class decreasing_cost_order : public cost_vec::order {
  public:
    virtual bool operator()
      (const hsps::rational& v0, const hsps::rational& v1) const
      { return (v0 > v1); };
  };
  class increasing_cost_order : public cost_vec::order {
  public:
    virtual bool operator()
      (const hsps::rational& v0, const hsps::rational& v1) const
      { return (v0 < v1); };
  };
  static class decreasing_cost_order decreasing;
  static class increasing_cost_order increasing;
  static hsps::rational max(const cost_vec& v);
  static hsps::rational min(const cost_vec& v);
  hsps::rational max() const { return max(*this); };
  hsps::rational min() const { return min(*this); };
};
struct interval : public comparable_pair<hsps::rational> {
  interval(const hsps::rational& v1, const hsps::rational& v2) :
    comparable_pair<hsps::rational>(v1, v2) { };
  interval(const hsps::rational& v) :
    comparable_pair<hsps::rational>(v) { };
  interval(const interval& p) :
    comparable_pair<hsps::rational>(p) { };
  interval() :
    comparable_pair<hsps::rational>(NEG_INF, POS_INF) { };
};
typedef std::pair<index_type, hsps::rational> index_cost_pair;
typedef lvector<index_cost_pair> index_cost_vec;
inline std::ostream& operator<<(std::ostream& s, const index_cost_pair& p)
{
  s << '(' << p.first << ',' << p.second << ')';
}
inline std::ostream& operator<<(std::ostream& s, const interval& i)
{
  s << '[' << i.first << ',' << i.second << ']';
}
}
#include <string>
#include <iostream>
namespace hsps {
class Name {
 public:
  static const unsigned int NC_DEFAULT = 0;
  static const unsigned int NC_INSTANCE = 1;
  static const unsigned int NC_DOMAIN = 2;
  static const unsigned int NC_PROBLEM = 4;
  static const unsigned int NC_PLAN = 8;
  static const unsigned int NC_ESCAPE = 16 + 32;
  static const unsigned int NC_PDDL = 16;
  static const unsigned int NC_XML = 32;
  static const unsigned int NC_LATEX = 16 + 32;
  static const unsigned int NC_IPC = 64;
  static bool context_is_instance(unsigned int c)
    { return ((c & NC_INSTANCE) == NC_INSTANCE); };
  static bool context_is_domain(unsigned int c)
    { return ((c & NC_DOMAIN) == NC_DOMAIN); };
  static bool context_is_problem(unsigned int c)
    { return ((c & NC_PROBLEM) == NC_PROBLEM); };
  static bool context_is_plan(unsigned int c)
    { return ((c & NC_PLAN) == NC_PLAN); };
  static bool escape_for_pddl(unsigned int c)
    { return ((c & NC_ESCAPE) == NC_PDDL); };
  static bool escape_for_xml(unsigned int c)
    { return ((c & NC_ESCAPE) == NC_XML); };
  static bool escape_for_latex(unsigned int c)
    { return ((c & NC_ESCAPE) == NC_LATEX); };
  static bool conform_to_IPC(unsigned int c)
    { return ((c & NC_IPC) == NC_IPC); };
  virtual ~Name();
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const = 0;
  virtual const Name* cast_to(const char* cname) const;
  ::std::string to_string(unsigned int c = NC_DEFAULT) const;
  char* to_cstring(unsigned int c = NC_DEFAULT) const;
  bool equals(const Name* name) const;
  void write_char_escaped(::std::ostream& s,
     char ch,
     unsigned int c) const;
  void write_string_escaped(::std::ostream& s,
       ::std::string& str,
       unsigned int c) const;
  void write_string_escaped(::std::ostream& s,
       const char* str,
       unsigned int c) const;
};
typedef lvector<const Name*> name_vec;
inline ::std::ostream& operator<<(::std::ostream& s, const Name& n) {
  n.write(s, false);
  return s;
}
inline ::std::ostream& operator<<(::std::ostream& s, const Name* n) {
  n->write(s, false);
  return s;
}
inline void Name::write_char_escaped
(::std::ostream& s, char ch, unsigned int c) const
{
  if (escape_for_latex(c)) {
    if (ch == '_') s << '\\' << '_';
    else if (ch == '%') s << '\\' << '%';
    else if (ch == '#') s << '\\' << '#';
    else s << ch;
  }
  else if (escape_for_xml(c)) {
    if (ch == '<') s << "&lt;";
    else if (ch == '>') s << "&gt;";
    else if (ch == '&') s << "&amp;";
    else if (ch == '"') s << "&quot;";
    else s << ch;
  }
  else if (escape_for_pddl(c)) {
    if (ch == ' ') s << '_';
    else s << ch;
  }
  else {
    s << ch;
  }
}
inline void Name::write_string_escaped
(::std::ostream& s, const char* str, unsigned int c) const
{
  while (*str) {
    write_char_escaped(s, *str, c);
    str++;
  }
}
inline void Name::write_string_escaped
(::std::ostream& s, ::std::string& str, unsigned int c) const
{
  for (index_type i = 0; i < str.length(); i++)
    write_char_escaped(s, str[i], c);
}
class NameWithContext : public Name {
  const Name* name;
  unsigned int c_on;
  unsigned int c_off;
 public:
  NameWithContext(const Name* n, unsigned int on, unsigned int off)
    : name(n), c_on(on), c_off(off) { };
  virtual ~NameWithContext() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class StringName : public Name {
  const char* _string;
  bool _own;
 public:
  StringName(const char* s, bool c = false)
    : _string(c ? strdup(s) : s), _own(c) { };
  virtual ~StringName() { if (_own) delete (char*)_string; };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class ConcatenatedName : public Name {
  name_vec elements;
  char catc;
 public:
  ConcatenatedName() : elements((Name*)0, 0), catc('+') { };
  ConcatenatedName(const Name* n) : elements(n, 1), catc('+') { };
  ConcatenatedName(char c) : elements((Name*)0, 0), catc(c) { };
  ConcatenatedName(const Name* n1, const Name* n2, char c)
    : elements((Name*)0, 0), catc(c)
  {
    elements.append(n1);
    elements.append(n2);
  };
  virtual ~ConcatenatedName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
  void append(const Name* n) { elements.append(n); };
};
class ModName : public Name {
  const char* _mod;
  const Name* _name;
 public:
  ModName(const Name* n, const char* m) : _mod(m), _name(n) { };
  virtual ~ModName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class CopyName : public Name {
  const Name* _name;
  index_type _num;
 public:
  CopyName(const Name* n) : _name(n), _num(no_such_index) { };
  CopyName(const Name* n, index_type m) : _name(n), _num(m) { };
  virtual ~CopyName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class NameAtIndex : public Name {
  const Name* _name;
  index_type _index;
 public:
  NameAtIndex(const Name* n, index_type i) : _name(n), _index(i) { };
  virtual ~NameAtIndex() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class EnumName : public Name {
  const char* prefix;
  index_type index;
 public:
  EnumName(const char* p, index_type i) : prefix(p), index(i) { };
  virtual ~EnumName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
}
#include <map>
#include <iostream>
namespace hsps {
class graph {
 private:
  index_type _size;
  bool_matrix adj;
  index_set_vec in;
  index_set_vec out;
  index_set_vec bi;
  index_vec comp;
  index_type n_comp;
 public:
  graph();
  graph(index_type s);
  graph(const graph& g);
  graph(const graph& g, const index_set& n);
  graph(const graph& g, const equivalence& eq);
  ~graph();
  index_type size() const { return _size; };
  bool adjacent(index_type i, index_type j) const { return adj[i][j]; };
  bool adjacent(index_type i, const index_set& n) const;
  bool adjacent(const index_set& n, index_type i) const;
  bool adjacent(const index_set& n0, const index_set& n1) const;
  bool bi_adjacent(index_type i, index_type j) const
    { return (adj[i][j] && adj[j][i]); };
  bool bi_adjacent(index_type i, const index_set& n) const;
  index_type n_edges() const;
  index_type n_edges(const index_set& from, const index_set& to) const;
  pair_set& edges(pair_set& s) const;
  index_type n_induced_undirected_edges() const;
  index_type n_induced_undirected_edges(const index_set& n0,
     const index_set& n1) const;
  index_type n_bidirectional_edges() const;
  index_type n_bidirectional_edges(const index_set& n0,
       const index_set& n1) const;
  const index_set& successors(index_type i) const { return out[i]; };
  index_type out_degree(index_type i) const { return out[i].length(); };
  const index_set& predecessors(index_type i) const { return in[i]; };
  index_type in_degree(index_type i) const { return in[i].length(); };
  const index_set& bidirectional(index_type i) const { return bi[i]; };
  index_type bi_degree(index_type i) const { return bi[i].length(); };
  pair_set& bidirectional_edges(pair_set& s) const;
  void descendants(index_type n0, bool_vec& s) const;
  void descendants(const index_set& s0, bool_vec& s) const;
  void descendants(index_type n0, index_set& s) const;
  void descendants(const index_set& s0, index_set& s) const;
  void ancestors(index_type n0, bool_vec& s) const;
  void ancestors(const index_set& s0, bool_vec& s) const;
  void ancestors(index_type n0, index_set& s) const;
  void ancestors(const index_set& s0, index_set& s) const;
  index_type max_out_degree() const;
  index_type max_in_degree() const;
  index_type max_bi_degree() const;
  index_type min_out_degree() const;
  index_type min_in_degree() const;
  index_type min_bi_degree() const;
  bool empty() const;
  bool connected() const;
  bool strongly_connected() const;
  bool reachable(index_type n0, index_type n1) const;
  void reachable(bool_vec& v) const;
  index_type count_reachable(index_type n0) const;
  bool acyclic() const;
  bool top_sort(index_vec& s) const;
  index_type first_root() const;
  index_type first_leaf() const;
  void fringe(const index_set& n, index_set& fn) const;
  void bi_fringe(const index_set& n, index_set& fn) const;
  void distance(index_type s0, index_vec& d) const;
  void distance(const index_set& s0, index_vec& d) const;
  index_type distance(index_type s0, index_type s1) const;
  void strongly_connected_components();
  index_type component(index_type i) const { return comp[i]; };
  index_type n_components() const { return n_comp; };
  index_type component_node(index_type i) const;
  index_type component_size(index_type i) const;
  void component_node_set(index_type i, index_set& set) const;
  graph& component_tree(graph& cg) const;
  equivalence& component_partitioning(equivalence& eq) const;
  index_type maximal_non_unit_component() const;
  graph& subgraph(graph& g, const index_set& n) const;
  graph& edge_subgraph(graph& g, const index_set& nodes) const;
  equivalence& induced_partitioning(equivalence& eq) const;
  graph& induced_undirected_graph(graph& g) const;
  graph& minimal_equivalent_digraph(graph& g) const;
  graph& minimal_distance_graph(graph& g, const index_set& s0) const;
  graph& quotient(graph& g, const equivalence& eq) const;
  bool equals(const graph& g) const;
  bool equals(const graph& g, const index_vec& c) const;
  void difference(const graph& g,
    const index_vec& c,
    pair_set& d0,
    pair_set& d1) const;
  void difference(const graph& g,
    pair_set& d0,
    pair_set& d1) const;
  index_type cardinality_of_difference(const graph& g) const;
  void init(index_type s);
  void copy(const graph& g);
  void copy(const graph& g, const index_vec& map);
  void copy_and_rename(const graph& g, const index_vec& map);
  index_type add_node();
  void remove_node(index_type n);
  void add_graph(const graph& g, mapping& m);
  void add_edge(index_type src, index_type dst);
  void add_edge(const index_set& srcs, index_type dst);
  void add_edge(index_type src, const index_set& dsts);
  void add_edge_to_transitive_closure(index_type src,
          index_type dst,
          pair_set& e);
  void remove_edge(index_type src, index_type dst);
  void remove_edges_from(index_type src);
  void remove_edges_to(index_type dst);
  void remove_edges_incident_on(index_type n);
  void remove_edges(const pair_set& e);
  void add_undirected_edge(index_type n0, index_type n1);
  void remove_undirected_edge(index_type n0, index_type n1);
  void remove_undirected_edges(const pair_set& e);
  void clear_edges();
  void recalculate();
  void complement();
  void complement_with_loops();
  void remove_loops();
  void reverse();
  void transitive_closure();
  void missing_transitive_edges(pair_set& e) const;
  void transitive_reduction();
  void intersect(const graph& g);
  void randomize(count_type n, RNG& rnd);
  void randomize_connected(count_type n, RNG& rnd);
  void randomize_strongly_connected(count_type n, RNG& rnd);
  void random_digraph(count_type n, RNG& rnd);
  void random_connected_digraph(count_type n, RNG& rnd);
  void random_strongly_connected_digraph(count_type n, RNG& rnd);
  void random_digraph_with_density(rational density, RNG& rnd);
  void random_tree(RNG& rnd);
  void random_tree(index_type b, index_type d, RNG& rnd);
  bool is_clique(const index_set& nodes) const;
  bool is_independent(const index_set& nodes) const;
  bool is_independent_range(index_type l, index_type u) const;
  void maximal_clique(index_set& clique) const;
  void maximal_clique_including(index_type node, index_set& clique) const;
  void maximal_clique_cover(index_set_vec& sets) const;
  void all_maximal_cliques(index_set_vec& cliques) const;
  void all_maximal_cliques_including(index_type node, index_set_vec& cliques)
    const;
  void apx_independent_set(index_set& set) const;
  void apx_independent_set_including(index_type node, index_set& set) const;
  void apx_independent_set_cover(index_set_vec& sets) const;
  void apx_independent_set_disjoint_cover(index_set_vec& sets) const;
  void all_nondominated_cliques(index_set_vec &cliques) const;
  void all_cliques_geq(index_type k, index_set_vec& cliques) const;
  void write_node_set(::std::ostream& s) const;
  void write_edge_set(::std::ostream& s) const;
  void write_compact(::std::ostream& s) const;
  void write_undirected_edge_set(::std::ostream& s) const;
  void write_adjacency_lists(::std::ostream& s) const;
  void write_digraph(::std::ostream& s,
       bool with_node_indices,
       const char* name) const;
  void write_component_labeled_digraph(::std::ostream& s,
           const char* name) const;
  void write_graph_correspondance(::std::ostream& s,
      const graph& g,
      const index_vec& c,
      const char* name) const;
 public:
  void max_clique(index_set& sel,
    index_type next,
    index_set& clique) const;
  void all_max_cliques(index_set& sel,
         index_type next,
         index_set_vec& cliques) const;
  void all_nondominated_cliques_aux(index_set_vec &cliques,
                                    index_set &current_clique,
                                    const index_set &candidates,
        index_type min) const;
  void ramsey(const index_set& nodes, index_set& I, index_set& C) const;
  void apx_independent_set(const index_set& nodes, index_set& set) const;
  void undirected_dfs(index_type n, bool_vec& visited) const;
  void reachable(index_type n, bool_vec& v) const;
  void reverse_reachable(index_type n, bool_vec& v) const;
 private:
  void scc_first_dfs(index_type n, bool_vec& visited, index_vec& num) const;
  void scc_second_dfs(index_type n, bool_vec& visited, index_type c_id);
};
template<class LS>
void write_labeled_digraph
(std::ostream& s,
 const graph& g,
 const LS& ls,
 bool with_node_indices = false,
 const char* name = 0,
 index_type c_id = no_such_index)
{
  if (c_id != no_such_index) {
    s << "subgraph cluster" << c_id << "{" << std::endl;
  }
  else if (name) {
    s << "digraph \"" << name << "\" {" << ::std::endl;
  }
  s << "node [width=0,height=0];" << ::std::endl;
  for (index_type k = 0; k < g.size(); k++) {
    if (with_node_indices) {
      s << "\t" << k + (c_id == no_such_index ? 0 : c_id)
 << " [label=\"(" << k << ") " << ls[k] << "\"];"
 << ::std::endl;
    }
    else {
      s << "\t" << k + (c_id == no_such_index ? 0 : c_id)
 << " [label=\"" << ls[k] << "\"];"
 << ::std::endl;
    }
  }
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j))
 s << "\t" << i + (c_id == no_such_index ? 0 : c_id)
   << " -> " << j + (c_id == no_such_index ? 0 : c_id)
   << ";" << ::std::endl;
  if ((c_id != no_such_index) || (name != 0)) {
    s << "}" << ::std::endl;
  }
}
typedef lvector<graph> graph_vec;
template<class N, class E> class labeled_graph : public graph {
 public:
  typedef std::map<index_type, N> node_label_map;
  typedef std::map<index_pair, E> edge_label_map;
  typedef lvector<N> node_label_vec;
  typedef lvector<E> edge_label_vec;
 protected:
  node_label_map _node_label;
  edge_label_map _edge_label;
 public:
  labeled_graph();
  labeled_graph(index_type size);
  labeled_graph(const graph& g);
  labeled_graph(const labeled_graph& g);
  labeled_graph(const graph& g, const index_set& nodes);
  labeled_graph(const labeled_graph& g, const index_set& nodes);
  labeled_graph(const graph& g, const equivalence& eq);
  ~labeled_graph();
  N& node_label(index_type n);
  E& edge_label(index_type i, index_type j);
  const N& node_label(index_type n) const;
  const E& edge_label(index_type i, index_type j) const;
  bool node_has_label(index_type n) const;
  bool edge_has_label(index_type i, index_type j) const;
  labeled_graph& subgraph(labeled_graph& g, const index_set& n) const;
  index_type node_with_label(const N& l) const;
  index_pair edge_with_label(const E& l) const;
  void init(index_type size);
  void init(index_type size, const N& n, const E& e);
  void copy(const graph& g);
  void copy(const labeled_graph& g);
  void add_graph(const graph& g, mapping& m);
  void add_graph(const labeled_graph& g, mapping& m);
  void add_edge(index_type src, index_type dst);
  void add_edge(index_type src, index_type dst, const E& lbl);
  void add_edge(const index_set& srcs, index_type dst);
  void add_edge(const index_set& srcs, index_type dst, const E& lbl);
  void add_edge(index_type src, const index_set& dsts);
  void add_edge(index_type src, const index_set& dsts, const E& lbl);
  index_type add_node();
  index_type add_node(const N& l);
  void remove_node(index_type n);
  void remove_edge(index_type src, index_type dst);
  void remove_edges_from(index_type src);
  void remove_edges_to(index_type dst);
  void remove_edges_incident_on(index_type n);
  void remove_undirected_edge(index_type n0, index_type n1);
  void remove_edges(const pair_set& e);
  void remove_undirected_edges(const pair_set& e);
  void clear_edges();
  void clear_node_labels();
  void clear_edge_labels();
  void remove_edges_with_label(const E& l);
  void write_digraph(::std::ostream& s,
       bool with_node_indices,
       bool with_node_labels,
       bool with_edge_labels,
       bool compact_edges,
       const char* name) const;
  void write_matrix(::std::ostream& s,
      const char* unlabeled_edge,
      const char* missing_edge) const;
};
template<class N, class E>
labeled_graph<N,E>::labeled_graph()
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(index_type s)
  : graph(s)
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(const graph& g)
  : graph(g)
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(const labeled_graph& g)
  : graph(g), _node_label(g._node_label), _edge_label(g._edge_label)
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(const graph& g, const index_set& n)
{
  g.subgraph(*this, n);
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph
(const labeled_graph& g, const index_set& n)
{
  g.subgraph(*this, n);
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph
(const graph& g, const equivalence& eq)
{
  g.quotient(*this, eq);
}
template<class N, class E>
labeled_graph<N,E>::~labeled_graph()
{
}
template<class N, class E>
N& labeled_graph<N,E>::node_label(index_type n)
{
  assert(n < size());
  return _node_label[n];
}
template<class N, class E>
E& labeled_graph<N,E>::edge_label(index_type i, index_type j)
{
  assert((i < size()) && (j < size()));
  return _edge_label[index_pair(i, j)];
}
template<class N, class E>
const N& labeled_graph<N,E>::node_label(index_type n) const
{
  assert(node_has_label(n));
  return (_node_label.find(n)->second);
}
template<class N, class E>
const E& labeled_graph<N,E>::edge_label(index_type i, index_type j) const
{
  assert(edge_has_label(i, j));
  return (_edge_label.find(index_pair(i, j))->second);
}
template<class N, class E>
bool labeled_graph<N,E>::node_has_label(index_type n) const
{
  assert(n < size());
  return (_node_label.find(n) != _node_label.end());
}
template<class N, class E>
bool labeled_graph<N,E>::edge_has_label(index_type i, index_type j) const
{
  assert((i < size()) && (j < size()));
  return (_edge_label.find(index_pair(i, j)) != _edge_label.end());
}
template<class N, class E>
void labeled_graph<N,E>::init(index_type s)
{
  graph::init(s);
  _node_label.clear();
  _edge_label.clear();
}
template<class N, class E>
void labeled_graph<N,E>::copy(const labeled_graph& g)
{
  graph::copy(g);
  _node_label = g._node_label;
  _edge_label = g._edge_label;
}
template<class N, class E>
labeled_graph<N,E>& labeled_graph<N,E>::subgraph
(labeled_graph& g, const index_set& n) const
{
  g.init(n.length());
  for (index_type k = 0; k < n.length(); k++) {
    assert(n[k] < size());
    if (node_has_label(n[k])) {
      g.node_label(k) = node_label(n[k]);
    }
  }
  for (index_type i = 0; i < n.length(); i++)
    for (index_type j = 0; j < n.length(); j++)
      if (adjacent(n[i], n[j])) {
 g.add_edge(i, j);
 if (edge_has_label(n[i], n[j])) {
   g.edge_label(i, j) = edge_label(n[i], n[j]);
 }
      }
}
template<class N, class E>
index_type labeled_graph<N,E>::node_with_label(const N& l) const
{
  for (index_type k = 0; k < size(); k++)
    if (node_has_label(k))
      if (node_label(k) == l)
 return k;
  return no_such_index;
}
template<class N, class E>
index_pair labeled_graph<N,E>::edge_with_label(const E& l) const
{
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) && edge_has_label(i, j))
 if (edge_label(i, j) == l)
   return index_pair(i, j);
  return no_such_index;
}
template<class N, class E>
void labeled_graph<N,E>::add_graph
(const graph& g, mapping& m)
{
  graph::add_graph(g, m);
}
template<class N, class E>
void labeled_graph<N,E>::add_graph
(const labeled_graph& g, mapping& m)
{
  graph::add_graph(g, m);
  for (index_type i = 0; i < g.size(); i++) {
    if (g.node_has_label(i))
      node_label(m[i]) = g.node_label(i);
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j) && g.edge_has_label(i, j))
 edge_label(m[i], m[j]) = g.edge_label(i, j);
  }
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, index_type dst)
{
  graph::add_edge(src, dst);
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, index_type dst, const E& lbl)
{
  graph::add_edge(src, dst);
  edge_label(src, dst) = lbl;
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(const index_set& srcs, index_type dst)
{
  graph::add_edge(srcs, dst);
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(const index_set& srcs, index_type dst, const E& lbl)
{
  graph::add_edge(srcs, dst);
  for (index_type k = 0; k < srcs.length(); k++)
    edge_label(srcs[k], dst) = lbl;
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, const index_set& dsts)
{
  graph::add_edge(src, dsts);
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, const index_set& dsts, const E& lbl)
{
  graph::add_edge(src, dsts);
  for (index_type k = 0; k < dsts.length(); k++)
    edge_label(src, dsts[k]) = lbl;
}
template<class N, class E>
index_type labeled_graph<N,E>::add_node()
{
  return graph::add_node();
}
template<class N, class E>
index_type labeled_graph<N,E>::add_node(const N& l)
{
  index_type n = graph::add_node();
  node_label(n) = l;
  return n;
}
template<class N, class E>
void labeled_graph<N,E>::remove_node(index_type n)
{
  assert(n < size());
  labeled_graph g(*this);
  index_set ns;
  ns.fill(size());
  ns.subtract(n);
  g.subgraph(*this, ns);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edge(index_type src, index_type dst)
{
  _edge_label.erase(index_pair(src, dst));
  graph::remove_edge(src, dst);
}
template<class N, class E>
void labeled_graph<N,E>::remove_undirected_edge(index_type n0, index_type n1)
{
  _edge_label.erase(index_pair(n0, n1));
  _edge_label.erase(index_pair(n1, n0));
  graph::remove_undirected_edge(n0, n1);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_from(index_type src)
{
  index_set ns(successors(src));
  for (index_type k = 0; k < ns.length(); k++)
    remove_edge(src, ns[k]);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_to(index_type dst)
{
  index_set ns(predecessors(dst));
  for (index_type k = 0; k < ns.length(); k++)
    remove_edge(ns[k], dst);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_incident_on(index_type n)
{
  remove_edges_from(n);
  remove_edges_to(n);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges(const pair_set& e)
{
  for (index_type k = 0; k < e.length(); k++) {
    remove_edge(e[k].first, e[k].second);
  }
}
template<class N, class E>
void labeled_graph<N,E>::remove_undirected_edges(const pair_set& e)
{
  for (index_type k = 0; k < e.length(); k++) {
    remove_undirected_edge(e[k].first, e[k].second);
  }
}
template<class N, class E>
void labeled_graph<N,E>::clear_edges()
{
  _edge_label.clear();
  graph::clear_edges();
}
template<class N, class E>
void labeled_graph<N,E>::clear_node_labels()
{
  _node_label.clear();
}
template<class N, class E>
void labeled_graph<N,E>::clear_edge_labels()
{
  _edge_label.clear();
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_with_label(const E& l)
{
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) && (edge_label(i, j) == l))
 remove_edge(i, j);
}
template<class N, class E>
void labeled_graph<N,E>::write_digraph
(::std::ostream& s,
 bool with_node_indices,
 bool with_node_labels,
 bool with_edge_labels,
 bool compact_edges,
 const char* name) const
{
  if (strncmp(name, "cluster", 7) == 0)
    s << "subgraph";
  else
    s << "digraph";
  s << " \"" << name << "\"" << ::std::endl << "{" << ::std::endl;
  if (with_node_indices || with_node_labels) {
    s << "\tnode [shape=ellipse];" << ::std::endl;
  }
  else {
    s << "\tnode [shape=point];" << ::std::endl;
  }
  for (index_type i = 0; i < size(); i++) {
    s << "\t" << i;
    if (with_node_indices || with_node_labels) {
      s << " [label=\"";
      if (with_node_indices) {
 if (with_node_labels) {
   s << i << ": ";
   if (node_has_label(i)) {
     s << node_label(i);
   }
 }
 else {
   s << i;
 }
      }
      else {
 if (node_has_label(i)) {
   s << node_label(i);
 }
      }
      s << "\"]";
    }
    s << ";" << std::endl;
  }
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j)) {
 if (adjacent(j, i) && compact_edges) {
   if (i < j) {
     s << "\t" << i << " -> " << j;
     s << " [dir=both";
     if (with_edge_labels &&
  (edge_has_label(i, j) || edge_has_label(j, i))) {
       if (!edge_has_label(i, j)) {
  s << ",label=\"" << edge_label(j, i) << "\"";
       }
       else if (!edge_has_label(j, i)) {
  s << ",label=\"" << edge_label(i, j) << "\"";
       }
       else if (edge_label(i, j) == edge_label(j, i)) {
  s << ",label=\"" << edge_label(i, j) << "\"";
       }
       else {
  s << ",label=\"" << edge_label(i, j) << ", "
    << edge_label(j, i) << "\"";
       }
     }
     s << "]" << ::std::endl;
   }
 }
 else {
   s << "\t" << i << " -> " << j;
   if (with_edge_labels && edge_has_label(i, j)) {
     s << " [label=\"" << edge_label(i, j) << "\"]";
   }
   s << ";" << ::std::endl;
 }
      }
  s << "}" << ::std::endl;
}
template<class N, class E>
void labeled_graph<N,E>::write_matrix
(::std::ostream& s, const char* unlabeled_edge, const char* missing_edge) const
{
  s << '[';
  for (index_type i = 0; i < size(); i++) {
    if (i > 0) s << ' ';
    s << '[';
    for (index_type j = 0; j < size(); j++) {
      if (j > 0) s << ',';
      if (adjacent(i, j)) {
 if (edge_has_label(i, j)) {
   s << edge_label(i, j);
 }
 else {
   s << unlabeled_edge;
 }
      }
      else {
 s << missing_edge;
      }
    }
    s << ']';
    if (i + 1 < size()) {
      s << ',' << '\n';
    }
    else {
      s << ']' << '\n';
    }
  }
}
class index_graph : public labeled_graph<index_type,index_type> {
  static const index_type NODE_SHAPE = 2 + 4 + 8 + 16;
  static const index_type NODE_STYLE = 64 + 128 + 256;
  static const index_type EDGE_STYLE = 64 + 128;
  static const index_type EDGE_DIR = 512 + 1024;
 public:
  static const index_type NS_CIRCLE = 0;
  static const index_type NS_ELLIPSE = 2;
  static const index_type NS_BOX = 4;
  static const index_type NS_POINT = 6;
  static const index_type NS_DIAMOND = 8;
  static const index_type NS_HEXAGON = 10;
  static const index_type NS_OCTAGON = 12;
  static const index_type NS_PLAINTEXT = 14;
  static const index_type NS_NORMAL = 0;
  static const index_type NS_DOUBLE = 32;
  static const index_type NS_BOLD = 64;
  static const index_type NS_DASHED = 128;
  static const index_type NS_DOTTED = 192;
  static const index_type NS_FILLED = 256;
  static const index_type ED_NONE = 0;
  static const index_type ED_FORWARD = 512;
  static const index_type ED_BACK = 1024;
  static const index_type ED_BOTH = ED_FORWARD + ED_BACK;
  static const index_type ES_NORMAL = NS_NORMAL;
  static const index_type ES_BOLD = NS_BOLD;
  static const index_type ES_DASHED = NS_DASHED;
  static const index_type ES_DOTTED = NS_DOTTED;
  static const index_type STYLE_MAX = 2048;
  index_graph()
    : labeled_graph<index_type, index_type>() { };
  index_graph(index_type size)
    : labeled_graph<index_type, index_type>(size) { };
  index_graph(const graph& g)
    : labeled_graph<index_type, index_type>(g) { };
  index_graph(const index_graph& g)
    : labeled_graph<index_type, index_type>(g) { };
  index_graph(const graph& g, const index_set& nodes)
    : labeled_graph<index_type, index_type>(g, nodes) { };
  index_graph(const index_graph& g, const index_set& nodes)
    : labeled_graph<index_type, index_type>(g, nodes) { };
  index_graph(const graph& g, const equivalence& eq)
    : labeled_graph<index_type, index_type>(g, eq) { };
  ~index_graph() { };
  void reverse();
  void reflect();
  static void write_node_style(std::ostream& s, index_type l);
  static void write_edge_style(std::ostream& s, index_type l);
  void write_styled_digraph(std::ostream& s,
       bool with_node_indices = false,
       const char* name = 0,
       index_type c_id = no_such_index) const;
  void write_matrix(std::ostream& s) const;
  void write_MATLAB(std::ostream& s,
      const char* n,
      const char* t) const;
};
template<class LS>
void write_styled_digraph
(std::ostream& s,
 const index_graph& g,
 const LS& ls,
 bool with_node_indices = false,
 const char* name = 0,
 index_type c_id = no_such_index)
{
  if (c_id != no_such_index) {
    s << "subgraph cluster" << c_id << " {" << std::endl;
    s << "node [width=0.5,height=0.5];" << ::std::endl;
  }
  else if (name) {
    s << "digraph \"" << name << "\" {" << std::endl;
    s << "node [width=0.5,height=0.5];" << ::std::endl;
  }
  for (index_type k = 0; k < g.size(); k++) {
    s << "\t" << k + (c_id != no_such_index ? c_id : 0) << " [";
    index_graph::write_node_style(s, g.node_has_label(k) ? g.node_label(k) : 0);
    if (with_node_indices)
      s << ",label=\"(" << k << ") " << ls[k] << "\"];" << std::endl;
    else
      s << ",label=\"" << ls[k] << "\"];" << std::endl;
  }
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j)) {
 s << "\t" << i + (c_id != no_such_index ? c_id : 0)
   << " -> " << j + (c_id != no_such_index ? c_id : 0) << " [";
 index_graph::write_edge_style(s, g.edge_has_label(i, j) ? g.edge_label(i, j) : 0);
 s << "];" << std::endl;
      }
  if ((c_id != no_such_index) || (name != 0)) {
    s << "}" << ::std::endl;
  }
}
class weighted_graph : public labeled_graph<hsps::rational,hsps::rational> {
 public:
  weighted_graph() { };
  weighted_graph(index_type s)
    : labeled_graph<hsps::rational,hsps::rational>(s) { };
  weighted_graph(const graph& g)
    : labeled_graph<hsps::rational,hsps::rational>(g) { };
  weighted_graph(const weighted_graph& g)
    : labeled_graph<hsps::rational,hsps::rational>(g) { };
  weighted_graph(const graph& g, const index_set& n)
    : labeled_graph<hsps::rational,hsps::rational>(g, n) { };
  weighted_graph(const weighted_graph& g, const index_set& n)
    : labeled_graph<hsps::rational,hsps::rational>(g, n) { };
  weighted_graph(const graph& g, const equivalence& eq)
    : labeled_graph<hsps::rational,hsps::rational>(g, eq) { };
  weighted_graph(const weighted_graph& g, const equivalence& eq);
  ~weighted_graph() { };
  weighted_graph& quotient(weighted_graph& g, const equivalence& eq) const;
  hsps::rational apx_weighted_independent_set_1(index_set& set) const;
  hsps::rational apx_weighted_independent_set_2(index_set& set) const;
  hsps::rational apx_weighted_independent_set(index_set& set) const;
  void add_edge(index_type src, index_type dst);
  void add_edge(index_type src, index_type dst, hsps::rational w);
  void add_undirected_edge(index_type n0, index_type n1);
  void add_undirected_edge(index_type n0, index_type n1, hsps::rational w);
  hsps::rational weight(index_type n) const;
  hsps::rational weight(index_type n0, index_type n1) const;
  hsps::rational weight(const index_set& ns) const;
  void set_weight(index_type n, hsps::rational w);
  void set_weight(index_type n0, index_type n1, hsps::rational w);
  void increment_edge_weight(index_type src, index_type dst, hsps::rational w);
  hsps::rational max_node_weight() const;
  void transitive_closure();
  hsps::rational critical_path(cost_vec& s);
  hsps::rational max_flow(index_type s, index_type t);
  hsps::rational max_flow(index_type s, index_type t, weighted_graph& rg);
  hsps::rational max_flow(index_type s, index_type t, cost_matrix& f);
  hsps::rational min_cut(index_type s, index_type t, bool_vec& s_set);
  hsps::rational min_cut(index_type s, index_type t, pair_set& e_set);
  index_pair max_weight_edge() const;
  void min_and_max_edges(const index_set& nodes,
    pair_set& e_min, hsps::rational& w_min,
    pair_set& e_max, hsps::rational& w_max) const;
  hsps::rational maximal_matching(weighted_graph& matching);
  hsps::rational apx_matching(bool_vec& nodes);
  void write_node_set(::std::ostream& s) const;
  void write_edge_set(::std::ostream& s) const;
  void write_compact(::std::ostream& s) const;
  void write_matrix(::std::ostream& s) const;
 private:
  hsps::rational augmenting_path(index_type s, index_type t, const cost_matrix& f,
   pair_vec& p);
};
class index_set_graph : public labeled_graph<index_set,index_set> {
 public:
  index_set_graph() { };
  index_set_graph(index_type s)
    : labeled_graph<index_set,index_set>(s) { };
  index_set_graph(const graph& g)
    : labeled_graph<index_set,index_set>(g) { };
  index_set_graph(const index_set_graph& g)
    : labeled_graph<index_set,index_set>(g) { };
  index_set_graph(const graph& g, const index_set& n)
    : labeled_graph<index_set,index_set>(g, n) { };
  index_set_graph(const index_set_graph& g, const index_set& n)
    : labeled_graph<index_set,index_set>(g, n) { };
  index_set_graph(const graph& g, const equivalence& eq);
  index_set_graph(const index_set_graph& g, const equivalence& eq);
  ~index_set_graph() { };
  void union_reachable();
  void merge_labels(const index_set& ns);
  void merge_labels_upwards();
  void merge_labels_downwards();
  index_set_graph& quotient(index_set_graph& g, const equivalence& eq) const;
  index_set_graph& union_reachable(index_set_graph& g) const;
  index_set_graph& subgraph_set_size_gt(index_set_graph& g, index_type l);
  void write_edge_set(::std::ostream& s) const;
  void write_digraph(::std::ostream& s, const char* name) const;
};
inline ::std::ostream& operator<<(::std::ostream& s, const graph& g)
{
  g.write_compact(s);
  return s;
};
inline ::std::ostream& operator<<(::std::ostream& s, const weighted_graph& g)
{
  g.write_compact(s);
  return s;
};
inline ::std::ostream& operator<<(::std::ostream& s, const index_set_graph& g)
{
  g.write_edge_set(s);
  return s;
};
}
namespace hsps {
class Heuristic;
struct rule {
  index_set antecedent;
  index_type consequent;
  rule() : antecedent(EMPTYSET), consequent(no_such_index) { };
  rule(index_type c) : antecedent(EMPTYSET), consequent(c) { };
  rule(const index_set& a, index_type c) : antecedent(a), consequent(c) { };
  rule(const rule& r) : antecedent(r.antecedent), consequent(r.consequent) { };
  rule& operator=(const rule& r) {
    antecedent = r.antecedent;
    consequent = r.consequent;
    return *this;
  };
  bool operator==(const rule& r) const {
    return ((antecedent == r.antecedent) && (consequent == r.consequent));
  };
  bool operator!=(const rule& r) const {
    return (!(*this == r));
  };
  bool operator<(const rule& r) const {
    return ((consequent < r.consequent) ||
     ((consequent == r.consequent) && (antecedent < r.antecedent)));
  };
  bool operator>(const rule& r) const {
    return ((consequent > r.consequent) ||
     ((consequent == r.consequent) && (antecedent > r.antecedent)));
  };
};
class rule_set : public svector<rule> {
 public:
  index_type find_rule(index_type c) const;
  void compute_dependency_graph(index_type n, index_graph& g) const;
  void remove(const bool_vec& set, index_vec& map);
  void remove(const bool_vec& set, index_graph& g);
  void remove(const bool_vec& set);
  void make_acyclic(index_graph& g);
  void make_post_unique(index_graph& g);
};
typedef svector<const char*> string_set;
class Instance {
  bool xrf;
 public:
  static bool write_negation;
  static bool write_DKEL;
  static bool write_PDDL2;
  static bool write_time;
  static bool write_PDDL3;
  static bool write_metric;
  static bool write_extra;
  static bool write_resource_constraints_at_start;
  static bool always_write_parameters;
  static bool always_write_requirements;
  static bool always_write_precondition;
  static bool always_write_effect;
  static bool always_write_conjunction;
  static bool write_atom_set_with_symbolic_names;
  static bool write_action_set_with_symbolic_names;
  static const char* goal_atom_name;
  static const char* goal_action_name;
  static hsps::rational goal_action_cost;
  static const char* pc_name;
  static index_type pc_count;
  struct Atom {
    const Name* name;
    index_type index;
    index_type neg;
    bool init;
    hsps::rational init_t;
    bool goal;
    hsps::rational goal_t;
    bool irrelevant;
    void* src;
    index_vec req_by;
    index_vec add_by;
    index_vec del_by;
    Atom() : name(0), index(no_such_index), neg(no_such_index),
  init(false), init_t(0), goal(false), goal_t(POS_INF),
  irrelevant(false), src(0), req_by(no_such_index, 0),
  add_by(no_such_index, 0), del_by(no_such_index, 0) { };
    Atom(const Name* n) : name(n), index(0), neg(no_such_index),
  init(false), init_t(0), goal(false), goal_t(POS_INF),
  irrelevant(false), src(0), req_by(no_such_index, 0),
  add_by(no_such_index, 0), del_by(no_such_index, 0) { };
    Atom(const Name* n, index_type i) : name(n), index(i),
  neg(no_such_index), init(false), init_t(0), goal(false),
  goal_t(POS_INF),
  irrelevant(false), req_by(no_such_index, 0),
  add_by(no_such_index, 0), del_by(no_such_index, 0) { };
    Atom& operator=(const Atom& a) {
      name = a.name;
      index = a.index;
      neg = a.neg;
      init = a.init;
      init_t = a.init_t;
      goal = a.goal;
      goal_t = a.goal_t;
      irrelevant = a.irrelevant;
      src = a.src;
      req_by = a.req_by;
      add_by = a.add_by;
      del_by = a.del_by;
      return *this;
    };
    bool operator==(const Atom& a) {
      return (index == a.index);
    };
  };
  struct Resource {
    const Name* name;
    index_type index;
    hsps::rational init;
    void* src;
    bool consumed;
    bool used;
    Resource() : name(0), index(no_such_index), init(0), src(0),
  consumed(false), used(false) { };
    Resource(const Name* n) : name(n), index(no_such_index), init(0), src(0),
  consumed(false), used(false) { };
    Resource(const Name* n, index_type i) : name(n), index(i), init(0),
  src(0), consumed(false), used(false) { };
    Resource& operator=(const Resource& r) {
      name = r.name;
      index = r.index;
      init = r.init;
      src = r.src;
      consumed = r.consumed;
      used = r.used;
      return *this;
    };
    bool operator==(const Resource& r) {
      return (index == r.index);
    };
    bool reusable() const { return (used && !consumed); };
    bool consumable() const { return (consumed); };
  };
  struct Action {
    const Name* name;
    index_type index;
    bool sel;
    index_set pre;
    index_set add;
    index_set del;
    index_set lck;
    amt_vec use;
    amt_vec cons;
    hsps::rational dur;
    hsps::rational dmin;
    hsps::rational dmax;
    hsps::rational cost;
    const char* assoc;
    void* src;
    index_set ncw_atms;
    Action()
      : name(0), index(no_such_index), sel(true), pre(), add(), del(),
        lck(), use(ZERO, 0), cons(ZERO, 0), dur(1), dmin(1), dmax(1), cost(1),
  assoc(0), src(0), ncw_atms() { };
    Action(const Name* n)
      : name(n), index(no_such_index), sel(true), pre(), add(), del(),
        lck(), use(ZERO, 0), cons(ZERO, 0), dur(1), dmin(1), dmax(1), cost(1),
 assoc(0), src(0), ncw_atms() { };
    Action& operator=(const Action& a) {
      name = a.name;
      index = a.index;
      sel = a.sel;
      pre = a.pre;
      add = a.add;
      del = a.del;
      lck = a.lck;
      use = a.use;
      cons = a.cons;
      dur = a.dur;
      dmin = a.dmin;
      dmax = a.dmax;
      cost = a.cost;
      assoc = a.assoc;
      src = a.src;
      ncw_atms = a.ncw_atms;
      return *this;
    };
    bool operator==(const Action& a) {
      return (index == a.index);
    };
    hsps::rational req(index_type r) const { return use[r] + cons[r]; };
    bool e_deletes(index_type p, Heuristic* inc) const;
    bool e_deletes(const index_set& s, Heuristic* inc) const;
  };
  struct Constraint {
    const Name* name;
    index_type index;
    index_set set;
    index_type lim;
    bool exact;
    void* src;
    bool verified;
    Constraint() : name(0), index(no_such_index), set(), lim(0),
  exact(false), src(0), verified(false) { };
    Constraint(const Name* n) : name(n), index(no_such_index),
  set(), lim(0), exact(false), src(0), verified(false) { };
    Constraint(index_set s, index_type n, bool e) : name(0),
  index(no_such_index), set(s), lim(n), exact(e), src(0),
  verified(false) { };
    Constraint& operator=(const Constraint& c) {
      name = c.name;
      index = c.index;
      set = c.set;
      lim = c.lim;
      exact = c.exact;
      src = c.src;
      verified = c.verified;
      return *this;
    };
    bool operator==(const Constraint& c) {
      return ((set == c.set) && (lim == c.lim) && (exact == c.exact));
    };
  };
  typedef lvector<Atom> atom_vec;
  typedef lvector<Resource> resource_vec;
  typedef lvector<Action> action_vec;
  typedef lvector<Constraint> constraint_vec;
  typedef atom_vec::element_reference atom_ref;
  typedef resource_vec::element_reference resource_ref;
  typedef action_vec::element_reference action_ref;
  typedef constraint_vec::element_reference constraint_ref;
  const Name* name;
  atom_vec atoms;
  action_vec actions;
  resource_vec resources;
  constraint_vec invariants;
  index_set init_atoms;
  index_set goal_atoms;
  index_type max_pre, max_add, max_del, max_lck,
               max_add_by, max_del_by, max_req_by;
  hsps::rational min_dur, max_dur, min_cost, max_cost;
  set_hash_function atom_set_hash;
  set_hash_function action_set_hash;
  static int default_trace_level;
  int trace_level;
  Instance();
  Instance(const Name* n);
  Instance(const Instance& ins);
  ~Instance() { };
  Atom& new_atom(const Name* name);
  Resource& new_resource(const Name* name);
  Action& new_action(const Name* name);
  Action& copy_action(index_type a);
  Constraint& new_invariant();
  Constraint& new_invariant(const Name* name);
  Constraint& new_invariant(const index_set& s, index_type l, bool e);
  void copy(const Instance& ins);
  Instance* copy() const;
  void clear();
  void restricted_copy(const Instance& ins, const index_set& atms,
         const index_set& rc, index_set& acts, index_vec& map);
  void restricted_copy(const Instance& ins, const index_set& acts,
         index_vec& map);
  void abstracted_copy(const Instance& ins, const index_set& atms,
         index_vec& atm_map, index_vec& act_map);
  void reverse_copy(const Instance& ins);
  void delete_relax(const index_set& x_atms);
  void delete_relax_less(const index_set& x_atms);
  void assign_unique_action_names();
  void remove_actions(const bool_vec& set, index_vec& map);
  void remove_atoms(const bool_vec& set, index_vec& map);
  void remove_invariants(const bool_vec& set, index_vec& map);
  void remap_set(index_set& set, const index_vec& map);
  void remap_sets(index_set_vec& sets, const index_vec& map);
  void set_initial(const index_set& init);
  void set_goal(const index_set& goal);
  void set_DNF_goal(const index_set_vec& goal);
  void replace_atom_by_conjunction(index_type p, const index_set& c);
  void set_cost_bound(hsps::rational b);
  void create_composite_resource(const index_set& set);
  void create_total_resource();
  void extract_atom_negations_from_invariants();
  index_type complete_atom_negation(index_type a);
  void complete_atom_negations(const index_set& s);
  void complete_atom_negations();
  index_type create_history_atom(index_type a);
  void add_all_negation_invariants();
  void add_missing_negation_invariants();
  index_type compile_pc_always(const index_set& f, const Name* n);
  index_type compile_pc_sometime(const index_set& f, const Name* n);
  index_type compile_pc_at_most_once(const index_set& f, const Name* n);
  index_type compile_pc_sometime_before(const index_set& f_t,
     const index_set& f_c,
     const Name* n);
  void enforce_pc_always(const index_set& f, const Name* n);
  void enforce_pc_sometime(const index_set& f, const Name* n);
  void enforce_pc_at_most_once(const index_set& f, const Name* n);
  void enforce_pc_sometime_before(const index_set& f_t,
      const index_set& f_c,
      const Name* n);
  void compute_iff_axioms(rule_set& ax);
  void cross_reference();
  void clear_cross_reference();
  bool cross_referenced() const;
  bool verify_invariant(Constraint& inv);
  void verify_invariants();
  void save_durations(cost_vec& out) const;
  void set_durations(const cost_vec& in);
  void set_durations(const cost_vec& in, cost_vec& out);
  void assign_unit_durations(hsps::rational unit = hsps::rational(1));
  void discretize_durations(hsps::rational interval_width);
  void quantize_durations(index_type n_intervals);
  void round_durations_up();
  void round_durations_down();
  void round_durations();
  void assign_unit_costs(cost_vec& save);
  void restore_costs(const cost_vec& saved);
  void assign_unlimited_resources(cost_vec& save);
  void restore_resources(const cost_vec& saved);
  index_type n_atoms() const { return atoms.length(); };
  index_type n_resources() const { return resources.length(); };
  index_type n_reusable_resources() const;
  index_type n_consumable_resources() const;
  index_type n_actions() const { return actions.length(); };
  index_type n_invariants() const { return invariants.length(); };
  index_type n_verified_invariants() const;
  void atom_names(name_vec& names) const;
  void action_names(name_vec& names) const;
  void coadd_graph(graph& g) const;
  void cochange_graph(graph& g) const;
  void causal_graph(graph& g) const;
  void partitioning_graph(const index_set& goal,
     index_set_graph& g,
     index_set& n_goal) const;
  void make_graph_representation(index_graph& g, name_vec& nn);
  bool non_interfering(index_type a0, index_type a1) const;
  bool lock_compatible(index_type a0, index_type a1) const;
  bool resource_compatible(index_type a0, index_type a1) const;
  bool commutative(const Action& a0, const Action& a1) const;
  bool commutative(index_type a0, index_type a1) const;
  bool additive(index_type p0, index_type p1) const;
  bool cochanged(index_type p0, index_type p1) const;
  bool eval_invariant_in_partial_state(const index_set& s,
           const Constraint& inv);
  bool eval_invariant_in_partial_state(const bool_vec& s,
           const Constraint& inv);
  bool eval_invariant_in_complete_state(const index_set& s,
     const Constraint& inv);
  bool eval_invariant_in_complete_state(const bool_vec& s,
     const Constraint& inv);
  void negation_atom_set(const index_set& pset, index_set& nset) const;
  void write_atom_set(::std::ostream& s,
        const index_vec& set,
        unsigned int c = Name::NC_DEFAULT) const;
  void write_atom_set(::std::ostream& s,
        const bool_vec& set,
        unsigned int c = Name::NC_DEFAULT) const;
  void write_atom_sets(::std::ostream& s,
         const index_set_vec& sets,
         unsigned int c = Name::NC_DEFAULT) const;
  void write_action_set(::std::ostream& s,
   const index_vec& set,
   unsigned int c = Name::NC_DEFAULT) const;
  void write_action_set(::std::ostream& s,
   const bool_vec& set,
   unsigned int c = Name::NC_DEFAULT) const;
  void write_iff_axiom(::std::ostream& s, const rule& r) const;
  void write_iff_axiom_set(::std::ostream& s, const rule_set& rset) const;
  void write_atom_digraph(::std::ostream& s,
     const graph& g,
     const index_set& atomset,
     const bool_vec& mark_shaded,
     const bool_vec& mark_dashed,
     const char* label) const;
  void write_atom_digraph(::std::ostream& s,
     const graph& g,
     const char* label) const;
  void write_atom_action_digraph(::std::ostream& s,
     const graph& g,
     const index_set& atomset,
     const index_set& actionset,
     const bool_vec& mark_shaded,
     const bool_vec& mark_bold,
     const bool_vec& mark_dashed,
     const char* label) const;
  void write_atom_set_digraph(::std::ostream& s,
         const index_set_graph& g,
         const char* label) const;
  void write_atom_set_graph(::std::ostream& s,
       const index_set_graph& g,
       const char* label) const;
  void write_axiom_dependency_graph(::std::ostream& s,
        const index_graph& g,
        const char* label) const;
  virtual void write_PDDL_action
    (::std::ostream& s, const Action& act) const;
  virtual void write_DKEL_invariant_item
    (::std::ostream& s, const Constraint& inv, string_set& tags) const;
  virtual void write_DKEL_irrelevant_atom_item
    (::std::ostream& s, const Atom& atm, string_set& tags) const;
  virtual void write_DKEL_irrelevant_action_item
    (::std::ostream& s, const Action& act, string_set& tags) const;
  virtual void write_domain_atom_set
    (::std::ostream& s, const index_set& set) const;
  virtual void write_domain_action_set
    (::std::ostream& s, const index_set& set) const;
  virtual void write_domain_action_set
    (::std::ostream& s, const index_set& set, const Name* name) const;
  virtual void write_domain(::std::ostream& s) const;
  virtual void write_domain_init(::std::ostream& s) const;
  virtual void write_domain_declarations(::std::ostream& s) const;
  virtual void write_domain_actions(::std::ostream& s) const;
  virtual void write_domain_DKEL_items(::std::ostream& s) const;
  virtual void write_problem(::std::ostream& s) const;
  virtual void write_problem_init(::std::ostream& s) const;
  virtual void write_problem_goal(::std::ostream& s) const;
  virtual void write_problem_metric(::std::ostream& s) const;
  void print_atom(::std::ostream& s, const Atom& a) const;
  void print_resource(::std::ostream& s, const Resource& r) const;
  void print_action(::std::ostream& s, const Action& a) const;
  void print_invariant(::std::ostream& s, const Constraint& c) const;
  virtual void print(::std::ostream& s) const;
 private:
  void create_atom_negation(index_type a);
};
typedef lvector<Instance*> instance_vec;
class PreconditionEvaluator {
  enum eval_node_type { positive_leaf,
   undecided_leaf,
   no_test,
   test_invariant,
   test_atom };
  Instance& instance;
  eval_node_type node_type;
  index_type i_test;
  lvector<PreconditionEvaluator*> next;
  PreconditionEvaluator* prev;
  index_type n_positive;
  index_set acts;
  static void construct(Instance& ins,
   PreconditionEvaluator* p,
   bool_vec& s,
   bool_vec& ua,
   index_type n_ua,
   index_type n_pos,
   bool_vec& rem_invs,
   bool_vec& rem_atoms,
   hsps::rational T);
 public:
  PreconditionEvaluator(Instance& ins);
  ~PreconditionEvaluator();
  static PreconditionEvaluator* construct(Instance& ins, hsps::rational T);
  PreconditionEvaluator* node(const bool_vec& s);
  index_type eval(const bool_vec& s,
    const bool_vec& a,
    index_type* app,
    index_type c);
  void write_graph(std::ostream& s, bool root = true);
};
inline ::std::ostream& operator<<(::std::ostream& s, const rule& r)
{
  return s << r.antecedent << "->" << r.consequent;
};
inline ::std::ostream& operator<<(::std::ostream& s, const rule_set& r)
{
  s << '{';
  for (index_type k = 0; k < r.length(); k++) {
    if (k > 0) s << ',';
    s << r[k];
  }
  s << '}';
  return s;
};
}
namespace hsps {
class Search;
class Plan;
class State {
 protected:
  State* pre;
 public:
  State() : pre(0) { };
  State(const State& s) : pre(s.pre) { };
  virtual ~State();
  virtual const State* predecessor() const;
  virtual State* predecessor();
  virtual void set_predecessor(State* p);
  virtual bool is_encapsulated();
  virtual hsps::rational delta_cost() = 0;
  virtual hsps::rational acc_cost();
  virtual index_type depth() const;
  virtual hsps::rational est_cost() = 0;
  virtual bool is_final() = 0;
  virtual bool is_max() = 0;
  virtual hsps::rational expand(Search& s, hsps::rational bound) = 0;
  virtual void store(hsps::rational cost, bool opt) = 0;
  virtual void reevaluate() = 0;
  virtual int compare(const State& s) = 0;
  virtual index_type hash() = 0;
  virtual State* copy() = 0;
  virtual void insert(Plan& p) = 0;
  virtual void insert_path(Plan& p) = 0;
  virtual void write(::std::ostream& s) = 0;
  virtual void write_plan(::std::ostream& s) = 0;
  virtual void write_eval(::std::ostream& s, char* p = 0, bool e = true);
  State* copy_path();
  void delete_path();
  int compare_path(const State* s);
  void write_path(::std::ostream& s);
  virtual void write_path_as_graph(::std::ostream& s);
};
inline bool operator==(State& s0, State& s1) {
  return (s0.compare(s1) == 0);
}
inline bool operator<(State& s0, State& s1) {
  return (s0.compare(s1) < 0);
}
inline bool operator<=(State& s0, State& s1) {
  return (s0.compare(s1) <= 0);
}
inline bool operator>(State& s0, State& s1) {
  return (s0.compare(s1) > 0);
}
inline bool operator>=(State& s0, State& s1) {
  return (s0.compare(s1) >= 0);
}
inline ::std::ostream& operator<<(::std::ostream& s, State& state) {
  state.write(s);
  return s;
}
class ProgressionState : public State {
 public:
  ProgressionState() { };
  ProgressionState(const ProgressionState& s) : State(s) { };
  virtual ~ProgressionState() { };
  virtual void insert_path(Plan& p);
};
class RegressionState : public State {
 public:
  RegressionState() { };
  RegressionState(const RegressionState& s) : State(s) { };
  virtual ~RegressionState() { };
  virtual void insert_path(Plan& p);
};
typedef lvector<State*> state_vec;
class PlanTrait {
 public:
  PlanTrait() { };
  virtual ~PlanTrait();
  virtual const PlanTrait* cast_to(const char* class_name) const;
};
typedef lvector<PlanTrait*> plan_trait_vec;
class Plan {
 public:
  virtual ~Plan();
  virtual void protect(index_type atom) = 0;
  virtual void insert(index_type act) = 0;
  virtual void advance(hsps::rational delta) = 0;
  virtual void end() = 0;
  virtual void output(Plan& to);
  virtual void set_name(const Name* n);
  virtual void set_optimal(bool o);
  virtual void add_trait(PlanTrait* t);
};
class Search {
 public:
  virtual ~Search();
  virtual hsps::rational new_state(State& s, hsps::rational bound) = 0;
  virtual bool solved() const = 0;
  virtual bool optimal() const = 0;
  virtual bool done() const = 0;
};
class NoSearch : public Search {
  bool _solved;
 public:
  NoSearch() : _solved(false) { };
  virtual ~NoSearch();
  void reset();
  virtual hsps::rational new_state(State& s, hsps::rational bound);
  virtual bool solved() const;
  virtual bool optimal() const;
  virtual bool done() const;
};
class Transitions : public state_vec, public Search {
  State* target_state;
  hsps::rational delta_bound;
  bool bound_is_exact;
 public:
  Transitions();
  Transitions(State* from, State* to, hsps::rational db);
  virtual ~Transitions();
  void clear();
  bool find(State* from, State* to, hsps::rational d, bool x);
  virtual hsps::rational new_state(State& s, hsps::rational bound);
  virtual bool solved() const;
  virtual bool optimal() const;
  virtual bool done() const;
};
class StateFactory {
 public:
  virtual ~StateFactory();
  virtual State* new_state(const index_set& s, State* pre) = 0;
  virtual State* new_state(const bool_vec& s, State* pre) = 0;
};
class PlanSet {
 public:
  virtual ~PlanSet();
  virtual Plan* new_plan() = 0;
  virtual void output(PlanSet& to);
  virtual void output(PlanSet& to, const bool_vec& s);
};
}
namespace hsps {
extern const double D_INF;
class Stopwatch {
  double start_t;
  double current_t;
  double total_t;
  static constexpr double TIME_OUT_TOLERANCE = 1.1;
  static bool interrupt_signal_trapped;
  static volatile bool interrupt_signal_raised;
  static bool alarm_signal_trapped;
  static volatile bool alarm_signal_raised;
  bool interrupt_enabled;
  bool time_out_enabled;
  double time_out_t;
  bool memory_limit_enabled;
  unsigned long memory_limit;
  bool stack_limit_enabled;
  unsigned long stack_limit;
  static void alarm_handler(int sig);
  static void interrupt_handler(int sig);
  static void check_stack();
  void set_interrupt();
  void clear_interrupt();
  void set_alarm(double t);
  void clear_alarm();
  void check_signals();
  static unsigned long peak_mem;
  static unsigned long peak_size;
  static unsigned long peak_stack;
  static unsigned long init_stack;
 protected:
  bool interrupt_flag;
  bool time_out_flag;
  bool out_of_memory_flag;
  bool out_of_stack_flag;
  bool error_flag;
  count_type running;
  bool terminate_on_interrupt;
  bool terminate_on_time_out;
  bool terminate_on_out_of_memory;
  bool terminate_on_out_of_stack;
  bool terminate_on_error;
 public:
  static const long FLAG_INTERRUPTED = 1;
  static const long FLAG_TIME_OUT = 2;
  static const long FLAG_OUT_OF_MEMORY = 4;
  static const long FLAG_OUT_OF_STACK = 8;
  static const long FLAG_ERROR = 16;
  Stopwatch();
  ~Stopwatch();
  static double seconds();
  void enable_interrupt(bool terminate);
  void disable_interrupt();
  void enable_time_out(double t, bool terminate);
  void disable_time_out();
  void enable_memory_limit(unsigned long l, bool terminate);
  void disable_memory_limit();
  void enable_stack_limit(unsigned long l, bool terminate);
  void disable_stack_limit();
  void set_terminate_flags(bool on_interrupt,
      bool on_time_out,
      bool on_out_of_memory,
      bool on_out_of_stack,
      bool on_error);
  bool interrupt_raised();
  bool time_out_raised();
  bool out_of_memory_raised();
  bool out_of_stack_raised();
  bool error_raised();
  double remaining();
  bool break_signal_raised();
  virtual void interrupt();
  virtual void time_out();
  virtual void out_of_memory();
  virtual void out_of_stack();
  virtual void error();
  virtual void start();
  virtual void stop();
  virtual void reset();
  count_type run_level() { return running; };
  void add(Stopwatch& s);
  void add_total(Stopwatch& s);
  double time();
  double total_time();
  unsigned long peak_memory() const;
  unsigned long peak_total_size() const;
  unsigned long peak_stack_size() const;
  unsigned long flags();
  void print(::std::ostream& s);
};
class Statistics : public Stopwatch {
  count_type min_nodes_created;
  count_type max_nodes_created;
  count_type min_nodes_expanded;
  count_type max_nodes_expanded;
  count_type iterations_started;
  count_type iterations_finished;
  count_type total_min_nodes_created;
  count_type total_max_nodes_created;
  count_type total_min_nodes_expanded;
  count_type total_max_nodes_expanded;
  count_type total_iterations_started;
  count_type total_iterations_finished;
  index_type max_depth;
  hsps::rational max_lb;
  count_type nodes_to_prove_lb;
 public:
  static bool long_print_format;
  static bool running_print_max;
  Statistics()
    : min_nodes_created(0), max_nodes_created(0),
    min_nodes_expanded(0), max_nodes_expanded(0),
    iterations_started(0), iterations_finished(0),
    total_min_nodes_created(0), total_max_nodes_created(0),
    total_min_nodes_expanded(0), total_max_nodes_expanded(0),
    total_iterations_started(0), total_iterations_finished(0),
    max_depth(0), max_lb(0), nodes_to_prove_lb(0)
    { };
  void create_node(State& s);
  void expand_node(State& s);
  void current_lower_bound(hsps::rational b);
  void begin_iteration();
  void end_iteration();
  virtual void start();
  virtual void stop();
  virtual void reset();
  virtual void time_out();
  virtual void interrupt();
  virtual void out_of_memory();
  virtual void out_of_stack();
  void add(Statistics& s);
  void add_nodes(Statistics& s);
  void add_total(Statistics& s);
  void add_nodes_total(Statistics& s);
  double branching_factor() const {
    return ((min_nodes_created + max_nodes_created)/
     ((double)(min_nodes_expanded + max_nodes_expanded)));
  };
  count_type nodes() const {
    return (min_nodes_expanded + max_nodes_expanded);
  };
  count_type total_nodes() const {
    if (running)
      return (total_min_nodes_expanded + total_max_nodes_expanded +
       min_nodes_expanded + max_nodes_expanded);
    else
      return (total_min_nodes_expanded + total_max_nodes_expanded);
  };
  count_type total_min_nodes() const {
    if (running) return (total_min_nodes_expanded + min_nodes_expanded);
    else return total_min_nodes_expanded;
  };
  count_type total_max_nodes() const {
    if (running) return (total_max_nodes_expanded + max_nodes_expanded);
    else return total_max_nodes_expanded;
  };
  hsps::rational max_lower_bound() const {
    return max_lb;
  };
  count_type nodes_at_max_lower_bound() const {
    return nodes_to_prove_lb;
  };
  count_type iterations() {
    return iterations_started;
  };
  count_type complete_iterations() {
    return iterations_finished;
  };
  count_type total_iterations() {
    if (running) return iterations_started + total_iterations_started;
    else return total_iterations_started;
  };
  count_type total_complete_iterations() {
    if (running) return iterations_finished + total_iterations_finished;
    else return total_iterations_finished;
  };
  void print_brief(::std::ostream& s, const char* p = 0);
  void print(::std::ostream& s, const char* p = 0);
  void print_total(::std::ostream& s, const char* p = 0);
};
inline ::std::ostream& operator<<(::std::ostream& s, Stopwatch& t) {
  return s << t.total_time();
}
inline ::std::ostream& operator<<(::std::ostream& s, Statistics& t) {
  if (Statistics::long_print_format) {
    t.print_total(s);
    return s;
  }
  else {
    return s << t.total_nodes() << " nodes, "
      << t.total_time() << " seconds, "
      << t.peak_memory() << "k heap, "
      << t.peak_stack_size() << "k stack";
  }
}
}
namespace hsps {
class ACF {
 public:
  virtual ~ACF() { };
  virtual hsps::rational operator()(index_type a) const = 0;
  virtual hsps::rational min_cost(index_type n) const;
  virtual hsps::rational max_cost(index_type n) const;
  virtual hsps::rational avg_cost(index_type n) const;
  virtual hsps::rational cost_gcd(index_type n) const;
};
class Heuristic {
 protected:
  Instance& instance;
  int trace_level;
 public:
  static count_type eval_count;
  static int default_trace_level;
  Heuristic(Instance& ins)
    : instance(ins), trace_level(default_trace_level) { };
  virtual ~Heuristic();
  virtual void set_trace_level(int level);
  virtual hsps::rational eval(const index_set& s) = 0;
  virtual hsps::rational eval(const bool_vec& s) = 0;
  virtual void write_eval(const index_set& s,
     ::std::ostream& st,
     char* p = 0,
     bool e = true);
  virtual void write_eval(const bool_vec& s,
     ::std::ostream& st,
     char* p = 0,
     bool e = true);
  virtual hsps::rational eval_precondition(const Instance::Action& a);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
  virtual void store(const index_set& s, hsps::rational v, bool opt);
  virtual void store(const bool_vec& s, hsps::rational v, bool opt);
  hsps::rational eval(index_type atom);
  void compute_heuristic_graph(const ACF& cost, graph& g);
};
class ZeroHeuristic : public Heuristic {
 public:
  ZeroHeuristic(Instance& ins) : Heuristic(ins) { };
  virtual ~ZeroHeuristic() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
};
class EvalActionCache : public Heuristic {
  Heuristic& base_h;
  cost_vec cache;
 public:
  EvalActionCache(Instance& ins, Heuristic& h);
  virtual ~EvalActionCache() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational eval_precondition(const Instance::Action& a);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class RegressionInvariantCheck : public Heuristic {
  Heuristic& base_h;
  bool verified_invariants_only;
 public:
  RegressionInvariantCheck(Instance& ins, Heuristic& h, bool v)
    : Heuristic(ins), base_h(h), verified_invariants_only(v) { };
  virtual ~RegressionInvariantCheck() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class ForwardReachabilityCheck : public Heuristic {
  index_set goals;
  bool_vec r;
  bool_vec f;
  bool_vec d;
  hsps::rational compute();
 public:
  ForwardReachabilityCheck(Instance& i, const index_set& g);
  virtual ~ForwardReachabilityCheck();
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
};
class Combine2ByMax : public Heuristic {
  Heuristic& h0;
  Heuristic& h1;
 public:
  Combine2ByMax(Instance& ins, Heuristic& _h0, Heuristic& _h1)
    : Heuristic(ins), h0(_h0), h1(_h1) { };
  virtual ~Combine2ByMax() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class CombineNByMax : public Heuristic {
  lvector<Heuristic*> h_vec;
 public:
  CombineNByMax(Instance& ins)
    : Heuristic(ins), h_vec((Heuristic*)0, 0) { };
  virtual ~CombineNByMax() { };
  void add(Heuristic* h) { h_vec.append(h); };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class CombineNBySum : public Heuristic {
  lvector<Heuristic*> h_vec;
 public:
  CombineNBySum(Instance& ins)
    : Heuristic(ins), h_vec((Heuristic*)0, 0) { };
  virtual ~CombineNBySum() { };
  void add(Heuristic* h) { h_vec.append(h); };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class RoundUp : public Heuristic {
  Heuristic& h;
  long d;
 public:
  RoundUp(Instance& ins, Heuristic& h0)
    : Heuristic(ins), h(h0), d(1) { };
  RoundUp(Instance& ins, Heuristic& h0, long d0)
    : Heuristic(ins), h(h0), d(d0) { };
  virtual ~RoundUp() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class HX : public Heuristic {
  Heuristic& h0;
  index_set X;
 public:
  HX(Instance& ins, Heuristic& h, const index_set& x)
    : Heuristic(ins), h0(h), X(x) { };
  HX(Instance& ins, Heuristic& h)
    : Heuristic(ins), h0(h) { };
  virtual ~HX() { };
  void setX(const index_set& x) { X = x; };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual void write_eval(const index_set& s,
     ::std::ostream& st,
     char* p = 0,
     bool e = true);
  virtual void write_eval(const bool_vec& s,
     ::std::ostream& st,
     char* p = 0,
     bool e = true);
};
class AtomMapAdapter : public Heuristic {
  index_vec map;
  Heuristic& base_h;
 public:
  AtomMapAdapter(Instance& i, const index_vec& m, Heuristic& h)
    : Heuristic(i), map(m), base_h(h)
  { assert(map.length() == instance.n_atoms()); };
  virtual ~AtomMapAdapter() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
};
class CompleteNegationAdapter : public Heuristic {
  Heuristic& h_base;
  pair_vec pn_map;
  bool_vec sc;
 public:
  CompleteNegationAdapter(Instance& ins, const pair_vec& p, Heuristic& h);
  virtual ~CompleteNegationAdapter();
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
};
class CompareEval : public Heuristic {
  Heuristic& base_h;
  Heuristic& alt_h;
  bool max_h_val;
 public:
  static count_type lower;
  static count_type equal;
  static count_type higher;
  CompareEval(Instance& i, Heuristic& h0, Heuristic& h1)
    : Heuristic(i), base_h(h0), alt_h(h1) { }
  virtual ~CompareEval() { };
  void set_maximal_heuristic_value(bool on) { max_h_val = on; };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
};
class UnitACF : public ACF {
 public:
  UnitACF() { };
  virtual ~UnitACF() { };
  virtual hsps::rational operator()(index_type a) const;
  virtual hsps::rational min_cost(index_type n) const;
  virtual hsps::rational max_cost(index_type n) const;
  virtual hsps::rational avg_cost(index_type n) const;
};
class ZeroACF : public ACF {
 public:
  ZeroACF() { };
  virtual ~ZeroACF() { };
  virtual hsps::rational operator()(index_type a) const;
  virtual hsps::rational min_cost(index_type n) const;
  virtual hsps::rational max_cost(index_type n) const;
  virtual hsps::rational avg_cost(index_type n) const;
};
class CostACF : public ACF {
  Instance& instance;
 public:
  CostACF(Instance& i) : instance(i) { };
  virtual ~CostACF() { };
  virtual hsps::rational operator()(index_type a) const;
};
class FracACF : public ACF {
  const ACF& baseACF;
  cost_vec df;
 public:
  FracACF(const ACF& b, index_type l);
  FracACF(const ACF& b, index_type l, hsps::rational f);
  virtual ~FracACF();
  void set(index_type a, hsps::rational f);
  void set(const index_set& d, hsps::rational f);
  virtual hsps::rational operator()(index_type a) const;
};
class DiscountACF : public ACF {
  const ACF& baseACF;
  bool_vec discounted;
 public:
  DiscountACF(const ACF& b, index_type l)
    : baseACF(b), discounted(false, l) { };
  DiscountACF(const ACF& b, const index_set& d, index_type l)
    : baseACF(b), discounted(d, l) { };
  DiscountACF(const ACF& b, const bool_vec& d)
    : baseACF(b), discounted(d) { };
  virtual ~DiscountACF() { };
  void discount(index_type a) { discounted[a] = true; };
  void discount(const index_set& d) { discounted.insert(d); };
  void discount(const bool_vec& d) { discounted.insert(d); };
  void count(index_type a) { discounted[a] = false; };
  void count(const index_set& d) { discounted.subtract(d); };
  void count(const bool_vec& d) { discounted.subtract(d); };
  void count_only(const bool_vec& d);
  const bool_vec& discounted_actions() { return discounted; };
  virtual hsps::rational operator()(index_type a) const;
};
class MakespanACF : public ACF {
  Instance& instance;
 public:
  MakespanACF(Instance& i) : instance(i) { };
  virtual ~MakespanACF() { };
  virtual hsps::rational operator()(index_type a) const;
};
class ResourceConsACF : public ACF {
  Instance& instance;
  index_type resource_id;
 public:
  ResourceConsACF(Instance& i, index_type r);
  virtual ~ResourceConsACF() { };
  virtual hsps::rational operator()(index_type a) const;
};
class ResourceReqACF : public ACF {
  Instance& instance;
  index_type resource_id;
 public:
  ResourceReqACF(Instance& i, index_type r);
  virtual ~ResourceReqACF() { };
  virtual hsps::rational operator()(index_type a) const;
};
}
namespace hsps {
class SearchResult {
 public:
  SearchResult() { };
  virtual ~SearchResult();
  virtual void solution(State& s, hsps::rational cost) = 0;
  virtual void no_more_solutions(hsps::rational cost) = 0;
  virtual bool more() = 0;
};
class Result : public SearchResult {
 public:
  enum stop_condition { stop_at_first,
   stop_at_nth,
   stop_at_all_optimal,
   stop_at_all };
 private:
  stop_condition sc;
  count_type find_n;
  PlanSet* plans;
  count_type n_found;
  hsps::rational min_cost;
  hsps::rational max_ex;
 public:
  Result() : sc(stop_at_first), find_n(1), plans(0), n_found(0),
    min_cost(POS_INF), max_ex(NEG_INF) { };
  Result(PlanSet* s) : sc(stop_at_first), find_n(1), plans(s), n_found(0),
    min_cost(POS_INF), max_ex(NEG_INF) { };
  virtual ~Result() { };
  void set_stop_condition(stop_condition c);
  void set_n_to_find(count_type n);
  void set_plan_set(PlanSet* s);
  count_type solution_count();
  bool search_space_exhausted();
  void reset();
  virtual void solution(State& s, hsps::rational cost);
  virtual void no_more_solutions(hsps::rational cost);
  virtual bool more();
};
class SearchStats : public Search {
 protected:
  Statistics& stats;
  hsps::rational cost_limit;
  count_type node_limit;
  count_type node_count;
  count_type work_limit;
  count_type work_count;
  count_type zero_eval_count;
  void start_count();
  void stop_count();
  void reset();
 public:
  SearchStats(Statistics& s);
  SearchStats(Statistics& s, hsps::rational limit);
  virtual ~SearchStats();
  void set_cost_limit(hsps::rational c_max);
  hsps::rational get_cost_limit() const;
  bool cost_limit_reached() const;
  void set_node_limit(count_type n);
  count_type get_node_limit() const;
  bool node_limit_reached() const;
  void set_work_limit(count_type n);
  count_type get_work_limit() const;
  bool work_limit_reached() const;
  bool break_signal_raised() const;
  virtual hsps::rational cost() const = 0;
  count_type work() const;
};
class SearchAlgorithm : public SearchStats {
  bool is_solved;
  bool is_optimal;
 protected:
  SearchResult& result;
  const Name* problem_name;
  int trace_level;
  void set_solved(bool s, bool o);
  void set_solved(bool s);
  void reset();
 public:
  static int default_trace_level;
  void set_problem_name(const Name* n);
  void set_trace_level(int level);
  SearchAlgorithm(Statistics& s, SearchResult& r);
  SearchAlgorithm(Statistics& s, SearchResult& r, hsps::rational limit);
  virtual ~SearchAlgorithm();
  virtual hsps::rational start(State& s, hsps::rational b) = 0;
  virtual hsps::rational start(State& s) = 0;
  virtual bool solved() const;
  virtual bool optimal() const;
  virtual bool done() const;
};
class SingleSearchAlgorithm : public SearchAlgorithm {
 public:
  SingleSearchAlgorithm(Statistics& s, SearchResult& r)
    : SearchAlgorithm(s, r) { };
  SingleSearchAlgorithm(Statistics& s, SearchResult& r, hsps::rational limit)
    : SearchAlgorithm(s, r, limit) { };
  virtual ~SingleSearchAlgorithm() { };
  virtual hsps::rational resume() = 0;
};
class MultiSearchAlgorithm : public SearchAlgorithm {
 public:
  MultiSearchAlgorithm(Statistics& s, SearchResult& r)
    : SearchAlgorithm(s, r) { };
  MultiSearchAlgorithm(Statistics& s, SearchResult& r, hsps::rational limit)
    : SearchAlgorithm(s, r, limit) { };
  virtual ~MultiSearchAlgorithm() { };
  virtual hsps::rational resume(State& s, hsps::rational b) = 0;
  virtual hsps::rational resume(State& s);
};
}
namespace hsps {
typedef lvector<Heuristic*> estimator_vec;
class BasicResourceState {
 protected:
  Instance& instance;
  estimator_vec& estimators;
  amt_vec amt_consumed;
 public:
  BasicResourceState(Instance& i, estimator_vec& est);
  BasicResourceState(Instance& i, estimator_vec& est, const amt_vec& ac);
  BasicResourceState(const BasicResourceState& s);
  virtual ~BasicResourceState();
  hsps::rational available(index_type r) const;
  hsps::rational available_for_consumption(index_type r) const;
  bool applicable(Instance::Action& a);
  bool sufficient_consumable(const index_set& s);
  bool sufficient_consumable(const bool_vec& s);
  void apply(Instance::Action& a);
  bool is_root();
  int compare(const BasicResourceState& s);
  index_type hash();
  BasicResourceState* new_state();
  BasicResourceState* copy();
  void write(std::ostream& s);
};
class RegressionResourceState : public BasicResourceState {
 protected:
  amt_vec max_required;
 public:
  RegressionResourceState(Instance& i, estimator_vec& est);
  RegressionResourceState(Instance& i, estimator_vec& est, const amt_vec& ac);
  RegressionResourceState(const RegressionResourceState& s);
  ~RegressionResourceState();
  hsps::rational available(index_type r) const;
  hsps::rational available_for_consumption(index_type r) const;
  bool applicable(Instance::Action& a);
  bool applicable(Instance::Action& a, const index_vec& c);
  bool applicable(Instance::Action& a, const index_cost_vec& c);
  bool applicable(Instance::Action& a,
    const index_cost_vec& c1,
    const index_vec& c2);
  bool sufficient_consumable(const index_set& s);
  bool sufficient_consumable(const bool_vec& s);
  bool sufficient_consumable(const index_set& s, const Instance::Action& cact);
  bool sufficient_consumable(const bool_vec& s, const Instance::Action& cact);
  bool sufficient_consumable(const index_set& s, const index_cost_vec& cacts);
  bool sufficient_consumable(const bool_vec& s, const index_cost_vec& cacts);
  void apply(Instance::Action& a);
  void reserve_as_required(const amt_vec& req);
  bool is_root();
  int compare(const RegressionResourceState& s);
  index_type hash();
  RegressionResourceState* new_state();
  RegressionResourceState* copy();
  void write(std::ostream& s);
};
}
namespace hsps {
class IterativeEnumerator {
 public:
  IterativeEnumerator() { };
  virtual ~IterativeEnumerator();
  virtual bool first() = 0;
  virtual bool next() = 0;
};
class RecursiveEnumerator {
 protected:
  virtual bool done() = 0;
 public:
  RecursiveEnumerator() { };
  virtual ~RecursiveEnumerator();
};
class SubsetEnumerator : public IterativeEnumerator {
 protected:
  index_type n;
  bool_vec in;
 public:
  SubsetEnumerator(index_type _n);
  virtual ~SubsetEnumerator() { };
  virtual bool first();
  virtual bool next();
  const bool_vec& current_set() const;
  void current_set(const index_set& elements, index_set& set);
  void current_set(index_set& set);
  index_type current_set_size();
  void all_sets(index_set_vec& sets);
};
class mSubsetEnumerator : public SubsetEnumerator {
 protected:
  index_type m;
 public:
  mSubsetEnumerator(index_type _n, index_type _m);
  virtual ~mSubsetEnumerator() { };
  count_type m_of_n();
  virtual bool first();
  virtual bool next();
};
class kAssignmentEnumerator : public IterativeEnumerator {
 protected:
  index_type n;
  index_type k;
  index_vec a;
 public:
  kAssignmentEnumerator(index_type _n, index_type _k);
  virtual ~kAssignmentEnumerator() { };
  virtual bool first();
  virtual bool next();
  void current_assignment(index_set_vec& sets);
};
class CorrespondanceEnumerator : public IterativeEnumerator {
 protected:
  const index_vec& a;
  const index_vec& b;
  mapping c;
  bool_vec f;
  index_type first_free(index_type x,
   const index_vec& vec,
   const bool_vec& f_vec);
  index_type next_free(index_type x,
         const index_vec& vec,
         const bool_vec& f_vec,
         index_type starting_from);
  bool find(index_type p);
 public:
  CorrespondanceEnumerator(const index_vec& v0, const index_vec& v1);
  virtual ~CorrespondanceEnumerator() { };
  virtual bool first();
  virtual bool next();
  const mapping& current() const { return c; };
};
void write_correspondance(::std::ostream& s, const index_vec& c);
class PermutationEnumerator : public IterativeEnumerator {
 protected:
  CorrespondanceEnumerator e;
 public:
  PermutationEnumerator(index_type n);
  virtual ~PermutationEnumerator() { };
  virtual bool first();
  virtual bool next();
  const mapping& current() const { return e.current(); };
};
class RecursivekPartitionEnumerator {
  index_vec ass;
 protected:
  index_type n;
  index_type k;
  index_set_vec sets;
  bool done;
  void partition(index_type n, index_type k);
  void construct();
  void construct(const index_set& set);
  virtual void solution();
 public:
  RecursivekPartitionEnumerator(index_type _n, index_type _k);
  virtual ~RecursivekPartitionEnumerator();
  void partition();
};
class RecursivePartitionEnumerator : public RecursivekPartitionEnumerator {
 public:
  RecursivePartitionEnumerator(index_type _n);
  virtual ~RecursivePartitionEnumerator() { };
  void partition();
  void partition_bounded(index_type min, index_type max);
};
class CountPartitions : public RecursivePartitionEnumerator {
  index_type c;
 protected:
  virtual void solution();
 public:
  CountPartitions(index_type _n) : RecursivePartitionEnumerator(_n) { };
  virtual ~CountPartitions() { };
  index_type count();
};
class PrintPartitions : public RecursivePartitionEnumerator {
 protected:
  virtual void solution();
 public:
  PrintPartitions(index_type _n) : RecursivePartitionEnumerator(_n) { };
  virtual ~PrintPartitions() { };
};
}
namespace hsps {
class ExecError {
 public:
  enum ErrorType { error_unknown,
     error_unsatisfied_precondition,
     error_incompatible_actions,
     error_resource_conflict,
     error_resource_shortage,
     error_unachieved_goal,
     warning_redundant_action
  };
  enum ErrorSeverity { severity_none = 0,
         severity_warning = 1,
         severity_plan_failure = 2,
         severity_execution_failure = 3
  };
 protected:
  ErrorType toe;
  hsps::rational at;
  index_type step;
 public:
  static const char* error_type_string(ErrorType t);
  static const char* error_severity_string(ErrorSeverity s);
  ExecError() : toe(error_unknown), at(0), step(no_such_index) { };
  ExecError(ErrorType e, hsps::rational t) : toe(e), at(t), step(no_such_index) { };
  ExecError(ErrorType e, hsps::rational t, index_type s) : toe(e), at(t), step(s) { };
  virtual ~ExecError();
  void remap_step(const index_vec& map);
  ErrorType type_of_error() const { return toe; };
  ErrorSeverity severity_of_error() const;
  hsps::rational time_of_error() const { return at; };
  index_type step_of_error() const { return step; };
  virtual ExecError* copy() const;
  virtual void write(::std::ostream& s) const;
};
typedef lvector<ExecError*> exec_error_vec;
typedef svector<ExecError::ErrorType> error_type_set;
typedef svector<ExecError::ErrorSeverity> error_severity_set;
class ExecErrorSet : public exec_error_vec {
  index_type current_step;
  error_type_set ignored_error_types;
 public:
  ExecErrorSet()
    : exec_error_vec((ExecError*)0, 0),
    current_step(no_such_index),
    ignored_error_types() { };
  ~ExecErrorSet();
  void ignore_error_type(ExecError::ErrorType t);
  void ignore_error_severity(ExecError::ErrorSeverity s);
  void clear_ignored_error_types();
  void new_error(ExecError* e);
  bool ignore(ExecError::ErrorType t);
  void remap_steps(const index_vec& map);
  hsps::rational earliest_time_of_error();
  ExecError::ErrorSeverity greatest_error_severity();
  bool executable();
  bool valid();
  index_type count_of_type(ExecError::ErrorType t);
  ExecErrorSet* earliest();
  ExecErrorSet* all_of_type(ExecError::ErrorType t);
  ExecErrorSet* all_of_severity(ExecError::ErrorSeverity s);
  ExecErrorSet* earliest_of_type(ExecError::ErrorType t);
  virtual void write(::std::ostream& s) const;
};
class UnsatisfiedPreconditionError : public ExecError {
  Instance& ins;
  index_type act;
  index_type pre;
  index_set holds;
 public:
  UnsatisfiedPreconditionError(Instance& i,
          index_type a,
          index_type p,
          hsps::rational at)
    : ExecError(ExecError::error_unsatisfied_precondition, at),
    ins(i), act(a), pre(p) { };
  UnsatisfiedPreconditionError(Instance& i,
          index_type a,
          index_type p,
          const index_set& h,
          hsps::rational at)
    : ExecError(ExecError::error_unsatisfied_precondition, at),
    ins(i), act(a), pre(p), holds(h) { };
  UnsatisfiedPreconditionError(Instance& i,
          index_type a,
          index_type p,
          hsps::rational at,
          index_type s)
    : ExecError(ExecError::error_unsatisfied_precondition, at, s),
    ins(i), act(a), pre(p) { };
  UnsatisfiedPreconditionError(Instance& i,
          index_type a,
          index_type p,
          const index_set& h,
          hsps::rational at,
          index_type s)
    : ExecError(ExecError::error_unsatisfied_precondition, at, s),
    ins(i), act(a), pre(p), holds(h) { };
  virtual ~UnsatisfiedPreconditionError() { };
  const Instance::Action& action() { return ins.actions[act]; };
  const Instance::Atom& precondition() { return ins.atoms[pre]; };
  const index_set& true_atoms() { return holds; };
  virtual ExecError* copy();
  virtual void write(::std::ostream& s) const;
};
class IncompatibleActionError : public ExecError {
  Instance& ins;
  index_type act0;
  index_type act1;
 public:
  IncompatibleActionError(Instance& i, index_type a0, index_type a1, hsps::rational at)
    : ExecError(ExecError::error_incompatible_actions, at),
    ins(i), act0(a0), act1(a1) { };
  IncompatibleActionError(Instance& i, index_type a0, index_type a1,
     hsps::rational at, index_type s)
    : ExecError(ExecError::error_incompatible_actions, at, s),
    ins(i), act0(a0), act1(a1) { };
  virtual ~IncompatibleActionError() { };
  const Instance::Action& action() { return ins.actions[act0]; };
  const Instance::Action& incompatible_action() { return ins.actions[act1]; };
  virtual ExecError* copy();
  virtual void write(::std::ostream& s) const;
};
class ResourceConflictError : public ExecError {
  Instance& ins;
  index_type res;
  index_set c_acts;
  index_set c_steps;
 public:
  ResourceConflictError(Instance& i,
   index_type r,
   const index_set& as,
   const index_set& ss,
   hsps::rational at) :
    ExecError(ExecError::error_resource_conflict, at), ins(i), res(r),
    c_acts(as), c_steps(ss) { };
  ResourceConflictError(Instance& i,
   index_type r,
   hsps::rational at) :
    ExecError(ExecError::error_resource_conflict, at), ins(i), res(r) { };
  ResourceConflictError(Instance& i,
   index_type r,
   const index_set& as,
   const index_set& ss,
   hsps::rational at,
   index_type s) :
    ExecError(ExecError::error_resource_conflict, at, s), ins(i), res(r),
    c_acts(as), c_steps(ss) { };
  ResourceConflictError(Instance& i,
   index_type r,
   hsps::rational at,
   index_type s) :
    ExecError(ExecError::error_resource_conflict, at, s), ins(i), res(r) { };
  void add_action(index_type a)
    { c_acts.insert(a); };
  void add_action(index_type a, index_type s)
    { c_acts.insert(a); c_steps.insert(s); };
  virtual ~ResourceConflictError() { };
  const Instance::Resource& resource() { return ins.resources[res]; };
  const index_set& conflict_actions() { return c_acts; };
  const index_set& conflict_steps() { return c_steps; };
  virtual ExecError* copy();
  virtual void write(::std::ostream& s) const;
};
class ResourceShortageError : public ExecError {
  Instance& ins;
  index_type res;
  hsps::rational avail;
  index_type act;
 public:
  ResourceShortageError(Instance& i,
   index_type r,
   hsps::rational v,
   index_type a,
   hsps::rational at) :
    ExecError(ExecError::error_resource_shortage, at), ins(i), res(r),
    avail(v), act(a) { };
  ResourceShortageError(Instance& i,
   index_type r,
   hsps::rational v,
   index_type a,
   hsps::rational at,
   index_type s) :
    ExecError(ExecError::error_resource_shortage, at, s), ins(i), res(r),
    avail(v), act(a) { };
  virtual ~ResourceShortageError() { };
  const Instance::Resource& resource() { return ins.resources[res]; };
  hsps::rational available() { return avail; };
  const Instance::Action& action() { return ins.actions[act]; };
  virtual ExecError* copy();
  virtual void write(::std::ostream& s) const;
};
class UnachievedGoalError : public ExecError {
  Instance& ins;
  index_type atom;
 public:
  UnachievedGoalError(Instance& i, index_type g, hsps::rational at)
    : ExecError(ExecError::error_unachieved_goal, at), ins(i), atom(g) { };
  UnachievedGoalError(Instance& i, index_type g, hsps::rational at, index_type s)
    : ExecError(ExecError::error_unachieved_goal, at, s), ins(i), atom(g) { };
  virtual ~UnachievedGoalError() { };
  const Instance::Atom& goal() { return ins.atoms[atom]; };
  virtual ExecError* copy();
  virtual void write(::std::ostream& s) const;
};
class RedundantActionWarning : public ExecError {
  Instance& ins;
  index_type act;
 public:
  RedundantActionWarning(Instance& i, index_type a, hsps::rational at) :
    ExecError(ExecError::warning_redundant_action, at), ins(i), act(a) { };
  RedundantActionWarning(Instance& i, index_type a, hsps::rational at, index_type s) :
    ExecError(ExecError::warning_redundant_action, at, s), ins(i), act(a) { };
  virtual ~RedundantActionWarning() { };
  const Instance::Action& action() { return ins.actions[act]; };
  virtual ExecError* copy();
  virtual void write(::std::ostream& s) const;
};
class ExecState : public ProgressionState {
 protected:
  Instance& instance;
  bool_vec atoms;
  amt_vec res;
  struct exec_act {
    index_type act;
    hsps::rational rem;
    index_type step;
    ExecState* start_state;
    exec_act() :
      act(no_such_index), rem(ZERO), step(no_such_index), start_state(0) { };
    exec_act(index_type a, hsps::rational r) :
      act(a), rem(r), step(no_such_index), start_state(0) { };
    exec_act(index_type a, hsps::rational r, index_type s) :
      act(a), rem(r), step(s), start_state(0) { };
    exec_act(const exec_act& e) :
      act(e.act), rem(e.rem), step(e.step), start_state(e.start_state) { };
    exec_act& operator=(const exec_act& e) {
      act = e.act;
      rem = e.rem;
      step = e.step;
      start_state = e.start_state;
    };
  };
  typedef lvector<exec_act> exec_act_vec;
  exec_act_vec actions;
  hsps::rational abs_t;
  hsps::rational delta_t;
  hsps::rational dur;
  int trace_level;
  void apply_conditional_delete_effects
    (Instance::Action& a, const ExecState* start_state, bool_vec& to);
  void active_conditional_add_effects
    (Instance::Action& a, const ExecState* start_state, bool_vec& eff);
 public:
  ExecState(Instance& i);
  ExecState(Instance& i, index_set g);
  ExecState(Instance& i, const bool_vec& g);
  ExecState(const ExecState& s);
  virtual ~ExecState();
  static bool extended_action_definition;
  void set_trace_level(int level);
  virtual hsps::rational delta_cost();
  virtual hsps::rational est_cost();
  virtual bool is_final();
  virtual bool is_max();
  virtual hsps::rational expand(Search& s, hsps::rational bound);
  virtual void store(hsps::rational cost, bool opt);
  virtual void reevaluate();
  virtual int compare(const State& s);
  virtual index_type hash();
  virtual State* new_state(index_set& s);
  virtual State* copy();
  virtual void insert(Plan& p);
  virtual void write_plan(::std::ostream& s);
  virtual void write(::std::ostream& s);
  hsps::rational current_time() const;
  hsps::rational end_time() const;
  void current_atoms(index_set& atms) const;
  const bool_vec& current_atoms() const;
  void current_actions(index_set& acts) const;
  index_type n_current_actions() const;
  void starting_actions(index_set& acts) const;
  void finishing_actions(index_set& acts) const;
  hsps::rational min_delta() const;
  hsps::rational max_delta() const;
  void current_resource_levels
    (amt_vec& avail, amt_vec& in_use) const;
  void current_resource_levels
    (index_type r, hsps::rational& avail, hsps::rational& in_use) const;
  void current_resource_use(amt_vec& res) const;
  bool check_atoms(const index_set& set) const;
  bool check_atoms(const index_set& set, index_set& holds) const;
  bool is_final(ExecErrorSet* errors);
  bool applicable(Instance::Action& act,
    ExecErrorSet* errors,
    index_type step);
  void apply(Instance::Action& act,
      ExecErrorSet* errors,
      index_type step);
  void advance(hsps::rational dt,
        ExecErrorSet* errors);
  void finish(ExecErrorSet* errors);
  void clip(hsps::rational at_t);
  void intersect(const bool_vec& atms);
};
class Timeline {
 public:
  virtual ~Timeline();
  virtual index_type n_intervals() = 0;
  virtual index_type n_points() = 0;
  virtual index_type interval_start_point(index_type i) = 0;
  virtual index_type interval_end_point(index_type i) = 0;
  virtual hsps::rational point_time(index_type i) = 0;
  virtual hsps::rational interval_start_time(index_type i) = 0;
  virtual hsps::rational interval_end_time(index_type i) = 0;
  hsps::rational total_time();
};
class ExecTrace : public Timeline, public lvector<ExecState*> {
  Instance& instance;
 public:
  ExecTrace(Instance& ins);
  ~ExecTrace();
  virtual index_type n_intervals();
  virtual index_type n_points();
  virtual index_type interval_start_point(index_type i);
  virtual index_type interval_end_point(index_type i);
  virtual hsps::rational point_time(index_type i);
  virtual hsps::rational interval_start_time(index_type i);
  virtual hsps::rational interval_end_time(index_type i);
  ExecState* final_state();
  ExecTrace* copy();
  ExecTrace* necessary_trace();
  void peak_resource_use(amt_vec& res);
  bool test_always(index_type p);
  bool test_sometime(index_type p);
  bool test_sometime_after(index_type p, index_type q);
  bool test_sometime_before(index_type p, index_type q);
  bool test_at_most_once(index_type p);
  void extract_always_within(bool_matrix& c, cost_matrix& t);
  void clip_last_state(hsps::rational at_t);
  void write(::std::ostream& s);
};
class BasicTimeline : public Timeline {
 protected:
  cost_vec points;
  bool open_start;
  bool open_end;
  void set_point(hsps::rational t);
  void clip_start(hsps::rational t);
  void clip_end(hsps::rational t);
 public:
  BasicTimeline();
  virtual ~BasicTimeline();
  virtual index_type n_intervals();
  virtual index_type n_points();
  virtual index_type interval_start_point(index_type i);
  virtual index_type interval_end_point(index_type i);
  virtual hsps::rational point_time(index_type i);
  virtual hsps::rational interval_start_time(index_type i);
  virtual hsps::rational interval_end_time(index_type i);
  void write(::std::ostream& s);
};
class ResourceProfile : public BasicTimeline {
 protected:
  Instance& instance;
  index_type res;
  amt_vec avail;
  amt_vec in_use;
  index_set_vec a_start;
  index_set_vec a_finish;
  hsps::rational max_req;
 public:
  ResourceProfile(Instance& ins, index_type r, ExecTrace& trace);
  virtual ~ResourceProfile();
  void set_makespan(hsps::rational t);
  const Name* resource_name() const { return instance.resources[res].name; };
  hsps::rational amount_available(index_type i);
  hsps::rational amount_in_use(index_type i);
  hsps::rational amount_free(index_type i);
  index_type first_use_interval(index_type i);
  index_type first_min_free_interval(index_type i);
  hsps::rational possible_unexpected_loss_to(index_type i);
  hsps::rational min_free_from(index_type i);
  hsps::rational min_free();
  hsps::rational peak_use();
  hsps::rational min_peak_use();
  hsps::rational tolerable_unexpected_loss();
  hsps::rational total_consumption();
  void writeGantt(::std::ostream& s);
  static double GANTT_EXTRA_WIDTH;
  static double GANTT_EXTRA_HEIGHT;
  void write(::std::ostream& s);
};
class Schedule : public Plan {
 public:
  struct step {
    index_type act;
    hsps::rational at;
    index_type track;
    step() : act(no_such_index), at(0), track(no_such_index) { };
    step(index_type a, hsps::rational t) : act(a), at(t), track(no_such_index) { };
    step& operator=(const step& s) {
      act = s.act;
      at = s.at;
      return *this;
    };
    bool operator==(const step& s) {
      return ((act == s.act) && (at == s.at));
    };
  };
  typedef lvector<step> step_vec;
 private:
  Instance& instance;
  step_vec steps;
  hsps::rational end_t;
  index_set action_set;
  index_vec action_vec;
  index_type n_tracks;
  const Name* ann_name;
  bool ann_optimal;
  int trace_level;
  hsps::rational current_t;
  bool finished;
  void insert_step(hsps::rational at, index_type act);
  hsps::rational next_start_time(hsps::rational t) const;
  hsps::rational next_finish_time(hsps::rational t) const;
  hsps::rational last_finish_time() const;
  void compute_action_set_and_vec();
  void assign_tracks();
  enum s_status { s_pending, s_ready, s_executing, s_finished };
  bool construct_minimal_makespan(const index_vec& acts,
      graph& prec,
      const index_set& c,
      hsps::rational& best,
      index_vec& sindex);
 public:
  static bool write_traits;
  Schedule(Instance& i);
  Schedule(const Schedule& s);
  virtual ~Schedule();
  void set_trace_level(int level) { trace_level = level; };
  index_type length() const;
  hsps::rational makespan() const;
  hsps::rational cost() const;
  index_type n_steps() const { return steps.length(); };
  const step_vec& plan_steps() const { return steps; };
  const index_set& plan_actions() const { return action_set; };
  const index_vec& step_actions() const { return action_vec; };
  void step_action_names(name_vec& nv);
  bool step_in_interval(index_type s, hsps::rational i_start, hsps::rational i_end) const;
  index_type step_action(index_type s) const;
  const Name* plan_name() const;
  bool plan_is_optimal() const;
  plan_trait_vec traits;
  const PlanTrait* find_trait(const char* cn);
  virtual void protect(index_type atom);
  virtual void insert(index_type act);
  virtual void advance(hsps::rational delta);
  virtual void end();
  void set_start_time(hsps::rational at);
  void reduce(ExecErrorSet* warnings);
  void clear();
  virtual void set_name(const Name* n);
  virtual void set_optimal(bool o);
  virtual void add_trait(PlanTrait* t);
  virtual void output(Plan& plan) const;
  virtual void output(Plan& plan, const index_vec& act_map) const;
  void write(::std::ostream& s, unsigned int c = Name::NC_DEFAULT) const;
  void write_step_set(::std::ostream& s, const index_set& set) const;
  void write_steps(::std::ostream& s) const;
  void writeXML(::std::ostream& s,
  ExecErrorSet* errors = 0,
  ExecTrace* trace = 0,
  graph* prec = 0,
  index_type id = 0) const;
  void writeGantt(::std::ostream& s) const;
  static double GANTT_UNIT_WIDTH;
  static double GANTT_UNIT_HEIGHT;
  static double GANTT_TEXT_XOFF;
  static double GANTT_TEXT_YOFF;
  static hsps::rational GANTT_TIME_MARK_INTERVAL;
  static bool GANTT_ACTION_NAMES_ON_CHART;
  bool simulate(ExecTrace* trace = 0,
  ExecErrorSet* errors = 0,
  bool finish = false) const;
  bool simulate_low_resolution(ExecTrace* trace = 0,
          ExecErrorSet* errors = 0,
          bool finish = false) const;
  bool simulate(index_set& achieved,
  ExecErrorSet* errors = 0) const;
  bool simulate(amt_vec& rtl) const;
  void deorder(graph& prec) const;
  void deorder(weighted_graph& prec) const;
  void base_precedence_graph(graph& prec) const;
  bool equivalent(const Schedule& s, index_vec* c = 0) const;
  bool schedule(const index_vec& acts,
  const graph& prec,
  index_vec* map = 0);
  bool construct_conflict_free(const index_vec& acts,
          const graph& prec,
          index_set& cs,
          index_vec& map);
  bool construct_minimal_makespan(const index_vec& acts,
      const graph& prec,
      index_vec& map);
  bool random_sequence(index_type ln_max,
         index_type ln_avg,
         bool continue_from_goal,
         ExecTrace* trace,
         RNG& rnd);
};
typedef lvector<Schedule*> plan_vec;
class ScheduleSet : public plan_vec, public PlanSet {
 protected:
  struct ScheduleProperties {
    bool valid;
    ExecTrace* trace;
    index_type n_resources;
    amt_vec total_consumption;
    amt_vec peak_use;
    amt_vec tolerable_loss;
    hsps::rational makespan;
    ScheduleProperties()
      : valid(true), trace(0), n_resources(0), total_consumption(0, 0),
 peak_use(0, 0), tolerable_loss(POS_INF, 0), makespan(0) { };
    ScheduleProperties(index_type n)
      : valid(true), trace(0), n_resources(n), total_consumption(0, n),
 peak_use(0, n), tolerable_loss(POS_INF, n), makespan(0) { };
    bool dominates(const ScheduleProperties& p);
  };
  typedef lvector<ScheduleProperties*> prop_vec;
  Instance& instance;
  prop_vec props;
  int trace_level;
  ScheduleProperties* compute_properties(Schedule* s);
  void cache_properties(index_type i, ScheduleProperties* p);
  bool dominated(const ScheduleProperties& p, prop_vec& pv);
  void dominated(prop_vec& pv, bool_vec& dom);
  bool dominated(const ScheduleProperties& p);
  void replace_schedule_with_properties
    (index_type i, Schedule* s, ScheduleProperties* p);
  void add_schedule_with_properties
    (Schedule* s, ScheduleProperties* p);
 public:
  ScheduleSet(Instance& i);
  ScheduleSet(ScheduleSet& s, const bool_vec& sel);
  ~ScheduleSet();
  void set_trace_level(int level);
  void add_schedule(Schedule* s);
  void add_schedule_if_different(Schedule* s);
  void reduce_plans();
  void filter_invalid_plans();
  void filter_unschedulable_plans();
  void filter_equivalent_plans();
  void add_distinguishing_traits_1();
  void add_distinguishing_traits_2();
  bool common_precedence_constraints(graph& prec);
  bool separating_precedence_constraints
    (ScheduleSet& s, pair_set& d0, pair_set& d1);
  void write_deordered_graphs(::std::ostream& s, bool w_names = true);
  void writeXML(::std::ostream& s);
  virtual Plan* new_plan();
  virtual void output(PlanSet& to);
  virtual void output(PlanSet& to, const bool_vec& s);
  void remove(bool_vec& set);
  void clear();
};
class ScheduleTrait : public PlanTrait {
 protected:
  Schedule* plan;
  ScheduleSet* plan_set;
  bool is_min;
  bool is_max;
  bool is_unique;
  void write_meta_short(::std::ostream& s) const;
  void write_meta_attributes(::std::ostream& s) const;
 public:
  ScheduleTrait(Schedule* p)
    : plan(p), plan_set(0), is_min(false), is_max(false), is_unique(false) { };
  ScheduleTrait(Schedule* p, ScheduleSet* s)
    : plan(p), plan_set(s), is_min(false), is_max(false), is_unique(false) { };
  virtual ~ScheduleTrait();
  void set_min() { is_min = true; };
  void set_max() { is_max = true; };
  void set_unique() { is_unique = true; };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const = 0;
  virtual void write_detail(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const = 0;
};
class EquivalentTo : public ScheduleTrait {
  Schedule* s_eq;
  index_vec cor;
 public:
  EquivalentTo(Schedule* p, ScheduleSet* ss, Schedule* s, const index_vec& c)
    : ScheduleTrait(p, ss), s_eq(s), cor(c) { };
  virtual ~EquivalentTo() { };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const;
  virtual void write_detail(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const;
};
class DerivedFrom : public ScheduleTrait {
  Schedule* s_src;
  pair_set e_prec;
 public:
  DerivedFrom(Schedule* p, ScheduleSet* ss, Schedule* s, const pair_set& e)
    : ScheduleTrait(p, ss), s_src(s), e_prec(e) { };
  DerivedFrom(Schedule* p, ScheduleSet* ss, Schedule* s, const index_pair& e)
    : ScheduleTrait(p, ss), s_src(s) { e_prec.assign_singleton(e); };
  DerivedFrom(Schedule* p, ScheduleSet* ss,
       DerivedFrom* a, const index_vec& m,
       const index_pair& e);
  virtual ~DerivedFrom() { };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const;
  virtual void write_detail(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const;
};
class PlanPrecedenceRelation : public ScheduleTrait {
  graph prec;
 public:
  PlanPrecedenceRelation(Schedule* s, const graph& p)
    : ScheduleTrait(s), prec(p) { };
  PlanPrecedenceRelation(Schedule* s, const graph& p, const index_vec& m)
    : ScheduleTrait(s) { prec.copy_and_rename(p, m); };
  virtual ~PlanPrecedenceRelation() { };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const;
  const graph& precedence_relation() const { return prec; };
};
class PlanActionOccurs : public ScheduleTrait {
  Instance& instance;
  index_type act;
  index_type n_of_times;
 public:
  PlanActionOccurs(Schedule* p, Instance& i, index_type a, index_type n)
    : ScheduleTrait(p), instance(i), act(a), n_of_times(n) { };
  virtual ~PlanActionOccurs() { };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const;
};
class PlanStepOrder : public ScheduleTrait {
  Instance& instance;
  index_pair order;
 public:
  PlanStepOrder(Schedule* p, Instance& i, const index_pair& o)
    : ScheduleTrait(p), instance(i), order(o) { };
  virtual ~PlanStepOrder() { };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const;
  const index_pair& precedence() const { return order; };
};
class PlanFeatureValue : public ScheduleTrait {
 public:
  enum plan_feature_type { makespan,
      cost,
      resource_peak_use,
      resource_total_consumption,
      resource_tolerable_loss };
 private:
  plan_feature_type ftype;
  Instance& instance;
  index_type index;
  hsps::rational value;
 public:
  PlanFeatureValue(Schedule* p,
     plan_feature_type t,
     Instance& i,
     index_type x,
     hsps::rational v) :
    ScheduleTrait(p), ftype(t), instance(i), index(x), value(v) { };
  virtual ~PlanFeatureValue() { };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const;
};
bool feasible(Instance& ins,
       const index_vec& acts,
       const graph& prec,
       graph_vec* rfps = 0,
       index_type* rff = 0);
bool feasible(Instance& ins,
       const index_vec& acts,
       index_type r,
       graph& uc,
       graph_vec* rfps = 0,
       index_type* rff = 0);
bool feasible(Instance& ins,
       const index_vec& acts,
       index_type r,
       const index_set& a,
       index_type i,
       graph& uc,
       graph_vec* rfps = 0,
       index_type* rff = 0);
bool feasible(Instance& ins,
       const index_vec& acts,
       index_type r,
       const index_set& a,
       index_type i_a,
       const index_set& b,
       index_type i_b,
       hsps::rational c_max,
       graph& uc,
       graph_vec* rfps = 0,
       index_type* rff = 0);
class PlanName : public Name {
  const Name* src;
  const char* desc;
  index_type index;
 public:
  PlanName(const char* s, index_type i)
    : src(0), desc(s), index(i) { };
  PlanName(const Name* n, const char* s, index_type i)
    : src(n), desc(s), index(i) { };
  virtual ~PlanName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
::std::ostream& operator<<(::std::ostream& s, ExecError::ErrorType t);
::std::ostream& operator<<(::std::ostream& s, ExecError::ErrorSeverity sev);
}
#include <list>
namespace hsps {
class SoftInstance : public Instance {
 public:
  struct SoftGoal {
    Name* name;
    index_set atoms;
    hsps::rational weight;
    void* src;
    SoftGoal() : name(0), atoms(EMPTYSET), weight(0), src(0) { };
    SoftGoal& operator=(const SoftGoal& g) {
      name = g.name;
      atoms = g.atoms;
      weight = g.weight;
      src = g.src;
      return *this;
    };
    bool operator==(const SoftGoal& g) const {
      return ((atoms == g.atoms) &&
       (weight == g.weight));
    };
    bool is_sat(const bool* s) const {
      for (index_type k = 0; k < atoms.length(); k++)
 if (!s[atoms[k]]) return false;
      return true;
    };
    bool is_sat_init(const Instance& ins) const {
      for (index_type k = 0; k < atoms.length(); k++)
 if (!ins.atoms[k].init) return false;
      return true;
    };
    bool is_sat(const index_set& s) const {
      for (index_type k = 0; k < atoms.length(); k++)
 if (!s.contains(atoms[k])) return false;
      return true;
    };
  };
  typedef lvector<SoftGoal> soft_goal_vec;
  soft_goal_vec soft;
  index_set hard;
  hsps::rational null_value;
  SoftInstance();
  SoftInstance(Name* n);
  ~SoftInstance() { };
  SoftGoal& new_soft_goal();
  index_type n_soft() const { return soft.length(); };
  index_type n_hard() const { return hard.length(); };
  bool empty_plan_valid();
  hsps::rational empty_plan_value();
  void remap_hard_goals(const index_vec& atom_map);
  void remap_soft_goals(const index_vec& atom_map);
  void compile(Instance& ins);
  void create_decision_problem(const bool_vec& sel, Instance& ins);
  void create_decision_problem(const bool_vec& sel, hsps::rational b, Instance& ins);
  hsps::rational compute_epsilon();
  hsps::rational eval_goal_state(const index_set& s);
  hsps::rational eval_goal_state(const index_set& s, index_set& g);
  hsps::rational eval_plan(Schedule& s);
  void eval_plan_set(ScheduleSet& s, cost_vec& v);
  virtual void write_problem_goal(std::ostream& s) const;
  virtual void write_problem_metric(std::ostream& s) const;
  void write_goal_value_expression(std::ostream& s) const;
  void write_soft_goal_set(std::ostream& s, const index_set& set) const;
  void write_soft_goal_set(std::ostream& s, const bool_vec& set) const;
  virtual void print(std::ostream& s) const;
};
class DecisionProblemEnumerator : public IterativeEnumerator {
  SoftInstance& instance;
  SubsetEnumerator selected;
  Heuristic& h_cost;
  hsps::rational nb_min;
  index_set g_sel;
  index_set a_sel;
  hsps::rational v_sel;
  hsps::rational c_sel;
  hsps::rational nb_sel;
  bool find_next(bool more);
 public:
  DecisionProblemEnumerator(SoftInstance& ins, Heuristic& h, hsps::rational b);
  virtual ~DecisionProblemEnumerator();
  virtual bool first();
  virtual bool next();
  hsps::rational current_value() const;
  hsps::rational current_min_cost() const;
  hsps::rational current_max_cost() const;
  hsps::rational current_min_nb() const;
  hsps::rational current_max_nb() const;
  const index_set& current_soft_goals() const;
  const index_set& current_goal_atoms() const;
  void create_decision_problem(Instance& ins);
};
class MaxValueSearch {
 protected:
  struct option {
    hsps::rational goal_value;
    hsps::rational est_cost;
    index_set goals;
    State* root;
    option() : goal_value(0), est_cost(0), goals(EMPTYSET), root(0) { };
    index_type n_goals() const { goals.length(); };
    hsps::rational est_value() const { return (goal_value - est_cost); };
  };
  typedef std::list<option> option_list;
  typedef option_list::iterator option_p;
  SoftInstance& instance;
  ACF& cost;
  Statistics& stats;
  Result& res;
  MultiSearchAlgorithm* search;
  option_list options;
  hsps::rational lb;
  bool solved_flag;
  int trace_level;
  void insert_option_in_list(const option& o);
  void init_option_list();
  void make_empty_plan();
  virtual void init_option(const index_set& selected, option& o) = 0;
  virtual hsps::rational explore_next_option() = 0;
 public:
  MaxValueSearch(SoftInstance& i, ACF& c, Statistics& s, Result& r);
  MaxValueSearch(SoftInstance& i, ACF& c, Statistics& s, Result& r,
   index_type tt_size, bool use_cc);
  ~MaxValueSearch();
  static index_type print_options_max;
  void print_option_list(std::ostream& s);
  index_type n_options() const { return options.size(); };
  hsps::rational best_option_estimated_value();
  index_type best_option_size();
  void init();
  hsps::rational main();
  bool solved() { return solved_flag; }
};
class MaxNetBenefit : public MaxValueSearch {
  Heuristic& heuristic;
  RegressionResourceState* root_rs;
 protected:
  virtual void init_option(const index_set& selected, option& o);
  virtual hsps::rational explore_next_option();
 public:
  MaxNetBenefit(SoftInstance& i, ACF& c, Statistics& s, Result& r,
  Heuristic& h)
    : MaxValueSearch(i, c, s, r), heuristic(h), root_rs(0)
    { };
  MaxNetBenefit(SoftInstance& i, ACF& c, Statistics& s, Result& r,
  Heuristic& h, index_type tt_size, bool use_cc)
    : MaxValueSearch(i, c, s, r, tt_size, use_cc), heuristic(h), root_rs(0)
    { };
  MaxNetBenefit(SoftInstance& i, ACF& c, Statistics& s, Result& r,
  Heuristic& h, RegressionResourceState* rs)
    : MaxValueSearch(i, c, s, r), heuristic(h), root_rs(rs)
    { };
  MaxNetBenefit(SoftInstance& i, ACF& c, Statistics& s, Result& r,
  Heuristic& h, RegressionResourceState* rs,
  index_type tt_size, bool use_cc)
    : MaxValueSearch(i, c, s, r, tt_size, use_cc), heuristic(h), root_rs(rs)
    { };
  ~MaxNetBenefit() { };
};
}
namespace hsps {
class PDDL_Name;
class PDDL_Base {
 public:
  static bool use_default_function_value;
  static hsps::rational default_function_value;
  static bool use_strict_borrow_definition;
  static bool use_extended_borrow_definition;
  static bool del_before_add_semantics;
  static bool compact_resource_effects;
  static bool compile_away_disjunctive_preconditions;
  static bool check_precondition_consistency;
  static bool compile_away_conditional_effects;
  static bool compile_away_plan_constraints;
  static bool compile_away_object_functions;
  static bool compile_for_validator;
  static bool create_all_atoms;
  static bool create_all_actions;
  static bool number_multiple_action_instances;
  static bool exclude_all_dkel_items;
  static string_set excluded_dkel_tags;
  static string_set required_dkel_tags;
  static bool strict_set_export;
  static bool best_effort;
  static bool write_PDDL31;
  static bool write_warnings;
  static bool write_info;
  static bool write_trace;
  static bool trace_print_context;
  static bool name_instance_by_problem_file;
  static const char* instance_name_prefix;
  enum symbol_class {
    sym_object,
    sym_typename,
    sym_predicate,
    sym_object_function,
    sym_function,
    sym_action,
    sym_variable,
    sym_misc,
    sym_preference,
    sym_set,
    sym_meta_variable
  };
  enum metric_class {
    metric_none,
    metric_makespan,
    metric_minimize,
    metric_maximize
  };
  enum mode_keyword {
    md_none,
    md_start,
    md_end,
    md_all,
    md_init,
    md_pos_goal,
    md_neg_goal
  };
  enum partial_value { p_false, p_true, p_unknown };
  enum expression_class {
    exp_fun,
    exp_list,
    exp_const,
    exp_add,
    exp_sub,
    exp_mul,
    exp_div,
    exp_time,
    exp_preference
  };
  enum relation_type {
    rel_equal,
    rel_greater,
    rel_greater_equal,
    rel_less,
    rel_less_equal
  };
  enum formula_class { fc_false,
         fc_true,
         fc_atom,
         fc_equality,
         fc_negation,
         fc_conjunction,
         fc_disjunction,
         fc_equivalence,
         fc_implication,
         fc_universal,
         fc_existential,
         fc_list
  };
  struct Symbol;
  struct TypeSymbol;
  struct Atom;
  struct FTerm;
  struct FChangeAtom;
  struct SetOf;
  struct ListExpression;
  struct ActionSymbol;
  struct Reference;
  struct IrrelevantItem;
  typedef lvector<TypeSymbol*> type_vec;
  typedef lvector<Atom*> atom_vec;
  typedef lvector<FChangeAtom*> ch_atom_vec;
  typedef lvector<SetOf*> atom_set_vec;
  typedef lvector<Reference*> ref_vec;
  typedef lvector<IrrelevantItem*> irrelevant_vec;
  struct TypeSet : public type_vec {
    TypeSet() : type_vec(0, 0) { };
    TypeSet(const TypeSet& s) : type_vec(s) { };
    TypeSet(TypeSymbol* t) : type_vec(t, 1) { };
    index_type n_elements() const;
    Symbol* get_element(index_type n);
    bool is_object() const;
    bool subtype_or_equal(const TypeSet& s) const;
    bool subtype_or_equal(TypeSymbol* t) const;
    void print(std::ostream& s) const;
    void write_type(std::ostream& s) const;
  };
  struct Symbol {
    symbol_class sym_class;
    char* print_name;
    TypeSet sym_types;
    bool defined_in_problem;
    bool visible;
    Symbol(symbol_class c, char* n)
      : sym_class(c), print_name(n), defined_in_problem(false), visible(true) { };
    Symbol(char* n)
      : sym_class(sym_object), print_name(n), defined_in_problem(false), visible(true) { };
    void print(std::ostream& s) const;
  };
  typedef zero_init_pair<Symbol*> symbol_pair;
  typedef lvector<Symbol*> symbol_vec;
  typedef svector<Symbol*> symbol_set;
  typedef lvector<symbol_pair> symbol_pair_vec;
  static bool extend_substitution(Symbol* out, Symbol* in, symbol_pair_vec& u);
  static bool print_substitution(std::ostream& s, const symbol_pair_vec& u);
  static bool print_inequality(std::ostream& s, const symbol_pair_vec& neq);
  static bool substitution_violates_inequality(const symbol_pair_vec& neq,
            const symbol_pair_vec& u);
  static index_type find_matching_atom(Atom* a, atom_vec& v);
  static index_type find_matching_atom(Atom* a, mode_keyword m, atom_vec& v);
  static index_type find_matching_fluent_atom
    (FChangeAtom* a, mode_keyword m, ch_atom_vec& v);
  struct TypeSymbol : public Symbol {
    symbol_vec elements;
    bool is_base_type;
    TypeSymbol(char* n) : Symbol(sym_typename, n), elements(0, 0),
  is_base_type(false) { };
    void add_element(Symbol* e);
    bool is_object() const { return (strcmp(print_name, "object") == 0); };
    bool subtype_or_equal(TypeSymbol* t) const;
    bool subtype_or_equal(const TypeSet& t) const;
    void print(std::ostream& s) const;
  };
  struct VariableSymbol : public Symbol {
    Symbol* value;
    FTerm* binding;
    VariableSymbol(char* n) : Symbol(sym_variable, n), value(0), binding(0) {};
    bool equality_type_check(Symbol* s);
    void print(std::ostream& s);
  };
  typedef lvector<VariableSymbol*> variable_vec;
  struct ParamSymbol : public Symbol {
    variable_vec param;
    ParamSymbol(symbol_class c, char* n) : Symbol(c, n), param(0, 0) { };
  };
  struct PredicateSymbol : public ParamSymbol {
    bool pos_pre;
    bool neg_pre;
    bool added;
    bool deleted;
    bool locked;
    bool modded;
    ptr_table init;
    ptr_table pos_goal;
    ptr_table neg_goal;
    ptr_table pos_prop;
    ptr_table neg_prop;
    irrelevant_vec irr_ins;
    PredicateSymbol(char* n) : ParamSymbol(sym_predicate, n),
  pos_pre(false), neg_pre(false), added(false), deleted(false),
  locked(false), modded(false), irr_ins(0, 0) { };
    bool is_static() const { return !modded; };
    bool is_equality() const { return (strcmp(print_name, "=") == 0); };
    void instantiate(Instance& ins);
    void initialise_missing(const symbol_vec& p,
       atom_vec* created,
       index_type i = 0);
    void write_prototype(std::ostream& s);
    void print(std::ostream& s);
  };
  struct ObjectFunctionSymbol : public ParamSymbol {
    bool modded;
    ptr_table init;
    ObjectFunctionSymbol(char* n)
      : ParamSymbol(sym_object_function, n), modded(false) { };
    bool is_static() const { return !modded; };
    void print(std::ostream& s);
  };
  struct FunctionSymbol : public ParamSymbol {
    bool modified;
    bool integral;
    bool linear;
    bool conditioned;
    bool increased;
    bool decreased;
    bool assigned;
    bool borrowed;
    ptr_table init;
    FunctionSymbol(char* n) : ParamSymbol(sym_function, n),
  modified(false), integral(true), linear(true), conditioned(false),
  increased(false), decreased(false), assigned(false), borrowed(false)
    { };
    bool is_static() const
    { return !modified; };
    bool is_reusable() const
    { return borrowed && !increased && !decreased && !assigned; };
    bool is_consumable() const
    { return !borrowed && !increased && decreased && !assigned; };
    interval eval_init_bounds(ptr_table* p, index_type i, ListExpression* r);
    void print(std::ostream& s);
  };
  struct AtomBase {
    symbol_vec param;
    mode_keyword at;
    hsps::rational at_time;
    AtomBase() : param(0, 0), at(md_none), at_time(0) { };
    AtomBase(mode_keyword t) : param(0, 0), at(t), at_time(0) { };
    AtomBase(AtomBase* b);
    bool equals(AtomBase& b);
    void free_variables(variable_vec& v);
    bool occurs(Symbol* s);
    void fill_in_args(AtomBase* b);
    void collect_bound_variables(variable_vec& v);
    void insert(ptr_table& t);
    static bool print_bindings;
    void print(std::ostream& s) const;
    void print_instance(std::ostream& s);
  };
  typedef lvector<AtomBase*> atom_base_vec;
  struct Atom : AtomBase {
    PredicateSymbol* pred;
    Atom(PredicateSymbol* p) : pred(p) { };
    Atom(PredicateSymbol* p, mode_keyword t) : AtomBase(t), pred(p) { };
    Atom(PredicateSymbol* p, variable_vec& a, bool as_value)
      : pred(p)
    {
      param.set_length(a.length());
      for (index_type k = 0; k < a.length(); k++)
 param[k] = (as_value ? a[k]->value : a[k]);
    };
    Atom(PredicateSymbol* p, Symbol* a0)
      : pred(p)
    {
      param.append(a0);
    };
    Atom(Atom* a) : AtomBase(a), pred(a->pred) { };
    bool equals(Atom& a);
    bool is_static() const {
      return ((at == md_init) ||
       (at == md_pos_goal) ||
       (at == md_neg_goal) ||
       pred->is_static());
    };
    bool check();
    Instance::Atom* find_prop(Instance& ins, bool neg, bool create);
    void build(Instance& ins, bool neg, index_type p);
    Atom* instantiate_partially();
    partial_value partial_eval(ptr_table* r, index_type p);
    partial_value partial_eval();
    bool initial_value();
    bool instance_of(Atom* a, symbol_pair_vec& u);
    bool instance_of(Atom* a, const symbol_pair_vec& neq, symbol_pair_vec& u);
    bool unify(Atom* a, symbol_pair_vec& u);
    bool unify(Atom* a, const symbol_pair_vec& neq, symbol_pair_vec& u);
    void print(std::ostream& s, bool neg) const;
    void print(std::ostream& s) const { print(s, false); };
  };
  struct CAtom : public Atom {
    symbol_pair_vec neq;
    CAtom(Atom* a) : Atom(a), neq(symbol_pair(0, 0), 0) { };
    CAtom(CAtom* s) : Atom(s), neq(s->neq) { };
    CAtom(const Atom* a, symbol_pair_vec& u);
    CAtom(const Atom* a, symbol_pair_vec& n, symbol_pair_vec& u);
    bool instance_of(Atom* a, symbol_pair_vec& u);
    bool instance_of(Atom* a, const symbol_pair_vec& neq, symbol_pair_vec& u);
    bool instance_of(CAtom* a, symbol_pair_vec& u);
    bool unify(Atom* a, symbol_pair_vec& u);
    bool unify(CAtom* a, symbol_pair_vec& u);
    void print(std::ostream& s);
  };
  typedef lvector<CAtom*> catom_vec;
  struct FTerm : AtomBase {
    ObjectFunctionSymbol* fun;
    FTerm(ObjectFunctionSymbol* f) : fun(f) { };
    bool equals(FTerm& a);
    void print(std::ostream& s) const;
  };
  struct OInitAtom : AtomBase {
    ObjectFunctionSymbol* fun;
    Symbol* val;
    OInitAtom(ObjectFunctionSymbol* f) : fun(f), val(0) { };
    void print(std::ostream& s);
  };
  typedef lvector<OInitAtom*> obj_init_atom_vec;
  struct FInitAtom : AtomBase {
    FunctionSymbol* fun;
    hsps::rational val;
    Instance::resource_ref res;
    FInitAtom(FunctionSymbol* f) : fun(f), val(0) { };
    FInitAtom(FChangeAtom* a);
    bool is_static() const { return fun->is_static(); };
    void print(std::ostream& s);
  };
  typedef lvector<FInitAtom*> fun_init_atom_vec;
  struct Expression;
  typedef lvector<Expression*> exp_vec;
  struct Expression {
    expression_class exp_class;
    Expression(expression_class c) : exp_class(c) { };
    static bool print_nary;
    bool is_static();
    bool is_constant();
    bool is_integral();
    hsps::rational eval_static();
    bool eval_partial(hsps::rational& val);
    interval eval_bounds();
    hsps::rational eval_init();
    hsps::rational eval_delta(ch_atom_vec& incs, ch_atom_vec& decs);
    hsps::rational eval_delta(Symbol* preference, hsps::rational p_value, hsps::rational d_value);
    Expression* copy();
    Expression* simplify();
    void collect_constants(exp_vec& c);
    void mark_functions_in_condition();
    hsps::rational integrify();
    void substitute_for_time(Expression* e);
    Expression* substitute_for_preference(Symbol* n, Expression* e);
    bool equals(Expression* e);
    void print_sum(std::ostream& s, bool grnd);
    void print_product(std::ostream& s, bool grnd);
    void print(std::ostream& s, bool grnd);
  };
  struct ListExpression : public Expression {
    Symbol* sym;
    ListExpression* rest;
    ListExpression(Symbol* s, ListExpression* r) :
      Expression(exp_list), sym(s), rest(r) { };
    bool match(AtomBase* atom);
  };
  struct FunctionExpression : public Expression {
    FunctionSymbol* fun;
    ListExpression* args;
    FunctionExpression(FunctionSymbol* f, ListExpression* a) :
      Expression(exp_fun), fun(f), args(a) { };
    bool match(FChangeAtom* atom);
    hsps::rational eval_delta(ch_atom_vec& incs, ch_atom_vec& decs);
    FChangeAtom* make_atom_base();
  };
  struct ConstantExpression : public Expression {
    hsps::rational val;
    ConstantExpression(hsps::rational v) :
      Expression(exp_const), val(v) { };
  };
  struct TimeExpression : public Expression {
    Expression* time_exp;
    TimeExpression() :
      Expression(exp_time), time_exp(0) { };
    TimeExpression(Expression* e) :
      Expression(exp_time), time_exp(e) { };
  };
  struct BinaryExpression : public Expression {
    Expression* first;
    Expression* second;
    BinaryExpression(expression_class c, Expression* e1, Expression* e2) :
      Expression(c), first(e1), second(e2) { };
  };
  struct PreferenceExpression : public Expression {
    Symbol* name;
    PreferenceExpression(Symbol* n) :
      Expression(exp_preference), name(n) { };
  };
  struct Relation {
    relation_type rel;
    mode_keyword at;
    Expression* first;
    Expression* second;
    Relation(relation_type r, Expression* e1, Expression* e2) :
      rel(r), at(md_none), first(e1), second(e2) { };
    Relation(relation_type r, mode_keyword m, Expression* e1, Expression* e2) :
      rel(r), at(m), first(e1), second(e2) { };
    Expression* match_gteq_constant(FChangeAtom* atom);
    FunctionExpression* match_lteq_fun(FChangeAtom* atom);
    bool is_static();
    partial_value partial_eval();
    void print(std::ostream& s, bool grnd);
  };
  typedef lvector<Relation*> relation_vec;
  struct FChangeAtom : AtomBase {
    FunctionSymbol* fun;
    Expression* val;
    FChangeAtom(FunctionSymbol* f) :
      fun(f), val(0) { };
    FChangeAtom(FunctionSymbol* f, mode_keyword t) :
      AtomBase(t), fun(f), val(0) { };
    FChangeAtom(FChangeAtom* a, hsps::rational v) :
      AtomBase(a), fun(a->fun), val(new ConstantExpression(v)) { };
    bool equals(FChangeAtom& a);
    bool fluent_equals(FChangeAtom& a);
    bool fluent_and_mode_equals(FChangeAtom& a);
    FChangeAtom* find_fluent_equals(ch_atom_vec& vec);
    Instance::Resource* find_resource(Instance& ins);
    void print(std::ostream& s);
  };
  struct Formula {
    formula_class fc;
    Formula(formula_class c) : fc(c) { };
    void rename_variables_1(PDDL_Base::symbol_pair_vec& sub);
    void rename_variables_2(PDDL_Base::symbol_pair_vec& sub);
    void rename_predicates_1(PDDL_Base::symbol_pair_vec& sub);
    void rename_predicates_2(PDDL_Base::symbol_pair_vec& sub);
    Formula* simplify();
    void write_otter(std::ostream& s) const;
    void print(std::ostream& s) const;
    void untype(PDDL_Base* base);
  };
  typedef lvector<Formula*> formula_vec;
  struct AFormula : public Formula, public Atom {
    AFormula(Atom* a) :
      Formula(fc_atom), Atom(a) { };
    AFormula(PredicateSymbol* p) :
      Formula(fc_atom), Atom(p) { };
    AFormula(PredicateSymbol* p, variable_vec& a) :
      Formula(fc_atom), Atom(p, a, false) { };
    void print(std::ostream& s) const;
    void write_otter(std::ostream& s) const;
  };
  struct EqFormula : public Formula {
    Symbol* t1;
    Symbol* t2;
    EqFormula(Symbol* s1, Symbol* s2) :
      Formula(fc_equality), t1(s1), t2(s2) { };
    void write_otter(std::ostream& s) const;
  };
  struct NFormula : public Formula {
    Formula* f;
    NFormula(Formula* g) : Formula(fc_negation), f(g) { };
  };
  struct BFormula : public Formula {
    Formula* f1;
    Formula* f2;
    BFormula(formula_class c, Formula* g1, Formula* g2) :
      Formula(c), f1(g1), f2(g2) { };
  };
  struct CFormula : public Formula {
    formula_vec parts;
    CFormula(formula_class c) : Formula(c), parts(0, 0) { };
    CFormula(formula_class c, Formula* f1, Formula* f2) :
      Formula(c), parts(0, 0)
    {
      parts.append(f1);
      parts.append(f2);
    };
    void add(Formula* f) { parts.append(f); };
    void add(formula_vec& f) { parts.append(f); };
    void write_otter(std::ostream& s) const;
  };
  struct QFormula : public Formula {
    variable_vec vars;
    Formula* f;
    QFormula(formula_class c) : Formula(c), vars(0, 0), f(0) { };
    QFormula(formula_class c, Formula* g) : Formula(c), vars(0, 0), f(g) { };
    QFormula(formula_class c, variable_vec& v, Formula* g) :
      Formula(c), vars(0, 0), f(g)
    {
      for (index_type k = 0; k < v.length(); k++) vars.append(v[k]);
    };
    void add(PDDL_Base::VariableSymbol* v) { vars.append(v); };
    void add(PDDL_Base::variable_vec& v) { vars.append(v); };
    void write_otter(std::ostream& s) const;
  };
  struct TypeConstraint {
    VariableSymbol* var;
    TypeSymbol* typ;
    TypeConstraint(VariableSymbol* v, TypeSymbol* t) : var(v), typ(t) { };
    bool is_true();
    partial_value partial_eval();
    void print(std::ostream& s);
  };
  typedef lvector<TypeConstraint*> type_constraint_vec;
  struct Context {
    variable_vec param;
    atom_vec pos_con;
    atom_vec neg_con;
    type_constraint_vec type_con;
    Context() : param(0, 0), pos_con(0, 0), neg_con(0, 0), type_con(0, 0) { };
    Context(const Context* c) : param(c->param), pos_con(c->pos_con),
  neg_con(c->neg_con), type_con(c->type_con) { };
    bool context_is_static() const;
    bool occurs_in_context(Symbol* s);
    void clear_arguments();
    void set_mode(mode_keyword m);
    bool is_true();
    partial_value partial_eval();
    void print(std::ostream& s);
    void print_assignment(std::ostream& s);
    void untype(PDDL_Base* base);
  };
  struct DKEL_Item : public Context {
    char* item_name;
    Symbol* name;
    string_set item_tags;
    bool defined_in_problem;
    bool included;
    DKEL_Item(char* name) : item_name(name), name(0),
  defined_in_problem(false), included(true) { };
    DKEL_Item(const DKEL_Item* i) : Context(i), item_name(i->item_name),
  name(i->name), item_tags(i->item_tags),
  defined_in_problem(i->defined_in_problem), included(i->included) { };
    bool item_is_included(string_set& ex_tags, string_set& req_tags);
    void print_begin(std::ostream& s);
    void print_end(std::ostream& s);
    void print(std::ostream& s);
    void write_dkel(std::ostream& s);
  };
  struct SetOf : public Context {
    atom_vec pos_atoms;
    atom_vec neg_atoms;
    SetOf() : pos_atoms(0, 0), neg_atoms(0, 0) { };
    SetOf(const SetOf* s)
      : Context(s), pos_atoms(s->pos_atoms), neg_atoms(s->neg_atoms)
    { };
    SetOf(Atom* a)
    { pos_atoms.append(a); };
    SetOf(Atom* a, bool n)
    { if (n) neg_atoms.append(a); else pos_atoms.append(a); };
    bool is_static() const;
    void set_mode(mode_keyword m);
    partial_value partial_eval(bool as_disjunction = false);
    partial_value partial_eval(index_type p, bool as_disjunction = false);
    void instantiate_as_set(Instance& ins, index_set& s);
    void instantiate_as_effect(Instance& ins, index_set& s_add,
          index_set& s_del);
    void instantiate_conditional(Instance& ins, rule_set& s_pos,
     rule_set& s_neg);
    SetOf* instantiate_partially();
    void compile(atom_vec& pos_ins, atom_vec& neg_ins, index_type p);
    void compile_non_static(atom_set_vec& ins, index_type p);
    void print(std::ostream& s);
    void print_as_disjunction(std::ostream& s);
    void build_set(Instance& ins, index_set& s, index_type p);
    void build_effect(Instance& ins, index_set& s_add, index_set& s_del,
        index_type p);
    void build_conditional(Instance& ins, rule_set& s_pos, rule_set& s_neg,
      index_type p);
  };
  struct QCNumericEffect : public Context {
    FChangeAtom* atom;
    QCNumericEffect() : atom(0) { };
    QCNumericEffect(FChangeAtom* a) : atom(a) { };
    void print(std::ostream& s);
  };
  typedef lvector<QCNumericEffect*> qc_numeric_effect_vec;
  enum set_constraint_keyword { sc_at_least, sc_at_most, sc_exactly };
  struct SetConstraint : public DKEL_Item {
    set_constraint_keyword sc_type;
    index_type sc_count;
    atom_vec pos_atoms;
    atom_vec neg_atoms;
    atom_set_vec atom_sets;
    SetConstraint() : DKEL_Item(":invariant"), sc_type(sc_at_least),
  sc_count(0), pos_atoms(0, 0), neg_atoms(0, 0), atom_sets(0, 0) { };
    SetConstraint(const DKEL_Item* item) : DKEL_Item(item),
  sc_type(sc_at_least), sc_count(0), pos_atoms(0, 0), neg_atoms(0, 0),
  atom_sets(0, 0) { };
    void build(Instance& ins, index_type p);
    void instantiate(Instance& ins);
    void print(std::ostream& s);
    void write_dkel(std::ostream& s);
    void untype(PDDL_Base* base);
  };
  struct InvariantFormula : public DKEL_Item {
    Formula* f;
    InvariantFormula(Formula* g)
      : DKEL_Item(":invariant"), f(g) { };
    InvariantFormula(const DKEL_Item* item, Formula* g)
      : DKEL_Item(item), f(g) { };
    void write_dkel(std::ostream& s);
    void untype(PDDL_Base* base);
  };
  struct Reference : public AtomBase {
    Symbol* name;
    bool neg;
    bool has_args;
    index_set index;
    Reference(Symbol* n) : name(n), neg(false), has_args(true) { };
    Reference(Symbol* n, bool ng, bool ha)
      : name(n), neg(ng), has_args(ha) { };
    bool match(symbol_vec& args);
    bool match(variable_vec& args);
    void* find_action();
    void find(const name_vec& names, index_set& ind);
    Reference* instantiate_partially();
    void print(std::ostream& s);
  };
  struct IrrelevantItem : public DKEL_Item {
    Reference* entity;
    IrrelevantItem() : DKEL_Item(":irrelevant"), entity(0) { };
    bool match(symbol_vec& args);
    bool match(variable_vec& args);
    IrrelevantItem* instantiate_partially();
    void print(std::ostream& s);
    void write_dkel(std::ostream& s);
  };
  struct SequentialTaskNet : public Context {
    ref_vec tasks;
    ActionSymbol* abs_act;
    SequentialTaskNet() : tasks(0, 0), abs_act(0) { };
    void print(std::ostream& s);
  };
  typedef lvector<SequentialTaskNet*> task_net_vec;
  struct SetSymbol : public Symbol {
    ptr_table set_table;
    lvector<index_set*> sets;
    name_vec names;
    SetSymbol(char* n) : Symbol(sym_set, n), sets(0, 0), names(0, 0) { };
  };
  struct SetName : public AtomBase {
    SetSymbol* sym;
    SetName(SetSymbol* s) : sym(s) { };
    index_set* find();
    SetName* instantiate_partially();
    void print(std::ostream& s);
    void print_instance(std::ostream& s);
  };
  struct ActionSymbol : public ParamSymbol {
    atom_vec pos_pre;
    atom_vec neg_pre;
    atom_set_vec set_pre;
    atom_set_vec dis_pre;
    relation_vec num_pre;
    atom_vec adds;
    atom_vec dels;
    atom_set_vec set_eff;
    atom_vec cons;
    atom_set_vec cond_eff;
    atom_vec locks;
    atom_vec enables;
    ch_atom_vec reqs;
    ch_atom_vec incs;
    ch_atom_vec decs;
    ch_atom_vec fass;
    qc_numeric_effect_vec qc_incs;
    qc_numeric_effect_vec qc_decs;
    qc_numeric_effect_vec qc_fass;
    Expression* dmin;
    Expression* dmax;
    irrelevant_vec irr_ins;
    ref_vec refs;
    task_net_vec exps;
    ptr_table instances;
    SetName* part;
    const char* assoc;
    ActionSymbol(char* n) : ParamSymbol(sym_action, n), pos_pre(0, 0),
  neg_pre(0, 0), set_pre(0, 0), dis_pre(0, 0), num_pre(0, 0),
  adds(0, 0), dels(0, 0), set_eff(0, 0), cons(0, 0), cond_eff(0, 0),
  locks(0, 0), enables(0, 0), reqs(0, 0), incs(0, 0), decs(0, 0),
  fass(0, 0), qc_incs(0, 0), qc_decs(0, 0), qc_fass(0, 0), dmin(0),
  dmax(0), irr_ins(0, 0), refs(0, 0), exps(0, 0), part(0), assoc(0) { };
    void build(Instance& ins, index_type p, Expression* cost_exp);
    Instance::Action& build_action(Instance& ins,
       PDDL_Name* name,
       index_type& count,
       const index_set& pre,
       const index_set& add,
       const index_set& del,
       const index_set& lck,
       const index_cost_vec& r_use,
       const index_cost_vec& r_cons,
       hsps::rational dmin,
       hsps::rational dmax,
       hsps::rational dur,
       hsps::rational cost);
    void build_actions_with_dc(Instance& ins,
          PDDL_Name* name,
          index_type& count,
          const index_set& pre,
          const index_set& add,
          const index_set& del,
          const index_set& lck,
          const index_cost_vec& r_use,
          const index_cost_vec& r_cons,
          hsps::rational dmin,
          hsps::rational dmax,
          hsps::rational dur,
          hsps::rational cost,
          const index_set_vec& dc,
          index_vec& s,
          index_type p);
    void build_actions_with_dc(Instance& ins,
          PDDL_Name* name,
          index_type& count,
          const index_set& pre,
          const index_set& add,
          const index_set& del,
          const index_set& lck,
          const index_cost_vec& r_use,
          const index_cost_vec& r_cons,
          hsps::rational dmin,
          hsps::rational dmax,
          hsps::rational dur,
          hsps::rational cost,
          const index_set_vec& dc);
    void build_actions_with_dc_and_ce(Instance& ins,
          PDDL_Name* name,
          index_type& count,
          const index_set& pre,
          const index_set& add,
          const index_set& del,
          const index_set& lck,
          const index_cost_vec& r_use,
          const index_cost_vec& r_cons,
          hsps::rational dmin,
          hsps::rational dmax,
          hsps::rational dur,
          hsps::rational cost,
          const index_set_vec& dc,
          const rule_set& pce,
          const rule_set& nce,
          const bool_vec& ece);
    index_type param_index(VariableSymbol* p);
    void get_param_inequalities(symbol_pair_vec& neq);
    void set_arguments(const symbol_vec& args);
    void set_arguments(const ptr_table::key_vec& args);
    void clear_arguments();
    void* find_instance();
    bool is_abstract();
    void post_process();
    void instantiate(Instance& ins, Expression* cost_exp);
    void write_prototype(std::ostream& s);
    void print(std::ostream& s);
    void untype(PDDL_Base* base);
  };
  struct InputPlanStep {
    Reference* act;
    hsps::rational start_time;
    InputPlanStep() : act(0), start_time(0) { };
    InputPlanStep(Reference* a, hsps::rational t) : act(a), start_time(t) { };
  };
  struct InputPlan {
    Symbol* name;
    bool is_opt;
    lvector<InputPlanStep*> steps;
    InputPlan() : name(0), is_opt(false), steps(0, 0) { };
    bool export_to_instance(Instance& ins, const index_vec& map, Plan& p);
    void print(std::ostream& s);
  };
  struct HTableEntry {
    atom_vec atoms;
    bool_vec neg;
    hsps::rational cost;
    bool opt;
    HTableEntry() : atoms(0, 0), neg(false, 0), cost(0), opt(false) { };
  };
  struct SimpleReferenceSet : public Context {
    Reference* ref;
    SimpleReferenceSet(Reference* r) : ref(r) { };
    bool build(const name_vec& names, index_set& set, index_type p);
    void print(std::ostream& s);
  };
  typedef lvector<SimpleReferenceSet*> refs_vec;
  struct ReferenceSet : public Context {
    refs_vec refs;
    Symbol* name;
    ReferenceSet() : refs(0, 0), name(0) { };
    void add(SimpleReferenceSet* ref) { refs.append(ref); };
    void build(const name_vec& names, index_set_vec& sets, index_type p);
    void print(std::ostream& s);
  };
  struct CPG {
    atom_vec atoms;
    index_vec atom_first_arg;
    bool_vec neg;
    symbol_vec args;
    type_vec arg_types;
    CPG() : atoms(0, 0), neg(false, 0), args(0, 0), arg_types(0, 0) { };
    CPG(CPG& g, index_vec& s);
    void make_key(ptr_table::key_vec& key);
    void make_typed_key(ptr_table::key_vec& key);
    void make_parameters(variable_vec& params);
    ListExpression* make_argument_list(index_type first);
    void add_asserting_effects(ActionSymbol* act,
          PredicateSymbol* p,
          bool p_val,
          PredicateSymbol* g,
          FunctionSymbol* f,
          Expression* f_val,
          bool strict);
    void add_destroying_effects(ActionSymbol* act,
    ParamSymbol* pf,
    PredicateSymbol* p,
    bool p_val,
    PredicateSymbol* g,
    FunctionSymbol* f,
    Expression* f_val,
    bool strict);
    bool initial_value();
    void add_asserting_effects(index_type c_atom,
          ActionSymbol* act,
          index_type c_eff,
          bool_vec& sat,
          PredicateSymbol* p,
          bool p_val,
          PredicateSymbol* g,
          FunctionSymbol* f,
          Expression* f_val,
          symbol_pair_vec& eq,
          symbol_pair_vec& neq,
          bool strict);
    void add_propositional_effect(ActionSymbol* act,
      PredicateSymbol* p, bool p_val,
      index_type c_atom, Atom* a_eff,
      bool strict);
    void add_fluent_effect(ActionSymbol* act,
      FunctionSymbol* f, Expression* f_val,
      index_type c_atom, Atom* a_eff);
    void add_effect_conditions(Context* e, ParamSymbol* pf, bool_vec& sat,
          symbol_vec& subs, symbol_pair_vec& eq,
          symbol_pair_vec& neq);
  };
  enum goal_class { goal_pos_atom, goal_neg_atom, goal_relation, goal_task,
      goal_conjunction, goal_disjunction, goal_forall,
      goal_exists, goal_always, goal_sometime,
      goal_at_most_once, goal_within, goal_always_within,
      goal_sometime_before, goal_sometime_after };
  struct Goal {
    goal_class g_class;
    Goal(goal_class c) : g_class(c) { };
    bool is_state();
    bool is_propositional();
    bool is_singular();
    bool makeCPG(CPG& g);
    bool makeCPG(CPG& g, index_vec& s);
    void instantiate(Instance& ins, hsps::rational deadline);
    void instantiate(Instance& ins, index_set& set, Symbol* p, index_type i);
    void print(std::ostream& s);
  };
  typedef lvector<Goal*> goal_vec;
  struct AtomicGoal : public Goal {
    Atom* atom;
    AtomicGoal(Atom* a, bool neg)
      : Goal(neg ? goal_neg_atom : goal_pos_atom), atom(a) { };
    void print(std::ostream& s);
  };
  struct NumericGoal : public Goal {
    Relation* rel;
    NumericGoal(Relation* r) : Goal(goal_relation), rel(r) { };
    void print(std::ostream& s);
  };
  struct TaskGoal : public Goal {
    Reference* task;
    TaskGoal(Reference* r) : Goal(goal_task), task(r) { };
    void print(std::ostream& s);
  };
  struct ConjunctiveGoal : public Goal {
    goal_vec goals;
    ConjunctiveGoal() : Goal(goal_conjunction), goals(0, 0) { };
    ConjunctiveGoal(goal_class gc) : Goal(gc), goals(0, 0) { };
    void print(std::ostream& s);
  };
  struct DisjunctiveGoal : public ConjunctiveGoal {
    DisjunctiveGoal() : ConjunctiveGoal(goal_disjunction) { };
    void print(std::ostream& s);
  };
  struct QuantifiedGoal : public Goal, public Context {
    Goal* goal;
    QuantifiedGoal() : Goal(goal_forall), goal(0) { };
    QuantifiedGoal(goal_class gc) : Goal(gc), goal(0) { };
    void print(std::ostream& s);
  };
  struct SimpleSequenceGoal : public Goal {
    Goal* constraint;
    SimpleSequenceGoal(goal_class c, Goal* g) : Goal(c), constraint(g) { };
    void print(std::ostream& s);
  };
  struct TriggeredSequenceGoal : public Goal {
    Goal* trigger;
    Goal* constraint;
    TriggeredSequenceGoal(goal_class c, Goal* t, Goal* g)
      : Goal(c), trigger(t), constraint(g) { };
    void print(std::ostream& s);
  };
  struct DeadlineGoal : public Goal {
    Goal* goal;
    hsps::rational at;
    DeadlineGoal(hsps::rational t, Goal* g) : Goal(goal_within), goal(g), at(t) { };
    void print(std::ostream& s);
  };
  struct TriggeredDeadlineGoal : public Goal {
    Goal* trigger;
    Goal* goal;
    hsps::rational delay;
    TriggeredDeadlineGoal(Goal* t, hsps::rational d, Goal* g)
      : Goal(goal_always_within), trigger(t), delay(d), goal(g) { };
    void print(std::ostream& s);
  };
  struct Preference {
    Symbol* name;
    Goal* goal;
    Preference() : name(0), goal(0) { };
    Preference(Symbol* n) : name(n), goal(0) { };
    Preference(Symbol* n, Goal* g) : name(n), goal(g) { };
    bool is_state() { return goal->is_state(); };
    bool is_propositional() { return goal->is_propositional(); };
    hsps::rational value(metric_class metric_type, Expression* m);
    void instantiate(SoftInstance& ins,
       metric_class metric_type,
       Expression* m);
    void print(std::ostream& s);
  };
  typedef lvector<Preference*> preference_vec;
  char* domain_name;
  char* problem_name;
  char* domain_file;
  char* problem_file;
  bool ready_to_instantiate;
  char* problem_file_basename();
  char* enum_problem_filename(const char* s, index_type i);
  StringTable& tab;
  type_vec dom_types;
  type_vec dom_base_types;
  TypeSymbol* dom_top_type;
  symbol_vec dom_constants;
  PredicateSymbol* dom_eq_pred;
  PredicateSymbol* dom_assign_pred;
  Symbol* dom_undefined_obj;
  static PredicateSymbol* current_eq_predicate;
  lvector<PredicateSymbol*> dom_predicates;
  lvector<ObjectFunctionSymbol*> dom_object_functions;
  lvector<FunctionSymbol*> dom_functions;
  lvector<ActionSymbol*> dom_actions;
  lvector<SetConstraint*> dom_sc_invariants;
  lvector<InvariantFormula*> dom_f_invariants;
  lvector<IrrelevantItem*> dom_irrelevant;
  atom_vec dom_init;
  obj_init_atom_vec dom_obj_init;
  fun_init_atom_vec dom_fun_init;
  goal_vec dom_goals;
  preference_vec dom_preferences;
  ref_vec goal_tasks;
  metric_class metric_type;
  Expression* metric;
  hsps::rational serial_length;
  hsps::rational parallel_length;
  lvector<InputPlan*> input_plans;
  lvector<HTableEntry*> h_table;
  lvector<ReferenceSet*> input_sets;
  lvector<SetSymbol*> partitions;
  static ActionSymbol* src_action_symbol(ptr_pair* p);
  TypeSymbol* find_type(const char* name);
  PredicateSymbol* find_predicate(const char* name);
  FunctionSymbol* find_function(const char* name);
  bool find_initial_fact(const char* pname, const symbol_vec& arg);
  hsps::rational find_function_value(const char* fname, const symbol_vec& arg);
  index_type find_element_satisfying(const symbol_vec& elements,
         const char* pname,
         symbol_vec& arg,
         index_type element_arg_p);
  void find_elements_satisfying(const symbol_vec& elements,
    const char* pname,
    symbol_vec& arg,
    index_type element_arg_p,
    index_set& sats);
  Atom* goal_to_atom(Goal* g);
  bool goal_to_atom_vec(Goal* g, atom_vec& av);
  PDDL_Base(StringTable& t);
  ~PDDL_Base();
  void set_variable_type(variable_vec& vec, TypeSymbol* t);
  void set_variable_type(variable_vec& vec, const TypeSet& t);
  void set_type_type(type_vec& vec, TypeSymbol* t);
  void set_constant_type(symbol_vec& vec, TypeSymbol* t);
  void clear_context(variable_vec& vec);
  void clear_context(variable_vec& vec, index_type n_min, index_type n_max);
  bool merge_type_vectors(type_vec& v0, type_vec& v1);
  void make_parameters(type_vec& t, const char* prefix, variable_vec& v);
  Atom* make_atom_from_prop(ptr_pair& src, bool& neg);
  Symbol* gensym(symbol_class c, const char* p, const TypeSet& t);
  Symbol* gensym(symbol_class c, const char* p, TypeSymbol* t);
  Symbol* gensym_i(symbol_class c, const char* p, index_type i, TypeSymbol* t);
  Symbol* gensym_s(symbol_class c, const char* p, const Symbol* s, TypeSymbol* t);
  Symbol* gensym_n(symbol_class c, const char* p, const Name* n, TypeSymbol* t);
  void new_variable_substitution(Atom* a,
     symbol_pair_vec& u,
     symbol_pair_vec& new_u);
  Atom* new_meta_atom(PredicateSymbol* p);
  CAtom* new_CAtom(Atom* a, symbol_pair_vec& u);
  CAtom* new_CAtom(Atom* a, symbol_pair_vec& n, symbol_pair_vec& u);
  void extend_cc(CAtom* l, catom_vec& m, catom_vec& nm,
   lvector< swapable_pair<catom_vec> >& x,
   index_type d);
  void find_cc();
  void post_process();
  void instantiate(Instance& ins);
  void instantiate_soft(SoftInstance& ins);
  void instantiate_atom_set(Instance& ins, atom_vec& a, index_set& s);
  index_type n_plans() const { return input_plans.length(); };
  bool export_plan(index_type i, Instance& ins, const index_vec& map, Plan& p);
  bool export_plan(index_type i, Instance& ins, Plan& p);
  void export_heuristic(Instance& ins,
   const index_vec& map,
   bool opt_maximize,
   Heuristic& h);
  void export_sets(const name_vec& names, index_set_vec& sets);
  void export_action_partitions(name_vec& names, index_set_vec& sets);
  void lift_DKEL_Items(const Instance& ins);
  PredicateSymbol* find_type_predicate(Symbol* type_sym);
  void untype();
  void compile_preferences();
  void compile_constraints_1();
  void compile_constraints_2();
  void select_preferences(const bool_vec& sel);
  void metric_to_goal(hsps::rational bound);
  void compile_set_conditions_and_effects();
  void compile_object_functions();
  Expression* replace_violations_1(Expression* exp,
       CPG* cpg[],
       FunctionSymbol* f_violated[]);
  Goal* compile_constraint_1(Goal* g, index_type i, const Symbol* n,
        symbol_vec& aut_states, index_type n_ra);
  AtomicGoal* make_automaton_type_a(CPG& f, index_type i, const Symbol* n,
        symbol_vec& aut_state, index_type n_ra);
  AtomicGoal* make_automaton_type_e(CPG& f, index_type i, const Symbol* n,
        symbol_vec& aut_state, index_type n_ra);
  AtomicGoal* make_automaton_type_o(CPG& f, index_type i, const Symbol* n,
        symbol_vec& aut_state, index_type n_ra);
  AtomicGoal* make_automaton_type_sb(CPG& f, CPG& g,
         index_type i, const Symbol* n,
         symbol_vec& aut_state, index_type n_ra);
  AtomicGoal* make_automaton_type_sa(CPG& f, CPG& g,
         index_type i, const Symbol* n,
         symbol_vec& aut_state, index_type n_ra);
  void make_automaton_transition(Symbol* s_from,
     Symbol* s_to,
     bool is_accept,
     CPG* f, bool neg_f,
     CPG* g, bool neg_g,
     PredicateSymbol* p_state,
     PredicateSymbol* p_accept,
     PredicateSymbol* p_synch);
  void add_precondition_formula(ActionSymbol* a, CPG* f, bool is_neg);
  Goal* compile_constraint_2(Goal* g, const Symbol* n);
  Goal* compile_always_constraint(SimpleSequenceGoal* g, const Symbol* n);
  Goal* compile_sometime_constraint(SimpleSequenceGoal* g, const Symbol* n);
  Goal* compile_at_most_once_constraint(SimpleSequenceGoal* g,
     const Symbol* n);
  Goal* compile_sometime_before_constraint(TriggeredSequenceGoal* g,
        const Symbol* n);
  void compile_set_conditions_and_effects(ActionSymbol* act);
  void compile_set_conditions_and_effects(ActionSymbol* act,
       variable_vec& i_param,
       variable_vec& d_param,
       index_type p);
  Atom* make_binding_atom(VariableSymbol* v);
  void compile_object_functions(ActionSymbol* act, Symbol* undefined_value);
  void compile_object_functions_for_validator(ActionSymbol* act);
  Goal* compile_object_functions(Goal* g);
  void write_declarations(std::ostream& s);
  void write_action(std::ostream& s, ActionSymbol* act);
  void write_set_precondition(std::ostream& s, SetOf* set);
  void write_disjunctive_set_precondition(std::ostream& s, SetOf* set);
  void write_set_effect(std::ostream& s, SetOf* set);
  void write_QCN_effect(std::ostream& s, const char* effect_type, QCNumericEffect* qcn);
  void write_objects(std::ostream& s, bool defined_in_problem);
  void write_init(std::ostream& s);
  void write_goal(std::ostream& s);
  void write_metric(std::ostream& s);
  void write_dkel_items(std::ostream& s, bool defined_in_problem);
  void write_domain_begin(std::ostream& s);
  void write_problem_begin(std::ostream& s);
  void write_end(std::ostream& s);
  void write_dkel_domain(std::ostream& s, bool leave_open);
  void write_dkel_problem(std::ostream& s, bool leave_open);
  void write_plans(std::ostream& s);
  void write_heuristic_table(std::ostream& s);
  void write_sets(std::ostream& s);
  void print(std::ostream& s);
};
class InstanceName : public Name {
  char* domain_name;
  char* problem_name;
 public:
  InstanceName(char* d, char* p) : domain_name(d), problem_name(p) { };
  virtual ~InstanceName() { };
  virtual void write(std::ostream& s, unsigned int c) const;
  virtual const Name* cast_to(const char* cname) const;
};
class PDDL_Name : public Name {
 protected:
  bool neg;
  PDDL_Base::Symbol* sym;
  PDDL_Base::symbol_vec arg;
  bool vis;
  bool_vec avis;
 public:
  static char catc;
  static bool obscure_symbol_names;
  PDDL_Name(PDDL_Base::Symbol* s)
    : neg(false), sym(s), arg(0, 0), vis(true), avis(true, 0) { };
  PDDL_Name(PDDL_Base::Symbol* s, bool n)
    : neg(n), sym(s), arg(0, 0), vis(true), avis(true, 0) { };
  PDDL_Name(PDDL_Base::Symbol* s, PDDL_Base::symbol_vec a, bool n)
    : neg(n), sym(s), arg(a), vis(true), avis(true, a.length()) { };
  PDDL_Name(PDDL_Base::Symbol* s, PDDL_Base::variable_vec a, bool n);
  void add(PDDL_Base::Symbol* s);
  void add(PDDL_Base::Symbol* s, bool v);
  PDDL_Base::Symbol* symbol() { return sym; };
  PDDL_Base::symbol_vec& args() { return arg; };
  index_type argc() { return arg.length(); };
  bool is_neg() { return neg; };
  virtual ~PDDL_Name() { };
  virtual void write(std::ostream& s, unsigned int c) const;
  virtual const Name* cast_to(const char* cname) const;
};
class Numbered_PDDL_Name : public PDDL_Name {
  index_type copy;
 public:
  Numbered_PDDL_Name(PDDL_Base::Symbol* sym, index_type c)
    : PDDL_Name(sym), copy(c) { };
  Numbered_PDDL_Name(PDDL_Name* n, index_type c);
  virtual ~Numbered_PDDL_Name() { };
  virtual void write(std::ostream& s, unsigned int c) const;
};
}
#include <sstream>
typedef union {
  hsps::StringTable::Cell* sym;
  hsps::PDDL_Base::Expression* exp;
  hsps::PDDL_Base::ListExpression* lst;
  hsps::PDDL_Base::Relation* rel;
  hsps::PDDL_Base::Goal* goal;
  hsps::PDDL_Base::Formula* ff;
  hsps::PDDL_Base::mode_keyword tkw;
  hsps::PDDL_Base::relation_type rkw;
  hsps::PDDL_Base::set_constraint_keyword sckw;
  hsps::rational::XR rval;
  int ival;
  char* sval;
} yy_PDDL_Parser_stype;
class PDDL_Parser : public hsps::PDDL_Base
{
public:
enum YY_PDDL_Parser_ENUM_TOKEN { YY_PDDL_Parser_NULL_TOKEN=0
 ,TK_OPEN=258
 ,TK_CLOSE=259
 ,TK_OPEN_SQ=260
 ,TK_CLOSE_SQ=261
 ,TK_GREATER=262
 ,TK_GREATEQ=263
 ,TK_LESS=264
 ,TK_LESSEQ=265
 ,TK_COLON=266
 ,TK_HASHT=267
 ,TK_EQ=268
 ,TK_HYPHEN=269
 ,TK_PLUS=270
 ,TK_MUL=271
 ,TK_DIV=272
 ,TK_UMINUS=273
 ,TK_NEW_SYMBOL=274
 ,TK_OBJ_SYMBOL=275
 ,TK_TYPE_SYMBOL=276
 ,TK_PRED_SYMBOL=277
 ,TK_OBJFUN_SYMBOL=278
 ,TK_FUN_SYMBOL=279
 ,TK_VAR_SYMBOL=280
 ,TK_ACTION_SYMBOL=281
 ,TK_MISC_SYMBOL=282
 ,TK_KEYWORD=283
 ,TK_NEW_VAR_SYMBOL=284
 ,TK_PREFERENCE_SYMBOL=285
 ,TK_SET_SYMBOL=286
 ,TK_FLOAT=287
 ,TK_INT=288
 ,TK_STRING=289
 ,KW_REQS=290
 ,KW_CONSTANTS=291
 ,KW_PREDS=292
 ,KW_FUNS=293
 ,KW_TYPES=294
 ,KW_DEFINE=295
 ,KW_DOMAIN=296
 ,KW_ACTION=297
 ,KW_PROCESS=298
 ,KW_EVENT=299
 ,KW_ARGS=300
 ,KW_PRE=301
 ,KW_COND=302
 ,KW_AT_START=303
 ,KW_AT_END=304
 ,KW_OVER_ALL=305
 ,KW_EFFECT=306
 ,KW_INVARIANT=307
 ,KW_DURATION=308
 ,KW_AND=309
 ,KW_OR=310
 ,KW_EXISTS=311
 ,KW_FORALL=312
 ,KW_IMPLY=313
 ,KW_NOT=314
 ,KW_WHEN=315
 ,KW_EITHER=316
 ,KW_PROBLEM=317
 ,KW_FORDOMAIN=318
 ,KW_OBJECTS=319
 ,KW_INIT=320
 ,KW_GOAL=321
 ,KW_LENGTH=322
 ,KW_SERIAL=323
 ,KW_PARALLEL=324
 ,KW_METRIC=325
 ,KW_MINIMIZE=326
 ,KW_MAXIMIZE=327
 ,KW_DURATION_VAR=328
 ,KW_TOTAL_TIME=329
 ,KW_INCREASE=330
 ,KW_DECREASE=331
 ,KW_SCALE_UP=332
 ,KW_SCALE_DOWN=333
 ,KW_ASSIGN=334
 ,KW_TAG=335
 ,KW_NAME=336
 ,KW_VARS=337
 ,KW_SET_CONSTRAINT=338
 ,KW_SETOF=339
 ,KW_AT_LEAST_N=340
 ,KW_AT_MOST_N=341
 ,KW_EXACTLY_N=342
 ,KW_CONTEXT=343
 ,KW_FORMULA=344
 ,KW_IRRELEVANT=345
 ,KW_PLAN=346
 ,KW_HEURISTIC=347
 ,KW_OPT=348
 ,KW_INF=349
 ,KW_FACT=350
 ,KW_SET=351
 ,KW_EXPANSION=352
 ,KW_TASKS=353
 ,KW_PREFERENCE=354
 ,KW_VIOLATED=355
 ,KW_WITHIN=356
 ,KW_ASSOC=357
 ,KW_CONSTRAINTS=358
 ,KW_ALWAYS=359
 ,KW_SOMETIME=360
 ,KW_AT_MOST_ONCE=361
 ,KW_SOMETIME_BEFORE=362
 ,KW_SOMETIME_AFTER=363
 ,KW_ALWAYS_WITHIN=364
 ,KW_IFF=365
 ,KW_FALSE=366
 ,KW_TRUE=367
 ,KW_NUMBER=368
 ,KW_UNDEFINED=369
     };
public:
 int yyparse (void);
 virtual void log_error(char *msg) = 0;
 virtual int next_token() = 0;
 yy_PDDL_Parser_stype yylval;
 int yynerrs;
 int yychar;
 int yydebug;
public:
 PDDL_Parser(hsps::StringTable& t);
public:
 public: virtual std::ostream& at_position(std::ostream& s) = 0; virtual char* current_file() = 0; bool error_flag; private: hsps::PDDL_Base::variable_vec current_param; hsps::index_vec stored_n_param; hsps::PDDL_Base::TypeSet current_type_set; hsps::index_type last_n_functions; hsps::PDDL_Base::AtomBase* current_atom; hsps::PDDL_Base::atom_base_vec current_atom_stack; hsps::PDDL_Base::Context* current_context; hsps::lvector<Context*> stored_context; hsps::PDDL_Base::DKEL_Item* current_item; hsps::lvector<ConjunctiveGoal*> current_goal; hsps::PDDL_Base::Symbol* current_preference_name; hsps::PDDL_Base::HTableEntry* current_entry; char* current_plan_file; hsps::index_type n_plans_in_current_file;
};
PDDL_Parser::PDDL_Parser(hsps::StringTable& t) : hsps::PDDL_Base(t), error_flag(false), current_param(0, 0), stored_n_param(0, 0), current_atom(0), current_atom_stack(0, 0), current_context(0), stored_context(0, 0), current_item(0), current_goal(0, 0), current_preference_name(0), current_entry(0), current_plan_file(0), n_plans_in_current_file(0)
{
yydebug=0;
;
};
static const char yytranslate[] = { 0,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 2, 1, 2, 3, 4, 5,
     6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
    26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
    36, 37, 38, 39, 40, 41, 42, 43, 44, 45,
    46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
    56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
    66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
    76, 77, 78, 79, 80, 81, 82, 83, 84, 85,
    86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
    96, 97, 98, 99, 100, 101, 102, 103, 104, 105,
   106, 107, 108, 109, 110, 111, 112, 113, 114
};
static const short yyprhs[] = { 0,
     0, 3, 6, 9, 12, 15, 16, 22, 25, 28,
    31, 34, 37, 40, 43, 46, 47, 52, 54, 56,
    58, 60, 62, 64, 66, 68, 70, 72, 74, 79,
    82, 85, 88, 89, 94, 97, 99, 100, 106, 111,
   112, 121, 124, 125, 128, 131, 133, 135, 138, 140,
   141, 147, 148, 154, 155, 161, 162, 171, 173, 174,
   177, 179, 180, 186, 187, 193, 198, 203, 206, 207,
   210, 213, 214, 219, 224, 229, 232, 233, 236, 238,
   241, 243, 245, 247, 249, 250, 257, 258, 265, 269,
   273, 277, 281, 285, 288, 292, 293, 294, 300, 301,
   307, 309, 311, 316, 319, 322, 324, 326, 328, 330,
   332, 334, 336, 338, 340, 342, 343, 349, 355, 356,
   365, 374, 375, 384, 393, 394, 406, 418, 421, 422,
   425, 426, 428, 430, 431, 437, 439, 441, 447, 456,
   458, 460, 462, 464, 466, 471, 477, 483, 489, 495,
   499, 501, 503, 507, 512, 514, 516, 519, 521, 524,
   529, 531, 534, 537, 538, 539, 540, 552, 553, 554,
   564, 565, 572, 573, 574, 589, 590, 591, 604, 605,
   615, 621, 623, 628, 630, 633, 635, 640, 642, 643,
   649, 650, 659, 665, 674, 675, 681, 682, 683, 684,
   694, 703, 708, 710, 713, 715, 716, 722, 728, 729,
   738, 747, 749, 754, 757, 759, 760, 761, 771, 772,
   779, 780, 781, 794, 795, 804, 806, 808, 814, 816,
   821, 823, 825, 830, 833, 835, 837, 839, 840, 846,
   847, 857, 858, 867, 869, 871, 872, 881, 882, 894,
   895, 905, 906, 916, 917, 927, 928, 941, 942, 955,
   956, 969, 971, 976, 978, 981, 983, 985, 987, 993,
   995, 1001, 1003, 1005, 1011, 1013, 1015, 1016, 1027, 1030,
  1031, 1032, 1038, 1044, 1049, 1055, 1058, 1061, 1064, 1067,
  1070, 1073, 1076, 1079, 1082, 1083, 1088, 1091, 1094, 1097,
  1098, 1099, 1105, 1106, 1116, 1117, 1127, 1133, 1138, 1146,
  1151, 1159, 1161, 1167, 1170, 1171, 1173, 1174, 1180, 1181,
  1187, 1190, 1191, 1192, 1198, 1199, 1208, 1214, 1216, 1221,
  1226, 1231, 1237, 1243, 1249, 1256, 1262, 1264, 1266, 1268,
  1274, 1280, 1282, 1286, 1288, 1290, 1291, 1297, 1298, 1307,
  1311, 1313, 1315, 1316, 1322, 1328, 1333, 1338, 1343, 1349,
  1355, 1356, 1365, 1366, 1375, 1378, 1380, 1381, 1387, 1389,
  1391, 1392, 1400, 1401, 1409, 1410, 1416, 1417, 1426, 1430,
  1433, 1436, 1439, 1442, 1443, 1446, 1449, 1452, 1453, 1459,
  1462, 1468, 1473, 1475, 1476, 1480, 1487, 1491, 1498, 1502,
  1509, 1510, 1513, 1519, 1520, 1523, 1529, 1532, 1538, 1539,
  1542, 1544, 1546, 1548, 1550, 1552, 1554, 1555, 1561, 1562,
  1571, 1572, 1581, 1587, 1588, 1597, 1598, 1610, 1611, 1623,
  1624, 1636, 1645, 1646, 1655, 1656, 1668, 1669, 1681, 1682,
  1697, 1702, 1707, 1709, 1711, 1713, 1716, 1719, 1720, 1721,
  1727, 1728, 1737, 1738, 1739, 1740, 1756, 1757, 1763, 1766,
  1769, 1772, 1773, 1776, 1777, 1785, 1787, 1789, 1792, 1794,
  1795, 1804, 1808, 1809, 1812, 1814, 1815, 1821, 1826, 1829,
  1830, 1831, 1837, 1840, 1842, 1845, 1847, 1849, 1851, 1852,
  1858, 1859, 1868, 1869, 1878, 1881, 1884, 1885, 1888, 1891,
  1892, 1893, 1899, 1901, 1902, 1910, 1911, 1917, 1918
};
static const short yyrhs[] = { 115,
   116, 0, 115, 249, 0, 115, 333, 0, 115, 339,
     0, 115, 347, 0, 0, 3, 40, 118, 117, 4,
     0, 121, 117, 0, 140, 117, 0, 144, 117, 0,
   123, 117, 0, 131, 117, 0, 147, 117, 0, 358,
   117, 0, 260, 117, 0, 0, 3, 41, 119, 4,
     0, 19, 0, 20, 0, 21, 0, 22, 0, 24,
     0, 25, 0, 26, 0, 27, 0, 30, 0, 19,
     0, 26, 0, 3, 35, 122, 4, 0, 122, 39,
     0, 122, 103, 0, 122, 28, 0, 0, 3, 37,
   124, 4, 0, 125, 124, 0, 125, 0, 0, 3,
    19, 126, 127, 4, 0, 127, 129, 14, 21, 0,
     0, 127, 129, 14, 3, 61, 128, 130, 4, 0,
   127, 129, 0, 0, 129, 29, 0, 129, 25, 0,
    29, 0, 25, 0, 130, 21, 0, 21, 0, 0,
     3, 38, 132, 133, 4, 0, 0, 137, 14, 113,
   134, 133, 0, 0, 137, 14, 21, 135, 133, 0,
     0, 137, 14, 3, 61, 130, 4, 136, 133, 0,
   137, 0, 0, 138, 137, 0, 138, 0, 0, 3,
    19, 139, 127, 4, 0, 0, 3, 39, 141, 142,
     4, 0, 142, 143, 14, 21, 0, 142, 143, 14,
    19, 0, 142, 143, 0, 0, 143, 21, 0, 143,
    19, 0, 0, 3, 36, 145, 4, 0, 3, 64,
   145, 4, 0, 145, 146, 14, 21, 0, 145, 146,
     0, 0, 146, 19, 0, 19, 0, 146, 20, 0,
    20, 0, 148, 0, 275, 0, 284, 0, 0, 3,
    42, 120, 149, 150, 4, 0, 0, 150, 45, 3,
   151, 127, 4, 0, 150, 96, 152, 0, 150, 51,
   207, 0, 150, 46, 155, 0, 150, 47, 155, 0,
   150, 53, 236, 0, 150, 244, 0, 150, 102, 34,
     0, 0, 0, 3, 19, 153, 166, 4, 0, 0,
     3, 31, 154, 166, 4, 0, 156, 0, 158, 0,
     3, 54, 157, 4, 0, 3, 4, 0, 157, 158,
     0, 158, 0, 160, 0, 163, 0, 179, 0, 197,
     0, 199, 0, 172, 0, 48, 0, 49, 0, 50,
     0, 0, 3, 22, 161, 167, 4, 0, 3, 13,
   171, 171, 4, 0, 0, 3, 159, 3, 22, 162,
   167, 4, 4, 0, 3, 159, 3, 13, 171, 171,
     4, 4, 0, 0, 3, 59, 3, 22, 164, 167,
     4, 4, 0, 3, 59, 3, 13, 171, 171, 4,
     4, 0, 0, 3, 159, 3, 59, 3, 22, 165,
   167, 4, 4, 4, 0, 3, 159, 3, 59, 3,
    13, 171, 171, 4, 4, 4, 0, 166, 168, 0,
     0, 167, 171, 0, 0, 25, 0, 20, 0, 0,
     3, 23, 170, 167, 4, 0, 168, 0, 169, 0,
     3, 173, 174, 174, 4, 0, 3, 159, 3, 173,
   174, 174, 4, 4, 0, 7, 0, 8, 0, 9,
     0, 10, 0, 13, 0, 3, 14, 174, 4, 0,
     3, 15, 174, 175, 4, 0, 3, 14, 174, 174,
     4, 0, 3, 16, 174, 176, 4, 0, 3, 17,
   174, 174, 4, 0, 174, 17, 174, 0, 33, 0,
    32, 0, 3, 74, 4, 0, 3, 100, 30, 4,
     0, 177, 0, 174, 0, 174, 175, 0, 174, 0,
   174, 176, 0, 3, 24, 178, 4, 0, 24, 0,
    25, 178, 0, 20, 178, 0, 0, 0, 0, 3,
    84, 180, 301, 304, 3, 22, 181, 167, 4, 4,
     0, 0, 0, 3, 57, 3, 182, 127, 4, 183,
   190, 4, 0, 0, 3, 58, 184, 193, 191, 4,
     0, 0, 0, 3, 159, 3, 84, 185, 301, 304,
     3, 22, 186, 167, 4, 4, 4, 0, 0, 0,
     3, 159, 3, 57, 3, 187, 127, 4, 188, 190,
     4, 4, 0, 0, 3, 159, 3, 58, 189, 193,
   191, 4, 4, 0, 3, 58, 193, 191, 4, 0,
   191, 0, 3, 54, 192, 4, 0, 194, 0, 194,
   192, 0, 194, 0, 3, 54, 306, 4, 0, 307,
     0, 0, 3, 22, 195, 167, 4, 0, 0, 3,
    59, 3, 22, 196, 167, 4, 4, 0, 3, 13,
   171, 171, 4, 0, 3, 59, 3, 13, 171, 171,
     4, 4, 0, 0, 3, 55, 198, 203, 4, 0,
     0, 0, 0, 3, 56, 3, 200, 127, 4, 201,
   202, 4, 0, 3, 54, 306, 3, 55, 203, 4,
     4, 0, 3, 55, 203, 4, 0, 204, 0, 204,
   203, 0, 204, 0, 0, 3, 22, 205, 167, 4,
     0, 3, 13, 171, 171, 4, 0, 0, 3, 59,
     3, 22, 206, 167, 4, 4, 0, 3, 59, 3,
    13, 171, 171, 4, 4, 0, 209, 0, 3, 54,
   208, 4, 0, 209, 208, 0, 209, 0, 0, 0,
     3, 57, 3, 210, 127, 4, 211, 216, 4, 0,
     0, 3, 60, 212, 218, 217, 4, 0, 0, 0,
     3, 159, 3, 57, 3, 213, 127, 4, 214, 216,
     4, 4, 0, 0, 3, 159, 3, 60, 215, 218,
   217, 4, 0, 220, 0, 229, 0, 3, 60, 218,
   217, 4, 0, 217, 0, 3, 54, 219, 4, 0,
   220, 0, 307, 0, 3, 54, 306, 4, 0, 220,
   219, 0, 220, 0, 221, 0, 226, 0, 0, 3,
    22, 222, 167, 4, 0, 0, 3, 79, 3, 23,
   223, 167, 4, 225, 4, 0, 0, 3, 159, 3,
    22, 224, 167, 4, 4, 0, 171, 0, 114, 0,
     0, 3, 59, 3, 22, 227, 167, 4, 4, 0,
     0, 3, 159, 3, 59, 3, 22, 228, 167, 4,
     4, 4, 0, 0, 3, 75, 3, 24, 230, 167,
     4, 174, 4, 0, 0, 3, 76, 3, 24, 231,
   167, 4, 174, 4, 0, 0, 3, 79, 3, 24,
   232, 167, 4, 174, 4, 0, 0, 3, 159, 3,
    75, 3, 24, 233, 167, 4, 174, 4, 4, 0,
     0, 3, 159, 3, 76, 3, 24, 234, 167, 4,
   174, 4, 4, 0, 0, 3, 159, 3, 79, 3,
    24, 235, 167, 4, 174, 4, 4, 0, 238, 0,
     3, 54, 237, 4, 0, 238, 0, 238, 237, 0,
   239, 0, 240, 0, 242, 0, 3, 13, 73, 174,
     4, 0, 174, 0, 3, 241, 73, 174, 4, 0,
     9, 0, 10, 0, 3, 243, 73, 174, 4, 0,
     7, 0, 8, 0, 0, 3, 97, 245, 302, 303,
    98, 3, 246, 4, 4, 0, 247, 246, 0, 0,
     0, 3, 26, 248, 167, 4, 0, 3, 40, 250,
   251, 4, 0, 3, 62, 119, 4, 0, 251, 3,
    63, 119, 4, 0, 251, 121, 0, 251, 144, 0,
   251, 252, 0, 251, 260, 0, 251, 270, 0, 251,
   273, 0, 251, 291, 0, 251, 284, 0, 251, 358,
     0, 0, 3, 65, 253, 4, 0, 253, 258, 0,
   253, 256, 0, 253, 254, 0, 0, 0, 3, 22,
   255, 167, 4, 0, 0, 3, 13, 3, 23, 257,
   167, 4, 20, 4, 0, 0, 3, 13, 3, 24,
   259, 167, 4, 274, 4, 0, 3, 13, 24, 274,
     4, 0, 3, 66, 261, 4, 0, 3, 66, 3,
    54, 262, 4, 4, 0, 3, 103, 261, 4, 0,
     3, 103, 3, 54, 262, 4, 4, 0, 267, 0,
     3, 99, 19, 263, 4, 0, 261, 262, 0, 0,
   267, 0, 0, 3, 54, 264, 266, 4, 0, 0,
     3, 55, 265, 266, 4, 0, 267, 266, 0, 0,
     0, 3, 22, 268, 167, 4, 0, 0, 3, 59,
     3, 22, 269, 167, 4, 4, 0, 3, 13, 171,
   171, 4, 0, 172, 0, 3, 104, 263, 4, 0,
     3, 105, 263, 4, 0, 3, 106, 263, 4, 0,
     3, 107, 263, 263, 4, 0, 3, 108, 263, 263,
     4, 0, 3, 101, 274, 263, 4, 0, 3, 109,
   274, 263, 263, 4, 0, 3, 70, 271, 272, 4,
     0, 71, 0, 72, 0, 174, 0, 3, 67, 68,
    33, 4, 0, 3, 67, 69, 33, 4, 0, 33,
     0, 33, 17, 33, 0, 32, 0, 94, 0, 0,
     3, 52, 276, 295, 277, 0, 0, 83, 278, 3,
   324, 33, 325, 4, 4, 0, 89, 279, 4, 0,
   111, 0, 112, 0, 0, 3, 22, 280, 166, 4,
     0, 3, 13, 168, 168, 4, 0, 3, 59, 279,
     4, 0, 3, 54, 283, 4, 0, 3, 55, 283,
     4, 0, 3, 58, 279, 279, 4, 0, 3, 110,
   279, 279, 4, 0, 0, 3, 57, 3, 281, 127,
     4, 279, 4, 0, 0, 3, 56, 3, 282, 127,
     4, 279, 4, 0, 283, 279, 0, 279, 0, 0,
     3, 90, 285, 295, 286, 0, 287, 0, 289, 0,
     0, 42, 3, 26, 288, 167, 4, 4, 0, 0,
    95, 3, 22, 290, 167, 4, 4, 0, 0, 3,
    52, 292, 295, 293, 0, 0, 83, 294, 3, 324,
    33, 325, 4, 4, 0, 89, 279, 4, 0, 295,
   296, 0, 295, 297, 0, 295, 298, 0, 295, 300,
     0, 0, 80, 119, 0, 81, 19, 0, 81, 27,
     0, 0, 82, 3, 299, 127, 4, 0, 88, 307,
     0, 88, 3, 54, 306, 4, 0, 82, 3, 127,
     4, 0, 301, 0, 0, 88, 307, 305, 0, 88,
     3, 54, 306, 4, 305, 0, 46, 307, 304, 0,
    46, 3, 54, 306, 4, 304, 0, 47, 307, 304,
     0, 47, 3, 54, 306, 4, 304, 0, 0, 88,
   307, 0, 88, 3, 54, 306, 4, 0, 0, 46,
   307, 0, 46, 3, 54, 306, 4, 0, 47, 307,
     0, 47, 3, 54, 306, 4, 0, 0, 306, 307,
     0, 307, 0, 308, 0, 312, 0, 317, 0, 320,
     0, 323, 0, 0, 3, 22, 309, 167, 4, 0,
     0, 3, 159, 3, 22, 310, 167, 4, 4, 0,
     0, 3, 65, 3, 22, 311, 167, 4, 4, 0,
     3, 13, 171, 171, 4, 0, 0, 3, 59, 3,
    22, 313, 167, 4, 4, 0, 0, 3, 159, 3,
    59, 3, 22, 314, 167, 4, 4, 4, 0, 0,
     3, 65, 3, 59, 3, 22, 315, 167, 4, 4,
     4, 0, 0, 3, 59, 3, 65, 3, 22, 316,
   167, 4, 4, 4, 0, 3, 59, 3, 13, 171,
   171, 4, 4, 0, 0, 3, 66, 3, 22, 318,
   167, 4, 4, 0, 0, 3, 66, 3, 59, 3,
    22, 319, 167, 4, 4, 4, 0, 0, 3, 59,
     3, 66, 3, 22, 321, 167, 4, 4, 4, 0,
     0, 3, 59, 3, 66, 3, 59, 3, 22, 322,
   167, 4, 4, 4, 4, 0, 3, 21, 25, 4,
     0, 3, 21, 169, 4, 0, 85, 0, 86, 0,
    87, 0, 325, 326, 0, 325, 329, 0, 0, 0,
     3, 22, 327, 167, 4, 0, 0, 3, 59, 3,
    22, 328, 167, 4, 4, 0, 0, 0, 0, 3,
    84, 82, 3, 330, 127, 4, 331, 304, 3, 22,
   332, 167, 4, 4, 0, 0, 3, 91, 334, 335,
     4, 0, 336, 335, 0, 93, 335, 0, 337, 335,
     0, 0, 81, 119, 0, 0, 274, 11, 3, 26,
   338, 167, 4, 0, 340, 0, 344, 0, 341, 340,
     0, 341, 0, 0, 274, 11, 3, 26, 342, 167,
     4, 343, 0, 5, 274, 6, 0, 0, 345, 344,
     0, 345, 0, 0, 3, 26, 346, 167, 4, 0,
     3, 92, 348, 4, 0, 348, 349, 0, 0, 0,
     3, 350, 352, 4, 351, 0, 93, 274, 0, 274,
     0, 352, 353, 0, 353, 0, 354, 0, 356, 0,
     0, 3, 22, 355, 167, 4, 0, 0, 3, 59,
     3, 22, 357, 167, 4, 4, 0, 0, 3, 96,
   359, 360, 302, 304, 361, 4, 0, 81, 19, 0,
    81, 27, 0, 0, 361, 364, 0, 361, 362, 0,
     0, 0, 3, 119, 363, 167, 4, 0, 119, 0,
     0, 3, 84, 365, 301, 304, 366, 4, 0, 0,
     3, 119, 367, 167, 4, 0, 0, 3, 59, 3,
   119, 368, 167, 4, 4, 0
};
static const short yyrline[] = { 0,
   103, 105, 106, 107, 108, 109, 112, 116, 118, 119,
   120, 121, 122, 123, 124, 125, 128, 136, 138, 139,
   140, 141, 142, 143, 144, 145, 148, 150, 155, 159,
   161, 162, 163, 168, 172, 174, 177, 182, 192, 197,
   201, 205, 209, 212, 225, 232, 244, 253, 258, 265,
   270, 273, 279, 279, 309, 309, 339, 339, 343, 346,
   348, 351, 356, 368, 373, 376, 384, 397, 404, 407,
   413, 419, 424, 426, 429, 434, 438, 441, 450, 458,
   465, 476, 478, 479, 484, 489, 498, 503, 507, 508,
   509, 510, 511, 512, 513, 518, 521, 530, 534, 539,
   545, 547, 548, 551, 555, 557, 560, 562, 563, 564,
   565, 566, 572, 577, 581, 587, 592, 598, 606, 610,
   616, 627, 632, 638, 646, 650, 656, 667, 674, 677,
   684, 687, 695, 701, 707, 727, 732, 737, 744, 753,
   758, 762, 766, 770, 776, 781, 785, 789, 793, 797,
   801, 805, 809, 813, 817, 823, 828, 834, 839, 845,
   850, 856, 861, 865, 871, 877, 881, 896, 901, 910,
   920, 924, 929, 934, 938, 954, 959, 968, 980, 984,
   992, 994, 997, 999, 1002, 1004, 1007, 1009, 1012, 1017,
  1024, 1028, 1035, 1044, 1081, 1086, 1094, 1095, 1100, 1109,
  1121, 1123, 1124, 1127, 1129, 1132, 1137, 1143, 1151, 1155,
  1161, 1171, 1173, 1176, 1178, 1181, 1187, 1195, 1206, 1210,
  1215, 1220, 1228, 1241, 1245, 1252, 1253, 1256, 1258, 1261,
  1263, 1266, 1268, 1271, 1273, 1276, 1278, 1281, 1287, 1297,
  1301, 1325, 1330, 1342, 1347, 1353, 1359, 1369, 1374, 1386,
  1391, 1398, 1402, 1409, 1413, 1420, 1424, 1431, 1435, 1442,
  1446, 1455, 1457, 1460, 1462, 1465, 1467, 1468, 1471, 1477,
  1484, 1491, 1493, 1496, 1503, 1505, 1508, 1518, 1541, 1543,
  1546, 1551, 1564, 1568, 1576, 1578, 1579, 1580, 1581, 1582,
  1583, 1584, 1585, 1586, 1587, 1590, 1594, 1596, 1597, 1598,
  1601, 1606, 1619, 1624, 1636, 1641, 1654, 1670, 1672, 1673,
  1674, 1677, 1682, 1690, 1692, 1695, 1700, 1704, 1710, 1714,
  1722, 1730, 1733, 1738, 1745, 1749, 1756, 1764, 1768, 1772,
  1776, 1780, 1784, 1788, 1792, 1828, 1832, 1842, 1853, 1868,
  1873, 1886, 1888, 1889, 1890, 1895, 1901, 1904, 1909, 1916,
  1924, 1929, 1933, 1937, 1942, 1946, 1950, 1955, 1960, 1964,
  1968, 1972, 1987, 1991, 2008, 2013, 2019, 2026, 2029, 2031,
  2034, 2039, 2051, 2056, 2068, 2075, 2078, 2083, 2090, 2098,
  2100, 2101, 2102, 2103, 2106, 2113, 2120, 2127, 2132, 2138,
  2140, 2143, 2153, 2155, 2158, 2160, 2161, 2162, 2163, 2164,
  2165, 2168, 2170, 2171, 2174, 2176, 2177, 2178, 2179, 2182,
  2184, 2187, 2189, 2190, 2191, 2192, 2195, 2200, 2207, 2211,
  2217, 2221, 2227, 2237, 2242, 2249, 2253, 2259, 2263, 2269,
  2273, 2279, 2289, 2294, 2300, 2304, 2312, 2317, 2323, 2327,
  2335, 2342, 2349, 2354, 2358, 2364, 2366, 2367, 2369, 2374,
  2379, 2383, 2390, 2396, 2404, 2408, 2424, 2433, 2446, 2448,
  2453, 2454, 2457, 2465, 2470, 2482, 2488, 2495, 2497, 2500,
  2505, 2534, 2536, 2539, 2541, 2544, 2549, 2579, 2583, 2585,
  2588, 2593, 2600, 2606, 2612, 2614, 2617, 2619, 2622, 2628,
  2637, 2643, 2652, 2661, 2668, 2674, 2678, 2681, 2683, 2684,
  2687, 2697, 2704, 2719, 2726, 2740, 2750, 2758, 2767
};
static const char * const yytname[] = { "$","error","$illegal.","TK_OPEN",
"TK_CLOSE","TK_OPEN_SQ","TK_CLOSE_SQ","TK_GREATER","TK_GREATEQ","TK_LESS","TK_LESSEQ",
"TK_COLON","TK_HASHT","TK_EQ","TK_HYPHEN","TK_PLUS","TK_MUL","TK_DIV","TK_UMINUS",
"TK_NEW_SYMBOL","TK_OBJ_SYMBOL","TK_TYPE_SYMBOL","TK_PRED_SYMBOL","TK_OBJFUN_SYMBOL",
"TK_FUN_SYMBOL","TK_VAR_SYMBOL","TK_ACTION_SYMBOL","TK_MISC_SYMBOL","TK_KEYWORD",
"TK_NEW_VAR_SYMBOL","TK_PREFERENCE_SYMBOL","TK_SET_SYMBOL","TK_FLOAT","TK_INT",
"TK_STRING","KW_REQS","KW_CONSTANTS","KW_PREDS","KW_FUNS","KW_TYPES","KW_DEFINE",
"KW_DOMAIN","KW_ACTION","KW_PROCESS","KW_EVENT","KW_ARGS","KW_PRE","KW_COND",
"KW_AT_START","KW_AT_END","KW_OVER_ALL","KW_EFFECT","KW_INVARIANT","KW_DURATION",
"KW_AND","KW_OR","KW_EXISTS","KW_FORALL","KW_IMPLY","KW_NOT","KW_WHEN","KW_EITHER",
"KW_PROBLEM","KW_FORDOMAIN","KW_OBJECTS","KW_INIT","KW_GOAL","KW_LENGTH","KW_SERIAL",
"KW_PARALLEL","KW_METRIC","KW_MINIMIZE","KW_MAXIMIZE","KW_DURATION_VAR","KW_TOTAL_TIME",
"KW_INCREASE","KW_DECREASE","KW_SCALE_UP","KW_SCALE_DOWN","KW_ASSIGN","KW_TAG",
"KW_NAME","KW_VARS","KW_SET_CONSTRAINT","KW_SETOF","KW_AT_LEAST_N","KW_AT_MOST_N",
"KW_EXACTLY_N","KW_CONTEXT","KW_FORMULA","KW_IRRELEVANT","KW_PLAN","KW_HEURISTIC",
"KW_OPT","KW_INF","KW_FACT","KW_SET","KW_EXPANSION","KW_TASKS","KW_PREFERENCE",
"KW_VIOLATED","KW_WITHIN","KW_ASSOC","KW_CONSTRAINTS","KW_ALWAYS","KW_SOMETIME",
"KW_AT_MOST_ONCE","KW_SOMETIME_BEFORE","KW_SOMETIME_AFTER","KW_ALWAYS_WITHIN",
"KW_IFF","KW_FALSE","KW_TRUE","KW_NUMBER","KW_UNDEFINED","pddl_declarations",
"pddl_domain","domain_elements","domain_name","any_symbol","action_symbol","domain_requires",
"require_list","domain_predicates","predicate_list","predicate_decl","@1","typed_param_list",
"@2","typed_param_sym_list","non_empty_type_name_list","domain_functions","@3",
"function_list","@4","@5","@6","function_decl_list","function_decl","@7","domain_types",
"@8","typed_type_list","primitive_type_list","domain_constants","typed_constant_list",
"ne_constant_sym_list","domain_structure","action_declaration","@9","action_elements",
"@10","action_set_name","@11","@12","action_condition","empty_action_condition",
"action_condition_list","single_action_condition","timing_keyword","positive_atom_condition",
"@13","@14","negative_atom_condition","@15","@16","flat_atom_argument_list",
"atom_argument_list","flat_atom_argument","functional_atom_argument","@17","atom_argument",
"numeric_condition","relation_keyword","d_expression","d_sum","d_product","d_function",
"d_argument_list","set_condition","@18","@19","@20","@21","@22","@23","@24",
"@25","@26","@27","universal_condition_body","one_or_more_condition_atoms","quantified_condition_atom_list",
"one_or_more_context_atoms","quantified_condition_atom","@28","@29","disjunctive_condition",
"@30","disjunctive_set_condition","@31","@32","existential_condition_body","disjunction_list",
"disjunction_atom","@33","@34","action_effect","action_effect_list","single_action_effect",
"@35","@36","@37","@38","@39","@40","quantified_effect_body","one_or_more_atomic_effects",
"effect_conditions","atomic_effect_list","atomic_effect","positive_atom_effect",
"@41","@42","@43","object_assignment_value","negative_atom_effect","@44","@45",
"numeric_effect","@46","@47","@48","@49","@50","@51","action_duration","action_duration_list",
"action_duration_exp","action_exact_duration","action_min_duration","less_or_lesseq",
"action_max_duration","greater_or_greatereq","action_expansion","@52","task_list",
"task","@53","pddl_problem","problem_name","problem_elements","initial_state",
"init_elements","init_atom","@54","init_object_function","@55","init_function",
"@56","goal_spec","single_goal_spec","goal_spec_list","new_goal","@57","@58",
"new_goal_list","new_single_goal","@59","@60","metric_spec","metric_keyword",
"metric_expression","length_spec","numeric_value","domain_invariant","@61","domain_invariant_body",
"@62","fol_formula","@63","@64","@65","fol_formula_list","irrelevant_item","@66",
"irrelevant_item_content","irrelevant_action","@67","irrelevant_atom","@68",
"problem_invariant","@69","problem_invariant_body","@70","dkel_element_list",
"dkel_tag_spec","dkel_name_spec","dkel_vars_spec","@71","dkel_context_spec",
"req_vars_spec","opt_vars_spec","opt_context_and_precondition_spec","opt_context_spec",
"opt_precondition_spec","context_list","context_atom","positive_context_atom",
"@72","@73","@74","negative_context_atom","@75","@76","@77","@78","positive_context_goal_atom",
"@79","@80","negative_context_goal_atom","@81","@82","type_constraint_atom",
"set_constraint_type","invariant_set","invariant_atom","@83","@84","invariant_set_of_atoms",
"@85","@86","@87","pddl_plan","@88","plan_elements","plan_name","plan_step",
"@89","ipc_plan","ipc_plan_step_list","ipc_plan_step","@90","opt_step_duration",
"ipc_plan_step_seq","simple_plan_step","@91","heuristic_table","table_entry_list",
"table_entry","@92","entry_value","ne_entry_atom_list","entry_atom","pos_entry_atom",
"@93","neg_entry_atom","@94","reference_set","@95","opt_set_name","reference_list",
"reference","@96","simple_reference_set","@97","simple_reference_set_body","@98",
"@99",""
};
static const short yyr1[] = { 0,
   115, 115, 115, 115, 115, 115, 116, 117, 117, 117,
   117, 117, 117, 117, 117, 117, 118, 119, 119, 119,
   119, 119, 119, 119, 119, 119, 120, 120, 121, 122,
   122, 122, 122, 123, 124, 124, 126, 125, 127, 128,
   127, 127, 127, 129, 129, 129, 129, 130, 130, 132,
   131, 134, 133, 135, 133, 136, 133, 133, 133, 137,
   137, 139, 138, 141, 140, 142, 142, 142, 142, 143,
   143, 143, 144, 144, 145, 145, 145, 146, 146, 146,
   146, 147, 147, 147, 149, 148, 151, 150, 150, 150,
   150, 150, 150, 150, 150, 150, 153, 152, 154, 152,
   155, 155, 155, 156, 157, 157, 158, 158, 158, 158,
   158, 158, 159, 159, 159, 161, 160, 160, 162, 160,
   160, 164, 163, 163, 165, 163, 163, 166, 166, 167,
   167, 168, 168, 170, 169, 171, 171, 172, 172, 173,
   173, 173, 173, 173, 174, 174, 174, 174, 174, 174,
   174, 174, 174, 174, 174, 175, 175, 176, 176, 177,
   177, 178, 178, 178, 180, 181, 179, 182, 183, 179,
   184, 179, 185, 186, 179, 187, 188, 179, 189, 179,
   190, 190, 191, 191, 192, 192, 193, 193, 195, 194,
   196, 194, 194, 194, 198, 197, 199, 200, 201, 199,
   202, 202, 202, 203, 203, 205, 204, 204, 206, 204,
   204, 207, 207, 208, 208, 210, 211, 209, 212, 209,
   213, 214, 209, 215, 209, 209, 209, 216, 216, 217,
   217, 218, 218, 219, 219, 220, 220, 222, 221, 223,
   221, 224, 221, 225, 225, 227, 226, 228, 226, 230,
   229, 231, 229, 232, 229, 233, 229, 234, 229, 235,
   229, 236, 236, 237, 237, 238, 238, 238, 239, 239,
   240, 241, 241, 242, 243, 243, 245, 244, 246, 246,
   248, 247, 249, 250, 251, 251, 251, 251, 251, 251,
   251, 251, 251, 251, 251, 252, 253, 253, 253, 253,
   255, 254, 257, 256, 259, 258, 258, 260, 260, 260,
   260, 261, 261, 262, 262, 263, 264, 263, 265, 263,
   266, 266, 268, 267, 269, 267, 267, 267, 267, 267,
   267, 267, 267, 267, 267, 270, 271, 271, 272, 273,
   273, 274, 274, 274, 274, 276, 275, 278, 277, 277,
   279, 279, 280, 279, 279, 279, 279, 279, 279, 279,
   281, 279, 282, 279, 283, 283, 285, 284, 286, 286,
   288, 287, 290, 289, 292, 291, 294, 293, 293, 295,
   295, 295, 295, 295, 296, 297, 297, 299, 298, 300,
   300, 301, 302, 302, 303, 303, 303, 303, 303, 303,
   303, 304, 304, 304, 305, 305, 305, 305, 305, 306,
   306, 307, 307, 307, 307, 307, 309, 308, 310, 308,
   311, 308, 308, 313, 312, 314, 312, 315, 312, 316,
   312, 312, 318, 317, 319, 317, 321, 320, 322, 320,
   323, 323, 324, 324, 324, 325, 325, 325, 327, 326,
   328, 326, 330, 331, 332, 329, 334, 333, 335, 335,
   335, 335, 336, 338, 337, 339, 339, 340, 340, 342,
   341, 343, 343, 344, 344, 346, 345, 347, 348, 348,
   350, 349, 351, 351, 352, 352, 353, 353, 355, 354,
   357, 356, 359, 358, 360, 360, 360, 361, 361, 361,
   363, 362, 362, 365, 364, 367, 366, 368, 366
};
static const short yyr2[] = { 0,
     2, 2, 2, 2, 2, 0, 5, 2, 2, 2,
     2, 2, 2, 2, 2, 0, 4, 1, 1, 1,
     1, 1, 1, 1, 1, 1, 1, 1, 4, 2,
     2, 2, 0, 4, 2, 1, 0, 5, 4, 0,
     8, 2, 0, 2, 2, 1, 1, 2, 1, 0,
     5, 0, 5, 0, 5, 0, 8, 1, 0, 2,
     1, 0, 5, 0, 5, 4, 4, 2, 0, 2,
     2, 0, 4, 4, 4, 2, 0, 2, 1, 2,
     1, 1, 1, 1, 0, 6, 0, 6, 3, 3,
     3, 3, 3, 2, 3, 0, 0, 5, 0, 5,
     1, 1, 4, 2, 2, 1, 1, 1, 1, 1,
     1, 1, 1, 1, 1, 0, 5, 5, 0, 8,
     8, 0, 8, 8, 0, 11, 11, 2, 0, 2,
     0, 1, 1, 0, 5, 1, 1, 5, 8, 1,
     1, 1, 1, 1, 4, 5, 5, 5, 5, 3,
     1, 1, 3, 4, 1, 1, 2, 1, 2, 4,
     1, 2, 2, 0, 0, 0, 11, 0, 0, 9,
     0, 6, 0, 0, 14, 0, 0, 12, 0, 9,
     5, 1, 4, 1, 2, 1, 4, 1, 0, 5,
     0, 8, 5, 8, 0, 5, 0, 0, 0, 9,
     8, 4, 1, 2, 1, 0, 5, 5, 0, 8,
     8, 1, 4, 2, 1, 0, 0, 9, 0, 6,
     0, 0, 12, 0, 8, 1, 1, 5, 1, 4,
     1, 1, 4, 2, 1, 1, 1, 0, 5, 0,
     9, 0, 8, 1, 1, 0, 8, 0, 11, 0,
     9, 0, 9, 0, 9, 0, 12, 0, 12, 0,
    12, 1, 4, 1, 2, 1, 1, 1, 5, 1,
     5, 1, 1, 5, 1, 1, 0, 10, 2, 0,
     0, 5, 5, 4, 5, 2, 2, 2, 2, 2,
     2, 2, 2, 2, 0, 4, 2, 2, 2, 0,
     0, 5, 0, 9, 0, 9, 5, 4, 7, 4,
     7, 1, 5, 2, 0, 1, 0, 5, 0, 5,
     2, 0, 0, 5, 0, 8, 5, 1, 4, 4,
     4, 5, 5, 5, 6, 5, 1, 1, 1, 5,
     5, 1, 3, 1, 1, 0, 5, 0, 8, 3,
     1, 1, 0, 5, 5, 4, 4, 4, 5, 5,
     0, 8, 0, 8, 2, 1, 0, 5, 1, 1,
     0, 7, 0, 7, 0, 5, 0, 8, 3, 2,
     2, 2, 2, 0, 2, 2, 2, 0, 5, 2,
     5, 4, 1, 0, 3, 6, 3, 6, 3, 6,
     0, 2, 5, 0, 2, 5, 2, 5, 0, 2,
     1, 1, 1, 1, 1, 1, 0, 5, 0, 8,
     0, 8, 5, 0, 8, 0, 11, 0, 11, 0,
    11, 8, 0, 8, 0, 11, 0, 11, 0, 14,
     4, 4, 1, 1, 1, 2, 2, 0, 0, 5,
     0, 8, 0, 0, 0, 15, 0, 5, 2, 2,
     2, 0, 2, 0, 7, 1, 1, 2, 1, 0,
     8, 3, 0, 2, 1, 0, 5, 4, 2, 0,
     0, 5, 2, 1, 2, 1, 1, 1, 0, 5,
     0, 8, 0, 8, 2, 2, 0, 2, 2, 0,
     0, 5, 1, 0, 7, 0, 5, 0, 8
};
static const short yydefact[] = { 6,
     0, 0, 344, 342, 345, 1, 2, 0, 3, 4,
   466, 469, 467, 475, 5, 476, 0, 457, 480, 0,
     0, 468, 0, 474, 131, 0, 16, 295, 462, 0,
   343, 0, 0, 0, 0, 0, 0, 16, 16, 16,
    16, 16, 16, 82, 16, 83, 84, 16, 0, 0,
   462, 0, 0, 462, 462, 481, 478, 479, 470, 0,
   477, 133, 132, 136, 137, 130, 18, 19, 20, 21,
    22, 23, 24, 25, 26, 0, 0, 33, 77, 0,
    50, 64, 0, 346, 77, 0, 367, 493, 0, 7,
     8, 11, 12, 9, 10, 13, 15, 14, 0, 283,
   286, 287, 288, 289, 290, 291, 293, 292, 294, 463,
   460, 0, 458, 459, 461, 0, 131, 134, 17, 284,
     0, 0, 0, 0, 36, 59, 69, 27, 28, 85,
   384, 0, 0, 328, 0, 312, 384, 497, 0, 0,
   375, 0, 300, 0, 0, 0, 0, 0, 486, 487,
   488, 0, 131, 29, 32, 30, 31, 73, 79, 81,
    76, 37, 34, 35, 0, 0, 58, 61, 72, 96,
     0, 74, 140, 141, 142, 143, 144, 323, 113, 114,
   115, 315, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 308, 0, 0, 394, 315, 310, 384,
     0, 0, 0, 0, 337, 338, 0, 464, 489, 0,
     0, 485, 473, 0, 0, 78, 80, 43, 62, 51,
     0, 60, 65, 68, 0, 0, 0, 0, 348, 0,
     0, 347, 380, 381, 382, 383, 0, 131, 0, 315,
     0, 0, 0, 0, 0, 0, 316, 0, 0, 0,
     0, 0, 0, 0, 161, 152, 151, 0, 155, 0,
     0, 368, 369, 370, 495, 496, 0, 393, 404, 0,
     0, 285, 0, 296, 299, 298, 297, 0, 0, 339,
     0, 131, 131, 0, 0, 484, 482, 0, 471, 135,
    75, 0, 43, 0, 54, 52, 0, 71, 70, 0,
    86, 0, 197, 197, 0, 0, 0, 0, 94, 385,
   386, 387, 388, 0, 0, 390, 412, 413, 414, 415,
   416, 0, 351, 352, 0, 0, 0, 314, 0, 325,
     0, 0, 317, 319, 329, 330, 331, 0, 0, 0,
   144, 0, 0, 0, 0, 0, 164, 0, 0, 0,
     0, 0, 0, 43, 0, 500, 0, 377, 0, 376,
     0, 301, 340, 341, 336, 0, 0, 491, 483, 0,
    38, 47, 46, 42, 0, 0, 59, 59, 67, 66,
   277, 87, 0, 91, 101, 102, 107, 108, 112, 109,
   110, 111, 92, 0, 90, 212, 226, 236, 237, 227,
     0, 270, 93, 262, 266, 267, 268, 0, 89, 95,
    43, 0, 0, 0, 417, 0, 0, 0, 0, 0,
     0, 353, 0, 0, 0, 0, 0, 0, 0, 350,
   327, 324, 309, 131, 313, 334, 322, 322, 332, 333,
     0, 0, 0, 0, 0, 0, 164, 164, 0, 153,
     0, 150, 138, 371, 373, 0, 0, 402, 0, 311,
     0, 0, 0, 0, 131, 465, 490, 131, 472, 0,
    45, 44, 63, 49, 0, 55, 53, 394, 43, 104,
   144, 116, 197, 195, 0, 0, 171, 0, 165, 0,
   238, 0, 0, 0, 219, 0, 0, 0, 0, 275,
   276, 272, 273, 0, 0, 0, 0, 97, 99, 0,
   443, 444, 445, 0, 0, 0, 0, 131, 0, 0,
   411, 0, 0, 0, 0, 0, 129, 366, 0, 0,
   363, 361, 0, 0, 0, 0, 0, 0, 322, 0,
   335, 0, 145, 0, 156, 0, 158, 0, 0, 163,
   162, 160, 154, 131, 131, 392, 0, 0, 494, 503,
   499, 498, 0, 379, 303, 305, 0, 0, 0, 0,
    39, 56, 48, 401, 0, 0, 131, 0, 0, 106,
     0, 198, 168, 0, 0, 0, 0, 131, 0, 0,
   215, 216, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 264, 0, 0, 129, 129, 389, 448, 0, 441,
   442, 0, 391, 410, 0, 424, 0, 0, 421, 0,
   433, 0, 419, 0, 0, 0, 357, 365, 358, 43,
    43, 0, 356, 0, 0, 318, 321, 320, 0, 147,
   157, 146, 159, 148, 149, 0, 0, 0, 504, 501,
     0, 131, 131, 307, 302, 0, 40, 59, 0, 0,
     0, 0, 88, 0, 0, 103, 105, 0, 0, 205,
    43, 43, 0, 0, 188, 0, 122, 404, 144, 119,
     0, 179, 0, 173, 0, 213, 214, 43, 246, 0,
     0, 232, 250, 252, 240, 254, 242, 0, 0, 224,
     0, 0, 0, 0, 263, 265, 0, 0, 0, 0,
     0, 423, 418, 0, 131, 0, 0, 131, 0, 131,
     0, 131, 0, 355, 354, 128, 0, 0, 359, 360,
   326, 139, 0, 0, 403, 0, 131, 448, 0, 0,
   492, 0, 57, 0, 404, 0, 404, 0, 409, 0,
   118, 117, 0, 206, 0, 196, 204, 0, 0, 0,
     0, 0, 184, 0, 131, 0, 0, 131, 176, 0,
     0, 0, 239, 0, 131, 0, 0, 0, 231, 131,
   131, 131, 131, 131, 221, 0, 0, 0, 0, 0,
   269, 271, 274, 98, 100, 0, 0, 446, 447, 0,
     0, 430, 437, 0, 0, 428, 0, 435, 0, 426,
     0, 0, 372, 374, 404, 0, 0, 0, 0, 0,
     0, 397, 0, 399, 0, 0, 0, 395, 280, 0,
   131, 0, 199, 169, 0, 0, 189, 0, 0, 172,
     0, 0, 0, 0, 0, 43, 0, 0, 125, 404,
   217, 0, 0, 0, 0, 0, 220, 0, 0, 0,
     0, 0, 43, 248, 0, 256, 258, 260, 449, 0,
     0, 349, 0, 0, 131, 131, 0, 0, 131, 0,
   131, 0, 131, 0, 0, 0, 502, 0, 0, 0,
    41, 0, 0, 0, 0, 405, 0, 407, 0, 0,
   280, 0, 0, 0, 209, 0, 0, 187, 0, 131,
     0, 0, 186, 0, 0, 0, 166, 0, 0, 0,
     0, 0, 131, 0, 0, 0, 233, 0, 0, 235,
     0, 0, 0, 0, 0, 0, 0, 0, 131, 0,
   131, 131, 131, 131, 0, 0, 432, 425, 0, 0,
   439, 422, 0, 434, 0, 420, 0, 364, 362, 0,
     0, 378, 304, 306, 404, 404, 409, 0, 0, 281,
     0, 279, 208, 207, 0, 131, 0, 0, 203, 0,
     0, 182, 0, 0, 183, 185, 0, 191, 124, 123,
   131, 121, 120, 177, 0, 0, 0, 0, 0, 0,
   229, 247, 230, 234, 0, 0, 245, 244, 0, 0,
   243, 222, 0, 225, 0, 0, 0, 0, 451, 453,
     0, 0, 131, 0, 0, 0, 0, 506, 505, 398,
   400, 396, 0, 0, 131, 278, 0, 0, 0, 0,
   200, 0, 170, 193, 190, 0, 131, 0, 0, 180,
     0, 0, 174, 0, 218, 251, 253, 241, 255, 0,
     0, 0, 0, 0, 450, 131, 43, 0, 0, 0,
     0, 0, 0, 0, 131, 406, 408, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 131,
     0, 0, 0, 0, 0, 0, 0, 0, 431, 438,
     0, 429, 436, 427, 508, 0, 282, 211, 210, 0,
   202, 0, 0, 0, 167, 0, 127, 126, 0, 0,
     0, 249, 0, 0, 0, 0, 454, 0, 131, 507,
     0, 181, 194, 192, 178, 0, 228, 223, 257, 259,
   261, 452, 404, 0, 0, 0, 0, 0, 440, 0,
     0, 175, 0, 509, 201, 455, 131, 0, 0, 456,
     0, 0
};
static const short yydefgoto[] = { 1,
     6, 37, 27, 76, 130, 38, 121, 39, 124, 125,
   218, 292, 742, 374, 475, 40, 126, 166, 378, 377,
   658, 167, 168, 293, 41, 127, 169, 224, 42, 122,
   161, 43, 44, 170, 225, 479, 409, 605, 606, 384,
   385, 579, 386, 420, 387, 577, 768, 388, 765, 923,
   626, 33, 64, 65, 153, 66, 134, 193, 402, 546,
   548, 259, 449, 390, 586, 991, 672, 907, 584, 772,
  1090, 846, 1049, 770, 981, 982, 912, 674, 763, 910,
  1047, 391, 581, 392, 671, 906, 978, 669, 670, 831,
   976, 395, 590, 591, 688, 925, 594, 863, 1060, 787,
  1000, 1001, 691, 929, 779, 398, 588, 782, 784, 1009,
   399, 775, 939, 400, 780, 781, 783, 941, 942, 943,
   403, 601, 602, 405, 406, 506, 407, 507, 309, 478,
   900, 901, 1035, 7, 28, 49, 103, 202, 275, 465,
   276, 652, 277, 653, 45, 240, 241, 246, 437, 438,
   538, 247, 238, 434, 105, 207, 281, 106, 52, 46,
   131, 232, 314, 528, 527, 631, 630, 529, 47, 137,
   262, 263, 554, 264, 555, 108, 200, 360, 461, 171,
   233, 234, 235, 411, 236, 268, 269, 662, 356, 828,
   520, 521, 317, 518, 722, 718, 318, 715, 883, 879,
   875, 319, 720, 881, 320, 876, 1023, 321, 514, 711,
   798, 944, 1066, 799, 1067, 1143, 1157, 9, 29, 53,
    54, 55, 282, 10, 11, 12, 117, 289, 13, 14,
    25, 15, 30, 58, 116, 287, 148, 149, 150, 283,
   151, 468, 48, 138, 197, 459, 561, 737, 562, 736,
   961, 1075, 1129
};
static const short yypact[] = {-32768,
    42, 20,-32768, 144,-32768,-32768,-32768, 160,-32768,-32768,
-32768, 29,-32768, 238,-32768,-32768, 264,-32768,-32768, 153,
   284,-32768, 263,-32768,-32768, 155, 340,-32768, 52, 241,
-32768, 300, 506, 1311, 1311, 276, 367, 340, 340, 340,
   340, 340, 340,-32768, 340,-32768,-32768, 340, 469, 1311,
    52, 370, 381, 52, 52,-32768,-32768,-32768,-32768, 382,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768, 421, 423,-32768,-32768, 432,
-32768,-32768, 318,-32768,-32768, 439,-32768,-32768, 442,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768, 634,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768, 484,-32768,-32768,-32768, 517,-32768,-32768,-32768,-32768,
    59, 348, 437, 520, 432, 529,-32768,-32768,-32768,-32768,
-32768, 475, 226,-32768, 542,-32768,-32768, 457, 534, 545,
-32768, 1311,-32768, 505, 585, 527, 49, 656,-32768,-32768,
-32768, 611,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
   709,-32768,-32768,-32768, 539, 588, 599, 529, 619,-32768,
   536,-32768,-32768,-32768,-32768,-32768, 194,-32768,-32768,-32768,
-32768, 623, 629, 615, 29, 646, 646, 646, 646, 646,
    29, 649, 64,-32768, 307, 228, 600, 623,-32768,-32768,
   664, 681, 654, 657,-32768,-32768, 64,-32768,-32768, 689,
   115,-32768, 698, 658, 691,-32768,-32768,-32768,-32768,-32768,
    27,-32768,-32768, 302, 122, 1311, 246, 722,-32768, 728,
    44,-32768,-32768,-32768,-32768,-32768, 194,-32768, 384, 623,
   732, 721, 646, 646, 667, 749,-32768, 751, 753, 646,
   646, 646, 637, 164,-32768,-32768,-32768, 407,-32768, 764,
   774,-32768,-32768,-32768,-32768,-32768, 782,-32768, 706, 800,
   727,-32768, 60,-32768,-32768,-32768,-32768, 817, 827, 806,
   830,-32768,-32768, 821, 29,-32768,-32768, 29,-32768,-32768,
-32768, 277,-32768, 778,-32768,-32768, 242,-32768,-32768, 761,
-32768, 852, 874, 874, 879, 167, 901, 881,-32768,-32768,
-32768,-32768,-32768, 910, 819,-32768,-32768,-32768,-32768,-32768,
-32768, 172,-32768,-32768, 916, 922, 668,-32768, 932,-32768,
   946, 949,-32768,-32768,-32768,-32768,-32768, 957, 958, 646,
-32768, 64, 64, 64, 64, 64, 357, 960, 936, 64,
    72, 939, 947,-32768, 972,-32768, 974,-32768, 44,-32768,
    67,-32768,-32768,-32768,-32768, 707, 736,-32768,-32768, 976,
-32768,-32768,-32768, 453, 325, 969, 529, 529,-32768,-32768,
-32768,-32768, 853,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768, 738,-32768,-32768,-32768,-32768,-32768,-32768,
   491, 806,-32768,-32768,-32768,-32768,-32768, 145,-32768,-32768,
-32768, 648, 194, 47,-32768, 988, 992, 993, 996, 1013,
   450,-32768, 44, 44, 1014, 1016, 44, 44, 44,-32768,
-32768,-32768,-32768,-32768,-32768,-32768, 1017, 1017,-32768,-32768,
   975, 407, 366, 407, 407, 407, 357, 357, 1019,-32768,
  1022,-32768,-32768,-32768,-32768, 332, 935,-32768, 1150,-32768,
  1025, 1028, 696, 29,-32768,-32768,-32768,-32768,-32768, 96,
-32768,-32768,-32768,-32768, 37,-32768,-32768, 600,-32768,-32768,
   194,-32768, 1030,-32768, 1031, 1032,-32768, 1041,-32768, 1042,
-32768, 1046, 1049, 1050,-32768, 1056, 1057, 1061, 1069,-32768,
-32768,-32768,-32768, 998, 397, 1003, 1007,-32768,-32768, 335,
-32768,-32768,-32768, 1052, 194, 1082, 1087,-32768, 1090, 742,
-32768, 150, 68, 85, 161, 450,-32768,-32768, 30, 48,
-32768,-32768, 44, 1095, 44, 776, 741, 1096, 1017, 1097,
-32768, 273,-32768, 303, 407, 1100, 407, 1101, 361,-32768,
-32768,-32768,-32768,-32768,-32768,-32768, 988, 427,-32768,-32768,
-32768,-32768, 648,-32768,-32768,-32768, 1102, 808, 861, 1047,
-32768,-32768,-32768, 18, 355, 194,-32768, 883, 766,-32768,
  1072,-32768,-32768, 1106, 271, 600, 46,-32768, 895, 1111,
  1046,-32768, 1088, 1120, 1107, 1108, 758, 183, 64, 553,
  1131, 397, 64, 64,-32768,-32768,-32768,-32768, 1139,-32768,
-32768, 894,-32768,-32768, 194,-32768, 1141, 1144,-32768, 1145,
-32768, 1148,-32768, 1149, 1157, 493,-32768,-32768,-32768,-32768,
-32768, 1169,-32768, 1182, 1183,-32768,-32768,-32768, 1185,-32768,
-32768,-32768,-32768,-32768,-32768, 896, 943, 780,-32768,-32768,
  1109,-32768,-32768,-32768,-32768, 1190,-32768, 529, 1193, 1196,
  1199, 1110,-32768, 1209, 973,-32768,-32768, 244, 1211, 1072,
-32768,-32768, 938, 1217,-32768, 194,-32768, 706, 194,-32768,
  1231,-32768, 1248,-32768, 1002,-32768,-32768,-32768,-32768, 959,
  1269,-32768,-32768,-32768,-32768,-32768,-32768, 1286, 1307,-32768,
  1315, 1316, 1321, 405,-32768,-32768, 419, 424, 577, 586,
   799,-32768,-32768, 194,-32768, 1305, 190,-32768, 1317,-32768,
  1318,-32768, 1326,-32768,-32768,-32768, 440, 455,-32768,-32768,
-32768,-32768, 1346, 1347,-32768, 600,-32768,-32768, 1011, 1043,
-32768, 969,-32768, 989, 706, 1008, 706, 1029, 773, 1322,
-32768,-32768, 194,-32768, 1350,-32768,-32768, 492, 508, 988,
    56, 1351,-32768, 194,-32768, 1353, 194,-32768,-32768, 1106,
   395, 600,-32768, 523,-32768, 988, 659, 1354,-32768,-32768,
-32768,-32768,-32768,-32768,-32768, 1332, 1120, 1333, 1335, 1336,
-32768,-32768,-32768,-32768,-32768, 55, 1357,-32768,-32768, 1358,
  1062,-32768,-32768, 1360, 1121,-32768, 1125,-32768, 1163,-32768,
    44, 44,-32768,-32768, 706, 1175, 834, 1344, 29, 185,
   988,-32768, 988,-32768, 988, 1362, 1363,-32768, 1364, 194,
-32768, 501,-32768,-32768, 848, 194,-32768, 1365, 1366,-32768,
  1367, 1178, 1348, 1368, 1181,-32768, 1217, 194,-32768, 706,
-32768, 1187, 850, 1370, 1371, 1372,-32768, 1189, 1201, 1207,
  1213, 1215,-32768,-32768, 1269,-32768,-32768,-32768,-32768, 1373,
  1296,-32768, 1375, 1376,-32768,-32768, 1355, 1377,-32768, 1378,
-32768, 1379,-32768, 1380, 1381, 1383,-32768, 1384, 1385, 1386,
-32768, 876, 884, 891, 1048,-32768, 1068,-32768, 1361, 1387,
  1364, 1388, 1219, 194,-32768, 1390, 1391,-32768, 194,-32768,
   279, 1392, 1365, 572, 1393, 1394,-32768, 1395, 1396, 546,
  1397, 194,-32768, 1399, 1400, 1401,-32768, 297, 1402, 1370,
  1389, 210, 64, 64, 24, 64, 1403, 551,-32768, 1404,
-32768,-32768,-32768,-32768, 1382, 1406,-32768,-32768, 1221, 1225,
-32768,-32768, 1227,-32768, 1233,-32768, 1239,-32768,-32768, 1138,
  1407,-32768,-32768,-32768, 706, 706, 773, 988, 988,-32768,
  1409,-32768,-32768,-32768, 194,-32768, 224, 1410,-32768, 70,
  1411,-32768, 1412, 1245,-32768,-32768, 194,-32768,-32768,-32768,
-32768,-32768,-32768,-32768, 1413, 1414, 1251, 1398, 480, 1415,
-32768,-32768,-32768,-32768, 464, 499,-32768,-32768, 1417, 547,
-32768,-32768, 1253,-32768, 1257, 1259, 1263, 1265,-32768,-32768,
  1418, 1419,-32768, 1420, 1421, 1422, 1424,-32768,-32768,-32768,
-32768,-32768, 919, 921,-32768,-32768, 1425, 1271, 988, 1072,
-32768, 1106,-32768,-32768,-32768, 194,-32768, 1277, 1391,-32768,
  1426, 1427,-32768, 1120,-32768,-32768,-32768,-32768,-32768, 1400,
  1428, 64, 64, 64,-32768,-32768,-32768, 1429, 1430, 1283,
  1431, 1432, 1433, 1311,-32768,-32768,-32768, 1289, 1434, 1435,
  1437, 1438, 1217, 1439, 1291, 1440, 1441, 1442, 1443,-32768,
  1269, 1444, 1445, 595, 604, 605, 1295, 575,-32768,-32768,
  1446,-32768,-32768,-32768,-32768, 1297,-32768,-32768,-32768, 1071,
-32768, 1447, 1448, 1449,-32768, 1450,-32768,-32768, 1301, 1451,
  1452,-32768, 1453, 1454, 1455, 1456,-32768, 1457,-32768,-32768,
  1072,-32768,-32768,-32768,-32768, 1458,-32768,-32768,-32768,-32768,
-32768,-32768, 706, 1459, 1303, 1460, 1461, 1463,-32768, 1464,
  1465,-32768, 1462,-32768,-32768,-32768,-32768, 1309, 1466,-32768,
  1467,-32768
};
static const short yypgoto[] = {-32768,
-32768, 1304,-32768, -33,-32768, 1423,-32768,-32768, 1270,-32768,
-32768, -268,-32768,-32768, 686,-32768,-32768, -349,-32768,-32768,
-32768, 1242,-32768,-32768,-32768,-32768,-32768,-32768, 1436, 1356,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768, 1167,
-32768,-32768, -448, -123,-32768,-32768,-32768,-32768,-32768,-32768,
   323, -117, -413, 1059,-32768, -157, -285, -246, -192, 929,
   928,-32768, 487,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768, 428, -665, 563, -756, -795,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768, -667, 573,-32768,
-32768,-32768, 887, 1176,-32768,-32768,-32768,-32768,-32768,-32768,
   420, -678, -766, 552, -300,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768, 885, 1177,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
   587,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768, 1468, 136, -103, -150,-32768,-32768,
  -407, -63,-32768,-32768,-32768,-32768,-32768,-32768, 10,-32768,
-32768,-32768,-32768, -225,-32768,-32768,-32768, 1065, 1469,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768, -80,
-32768,-32768,-32768,-32768,-32768, -562, 1012,-32768, -666, 519,
  -553, -198,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768, 930, 754,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768, 651,
-32768,-32768,-32768,-32768, 1479,-32768,-32768,-32768, 1480,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768, 1349,-32768,-32768,
-32768,-32768, 1470,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768
};
static const short yytable[] = { 152,
   258, 77, 757, 648, 397, 325, 342, 526, 762, 192,
     8, 766, 778, 847, 280, 192, 110, 389, 389, 237,
   865, 8, 136, 678, 375, 136, 60, 476, 477, 294,
   540, 316, 322, 627, 580, 214, 248, 249, 250, 251,
   572, 1161, 913, 62, 2, 16, 322, 295, 63, 60,
   322, 629, 173, 174, 175, 176, 195, 573, 679, 17,
     3, 4, 154, 659, 660, 351, 254, 680, 836, 463,
   209, 516, 361, 3, 4, 453, 869, 837, 822, 326,
   824, 362, 836, 3, 4, 456, 155, 255, 350, 619,
   464, 837, 331, 332, 270, 256, 257, 156, 570, 338,
   339, 340, 681, 682, 683, 661, 621, 210, 201, 838,
    18, 19, 625, 870, 839, 192, 571, 913, 136, 271,
   327, 192, 5, 838, 300, 301, 620, 1042, 839, 684,
   667, 637, 50, 462, 136, 5, 328, 1007, 871, 296,
   323, 324, 510, 622, 51, 5, 3, 4, 886, 442,
   443, 444, 445, 446, 323, 324, 458, 452, 323, 324,
    20, 157, 615, 508, 366, 367, 302, 303, 304, 401,
    21, 616, 305, 815, 306, 509, 136, 343, 344, 345,
   346, 921, 623, 924, 421, 31, 940, 347, 891, 441,
   255, 397, 310, 422, 244, 34, 60, 389, 256, 257,
   252, 533, 534, 535, 697, 573, 835, 285, 5, 850,
   575, 803, 726, 62, 617, 618, 35, 307, 63, 624,
   286, 135, 853, 308, 140, 423, 424, 425, 426, 427,
   428, 697, 173, 174, 175, 176, 753, 348, 177, 698,
    23, 699, 700, 56, 57, 754, 265, 178, 804, 542,
   544, 545, 547, 549, 266, 515, 753, 701, 702, 490,
   379, 703, 380, 349, 311, 754, 26, 892, 699, 893,
   499, 894, 312, 179, 180, 181, 639, 1039, 1040, 182,
   371, 429, 755, 676, 183, 1083, 32, 1091, 16, 350,
   397, 836, 677, 389, 369, 726, 726, 370, 1030, 1031,
   837, 372, 755, 628, 628, 373, 640, 632, 743, 634,
    78, 79, 80, 81, 82, 297, 536, 83, 491, 350,
   298, 614, 299, 576, 184, 59, 185, 84, 473, 186,
   187, 188, 189, 190, 191, 556, 128, 839, 607, 85,
   342, 86, 36, 129, 179, 180, 181, 568, 260, 372,
   569, 158, 545, 373, 547, 494, 372, 609, 663, 372,
   373, 727, 728, 373, 645, 87, 159, 160, 254, 543,
    90, 88, 1082, 539, 539, 855, 447, 350, 89, 372,
   112, 448, 350, 373, 113, 675, 226, 227, 228, 255,
   173, 174, 175, 176, 230, 692, 177, 256, 257, 600,
   612, 261, 758, 759, 118, 178, 704, 848, 791, 254,
   707, 708, 1120, 192, 1033, 1034, 849, 1112, 664, 774,
   255, 350, 792, 350, 119, 560, 120, 793, 256, 257,
   255, 179, 180, 181, 123, 350, 646, 647, 256, 257,
   350, 133, 183, 811, 139, 67, 68, 69, 70, 614,
    71, 72, 73, 74, 490, 162, 75, 714, 812, 665,
   745, 747, 749, 1146, 372, 499, 470, 1056, 373, 62,
   685, 99, 100, 567, 63, 539, 1148, 471, 172, 372,
   350, 472, 184, 373, 185, 1081, 146, 186, 187, 188,
   189, 190, 191, 159, 160, 833, 725, 500, 501, 502,
   503, 491, 1057, 504, 343, 344, 345, 346, 60, 61,
   649, 834, 62, 904, 347, 350, 372, 63, 764, 147,
   373, 767, 905, 163, 650, 62, 851, 179, 180, 181,
    63, 165, 372, 854, 739, 740, 373, 196, 494, 1054,
   173, 174, 175, 176, 505, 194, 177, 372, 199, 994,
  1059, 373, 208, 930, 1012, 178, 800, 219, 855, 500,
   501, 502, 503, 350, 348, 504, 343, 344, 345, 346,
   372, 675, 203, 204, 373, 372, 347, 920, 1127, 373,
   794, 179, 180, 181, 987, 884, 885, 198, 692, 795,
   349, 220, 183, 988, 938, 830, 62, 801, 1123, 372,
   805, 63, 807, 373, 809, 62, 841, 1124, 1125, 844,
    63, 350, 221, 60, 213, 226, 227, 228, 229, 816,
   350, 350, 223, 230, 231, 239, 348, 896, 898, 930,
    62, 242, 184, 243, 185, 63, 614, 186, 187, 188,
   189, 190, 191, 173, 174, 175, 176, 842, 245, 341,
   845, 253, 349, 856, 614, 205, 206, 852, 147, 211,
    60, 290, 858, 859, 860, 861, 862, 272, 78, 79,
    60, 432, 902, 173, 174, 175, 176, 62, 909, 177,
   491, 267, 63, 273, 274, 141, 278, 62, 178, 279,
   922, 284, 63, 614, 614, 614, 142, 85, 143, 86,
   144, 111, 288, 145, 114, 115, 179, 180, 181, 60,
   466, 291, 854, 903, 179, 180, 181, 494, 565, 566,
   333, 334, 215, 87, 313, 183, 62, 216, 217, 88,
   315, 63, 511, 512, 513, 329, 89, 855, 60, 467,
  1005, 1006, 330, 1010, 519, 613, 975, 173, 174, 175,
   176, 983, 335, 177, 336, 62, 337, 949, 950, 491,
    63, 953, 178, 955, 996, 957, 352, 185, 578, 666,
   186, 187, 188, 189, 190, 191, 353, 1008, 60, 635,
   695, 696, 519, 735, 354, 179, 180, 181, 179, 180,
   181, 492, 984, 355, 493, 62, 494, 495, 1098, 183,
    63, 796, 797, 357, 856, 997, 226, 227, 228, 358,
    60, 655, 496, 497, 230, 359, 498, 1037, 826, 827,
   363, 1013, 350, 1015, 1016, 1017, 1018, 62, 890, 1046,
   364, 413, 63, 365, 614, 614, 796, 888, 376, 414,
   415, 185, 368, 675, 186, 187, 188, 189, 190, 191,
   519, 908, 519, 927, 382, 692, 480, 381, 1038, 173,
   174, 175, 176, 60, 656, 481, 179, 180, 181, 1094,
  1095, 1096, 416, 1048, 482, 856, 383, 417, 519, 965,
    62, 394, 614, 418, 419, 63, 519, 966, 1084, 173,
   174, 175, 176, 519, 967, 481, 60, 713, 60, 733,
   179, 180, 181, 408, 482, 1070, 483, 484, 485, 486,
   487, 488, 412, 62, 410, 62, 491, 1078, 63, 430,
    63, 519, 1076, 519, 1077, 431, 1028, 709, 710, 1085,
   179, 180, 181, 550, 551, 433, 489, 484, 485, 486,
   487, 488, 179, 180, 181, 60, 734, 413, 1097, 435,
   413, 493, 436, 494, 495, 414, 415, 1106, 414, 415,
   439, 440, 62, 450, 454, 451, 489, 63, 455, 496,
   497, 413, 1119, 498, 457, 60, 752, 460, 541, 414,
   415, 469, 179, 180, 181, 179, 180, 181, 557, 474,
   519, 760, 62, 417, 522, 523, 417, 63, 524, 418,
   419, 413, 418, 419, 60, 773, 179, 180, 181, 414,
   415, 1145, 776, 60, 818, 525, 531, 417, 532, 537,
   413, 62, 552, 418, 419, 553, 63, 563, 414, 415,
    62, 564, 578, 582, 583, 63, 179, 180, 181, 1158,
  1105, 413, 821, 585, 587, 60, 819, 417, 589, 414,
   415, 592, 593, 418, 419, 179, 180, 181, 595, 596,
   413, 823, 62, 597, 60, 874, 417, 63, 414, 415,
   599, 598, 418, 419, 668, 603, 179, 180, 181, 604,
   413, 62, 825, 413, 608, 610, 63, 417, 414, 415,
   611, 414, 415, 418, 419, 179, 180, 181, 633, 636,
   638, 968, 413, 642, 644, 654, 417, 657, 673, 689,
   414, 415, 418, 419, 686, 179, 180, 181, 179, 180,
   181, 969, 690, 60, 878, 1131, 417, 60, 880, 417,
   693, 694, 418, 419, 705, 418, 419, 179, 180, 181,
    62, 738, 712, 716, 62, 63, 717, 719, 417, 63,
   721, 723, 558, 559, 418, 419, 67, 68, 69, 70,
   724, 71, 72, 73, 74, 60, 882, 75, 67, 68,
    69, 70, 729, 71, 72, 73, 74, 60, 887, 75,
    60, 916, 62, 60, 919, 730, 731, 63, 732, 60,
   926, 60, 933, 741, 62, 744, 1027, 62, 746, 63,
    62, 748, 63, 60, 934, 63, 62, 750, 62, 60,
   935, 63, 751, 63, 756, 60, 936, 60, 937, 761,
    62, 60, 974, 60, 1021, 63, 62, 60, 1022, 60,
  1024, 63, 62, 769, 62, 60, 1025, 63, 62, 63,
    62, 60, 1026, 63, 62, 63, 62, 60, 1045, 63,
   771, 63, 62, 60, 1052, 60, 1061, 63, 62, 60,
  1062, 60, 1063, 63, 62, 60, 1064, 60, 1065, 63,
    62, 777, 62, 60, 1080, 63, 62, 63, 62, 60,
  1086, 63, 62, 63, 62, 60, 1101, 63, 785, 63,
    62, 60, 1107, 60, 1114, 63, 62, 60, 1126, 60,
  1130, 63, 62, 60, 1136, 60, 1150, 63, 62, 786,
    62, 60, 1159, 63, 62, 63, 62, 788, 789, 63,
    62, 63, 62, 790, 829, 63, 802, 63, 62, 67,
    68, 69, 70, 63, 71, 72, 73, 74, 806, 808,
    75, 91, 92, 93, 94, 95, 96, 810, 97, 813,
   814, 98, 832, 864, 840, 843, 866, 857, 867, 868,
   872, 873, 877, 889, 895, 897, 899, 911, 914, 917,
   915, 918, 928, 931, 932, 945, 951, 946, 947, 948,
   952, 954, 956, 958, 959, 960, 970, 962, 963, 964,
   971, 973, 977, 980, 164, 985, 989, 990, 992, 993,
   995, 998, 999, 1019, 1002, 1003, 1011, 1014, 1020, 222,
  1029, 695, 1036, 1041, 1043, 1044, 1050, 1051, 1055, 1053,
  1058, 1068, 1069, 1071, 1072, 1073, 1074, 820, 1079, 1088,
  1089, 1093, 1099, 1100, 1102, 1103, 1104, 1108, 1109, 1110,
   132, 1111, 1113, 1115, 1116, 1117, 1118, 1121, 1122, 1128,
  1132, 1133, 1134, 1135, 1137, 1138, 1139, 1140, 1141, 1142,
  1144, 1147, 1149, 1151, 1152, 1153, 1162, 1154, 1155, 1160,
   393, 101, 517, 641, 643, 986, 1087, 687, 979, 1092,
   396, 1004, 404, 1156, 102, 1032, 706, 972, 530, 574,
    22, 817, 651, 24, 0, 0, 212, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 0, 0, 0, 0, 0, 104, 107, 109
};
static const short yycheck[] = { 117,
   193, 35, 670, 557, 305, 231, 253, 421, 674, 133,
     1, 678, 691, 770, 207, 139, 50, 303, 304, 177,
   787, 12, 86, 586, 293, 89, 3, 377, 378, 3,
   438, 230, 3, 4, 483, 153, 187, 188, 189, 190,
     4, 0, 838, 20, 3, 26, 3, 21, 25, 3,
     3, 4, 7, 8, 9, 10, 137, 21, 13, 40,
    32, 33, 4, 46, 47, 258, 3, 22, 13, 3,
    22, 25, 13, 32, 33, 4, 22, 22, 745, 237,
   747, 22, 13, 32, 33, 354, 28, 24, 17, 22,
    24, 22, 243, 244, 198, 32, 33, 39, 3, 250,
   251, 252, 57, 58, 59, 88, 22, 59, 142, 54,
    91, 92, 526, 59, 59, 239, 21, 913, 182, 200,
   238, 245, 94, 54, 3, 4, 59, 58, 59, 84,
   579, 539, 81, 359, 198, 94, 240, 114, 84, 113,
   111, 112, 411, 59, 93, 94, 32, 33, 815, 342,
   343, 344, 345, 346, 111, 112, 355, 350, 111, 112,
    17, 103, 13, 19, 282, 283, 45, 46, 47, 3,
    11, 22, 51, 736, 53, 31, 240, 14, 15, 16,
    17, 847, 22, 850, 13, 33, 865, 24, 4, 340,
    24, 492, 226, 22, 185, 41, 3, 483, 32, 33,
   191, 427, 428, 429, 22, 21, 760, 93, 94, 772,
   479, 22, 626, 20, 65, 66, 62, 96, 25, 59,
   211, 86, 776, 102, 89, 54, 55, 56, 57, 58,
    59, 22, 7, 8, 9, 10, 13, 74, 13, 57,
     3, 59, 60, 3, 4, 22, 19, 22, 59, 442,
   443, 444, 445, 446, 27, 413, 13, 75, 76, 383,
    19, 79, 21, 100, 19, 22, 3, 821, 59, 823,
   394, 825, 27, 48, 49, 50, 4, 54, 55, 54,
     4, 110, 59, 13, 59, 1042, 3, 1054, 26, 17,
   591, 13, 22, 579, 285, 709, 710, 288, 965, 966,
    22, 25, 59, 529, 530, 29, 4, 533, 658, 535,
    35, 36, 37, 38, 39, 14, 434, 42, 22, 17,
    19, 520, 21, 481, 99, 26, 101, 52, 4, 104,
   105, 106, 107, 108, 109, 4, 19, 59, 4, 64,
   587, 66, 3, 26, 48, 49, 50, 465, 42, 25,
   468, 4, 545, 29, 547, 59, 25, 515, 4, 25,
    29, 630, 631, 29, 4, 90, 19, 20, 3, 4,
     4, 96, 1040, 437, 438, 79, 20, 17, 103, 25,
    11, 25, 17, 29, 4, 584, 80, 81, 82, 24,
     7, 8, 9, 10, 88, 594, 13, 32, 33, 3,
   518, 95, 671, 672, 23, 22, 599, 13, 4, 3,
   603, 604, 1091, 537, 968, 969, 22, 1083, 576, 688,
    24, 17, 4, 17, 4, 459, 4, 4, 32, 33,
    24, 48, 49, 50, 3, 17, 554, 555, 32, 33,
    17, 3, 59, 4, 3, 19, 20, 21, 22, 648,
    24, 25, 26, 27, 578, 19, 30, 615, 4, 577,
   659, 660, 661, 1131, 25, 589, 14, 4, 29, 20,
   588, 3, 4, 464, 25, 539, 1143, 25, 4, 25,
    17, 29, 99, 29, 101, 1039, 3, 104, 105, 106,
   107, 108, 109, 19, 20, 4, 4, 7, 8, 9,
    10, 22, 4, 13, 14, 15, 16, 17, 3, 4,
    84, 4, 20, 13, 24, 17, 25, 25, 676, 3,
    29, 679, 22, 4, 558, 20, 4, 48, 49, 50,
    25, 3, 25, 54, 652, 653, 29, 81, 59, 60,
     7, 8, 9, 10, 54, 4, 13, 25, 4, 4,
     4, 29, 26, 854, 4, 22, 714, 19, 79, 7,
     8, 9, 10, 17, 74, 13, 14, 15, 16, 17,
    25, 770, 68, 69, 29, 25, 24, 846, 4, 29,
     4, 48, 49, 50, 13, 811, 812, 54, 787, 4,
   100, 4, 59, 22, 863, 753, 20, 715, 4, 25,
   718, 25, 720, 29, 722, 20, 764, 4, 4, 767,
    25, 17, 14, 3, 4, 80, 81, 82, 83, 737,
    17, 17, 4, 88, 89, 3, 74, 826, 827, 930,
    20, 3, 99, 19, 101, 25, 835, 104, 105, 106,
   107, 108, 109, 7, 8, 9, 10, 765, 3, 13,
   768, 3, 100, 777, 853, 71, 72, 775, 3, 4,
     3, 4, 780, 781, 782, 783, 784, 4, 35, 36,
     3, 4, 830, 7, 8, 9, 10, 20, 836, 13,
    22, 82, 25, 3, 4, 52, 33, 20, 22, 33,
   848, 3, 25, 892, 893, 894, 63, 64, 65, 66,
    67, 51, 5, 70, 54, 55, 48, 49, 50, 3,
     4, 21, 54, 831, 48, 49, 50, 59, 23, 24,
    54, 55, 14, 90, 3, 59, 20, 19, 20, 96,
     3, 25, 85, 86, 87, 4, 103, 79, 3, 4,
   933, 934, 22, 936, 3, 4, 904, 7, 8, 9,
    10, 909, 4, 13, 4, 20, 4, 875, 876, 22,
    25, 879, 22, 881, 922, 883, 3, 101, 3, 4,
   104, 105, 106, 107, 108, 109, 3, 935, 3, 4,
    23, 24, 3, 4, 3, 48, 49, 50, 48, 49,
    50, 54, 910, 88, 57, 20, 59, 60, 1067, 59,
    25, 3, 4, 4, 928, 923, 80, 81, 82, 83,
     3, 4, 75, 76, 88, 89, 79, 975, 46, 47,
     4, 939, 17, 941, 942, 943, 944, 20, 819, 987,
     4, 13, 25, 4, 1033, 1034, 3, 4, 61, 21,
    22, 101, 22, 1042, 104, 105, 106, 107, 108, 109,
     3, 4, 3, 4, 3, 1054, 4, 97, 976, 7,
     8, 9, 10, 3, 4, 13, 48, 49, 50, 1062,
  1063, 1064, 54, 991, 22, 999, 3, 59, 3, 4,
    20, 3, 1081, 65, 66, 25, 3, 4, 1046, 7,
     8, 9, 10, 3, 4, 13, 3, 4, 3, 4,
    48, 49, 50, 3, 22, 1023, 54, 55, 56, 57,
    58, 59, 3, 20, 34, 20, 22, 1035, 25, 4,
    25, 3, 4, 3, 4, 4, 960, 605, 606, 1047,
    48, 49, 50, 447, 448, 4, 84, 55, 56, 57,
    58, 59, 48, 49, 50, 3, 4, 13, 1066, 4,
    13, 57, 4, 59, 60, 21, 22, 1075, 21, 22,
     4, 4, 20, 4, 26, 30, 84, 25, 22, 75,
    76, 13, 1090, 79, 3, 3, 4, 4, 4, 21,
    22, 6, 48, 49, 50, 48, 49, 50, 54, 21,
     3, 54, 20, 59, 3, 3, 59, 25, 3, 65,
    66, 13, 65, 66, 3, 4, 48, 49, 50, 21,
    22, 1129, 54, 3, 4, 3, 3, 59, 3, 3,
    13, 20, 4, 65, 66, 4, 25, 3, 21, 22,
    20, 4, 3, 3, 3, 25, 48, 49, 50, 1157,
  1074, 13, 54, 3, 3, 3, 4, 59, 3, 21,
    22, 3, 3, 65, 66, 48, 49, 50, 3, 3,
    13, 54, 20, 3, 3, 4, 59, 25, 21, 22,
    73, 3, 65, 66, 3, 73, 48, 49, 50, 73,
    13, 20, 54, 13, 33, 4, 25, 59, 21, 22,
     4, 21, 22, 65, 66, 48, 49, 50, 4, 4,
     4, 54, 13, 4, 4, 4, 59, 61, 3, 22,
    21, 22, 65, 66, 4, 48, 49, 50, 48, 49,
    50, 54, 3, 3, 4, 55, 59, 3, 4, 59,
    24, 24, 65, 66, 4, 65, 66, 48, 49, 50,
    20, 33, 4, 3, 20, 25, 3, 3, 59, 25,
     3, 3, 3, 4, 65, 66, 19, 20, 21, 22,
     4, 24, 25, 26, 27, 3, 4, 30, 19, 20,
    21, 22, 4, 24, 25, 26, 27, 3, 4, 30,
     3, 4, 20, 3, 4, 4, 4, 25, 4, 3,
     4, 3, 4, 4, 20, 3, 59, 20, 3, 25,
    20, 3, 25, 3, 4, 25, 20, 98, 20, 3,
     4, 25, 4, 25, 4, 3, 4, 3, 4, 3,
    20, 3, 4, 3, 4, 25, 20, 3, 4, 3,
     4, 25, 20, 3, 20, 3, 4, 25, 20, 25,
    20, 3, 4, 25, 20, 25, 20, 3, 4, 25,
     3, 25, 20, 3, 4, 3, 4, 25, 20, 3,
     4, 3, 4, 25, 20, 3, 4, 3, 4, 25,
    20, 3, 20, 3, 4, 25, 20, 25, 20, 3,
     4, 25, 20, 25, 20, 3, 4, 25, 3, 25,
    20, 3, 4, 3, 4, 25, 20, 3, 4, 3,
     4, 25, 20, 3, 4, 3, 4, 25, 20, 3,
    20, 3, 4, 25, 20, 25, 20, 3, 3, 25,
    20, 25, 20, 3, 3, 25, 22, 25, 20, 19,
    20, 21, 22, 25, 24, 25, 26, 27, 22, 22,
    30, 38, 39, 40, 41, 42, 43, 22, 45, 4,
     4, 48, 3, 22, 4, 3, 24, 4, 24, 24,
     4, 4, 3, 20, 3, 3, 3, 3, 3, 22,
     4, 4, 3, 3, 3, 3, 22, 82, 4, 4,
     4, 4, 4, 4, 4, 3, 26, 4, 4, 4,
     4, 4, 3, 3, 125, 4, 4, 4, 4, 4,
     4, 3, 3, 22, 4, 4, 4, 4, 3, 168,
     4, 23, 4, 4, 4, 4, 4, 4, 4, 22,
     4, 4, 4, 4, 4, 4, 3, 742, 4, 4,
     4, 4, 4, 4, 4, 4, 4, 4, 4, 3,
    85, 4, 4, 4, 4, 4, 4, 4, 4, 4,
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
     4, 4, 4, 4, 4, 3, 0, 4, 4, 4,
   304, 49, 414, 545, 547, 913, 1049, 591, 906, 1060,
   305, 930, 306, 22, 49, 967, 602, 901, 424, 478,
    12, 738, 563, 14, -1, -1, 148, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, 49, 49, 49
};











int
 PDDL_Parser::
     yyparse(void)
{
  register int yystate;
  register int yyn;
  register short *yyssp;
  register yy_PDDL_Parser_stype *yyvsp;
  int yyerrstatus;
  int yychar1=0;
  short yyssa[200];
  yy_PDDL_Parser_stype yyvsa[200];
  short *yyss = yyssa;
  yy_PDDL_Parser_stype *yyvs = yyvsa;
  int yystacksize = 200;
  yy_PDDL_Parser_stype yyval;
  int yylen;

  if (yydebug)
    fprintf(stderr, "Starting parse\n");
  yystate = 0;
  yyerrstatus = 0;
  yynerrs = 0;
  yychar = -2;
  yyssp = yyss - 1;
  yyvsp = yyvs;
yynewstate:
  *++yyssp = yystate;
  if (yyssp >= yyss + yystacksize - 1)
    {
      yy_PDDL_Parser_stype *yyvs1 = yyvs;
      short *yyss1 = yyss;
      int size = yyssp - yyss + 1;
      if (yystacksize >= 10000)
 {
   log_error("parser stack overflow");
   return(2);
 }
      yystacksize *= 2;
      if (yystacksize > 10000)
 yystacksize = 10000;
      yyss = (short *) __builtin_alloca(yystacksize * sizeof (*yyssp));
      __builtin_memcpy((char *)yyss,(char *)yyss1,size * sizeof (*yyssp));
      ;
      yyvs = (yy_PDDL_Parser_stype *) __builtin_alloca(yystacksize * sizeof (*yyvsp));
      __builtin_memcpy((char *)yyvs,(char *)yyvs1,size * sizeof (*yyvsp));
      ;
      yyssp = yyss + size - 1;
      yyvsp = yyvs + size - 1;
      if (yydebug)
 fprintf(stderr, "Stack size increased to %d\n", yystacksize);
      if (yyssp >= yyss + yystacksize - 1)
 return(1);
    }
  if (yydebug)
    fprintf(stderr, "Entering state %d\n", yystate);
  goto yybackup;
yybackup:
  yyn = yypact[yystate];
  if (yyn == -32768)
    goto yydefault;
  if (yychar == -2)
    {
      if (yydebug)
 fprintf(stderr, "Reading a token: ");
      yychar = next_token();
    }
  if (yychar <= 0)
    {
      yychar1 = 0;
      yychar = 0;
      if (yydebug)
 fprintf(stderr, "Now at end of input.\n");
    }
  else
    {
      yychar1 = ((unsigned)(yychar) <= 369 ? yytranslate[yychar] : 369);
      if (yydebug)
 {
   fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
   fprintf (stderr, ")\n");
 }
    }
  yyn += yychar1;
  if (yyn < 0 || yyn > 1519 || yycheck[yyn] != yychar1)
    goto yydefault;
  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == -32768)
 goto yyerrlab;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrlab;
  if (yyn == 1162)
    return(0);
  if (yydebug)
    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
  if (yychar != 0)
    yychar = -2;
  *++yyvsp = yylval;
  if (yyerrstatus) yyerrstatus--;
  yystate = yyn;
  goto yynewstate;
yydefault:
  yyn = yydefact[yystate];
  if (yyn == 0)
    goto yyerrlab;
yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvsp[1-yylen];
  if (yydebug)
    {
      int i;
      fprintf (stderr, "Reducing via rule %d (line %d), ",
        yyn, yyrline[yyn]);
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
 fprintf (stderr, "%s ", yytname[yyrhs[i]]);
      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
    }
  switch (yyn) {
case 17:
{
  domain_name = yyvsp[-1].sym->text;
  if (current_file()) domain_file = strdup(current_file());
;
    break;}
case 18:
{ yyval.sym = yyvsp[0].sym; ;
    break;}
case 19:
{ yyval.sym = yyvsp[0].sym; ;
    break;}
case 20:
{ yyval.sym = yyvsp[0].sym; ;
    break;}
case 21:
{ yyval.sym = yyvsp[0].sym; ;
    break;}
case 22:
{ yyval.sym = yyvsp[0].sym; ;
    break;}
case 23:
{ yyval.sym = yyvsp[0].sym; ;
    break;}
case 24:
{ yyval.sym = yyvsp[0].sym; ;
    break;}
case 25:
{ yyval.sym = yyvsp[0].sym; ;
    break;}
case 26:
{ yyval.sym = yyvsp[0].sym; ;
    break;}
case 27:
{ yyval.sym = yyvsp[0].sym; ;
    break;}
case 28:
{ yyval.sym = yyvsp[0].sym; ;
    break;}
case 37:
{
  current_param.clear()
;
    break;}
case 38:
{
  PredicateSymbol* p = new PredicateSymbol(yyvsp[-3].sym->text);
  p->param = current_param;
  dom_predicates.append(p);
  clear_context(current_param);
  yyvsp[-3].sym->val = p;
;
    break;}
case 39:
{
  set_variable_type(current_param, (TypeSymbol*)yyvsp[0].sym->val);
;
    break;}
case 40:
{
  current_type_set.clear();
;
    break;}
case 41:
{
  set_variable_type(current_param, current_type_set);
;
    break;}
case 42:
{
  set_variable_type(current_param, dom_top_type);
;
    break;}
case 44:
{
  yyvsp[0].sym->val = new VariableSymbol(yyvsp[0].sym->text);
  current_param.append((VariableSymbol*)yyvsp[0].sym->val);
  if (trace_print_context) {
    std::cerr << "variable ";
    current_param[current_param.length() - 1]->print(std::cerr);
    std::cerr << " added to context (now "
       << current_param.length() << " variables)"
       << std::endl;
  }
;
    break;}
case 45:
{
  std::cerr << "error: variable ";
  ((VariableSymbol*)yyvsp[0].sym->val)->print(std::cerr);
  std::cerr << " redeclared" << std::endl;
  exit(255);
;
    break;}
case 46:
{
  yyvsp[0].sym->val = new VariableSymbol(yyvsp[0].sym->text);
  current_param.append((VariableSymbol*)yyvsp[0].sym->val);
  if (trace_print_context) {
    std::cerr << "variable ";
    current_param[current_param.length() - 1]->print(std::cerr);
    std::cerr << " added to context (now "
       << current_param.length() << " variables)"
       << std::endl;
  }
;
    break;}
case 47:
{
  std::cerr << "error: variable ";
  ((VariableSymbol*)yyvsp[0].sym->val)->print(std::cerr);
  std::cerr << " redeclared" << std::endl;
  exit(255);
;
    break;}
case 48:
{
  current_type_set.append((TypeSymbol*)yyvsp[0].sym->val);
;
    break;}
case 49:
{
  current_type_set.append((TypeSymbol*)yyvsp[0].sym->val);
;
    break;}
case 50:
{
  last_n_functions = dom_functions.length();
;
    break;}
case 52:
{
  last_n_functions = dom_functions.length();
;
    break;}
case 54:
{
  TypeSymbol* t = (TypeSymbol*)yyvsp[0].sym->val;
  for (hsps::index_type k = last_n_functions; k < dom_functions.length(); k++){
    if (write_info) {
      std::cerr << "info: converting ";
      dom_functions[k]->print(std::cerr);
      std::cerr << " to object function with type " << t->print_name
  << std::endl;
    }
    hsps::PDDL_Base::ObjectFunctionSymbol* f =
      new hsps::PDDL_Base::ObjectFunctionSymbol(dom_functions[k]->print_name);
    f->param = dom_functions[k]->param;
    f->sym_types.assign_value(t, 1);
    dom_object_functions.append(f);
    hsps::StringTable::Cell* c =
      (hsps::StringTable::Cell*)tab.find(f->print_name);
    if (c == 0) {
      std::cerr << "very bad error: function "
  << dom_functions[k]->print_name
  << " declared but not found in string table!"
  << std::endl;
      exit(255);
    }
    c->val = f;
  }
  dom_functions.set_length(last_n_functions);
;
    break;}
case 56:
{
  for (hsps::index_type k = last_n_functions; k < dom_functions.length(); k++){
    if (write_info) {
      std::cerr << "info: converting ";
      dom_functions[k]->print(std::cerr);
      std::cerr << " to object function with type ";
      current_type_set.write_type(std::cerr);
      std::cerr << std::endl;
    }
    hsps::PDDL_Base::ObjectFunctionSymbol* f =
      new hsps::PDDL_Base::ObjectFunctionSymbol(dom_functions[k]->print_name);
    f->param = dom_functions[k]->param;
    f->sym_types.assign_copy(current_type_set);
    dom_object_functions.append(f);
    hsps::StringTable::Cell* c =
      (hsps::StringTable::Cell*)tab.find(f->print_name);
    if (c == 0) {
      std::cerr << "very bad error: function "
  << dom_functions[k]->print_name
  << " declared but not found in string table!"
  << std::endl;
      exit(255);
    }
    c->val = f;
  }
  dom_functions.set_length(last_n_functions);
;
    break;}
case 58:
{
  last_n_functions = dom_functions.length();
;
    break;}
case 62:
{
  current_param.clear();
;
    break;}
case 63:
{
  FunctionSymbol* f = new FunctionSymbol(yyvsp[-3].sym->text);
  f->param = current_param;
  dom_functions.append(f);
  clear_context(current_param);
  yyvsp[-3].sym->val = f;
;
    break;}
case 64:
{
  current_type_set.clear();
;
    break;}
case 66:
{
  for (hsps::index_type k = 0; k < current_type_set.length(); k++)
    current_type_set[k]->sym_types.assign_value((TypeSymbol*)yyvsp[0].sym->val, 1);
  current_type_set.clear();
;
    break;}
case 67:
{
  yyvsp[0].sym->val = new TypeSymbol(yyvsp[0].sym->text);
  ((TypeSymbol*)yyvsp[0].sym->val)->sym_types.assign_value(dom_top_type, 1);
  dom_types.append((TypeSymbol*)yyvsp[0].sym->val);
  for (hsps::index_type k = 0; k < current_type_set.length(); k++)
    current_type_set[k]->sym_types.assign_value((TypeSymbol*)yyvsp[0].sym->val, 1);
  current_type_set.clear();
;
    break;}
case 68:
{
  for (hsps::index_type k = 0; k < current_type_set.length(); k++)
    current_type_set[k]->sym_types.assign_value(dom_top_type, 1);
  current_type_set.clear();
;
    break;}
case 70:
{
  current_type_set.append((TypeSymbol*)yyvsp[0].sym->val);
;
    break;}
case 71:
{
  yyvsp[0].sym->val = new TypeSymbol(yyvsp[0].sym->text);
  dom_types.append((TypeSymbol*)yyvsp[0].sym->val);
  current_type_set.append((TypeSymbol*)yyvsp[0].sym->val);
;
    break;}
case 75:
{
  set_constant_type(dom_constants, (TypeSymbol*)yyvsp[0].sym->val);
;
    break;}
case 76:
{
  set_constant_type(dom_constants, dom_top_type);
;
    break;}
case 78:
{
  yyvsp[0].sym->val = new Symbol(yyvsp[0].sym->text);
  if (problem_name) {
    ((Symbol*)yyvsp[0].sym->val)->defined_in_problem = true;
  }
  dom_constants.append((Symbol*)yyvsp[0].sym->val);
;
    break;}
case 79:
{
  yyvsp[0].sym->val = new Symbol(yyvsp[0].sym->text);
  if (problem_name) {
    ((Symbol*)yyvsp[0].sym->val)->defined_in_problem = true;
  }
  dom_constants.append((Symbol*)yyvsp[0].sym->val);
;
    break;}
case 80:
{
  if (write_warnings) {
    std::cerr << "warning: redeclaration of constant " << yyvsp[0].sym->text
       << " ignored" << std::endl;
  }
;
    break;}
case 81:
{
  if (write_warnings) {
    std::cerr << "warning: redeclaration of constant " << yyvsp[0].sym->text
       << " ignored" << std::endl;
  }
;
    break;}
case 85:
{
  dom_actions.append(new ActionSymbol(yyvsp[0].sym->text));
;
    break;}
case 86:
{
  clear_context(current_param);
  yyvsp[-3].sym->val = dom_actions[dom_actions.length() - 1];
;
    break;}
case 87:
{
  current_param.clear();
;
    break;}
case 88:
{
  dom_actions[dom_actions.length() - 1]->param = current_param;
;
    break;}
case 95:
{
  dom_actions[dom_actions.length() - 1]->assoc = yyvsp[0].sval;
;
    break;}
case 97:
{
  SetSymbol* ssym = new SetSymbol(yyvsp[0].sym->text);
  yyvsp[0].sym->val = ssym;
  partitions.append(ssym);
  SetName* s = new SetName(ssym);
  current_atom = s;
;
    break;}
case 98:
{
  dom_actions[dom_actions.length() - 1]->part = (SetName*)current_atom;
;
    break;}
case 99:
{
  SetName* s = new SetName((SetSymbol*)yyvsp[0].sym->val);
  current_atom = s;
;
    break;}
case 100:
{
  dom_actions[dom_actions.length() - 1]->part = (SetName*)current_atom;
;
    break;}
case 112:
{
  dom_actions[dom_actions.length() - 1]->num_pre.append(yyvsp[0].rel);
;
    break;}
case 113:
{
  yyval.tkw = PDDL_Base::md_start;
;
    break;}
case 114:
{
  yyval.tkw = PDDL_Base::md_end;
;
    break;}
case 115:
{
  yyval.tkw = PDDL_Base::md_all;
;
    break;}
case 116:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 117:
{
  ((Atom*)current_atom)->check();
  dom_actions[dom_actions.length() - 1]->pos_pre.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->pos_pre = true;
;
    break;}
case 118:
{
  Atom* eq_atom = new Atom(dom_eq_pred);
  eq_atom->param.set_length(2);
  eq_atom->param[0] = (Symbol*)yyvsp[-2].sym->val;
  eq_atom->param[1] = (Symbol*)yyvsp[-1].sym->val;
  dom_actions[dom_actions.length() - 1]->pos_pre.append(eq_atom);
;
    break;}
case 119:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val, yyvsp[-2].tkw);
;
    break;}
case 120:
{
  ((Atom*)current_atom)->check();
  dom_actions[dom_actions.length() - 1]->pos_pre.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->pos_pre = true;
;
    break;}
case 121:
{
  Atom* eq_atom = new Atom(dom_eq_pred, yyvsp[-6].tkw);
  eq_atom->param.set_length(2);
  eq_atom->param[0] = (Symbol*)yyvsp[-3].sym->val;
  eq_atom->param[1] = (Symbol*)yyvsp[-2].sym->val;
  dom_actions[dom_actions.length() - 1]->pos_pre.append(eq_atom);
;
    break;}
case 122:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 123:
{
  ((Atom*)current_atom)->check();
  dom_actions[dom_actions.length() - 1]->neg_pre.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->neg_pre = true;
;
    break;}
case 124:
{
  Atom* eq_atom = new Atom(dom_eq_pred);
  eq_atom->param.set_length(2);
  eq_atom->param[0] = (Symbol*)yyvsp[-3].sym->val;
  eq_atom->param[1] = (Symbol*)yyvsp[-2].sym->val;
  dom_actions[dom_actions.length() - 1]->neg_pre.append(eq_atom);
;
    break;}
case 125:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val, yyvsp[-4].tkw);
;
    break;}
case 126:
{
  ((Atom*)current_atom)->check();
  dom_actions[dom_actions.length() - 1]->neg_pre.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->neg_pre = true;
;
    break;}
case 127:
{
  Atom* eq_atom = new Atom(dom_eq_pred, yyvsp[-9].tkw);
  eq_atom->param.set_length(2);
  eq_atom->param[0] = (Symbol*)yyvsp[-4].sym->val;
  eq_atom->param[1] = (Symbol*)yyvsp[-3].sym->val;
  dom_actions[dom_actions.length() - 1]->neg_pre.append(eq_atom);
;
    break;}
case 128:
{
  if (current_atom != 0) {
    current_atom->param.append((Symbol*)yyvsp[0].sym->val);
  }
;
    break;}
case 130:
{
  if (current_atom != 0) {
    current_atom->param.append((Symbol*)yyvsp[0].sym->val);
  }
;
    break;}
case 132:
{
  if (yyvsp[0].sym->val == 0) {
    log_error("undeclared variable in atom argument");
  }
  yyval.sym = yyvsp[0].sym;
;
    break;}
case 133:
{
  yyval.sym = yyvsp[0].sym;
;
    break;}
case 134:
{
  current_atom_stack.append(current_atom);
  current_atom = new FTerm((ObjectFunctionSymbol*)yyvsp[0].sym->val);
;
    break;}
case 135:
{
  ObjectFunctionSymbol* f = (ObjectFunctionSymbol*)yyvsp[-3].sym->val;
  VariableSymbol* v =
    (VariableSymbol*)gensym(sym_variable, "?omsk", f->sym_types);
  v->binding = (FTerm*)current_atom;
  assert(current_atom_stack.length() > 0);
  current_atom = current_atom_stack[current_atom_stack.length() - 1];
  current_atom_stack.dec_length();
  hsps::StringTable::Cell* c =
    (hsps::StringTable::Cell*)tab.find(v->print_name);
  if (c == 0) {
    std::cerr << "very bad error: omsk symbol " << v->print_name
       << " generated but not found in string table!"
       << std::endl;
    exit(255);
  }
  yyval.sym = c;
;
    break;}
case 136:
{
  yyval.sym = yyvsp[0].sym;
;
    break;}
case 137:
{
  yyval.sym = yyvsp[0].sym;
;
    break;}
case 138:
{
  yyval.rel = new Relation(yyvsp[-3].rkw, yyvsp[-2].exp, yyvsp[-1].exp);
  yyvsp[-2].exp->mark_functions_in_condition();
  yyvsp[-1].exp->mark_functions_in_condition();
;
    break;}
case 139:
{
  yyval.rel = new Relation(yyvsp[-4].rkw, yyvsp[-6].tkw, yyvsp[-3].exp, yyvsp[-2].exp);
  yyvsp[-3].exp->mark_functions_in_condition();
  yyvsp[-2].exp->mark_functions_in_condition();
;
    break;}
case 140:
{
  yyval.rkw = rel_greater;
;
    break;}
case 141:
{
  yyval.rkw = rel_greater_equal;
;
    break;}
case 142:
{
  yyval.rkw = rel_less;
;
    break;}
case 143:
{
  yyval.rkw = rel_less_equal;
;
    break;}
case 144:
{
  yyval.rkw = rel_equal;
;
    break;}
case 145:
{
  yyval.exp = new BinaryExpression(exp_sub, new ConstantExpression(0), yyvsp[-1].exp);
;
    break;}
case 146:
{
  yyval.exp = new BinaryExpression(exp_add, yyvsp[-2].exp, yyvsp[-1].exp);
;
    break;}
case 147:
{
  yyval.exp = new BinaryExpression(exp_sub, yyvsp[-2].exp, yyvsp[-1].exp);
;
    break;}
case 148:
{
  yyval.exp = new BinaryExpression(exp_mul, yyvsp[-2].exp, yyvsp[-1].exp);
;
    break;}
case 149:
{
  yyval.exp = new BinaryExpression(exp_div, yyvsp[-2].exp, yyvsp[-1].exp);
;
    break;}
case 150:
{
  yyval.exp = new BinaryExpression(exp_div, yyvsp[-2].exp, yyvsp[0].exp);
;
    break;}
case 151:
{
  yyval.exp = new ConstantExpression(yyvsp[0].ival);
;
    break;}
case 152:
{
  yyval.exp = new ConstantExpression(hsps::rational(yyvsp[0].rval));
;
    break;}
case 153:
{
  yyval.exp = new TimeExpression();
;
    break;}
case 154:
{
  yyval.exp = new PreferenceExpression((Symbol*)yyvsp[-1].sym->val);
;
    break;}
case 155:
{
  yyval.exp = yyvsp[0].exp;
;
    break;}
case 156:
{
  yyval.exp = yyvsp[0].exp;
;
    break;}
case 157:
{
  yyval.exp = new BinaryExpression(exp_add, yyvsp[-1].exp, yyvsp[0].exp);
;
    break;}
case 158:
{
  yyval.exp = yyvsp[0].exp;
;
    break;}
case 159:
{
  yyval.exp = new BinaryExpression(exp_mul, yyvsp[-1].exp, yyvsp[0].exp);
;
    break;}
case 160:
{
  yyval.exp = new FunctionExpression((FunctionSymbol*)yyvsp[-2].sym->val, yyvsp[-1].lst);
;
    break;}
case 161:
{
  yyval.exp = new FunctionExpression((FunctionSymbol*)yyvsp[0].sym->val, 0);
;
    break;}
case 162:
{
  yyval.lst = new ListExpression((VariableSymbol*)yyvsp[-1].sym->val, yyvsp[0].lst);
;
    break;}
case 163:
{
  yyval.lst = new ListExpression((Symbol*)yyvsp[-1].sym->val, yyvsp[0].lst);
;
    break;}
case 164:
{
  yyval.lst = 0;
;
    break;}
case 165:
{
  stored_n_param.append(current_param.length());
  current_context = new SetOf();
;
    break;}
case 166:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 167:
{
  ((Atom*)current_atom)->check();
  SetOf* s = (SetOf*)current_context;
  s->pos_atoms.append((Atom*)current_atom);
  dom_actions[dom_actions.length() - 1]->set_pre.append(s);
  ((Atom*)current_atom)->pred->pos_pre = true;
  assert(stored_n_param.length() > 0);
  clear_context(current_param,
  stored_n_param[stored_n_param.length() - 1],
  current_param.length());
  current_param.set_length(stored_n_param[stored_n_param.length() - 1]);
  stored_n_param.dec_length();
  current_context = 0;
;
    break;}
case 168:
{
  stored_n_param.append(current_param.length());
  current_context = new SetOf();
;
    break;}
case 169:
{
  SetOf* s = (SetOf*)current_context;
  for (hsps::index_type k = stored_n_param[stored_n_param.length() - 1];
       k < current_param.length(); k++) {
    s->param.append(current_param[k]);
  }
  dom_actions[dom_actions.length() - 1]->set_pre.append(s);
;
    break;}
case 170:
{
  assert(stored_n_param.length() > 0);
  clear_context(current_param,
  stored_n_param[stored_n_param.length() - 1],
  current_param.length());
  current_param.set_length(stored_n_param[stored_n_param.length() - 1]);
  stored_n_param.dec_length();
  current_context = 0;
;
    break;}
case 171:
{
  current_context = new SetOf();
;
    break;}
case 172:
{
  SetOf* s = (SetOf*)current_context;
  dom_actions[dom_actions.length() - 1]->set_pre.append(s);
;
    break;}
case 173:
{
  stored_n_param.append(current_param.length());
  current_context = new SetOf();
;
    break;}
case 174:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 175:
{
  ((Atom*)current_atom)->check();
  SetOf* s = (SetOf*)current_context;
  s->pos_atoms.append((Atom*)current_atom);
  s->set_mode(yyvsp[-12].tkw);
  dom_actions[dom_actions.length() - 1]->set_pre.append(s);
  ((Atom*)current_atom)->pred->pos_pre = true;
  assert(stored_n_param.length() > 0);
  clear_context(current_param,
  stored_n_param[stored_n_param.length() - 1],
  current_param.length());
  current_param.set_length(stored_n_param[stored_n_param.length() - 1]);
  stored_n_param.dec_length();
  current_context = 0;
;
    break;}
case 176:
{
  stored_n_param.append(current_param.length());
  current_context = new SetOf();
;
    break;}
case 177:
{
  SetOf* s = (SetOf*)current_context;
  for (hsps::index_type k = stored_n_param[stored_n_param.length() - 1];
       k < current_param.length(); k++) {
    s->param.append(current_param[k]);
  }
  dom_actions[dom_actions.length() - 1]->set_pre.append(s);
;
    break;}
case 178:
{
  SetOf* s = (SetOf*)current_context;
  s->set_mode(yyvsp[-10].tkw);
  assert(stored_n_param.length() > 0);
  clear_context(current_param,
  stored_n_param[stored_n_param.length() - 1],
  current_param.length());
  current_param.set_length(stored_n_param[stored_n_param.length() - 1]);
  stored_n_param.dec_length();
  current_context = 0;
;
    break;}
case 179:
{
  current_context = new SetOf();
;
    break;}
case 180:
{
  SetOf* s = (SetOf*)current_context;
  s->set_mode(yyvsp[-7].tkw);
  dom_actions[dom_actions.length() - 1]->set_pre.append(s);
;
    break;}
case 189:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 190:
{
  ((Atom*)current_atom)->check();
  SetOf* s = (SetOf*)current_context;
  s->pos_atoms.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->pos_pre = true;
;
    break;}
case 191:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 192:
{
  ((Atom*)current_atom)->check();
  SetOf* s = (SetOf*)current_context;
  s->neg_atoms.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->neg_pre = true;
;
    break;}
case 193:
{
  Atom* eq_atom = new Atom(dom_eq_pred);
  eq_atom->param.set_length(2);
  eq_atom->param[0] = (Symbol*)yyvsp[-2].sym->val;
  eq_atom->param[1] = (Symbol*)yyvsp[-1].sym->val;
  SetOf* s = (SetOf*)current_context;
  s->pos_atoms.append(eq_atom);
;
    break;}
case 194:
{
  Atom* eq_atom = new Atom(dom_eq_pred);
  eq_atom->param.set_length(2);
  eq_atom->param[0] = (Symbol*)yyvsp[-3].sym->val;
  eq_atom->param[1] = (Symbol*)yyvsp[-2].sym->val;
  SetOf* s = (SetOf*)current_context;
  s->neg_atoms.append(eq_atom);
;
    break;}
case 195:
{
  current_context = new SetOf();
;
    break;}
case 196:
{
  SetOf* s = (SetOf*)current_context;
  dom_actions[dom_actions.length() - 1]->dis_pre.append(s);
  current_context = 0;
;
    break;}
case 198:
{
  stored_n_param.append(current_param.length());
  current_context = new SetOf();
;
    break;}
case 199:
{
  SetOf* s = (SetOf*)current_context;
  for (hsps::index_type k = stored_n_param[stored_n_param.length() - 1];
       k < current_param.length(); k++) {
    s->param.append(current_param[k]);
  }
  dom_actions[dom_actions.length() - 1]->dis_pre.append(s);
;
    break;}
case 200:
{
  assert(stored_n_param.length() > 0);
  clear_context(current_param,
  stored_n_param[stored_n_param.length() - 1],
  current_param.length());
  current_param.set_length(stored_n_param[stored_n_param.length() - 1]);
  stored_n_param.dec_length();
  current_context = 0;
;
    break;}
case 206:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 207:
{
  ((Atom*)current_atom)->check();
  ((SetOf*)current_context)->pos_atoms.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->pos_pre = true;
;
    break;}
case 208:
{
  Atom* eq_atom = new Atom(dom_eq_pred);
  eq_atom->param.set_length(2);
  eq_atom->param[0] = (Symbol*)yyvsp[-2].sym->val;
  eq_atom->param[1] = (Symbol*)yyvsp[-1].sym->val;
  ((SetOf*)current_context)->pos_atoms.append(eq_atom);
;
    break;}
case 209:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 210:
{
  ((Atom*)current_atom)->check();
  ((SetOf*)current_context)->neg_atoms.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->neg_pre = true;
;
    break;}
case 211:
{
  Atom* eq_atom = new Atom(dom_eq_pred);
  eq_atom->param.set_length(2);
  eq_atom->param[0] = (Symbol*)yyvsp[-3].sym->val;
  eq_atom->param[1] = (Symbol*)yyvsp[-2].sym->val;
  ((SetOf*)current_context)->neg_atoms.append(eq_atom);
;
    break;}
case 216:
{
  stored_n_param.append(current_param.length());
  current_context = new SetOf();
;
    break;}
case 217:
{
  SetOf* s = (SetOf*)current_context;
  for (hsps::index_type k = stored_n_param[stored_n_param.length() - 1];
       k < current_param.length(); k++) {
    s->param.append(current_param[k]);
  }
;
    break;}
case 218:
{
  dom_actions[dom_actions.length() - 1]->set_eff.append((SetOf*)current_context);
  assert(stored_n_param.length() > 0);
  clear_context(current_param,
  stored_n_param[stored_n_param.length() - 1],
  current_param.length());
  current_param.set_length(stored_n_param[stored_n_param.length() - 1]);
  stored_n_param.dec_length();
  current_context = 0;
;
    break;}
case 219:
{
  current_context = new SetOf();
;
    break;}
case 220:
{
  dom_actions[dom_actions.length() - 1]->set_eff.append((SetOf*)current_context);
  current_context = 0;
;
    break;}
case 221:
{
  stored_n_param.append(current_param.length());
  current_context = new SetOf();
;
    break;}
case 222:
{
  SetOf* s = (SetOf*)current_context;
  for (hsps::index_type k = stored_n_param[stored_n_param.length() - 1];
       k < current_param.length(); k++) {
    s->param.append(current_param[k]);
  }
;
    break;}
case 223:
{
  SetOf* s = (SetOf*)current_context;
  s->set_mode(yyvsp[-10].tkw);
  dom_actions[dom_actions.length() - 1]->set_eff.append(s);
  assert(stored_n_param.length() > 0);
  clear_context(current_param,
  stored_n_param[stored_n_param.length() - 1],
  current_param.length());
  current_param.set_length(stored_n_param[stored_n_param.length() - 1]);
  stored_n_param.dec_length();
  current_context = 0;
;
    break;}
case 224:
{
  current_context = new SetOf();
;
    break;}
case 225:
{
  SetOf* s = (SetOf*)current_context;
  s->set_mode(yyvsp[-6].tkw);
  dom_actions[dom_actions.length() - 1]->set_eff.append(s);
  current_context = 0;
;
    break;}
case 238:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
  ((PredicateSymbol*)yyvsp[0].sym->val)->modded = true;
;
    break;}
case 239:
{
  ((Atom*)current_atom)->check();
  if (current_context != 0) {
    ((SetOf*)current_context)->pos_atoms.append((Atom*)current_atom);
  }
  else {
    dom_actions[dom_actions.length() - 1]->adds.append((Atom*)current_atom);
  }
;
    break;}
case 240:
{
  current_atom = new FTerm((ObjectFunctionSymbol*)yyvsp[0].sym->val);
;
    break;}
case 241:
{
  FTerm* ft = (FTerm*)current_atom;
  ft->fun->modded = true;
  VariableSymbol* v =
    (VariableSymbol*)gensym(sym_variable,"?omsk",ft->fun->sym_types);
  v->binding = ft;
  Atom* a = new Atom(dom_assign_pred);
  a->param.set_length(2);
  a->param[0] = v;
  a->param[1] = (Symbol*)yyvsp[-1].sym->val;
  if (current_context != 0) {
    if (write_warnings || !best_effort) {
      std::cerr << "warning: object function assignment ";
      a->print(std::cerr);
      std::cerr << " in quantified/conditional effect ignored"
  << std::endl;
    }
    if (!best_effort) exit(1);
  }
  else {
    dom_actions[dom_actions.length() - 1]->adds.append(a);
  }
;
    break;}
case 242:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val, yyvsp[-2].tkw);
  ((PredicateSymbol*)yyvsp[0].sym->val)->modded = true;
;
    break;}
case 243:
{
  ((Atom*)current_atom)->check();
  if (current_context != 0) {
    ((SetOf*)current_context)->pos_atoms.append((Atom*)current_atom);
  }
  else {
    dom_actions[dom_actions.length() - 1]->adds.append((Atom*)current_atom);
  }
;
    break;}
case 244:
{
  yyval.sym = yyvsp[0].sym;
;
    break;}
case 245:
{
  yyval.sym = (hsps::StringTable::Cell*)tab.find("undefined");
  assert(yyval.sym != 0);
;
    break;}
case 246:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
  ((PredicateSymbol*)yyvsp[0].sym->val)->modded = true;
;
    break;}
case 247:
{
  ((Atom*)current_atom)->check();
  if (current_context != 0) {
    ((SetOf*)current_context)->neg_atoms.append((Atom*)current_atom);
  }
  else {
    dom_actions[dom_actions.length() - 1]->dels.append((Atom*)current_atom);
  }
;
    break;}
case 248:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val, yyvsp[-4].tkw);
  ((PredicateSymbol*)yyvsp[0].sym->val)->modded = true;
;
    break;}
case 249:
{
  ((Atom*)current_atom)->check();
  if (current_context != 0) {
    ((SetOf*)current_context)->neg_atoms.append((Atom*)current_atom);
  }
  else {
    dom_actions[dom_actions.length() - 1]->dels.append((Atom*)current_atom);
  }
;
    break;}
case 250:
{
  current_atom = new FChangeAtom((FunctionSymbol*)yyvsp[0].sym->val);
;
    break;}
case 251:
{
  ((FChangeAtom*)current_atom)->val = yyvsp[-1].exp;
  ((FChangeAtom*)current_atom)->fun->modified = true;
  if (!yyvsp[-1].exp->is_integral()) ((FChangeAtom*)current_atom)->fun->integral = false;
  dom_actions[dom_actions.length() - 1]->incs.append((FChangeAtom*)current_atom);
;
    break;}
case 252:
{
  current_atom = new FChangeAtom((FunctionSymbol*)yyvsp[0].sym->val);
;
    break;}
case 253:
{
  ((FChangeAtom*)current_atom)->val = yyvsp[-1].exp;
  ((FChangeAtom*)current_atom)->fun->modified = true;
  if (!yyvsp[-1].exp->is_integral()) ((FChangeAtom*)current_atom)->fun->integral = false;
  dom_actions[dom_actions.length() - 1]->decs.append((FChangeAtom*)current_atom);
;
    break;}
case 254:
{
  current_atom = new FChangeAtom((FunctionSymbol*)yyvsp[0].sym->val);
;
    break;}
case 255:
{
  ((FChangeAtom*)current_atom)->val = yyvsp[-1].exp;
  ((FChangeAtom*)current_atom)->fun->modified = true;
  if (!yyvsp[-1].exp->is_integral()) ((FChangeAtom*)current_atom)->fun->integral = false;
  dom_actions[dom_actions.length() - 1]->fass.append((FChangeAtom*)current_atom);
;
    break;}
case 256:
{
  current_atom = new FChangeAtom((FunctionSymbol*)yyvsp[0].sym->val, yyvsp[-4].tkw);
;
    break;}
case 257:
{
  ((FChangeAtom*)current_atom)->val = yyvsp[-2].exp;
  ((FChangeAtom*)current_atom)->fun->modified = true;
  if (!yyvsp[-2].exp->is_integral()) ((FChangeAtom*)current_atom)->fun->integral = false;
  dom_actions[dom_actions.length() - 1]->incs.append((FChangeAtom*)current_atom);
;
    break;}
case 258:
{
  current_atom = new FChangeAtom((FunctionSymbol*)yyvsp[0].sym->val, yyvsp[-4].tkw);
;
    break;}
case 259:
{
  ((FChangeAtom*)current_atom)->val = yyvsp[-2].exp;
  ((FChangeAtom*)current_atom)->fun->modified = true;
  if (!yyvsp[-2].exp->is_integral()) ((FChangeAtom*)current_atom)->fun->integral = false;
  dom_actions[dom_actions.length() - 1]->decs.append((FChangeAtom*)current_atom);
;
    break;}
case 260:
{
  current_atom = new FChangeAtom((FunctionSymbol*)yyvsp[0].sym->val, yyvsp[-4].tkw);
;
    break;}
case 261:
{
  ((FChangeAtom*)current_atom)->val = yyvsp[-2].exp;
  ((FChangeAtom*)current_atom)->fun->modified = true;
  if (!yyvsp[-2].exp->is_integral()) ((FChangeAtom*)current_atom)->fun->integral = false;
  dom_actions[dom_actions.length() - 1]->fass.append((FChangeAtom*)current_atom);
;
    break;}
case 269:
{
  dom_actions[dom_actions.length() - 1]->dmin = yyvsp[-1].exp;
  dom_actions[dom_actions.length() - 1]->dmax = yyvsp[-1].exp;
;
    break;}
case 270:
{
  dom_actions[dom_actions.length() - 1]->dmin = yyvsp[0].exp;
  dom_actions[dom_actions.length() - 1]->dmax = yyvsp[0].exp;
;
    break;}
case 271:
{
  dom_actions[dom_actions.length() - 1]->dmax = yyvsp[-1].exp;
;
    break;}
case 274:
{
  dom_actions[dom_actions.length() - 1]->dmin = yyvsp[-1].exp;
;
    break;}
case 277:
{
  current_context = new SequentialTaskNet();
  stored_n_param.append(current_param.length());
  if (trace_print_context) {
    std::cerr << "pushed context (" << current_param.length() << " variables)"
       << std::endl;
  }
;
    break;}
case 278:
{
  SequentialTaskNet* n = (SequentialTaskNet*)current_context;
  n->abs_act = dom_actions[dom_actions.length() - 1];
  dom_actions[dom_actions.length() - 1]->exps.append(n);
  if (trace_print_context) {
    std::cerr << "poping context from "
       << current_param.length()
       << " to "
       << stored_n_param[stored_n_param.length() - 1]
       << " variables..." << std::endl;
  }
  assert(stored_n_param.length() > 0);
  clear_context(current_param,
  stored_n_param[stored_n_param.length() - 1],
  current_param.length());
  current_param.set_length(stored_n_param[stored_n_param.length() - 1]);
  stored_n_param.dec_length();
  current_context = 0;
;
    break;}
case 281:
{
  current_atom = new Reference((ActionSymbol*)yyvsp[0].sym->val);
;
    break;}
case 282:
{
  Reference* ref = (Reference*)current_atom;
  SequentialTaskNet* task_net = (SequentialTaskNet*)current_context;
  task_net->tasks.append(ref);
;
    break;}
case 284:
{
  problem_name = yyvsp[-1].sym->text;
  if (current_file()) problem_file = strdup(current_file());
;
    break;}
case 301:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 302:
{
  ((Atom*)current_atom)->check();
  PredicateSymbol* p = (PredicateSymbol*)yyvsp[-3].sym->val;
  if (p->param.length() != current_atom->param.length()) {
    log_error("wrong number of arguments for predicate in (:init ...");
  }
  ((Atom*)current_atom)->insert(p->init);
  current_atom->at_time = 0;
  dom_init.append((Atom*)current_atom);
;
    break;}
case 303:
{
  current_atom = new OInitAtom((ObjectFunctionSymbol*)yyvsp[0].sym->val);
;
    break;}
case 304:
{
  ObjectFunctionSymbol* f = (ObjectFunctionSymbol*)yyvsp[-5].sym->val;
  if (f->param.length() != current_atom->param.length()) {
    log_error("wrong number of arguments for object function in (:init ...");
  }
  ((OInitAtom*)current_atom)->val = (Symbol*)yyvsp[-1].sym->val;
  current_atom->at_time = 0;
  ((OInitAtom*)current_atom)->insert(f->init);
  dom_obj_init.append((OInitAtom*)current_atom);
;
    break;}
case 305:
{
  current_atom = new FInitAtom((FunctionSymbol*)yyvsp[0].sym->val);
;
    break;}
case 306:
{
  FunctionSymbol* f = (FunctionSymbol*)yyvsp[-5].sym->val;
  if (f->param.length() != current_atom->param.length()) {
    log_error("wrong number of arguments for function in (:init ...");
  }
  ((FInitAtom*)current_atom)->val = hsps::rational(yyvsp[-1].rval);
  if (!(((FInitAtom*)current_atom)->val).integral())
    ((FInitAtom*)current_atom)->fun->integral = false;
  ((FInitAtom*)current_atom)->insert(f->init);
  current_atom->at_time = 0;
  dom_fun_init.append((FInitAtom*)current_atom);
;
    break;}
case 307:
{
  FunctionSymbol* f = (FunctionSymbol*)yyvsp[-2].sym->val;
  current_atom = new FInitAtom((FunctionSymbol*)yyvsp[-2].sym->val);
  if (f->param.length() != 0) {
    log_error("wrong number of arguments for function in (:init ...");
  }
  ((FInitAtom*)current_atom)->val = hsps::rational(yyvsp[-1].rval);
  if (!(((FInitAtom*)current_atom)->val).integral())
    ((FInitAtom*)current_atom)->fun->integral = false;
  current_atom->at_time = 0;
  ((FInitAtom*)current_atom)->insert(f->init);
  dom_fun_init.append((FInitAtom*)current_atom);
;
    break;}
case 312:
{
  dom_goals.append(yyvsp[0].goal);
;
    break;}
case 313:
{
  Symbol* name = new Symbol(sym_preference, yyvsp[-2].sym->text);
  yyvsp[-2].sym->val = name;
  dom_preferences.append(new Preference(name, yyvsp[-1].goal));
;
    break;}
case 316:
{
  yyval.goal = yyvsp[0].goal;
;
    break;}
case 317:
{
  current_goal.append(new ConjunctiveGoal());
;
    break;}
case 318:
{
  assert(current_goal.length() > 0);
  yyval.goal = current_goal[current_goal.length() - 1];
  current_goal.dec_length();
;
    break;}
case 319:
{
  current_goal.append(new DisjunctiveGoal());
;
    break;}
case 320:
{
  assert(current_goal.length() > 0);
  yyval.goal = current_goal[current_goal.length() - 1];
  current_goal.dec_length();
;
    break;}
case 321:
{
  assert(current_goal.length() > 0);
  ConjunctiveGoal* cg = current_goal[current_goal.length() - 1];
  assert(cg != 0);
  cg->goals.append(yyvsp[-1].goal);
;
    break;}
case 323:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 324:
{
  ((Atom*)current_atom)->check();
  yyval.goal = new AtomicGoal((Atom*)current_atom, false);
  ((Atom*)current_atom)->pred->pos_pre = true;
  ((Atom*)current_atom)->insert(((Atom*)current_atom)->pred->pos_goal);
;
    break;}
case 325:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 326:
{
  ((Atom*)current_atom)->check();
  yyval.goal = new AtomicGoal((Atom*)current_atom, true);
  ((Atom*)current_atom)->pred->neg_pre = true;
  ((Atom*)current_atom)->insert(((Atom*)current_atom)->pred->neg_goal);
;
    break;}
case 327:
{
  Atom* eq_atom = new Atom(dom_eq_pred);
  eq_atom->param.set_length(2);
  eq_atom->param[0] = (Symbol*)yyvsp[-2].sym->val;
  eq_atom->param[1] = (Symbol*)yyvsp[-1].sym->val;
  yyval.goal = new AtomicGoal(eq_atom, false);
;
    break;}
case 328:
{
  yyval.goal = new NumericGoal(yyvsp[0].rel);
;
    break;}
case 329:
{
  yyval.goal = new SimpleSequenceGoal(goal_always, yyvsp[-1].goal);
;
    break;}
case 330:
{
  yyval.goal = new SimpleSequenceGoal(goal_sometime, yyvsp[-1].goal);
;
    break;}
case 331:
{
  yyval.goal = new SimpleSequenceGoal(goal_at_most_once, yyvsp[-1].goal);
;
    break;}
case 332:
{
  yyval.goal = new TriggeredSequenceGoal(goal_sometime_before, yyvsp[-2].goal, yyvsp[-1].goal);
;
    break;}
case 333:
{
  yyval.goal = new TriggeredSequenceGoal(goal_sometime_after, yyvsp[-2].goal, yyvsp[-1].goal);
;
    break;}
case 334:
{
  yyval.goal = new DeadlineGoal(yyvsp[-2].rval, yyvsp[-1].goal);
;
    break;}
case 335:
{
  yyval.goal = new TriggeredDeadlineGoal(yyvsp[-2].goal, yyvsp[-3].rval, yyvsp[-1].goal);
;
    break;}
case 337:
{
  if (metric_type != metric_none) {
    if (write_warnings) {
      std::cerr << "warning: multiple :metric expressions - overwriting previous definition" << std::endl;
    }
  }
  metric_type = metric_minimize;
;
    break;}
case 338:
{
  if (metric_type != metric_none) {
    if (write_warnings) {
      std::cerr << "warning: multiple :metric expressions - overwriting previous definition" << std::endl;
    }
  }
  metric_type = metric_maximize;
;
    break;}
case 339:
{
  if (yyvsp[0].exp->exp_class == exp_time) {
    metric = 0;
    metric_type = metric_makespan;
    yyval.exp = 0;
  }
  else {
    metric = yyvsp[0].exp;
    yyval.exp = yyvsp[0].exp;
  }
;
    break;}
case 340:
{
  serial_length = hsps::rational(yyvsp[-1].ival);
;
    break;}
case 341:
{
  parallel_length = hsps::rational(yyvsp[-1].ival);
;
    break;}
case 342:
{ yyval.rval = yyvsp[0].ival; ;
    break;}
case 343:
{ yyval.rval = (hsps::rational(yyvsp[-2].ival,yyvsp[0].ival).reduce()); ;
    break;}
case 344:
{ yyval.rval = yyvsp[0].rval; ;
    break;}
case 345:
{ yyval.rval = POS_INF; ;
    break;}
case 346:
{
  current_item = new DKEL_Item(":invariant");
  current_context = current_item;
;
    break;}
case 348:
{
  dom_sc_invariants.append(new SetConstraint(current_item));
;
    break;}
case 349:
{
  dom_sc_invariants[dom_sc_invariants.length() - 1]->sc_type = yyvsp[-4].sckw;
  dom_sc_invariants[dom_sc_invariants.length() - 1]->sc_count = yyvsp[-3].ival;
  clear_context(current_param);
  current_context = 0;
;
    break;}
case 350:
{
  dom_f_invariants.append(new InvariantFormula(current_item, yyvsp[-1].ff));
  clear_context(current_param);
  current_context = 0;
;
    break;}
case 351:
{
  yyval.ff = new Formula(fc_false);
;
    break;}
case 352:
{
  yyval.ff = new Formula(fc_true);
;
    break;}
case 353:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 354:
{
  ((Atom*)current_atom)->check();
  yyval.ff = new AFormula((Atom*)current_atom);
;
    break;}
case 355:
{
  yyval.ff = new EqFormula((Symbol*)yyvsp[-2].sym->val, (Symbol*)yyvsp[-1].sym->val);
;
    break;}
case 356:
{
  yyval.ff = new NFormula(yyvsp[-1].ff);
;
    break;}
case 357:
{
  yyval.ff = yyvsp[-1].ff;
  yyval.ff->fc = fc_conjunction;
;
    break;}
case 358:
{
  yyval.ff = yyvsp[-1].ff;
  yyval.ff->fc = fc_conjunction;
;
    break;}
case 359:
{
  yyval.ff = new BFormula(fc_implication, yyvsp[-2].ff, yyvsp[-1].ff);
;
    break;}
case 360:
{
  yyval.ff = new BFormula(fc_equivalence, yyvsp[-2].ff, yyvsp[-1].ff);
;
    break;}
case 361:
{
  stored_n_param.append(current_param.length());
;
    break;}
case 362:
{
  QFormula* qf = new QFormula(fc_universal, yyvsp[-1].ff);
  assert(stored_n_param.length() > 0);
  for (hsps::index_type k = stored_n_param[stored_n_param.length() - 1];
       k < current_param.length(); k++) {
    qf->vars.append(current_param[k]);
  }
  clear_context(current_param,
  stored_n_param[stored_n_param.length() - 1],
  current_param.length());
  current_param.set_length(stored_n_param[stored_n_param.length() - 1]);
  stored_n_param.dec_length();
  yyval.ff = qf;
;
    break;}
case 363:
{
  stored_n_param.append(current_param.length());
;
    break;}
case 364:
{
  QFormula* qf = new QFormula(fc_existential, yyvsp[-1].ff);
  assert(stored_n_param.length() > 0);
  for (hsps::index_type k = stored_n_param[stored_n_param.length() - 1];
       k < current_param.length(); k++) {
    qf->vars.append(current_param[k]);
  }
  clear_context(current_param,
  stored_n_param[stored_n_param.length() - 1],
  current_param.length());
  current_param.set_length(stored_n_param[stored_n_param.length() - 1]);
  stored_n_param.dec_length();
  yyval.ff = qf;
;
    break;}
case 365:
{
  ((CFormula*)yyval.ff)->add(yyvsp[0].ff);
;
    break;}
case 366:
{
  yyval.ff = new CFormula(fc_list);
;
    break;}
case 367:
{
  current_item = new IrrelevantItem();
  if (problem_name) current_item->defined_in_problem = true;
  current_context = current_item;
;
    break;}
case 371:
{
  current_atom = new Reference((ActionSymbol*)yyvsp[0].sym->val);
;
    break;}
case 372:
{
  IrrelevantItem* item = (IrrelevantItem*)current_item;
  item->entity = (Reference*)current_atom;
  dom_irrelevant.append(item);
  ActionSymbol* act = (ActionSymbol*)yyvsp[-4].sym->val;
  act->irr_ins.append(item);
  clear_context(current_param);
  current_context = 0;
;
    break;}
case 373:
{
  current_atom = new Reference((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 374:
{
  IrrelevantItem* item = (IrrelevantItem*)current_item;
  item->entity = (Reference*)current_atom;
  dom_irrelevant.append(item);
  PredicateSymbol* pred = (PredicateSymbol*)yyvsp[-4].sym->val;
  pred->irr_ins.append(item);
  clear_context(current_param);
  current_context = 0;
;
    break;}
case 375:
{
  current_item = new DKEL_Item(":invariant");
  current_item->defined_in_problem = true;
  current_context = current_item;
;
    break;}
case 377:
{
  dom_sc_invariants.append(new SetConstraint(current_item));
;
    break;}
case 378:
{
  dom_sc_invariants[dom_sc_invariants.length() - 1]->sc_type = yyvsp[-4].sckw;
  dom_sc_invariants[dom_sc_invariants.length() - 1]->sc_count = yyvsp[-3].ival;
  clear_context(current_param);
  current_context = 0;
;
    break;}
case 379:
{
  dom_f_invariants.append(new InvariantFormula(current_item, yyvsp[-1].ff));
  clear_context(current_param);
  current_context = 0;
;
    break;}
case 385:
{
  current_item->item_tags.insert(yyvsp[0].sym->text);
;
    break;}
case 386:
{
  yyvsp[0].sym->val = new Symbol(sym_misc, yyvsp[0].sym->text);
  current_item->name = (Symbol*)yyvsp[0].sym->val;
  current_item->item_tags.insert(yyvsp[0].sym->text);
;
    break;}
case 387:
{
  current_item->name = (Symbol*)yyvsp[0].sym->val;
  current_item->item_tags.insert(yyvsp[0].sym->text);
;
    break;}
case 388:
{
  current_param.clear();
;
    break;}
case 389:
{
  current_context->param = current_param;
;
    break;}
case 392:
{
  for (hsps::index_type k = stored_n_param[stored_n_param.length() - 1];
       k < current_param.length(); k++) {
    current_context->param.append(current_param[k]);
  }
;
    break;}
case 417:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 418:
{
  ((Atom*)current_atom)->check();
  current_context->pos_con.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->pos_pre = true;
;
    break;}
case 419:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 420:
{
  ((Atom*)current_atom)->check();
  current_context->pos_con.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->pos_pre = true;
;
    break;}
case 421:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val, md_init);
;
    break;}
case 422:
{
  ((Atom*)current_atom)->check();
  current_context->pos_con.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->pos_pre = true;
;
    break;}
case 423:
{
  Atom* eq_atom = new Atom(dom_eq_pred);
  eq_atom->param.set_length(2);
  eq_atom->param[0] = (Symbol*)yyvsp[-2].sym->val;
  eq_atom->param[1] = (Symbol*)yyvsp[-1].sym->val;
  current_context->pos_con.append(eq_atom);
;
    break;}
case 424:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 425:
{
  ((Atom*)current_atom)->check();
  current_context->neg_con.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->neg_pre = true;
;
    break;}
case 426:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 427:
{
  ((Atom*)current_atom)->check();
  current_context->neg_con.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->neg_pre = true;
;
    break;}
case 428:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val, md_init);
;
    break;}
case 429:
{
  ((Atom*)current_atom)->check();
  current_context->neg_con.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->neg_pre = true;
;
    break;}
case 430:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val, md_init);
;
    break;}
case 431:
{
  ((Atom*)current_atom)->check();
  current_context->neg_con.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->neg_pre = true;
;
    break;}
case 432:
{
  Atom* eq_atom = new Atom(dom_eq_pred);
  eq_atom->param.set_length(2);
  eq_atom->param[0] = (Symbol*)yyvsp[-3].sym->val;
  eq_atom->param[1] = (Symbol*)yyvsp[-2].sym->val;
  current_context->neg_con.append(eq_atom);
;
    break;}
case 433:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val, md_pos_goal);
;
    break;}
case 434:
{
  ((Atom*)current_atom)->check();
  current_context->pos_con.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->pos_pre = true;
;
    break;}
case 435:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val, md_neg_goal);
;
    break;}
case 436:
{
  ((Atom*)current_atom)->check();
  current_context->pos_con.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->pos_pre = true;
;
    break;}
case 437:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val, md_pos_goal);
;
    break;}
case 438:
{
  ((Atom*)current_atom)->check();
  current_context->neg_con.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->neg_pre = true;
;
    break;}
case 439:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val, md_neg_goal);
;
    break;}
case 440:
{
  ((Atom*)current_atom)->check();
  current_context->neg_con.append((Atom*)current_atom);
  ((Atom*)current_atom)->pred->neg_pre = true;
;
    break;}
case 441:
{
  TypeConstraint* c =
    new TypeConstraint((VariableSymbol*)yyvsp[-1].sym->val, (TypeSymbol*)yyvsp[-2].sym->val);
  current_context->type_con.append(c);
;
    break;}
case 442:
{
  TypeConstraint* c =
    new TypeConstraint((VariableSymbol*)yyvsp[-1].sym->val, (TypeSymbol*)yyvsp[-2].sym->val);
  current_context->type_con.append(c);
;
    break;}
case 443:
{
  yyval.sckw = sc_at_least;
;
    break;}
case 444:
{
  yyval.sckw = sc_at_most;
;
    break;}
case 445:
{
  yyval.sckw = sc_exactly;
;
    break;}
case 449:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 450:
{
  ((Atom*)current_atom)->check();
  dom_sc_invariants[dom_sc_invariants.length()-1]->pos_atoms.append((Atom*)current_atom);
;
    break;}
case 451:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 452:
{
  ((Atom*)current_atom)->check();
  dom_sc_invariants[dom_sc_invariants.length()-1]->neg_atoms.append((Atom*)current_atom);
;
    break;}
case 453:
{
  stored_n_param.append(current_param.length());
  current_context = new SetOf();
;
    break;}
case 454:
{
  SetOf* s = (SetOf*)current_context;
  for (hsps::index_type k = stored_n_param[stored_n_param.length() - 1];
       k < current_param.length(); k++) {
    s->param.append(current_param[k]);
  }
;
    break;}
case 455:
{
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 456:
{
  ((Atom*)current_atom)->check();
  SetOf* s = (SetOf*)current_context;
  s->pos_atoms.append((Atom*)current_atom);
  dom_sc_invariants[dom_sc_invariants.length()-1]->atom_sets.append(s);
  assert(stored_n_param.length() > 0);
  clear_context(current_param,
  stored_n_param[stored_n_param.length() - 1],
  current_param.length());
  current_param.set_length(stored_n_param[stored_n_param.length() - 1]);
  stored_n_param.dec_length();
  current_context = 0;
;
    break;}
case 457:
{
  input_plans.append(new InputPlan());
  if (current_plan_file != current_file()) {
    n_plans_in_current_file = 0;
    current_plan_file = current_file();
  }
;
    break;}
case 458:
{
  if (input_plans[input_plans.length() - 1]->name == 0)
    if (current_plan_file) {
      std::ostringstream pn;
      pn << current_plan_file << ":" << n_plans_in_current_file;
      Symbol* plan_file_name = new Symbol(sym_misc, strdup(pn.str().c_str()));
      input_plans[input_plans.length() - 1]->name = plan_file_name;
    }
  n_plans_in_current_file += 1;
;
    break;}
case 460:
{
  assert(input_plans.length() > 0);
  input_plans[input_plans.length() - 1]->is_opt = true;
;
    break;}
case 463:
{
  assert(input_plans.length() > 0);
  input_plans[input_plans.length() - 1]->name = new Symbol(yyvsp[0].sym->text);
;
    break;}
case 464:
{
  current_atom = new Reference((ActionSymbol*)yyvsp[0].sym->val);
;
    break;}
case 465:
{
  Reference* ref = (Reference*)current_atom;
  ActionSymbol* act = (ActionSymbol*)yyvsp[-3].sym->val;
  act->refs.append(ref);
  assert(input_plans.length() > 0);
  input_plans[input_plans.length() - 1]->
    steps.append(new InputPlanStep(ref, yyvsp[-6].rval));
  clear_context(current_param);
;
    break;}
case 466:
{
  current_plan_file = 0;
;
    break;}
case 467:
{
  current_plan_file = 0;
;
    break;}
case 470:
{
  current_atom = new Reference((ActionSymbol*)yyvsp[0].sym->val);
;
    break;}
case 471:
{
  Reference* ref = (Reference*)current_atom;
  ActionSymbol* act = (ActionSymbol*)yyvsp[-4].sym->val;
  act->refs.append(ref);
  if (input_plans.length() == 0) {
    at_position(std::cerr) << "beginning of new plan" << std::endl;
    input_plans.append(new InputPlan());
    if (current_file()) {
      Symbol* plan_file_name = new Symbol(sym_misc, current_file());
      input_plans[input_plans.length() - 1]->name = plan_file_name;
    }
    current_plan_file = current_file();
  }
  else if (current_file() != current_plan_file) {
    at_position(std::cerr) << "beginning of new plan (new file)" << std::endl;
    input_plans.append(new InputPlan());
    if (current_file()) {
      Symbol* plan_file_name = new Symbol(sym_misc, current_file());
      input_plans[input_plans.length() - 1]->name = plan_file_name;
    }
    current_plan_file = current_file();
  }
  input_plans[input_plans.length() - 1]->
    steps.append(new InputPlanStep(ref, yyvsp[-7].rval));
  clear_context(current_param);
;
    break;}
case 476:
{
  current_atom = new Reference((ActionSymbol*)yyvsp[0].sym->val);
;
    break;}
case 477:
{
  Reference* ref = (Reference*)current_atom;
  ActionSymbol* act = (ActionSymbol*)yyvsp[-3].sym->val;
  act->refs.append(ref);
  if (input_plans.length() == 0) {
    at_position(std::cerr) << "beginning of new plan" << std::endl;
    input_plans.append(new InputPlan());
    if (current_file()) {
      Symbol* plan_file_name = new Symbol(sym_misc, current_file());
      input_plans[input_plans.length() - 1]->name = plan_file_name;
    }
    current_plan_file = current_file();
  }
  else if (current_file() != current_plan_file) {
    at_position(std::cerr) << "beginning of new plan (new file)" << std::endl;
    input_plans.append(new InputPlan());
    if (current_file()) {
      Symbol* plan_file_name = new Symbol(sym_misc, current_file());
      input_plans[input_plans.length() - 1]->name = plan_file_name;
    }
    current_plan_file = current_file();
  }
  hsps::index_type n = input_plans[input_plans.length() - 1]->steps.length();
  input_plans[input_plans.length() - 1]->
    steps.append(new InputPlanStep(ref, n));
  clear_context(current_param);
;
    break;}
case 481:
{
  current_entry = new HTableEntry();
;
    break;}
case 482:
{
  h_table.append(current_entry);
  current_entry = 0;
;
    break;}
case 483:
{
  current_entry->cost = yyvsp[0].rval;
  current_entry->opt = true;
;
    break;}
case 484:
{
  current_entry->cost = yyvsp[0].rval;
;
    break;}
case 489:
{
  assert(current_entry);
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 490:
{
  ((Atom*)current_atom)->check();
  current_entry->atoms.append((Atom*)current_atom);
  current_entry->neg.append(false);
  assert(current_entry->atoms.length() == current_entry->neg.length());
;
    break;}
case 491:
{
  assert(current_entry);
  current_atom = new Atom((PredicateSymbol*)yyvsp[0].sym->val);
;
    break;}
case 492:
{
  ((Atom*)current_atom)->check();
  current_entry->atoms.append((Atom*)current_atom);
  current_entry->neg.append(true);
  assert(current_entry->atoms.length() == current_entry->neg.length());
;
    break;}
case 493:
{
  ReferenceSet* set = new ReferenceSet();
  current_context = set;
  stored_n_param.assign_value(0, 1);
  current_param.clear();
  input_sets.append(set);
;
    break;}
case 494:
{
  clear_context(current_param);
  current_context = 0;
;
    break;}
case 495:
{
  yyvsp[0].sym->val = new Symbol(sym_misc, yyvsp[0].sym->text);
  ((ReferenceSet*)current_context)->name = (Symbol*)yyvsp[0].sym->val;
;
    break;}
case 496:
{
  ((ReferenceSet*)current_context)->name = (Symbol*)yyvsp[0].sym->val;
;
    break;}
case 501:
{
  if (yyvsp[0].sym->val) {
    current_atom = new Reference((Symbol*)yyvsp[0].sym->val, false, true);
  }
  else {
    current_atom = new Reference(new Symbol(sym_misc, yyvsp[0].sym->text), false, true);
  }
;
    break;}
case 502:
{
  assert(input_sets.length() > 0);
  assert(input_sets[input_sets.length() - 1] != 0);
  input_sets[input_sets.length() - 1]->
    add(new SimpleReferenceSet((Reference*)current_atom));
;
    break;}
case 503:
{
  assert(input_sets.length() > 0);
  assert(input_sets[input_sets.length() - 1] != 0);
  if (yyvsp[0].sym->val) {
    input_sets[input_sets.length() - 1]->add
      (new SimpleReferenceSet(new Reference((Symbol*)yyvsp[0].sym->val, false, false)));
  }
  else {
    input_sets[input_sets.length() - 1]->add
      (new SimpleReferenceSet(new Reference(new Symbol(sym_misc, yyvsp[0].sym->text), false, false)));
  }
;
    break;}
case 504:
{
  stored_n_param.append(current_param.length());
  stored_context.append(current_context);
  current_context = new SimpleReferenceSet(0);
;
    break;}
case 505:
{
  assert(stored_n_param.length() > 0);
  assert(stored_context.length() > 0);
  clear_context(current_param,
  stored_n_param[stored_n_param.length() - 1],
  current_param.length());
  current_param.set_length(stored_n_param[stored_n_param.length() - 1]);
  stored_n_param.dec_length();
  current_context = stored_context[stored_context.length() - 1];
  stored_context.dec_length();
;
    break;}
case 506:
{
  if (yyvsp[0].sym->val) {
    current_atom = new Reference((Symbol*)yyvsp[0].sym->val, false, true);
  }
  else {
    current_atom = new Reference(new Symbol(sym_misc, yyvsp[0].sym->text), false, true);
  }
;
    break;}
case 507:
{
  SimpleReferenceSet* s = (SimpleReferenceSet*)current_context;
  s->ref = (Reference*)current_atom;
  assert(input_sets.length() > 0);
  assert(input_sets[input_sets.length() - 1] != 0);
  input_sets[input_sets.length() - 1]->add(s);
;
    break;}
case 508:
{
  if (yyvsp[0].sym->val) {
    current_atom = new Reference((Symbol*)yyvsp[0].sym->val, true, true);
  }
  else {
    current_atom = new Reference(new Symbol(sym_misc, yyvsp[0].sym->text), true, true);
  }
;
    break;}
case 509:
{
  SimpleReferenceSet* s = (SimpleReferenceSet*)current_context;
  s->ref = (Reference*)current_atom;
  assert(input_sets.length() > 0);
  assert(input_sets[input_sets.length() - 1] != 0);
  input_sets[input_sets.length() - 1]->add(s);
;
    break;}
}
  yyvsp -= yylen;
  yyssp -= yylen;
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "state stack now");
      while (ssp1 != yyssp)
 fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
  *++yyvsp = yyval;
  yyn = yyr1[yyn];
  yystate = yypgoto[yyn - 115] + *yyssp;
  if (yystate >= 0 && yystate <= 1519 && yycheck[yystate] == *yyssp)
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - 115];
  goto yynewstate;
yyerrlab:
  if (! yyerrstatus)
    {
      ++yynerrs;
      yyn = yypact[yystate];
      if (yyn > -32768 && yyn < 1519)
 {
   int size = 0;
   char *msg;
   int x, count;
   count = 0;
   for (x = (yyn < 0 ? -yyn : 0);
        x < (sizeof(yytname) / sizeof(char *)); x++)
     if (yycheck[x + yyn] == x)
       size += strlen(yytname[x]) + 15, count++;
   msg = (char *) malloc(size + 15);
   if (msg != 0)
     {
       strcpy(msg, "parse error");
       if (count < 5)
  {
    count = 0;
    for (x = (yyn < 0 ? -yyn : 0);
         x < (sizeof(yytname) / sizeof(char *)); x++)
      if (yycheck[x + yyn] == x)
        {
   strcat(msg, count == 0 ? ", expecting `" : " or `");
   strcat(msg, yytname[x]);
   strcat(msg, "'");
   count++;
        }
  }
       log_error(msg);
       free(msg);
     }
   else
     log_error ("parse error; also virtual memory exceeded");
 }
      else
 log_error("parse error");
    }
  goto yyerrlab1;
yyerrlab1:
  if (yyerrstatus == 3)
    {
      if (yychar == 0)
 return(1);
      if (yydebug)
 fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
      yychar = -2;
    }
  yyerrstatus = 3;
  goto yyerrhandle;
yyerrdefault:
yyerrpop:
  if (yyssp == yyss) return(1);
  yyvsp--;
  yystate = *--yyssp;
  if (yydebug)
    {
      short *ssp1 = yyss - 1;
      fprintf (stderr, "Error: state stack now");
      while (ssp1 != yyssp)
 fprintf (stderr, " %d", *++ssp1);
      fprintf (stderr, "\n");
    }
yyerrhandle:
  yyn = yypact[yystate];
  if (yyn == -32768)
    goto yyerrdefault;
  yyn += 1;
  if (yyn < 0 || yyn > 1519 || yycheck[yyn] != 1)
    goto yyerrdefault;
  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == -32768)
 goto yyerrpop;
      yyn = -yyn;
      goto yyreduce;
    }
  else if (yyn == 0)
    goto yyerrpop;
  if (yyn == 1162)
    return(0);
  if (yydebug)
    fprintf(stderr, "Shifting error token, ");
  *++yyvsp = yylval;
  yystate = yyn;
  goto yynewstate;

}
