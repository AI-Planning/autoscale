#include <string.h>
inline char* strndup(char* s, unsigned int n)
{
  char* d = new char[n+1];
  strncpy(s, d, n);
  return d;
}
#include <assert.h>
#include <limits.h>
#include <vector>
#include <utility>
#include <iostream>
namespace hsps {
typedef unsigned int index_type;
const index_type index_type_max = (UINT_MAX - 1);

const index_type LARGE_PRIME = 2147483629U;
const index_type no_such_index = UINT_MAX;

typedef unsigned long count_type;
const count_type count_type_max = ULONG_MAX;

template<class T> class swapable_pair : public std::pair<T, T>
{
 public:
  swapable_pair()
    : std::pair<T, T>() { };
  swapable_pair(const T& v1, const T& v2)
    : std::pair<T, T>(v1, v2) { };
  swapable_pair(const T& v)
    : std::pair<T, T>(v, v) { };
  swapable_pair(const swapable_pair& p)
    : std::pair<T, T>(p) { };

  void swap();
};

template<class T> class comparable_pair : public swapable_pair<T>
{
 public:
  comparable_pair()
    : swapable_pair<T>() { };
  comparable_pair(const T& v1, const T& v2)
    : swapable_pair<T>(v1, v2) { };
  comparable_pair(const T& v)
    : swapable_pair<T>(v) { };
  comparable_pair(const comparable_pair& p)
    : swapable_pair<T>(p) { };

  void sort_ascending();
  void sort_descending();
};

typedef comparable_pair<index_type> index_pair;

template<class T> class zero_init_pair : public comparable_pair<T>
{
 public:
  zero_init_pair()
    : comparable_pair<T>(0) { };
  zero_init_pair(const T& v1, const T& v2)
    : comparable_pair<T>(v1, v2) { };
  zero_init_pair(const T& v)
    : comparable_pair<T>(v) { };
  zero_init_pair(const zero_init_pair& p)
    : comparable_pair<T>(p) { };
};




class index_set;
class bool_vec;

template<class T> class lvector : public std::vector<T>
{
 public:
  lvector() : std::vector<T>() { };
  lvector(const T& v, index_type l) : std::vector<T>(l, v) { };
  lvector(const lvector<T>& vec) : std::vector<T>(vec) { };




  class element_reference {
    lvector* _vec;
    index_type _pos;
  public:
    element_reference() : _vec(0), _pos(no_such_index) { };
    element_reference(lvector& v, index_type p) : _vec(&v), _pos(p) { };
    operator T*() const {
      if (_vec == 0) return 0;
      return &((*_vec)[_pos]);
    };
  };

  class order {
   public:
    virtual bool operator()(const T& v0, const T& v1) const = 0;
  };

  index_type length() const;
  bool contains(const T& v) const;
  index_type first(const T& v) const;
  index_type next(const T& v, index_type i) const;
  index_type find(const T& v, bool_vec& s) const;
  index_type count(const T& v) const;
  index_type arg_max() const;
  index_type arg_min() const;
  index_type arg_first(const order& o) const;
  index_type arg_last(const order& o) const;
  index_pair first_common(const lvector<T>& vec) const;
  index_pair next_common(const lvector<T>& vec, index_pair p) const;
  void difference(const lvector& v1, lvector& d0, lvector& d1);
  bool operator==(const lvector& _vec) const;
  bool operator!=(const lvector& _vec) const;
  bool operator<(const lvector& vec) const;
  bool operator>(const lvector& vec) const;
  bool operator<=(const lvector& vec) const;
  bool operator>=(const lvector& vec) const;
  void assign_copy(const lvector& _vec);
  void assign_copy(const T* _arr, index_type n);
  void assign_value(const T& val);
  void assign_value(const T& val, index_type l);
  void assign_remap(const lvector& vec, const lvector<index_type>& map);
  void remap(const lvector<index_type>& map);
  void assign_select(const lvector& _vec, const index_set& s);
  void assign_select(const lvector& _vec, const bool_vec& s);
  const lvector& operator=(const lvector& _vec);
  void set_length(index_type l);
  void set_length(index_type l, const T& v);
  void inc_length_to(index_type l);
  void inc_length_to(index_type l, const T& v);
  index_type inc_length() { return inc_length(1); };
  index_type inc_length(index_type d);
  index_type inc_length(index_type d, const T& v);
  index_type dec_length() { return dec_length(1); };
  index_type dec_length(index_type d);
  void clear();
  void append(const T& v);
  void append(const lvector& v);
  T& append();
  void insert(const T& v, index_type p);
  index_type insert_ordered(const T& v, const order& o, index_type f = 0);
  index_type insert_ordered(const lvector& vec, const order& o);
  void remove(index_type p);
  void remove(index_type p0, index_type p1);
  void remove(const index_set& s);
  void remove(const index_set& s, lvector<index_type>& map);
  void remove(const bool_vec& s);
  void remove(const bool_vec& s, lvector<index_type>& map);
  void remove_duplicate_elements();
  void swap(index_type i, index_type j);
};
template<class T> class auto_expanding_vector : public lvector<T>
{
  T _default;
 public:
  auto_expanding_vector() : lvector<T>() { };
  auto_expanding_vector(const T& v, index_type l)
    : lvector<T>(v, l), _default(v) { };
  auto_expanding_vector(const lvector<T>& vec)
    : lvector<T>(vec) { };
  auto_expanding_vector(const auto_expanding_vector<T>& vec)
    : lvector<T>(vec), _default(vec._default) { };
  typename std::vector<T>::reference
  operator[](typename std::vector<T>::size_type k)
  {
    this->inc_length_to(k + 1, _default);
    return lvector<T>::operator[](k);
  };
  typename std::vector<T>::const_reference
  operator[](typename std::vector<T>::size_type k) const
  {
    if (k >= std::vector<T>::size())
      return _default;
    else
      return lvector<T>::operator[](k);
  };
  void assign_value(const T& val)
  {
    _default = val;
    lvector<T>::assign_value(val);
  };
  void assign_value(const T& val, index_type l)
  {
    _default = val;
    lvector<T>::assign_value(val, l);
  };
};
typedef lvector<index_type> index_vec;
typedef lvector<index_pair> pair_vec;
class index_vec_util : public index_vec
{
 public:
  class decreasing_index_order : public index_vec::order {
  public:
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      { return (v0 > v1); };
  };
  class increasing_index_order : public index_vec::order {
  public:
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      { return (v0 < v1); };
  };
  class increasing_value_order : public index_vec::order {
    const index_vec& value;
  public:
    increasing_value_order(const index_vec& v) : value(v) { };
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      {
 assert(v0 < value.length());
 assert(v1 < value.length());
 return (value[v0] < value[v1]);
      };
  };
  static class decreasing_index_order decreasing;
  static class increasing_index_order increasing;
  static void fill(index_vec& vec, index_type max);
  static index_type min(const index_vec& vec, index_type def = no_such_index);
  static index_type max(const index_vec& vec, index_type def = no_such_index);
  static int compare(const index_vec& v0, const index_vec& v1);
  static index_type hash(const index_vec& vec);
  void fill(index_type max);
  int compare(const index_vec& v1) const;
  index_type hash() const;
};
void factors(index_type n, index_vec& f);
template<class T> class svector : public lvector<T>
{
 public:
  svector() : lvector<T>() { };
  svector(const svector<T>& _svec) : lvector<T>(_svec) { };
  svector(const lvector<T>& _lvec) : lvector<T>() {
    for (index_type k = 0; k < _lvec.size(); k++) insert(_lvec[k]);
  };
  bool contains(const T& v) const;
  bool contains(const svector& vec) const;
  bool subset(const svector& vec) const;
  index_pair first_common(const lvector<T>& vec) const;
  index_pair next_common(const lvector<T>& vec, index_pair p) const;
  index_pair first_common(const svector<T>& vec) const;
  index_pair next_common(const svector<T>& vec, index_pair p) const;
  index_type count_common(const svector& vec) const;
  void assign_singleton(const T& _val);
  void assign_values(const lvector<T>& vec);
  void insert(const T& v);
  void insert(const lvector<T>& vec);
  void intersect(const svector& vec);
  void difference(const svector& vec);
  void subtract(const svector& vec);
  void subtract(const T& v);
};
class index_set : public svector<index_type>
{
 public:
  index_set()
    : svector<index_type>() { };
  index_set(const index_set& _svec)
    : svector<index_type>(_svec) { };
  index_set(const lvector<index_type>& _lvec)
    : svector<index_type>(_lvec) { };
  index_set(const bool* _arr, index_type n);
  index_set(const bool_vec& _vec);
  index_set(const index_set& s0, const index_set& s);
  index_set(const index_set& s0, const bool_vec& s);
  index_set(const index_set& s0, const index_vec& map);
  index_type first_common_element(const index_set& set) const;
  index_type first_common_element(const index_vec& vec) const;
  index_type first_common_element(const bool_vec vec) const;
  index_type first_common_element(const bool* vec, index_type n) const;
  index_type count_common(const index_set& set) const;
  index_type count_common(const bool_vec& set) const;
  bool have_common_element(const index_set& set) const;
  bool have_common_element(const bool_vec& set) const;
  void insert(const index_type& v);
  void insert(const index_vec& vec);
  void insert(const bool_vec& set);
  void intersect(const index_set& vec);
  void intersect(const bool_vec& set);
  void subtract(const index_vec& vec);
  void subtract(const bool_vec& set);
  void subtract(const index_type& v);
  bool* copy_to(bool* s, index_type n) const;
  void fill(index_type to);
  void assign_remap(const index_set& set, const index_vec& map);
  void remap(const index_vec& map);
};
extern const index_set EMPTYSET;
typedef svector<index_pair> pair_set;
class bool_vec : public lvector<bool>
{
 public:
  bool_vec() : lvector<bool>() { };
  bool_vec(bool _val, index_type l) : lvector<bool>(_val, l) { };
  bool_vec(const bool_vec& _vec) : lvector<bool>(_vec) { };
  bool_vec(const bool* _arr, index_type n) : lvector<bool>(false, n) {
    for (index_type k = 0; k < n; k++) {
      if (_arr[k])
 (*this)[k] = true;
      else
 (*this)[k] = false;
    }
  };
  bool_vec(const index_set& set, index_type l);
  void complement();
  void insert(const bool_vec& vec);
  void insert(const index_set& set);
  void intersect(const bool_vec& vec);
  void intersect(const index_set& set);
  void subtract(const bool_vec& vec);
  void subtract(const index_set& set);
  bool subset(const bool_vec& vec) const;
  bool strict_subset(const bool_vec& vec) const;
  bool superset(const bool_vec& vec) const;
  bool strict_superset(const bool_vec& vec) const;
  bool contains(const bool& v) const;
  bool contains(const bool_vec& set) const;
  bool contains(const index_set& set) const;
  bool contains_any(const index_set& set) const;
  index_type first_common_element(const index_set& vec) const;
  index_type first_common_element(const bool_vec vec) const;
  index_type count_common(const bool_vec& vec) const;
  index_type count_common(const index_set& set) const;
  index_set& copy_to(index_set& set) const;
  index_set& insert_into(index_set& set) const;
  index_set& subtract_from(index_set& set) const;
  bool* copy_to(bool* s, index_type n) const;
  int compare(const bool_vec& vec) const;
  index_type hash() const;
};
class index_set_vec : public lvector<index_set>
{
 public:
  index_set_vec()
    : lvector<index_set>() { };
  index_set_vec(const index_set& set, index_type l)
    : lvector<index_set>(set, l) { };
  index_set_vec(index_type l)
    : lvector<index_set>(EMPTYSET, l) { };
  index_set_vec(const index_set_vec& vec)
    : lvector<index_set>(vec) { };
  class decreasing_cardinality_order : public index_set_vec::order {
  public:
    virtual bool operator()
      (const index_set& v0, const index_set& v1) const
      { return (v0.size() > v1.size()); };
  };
  decreasing_cardinality_order decreasing_cardinality;
  index_type minimum_cardinality() const;
  index_type maxmimum_cardinality() const;
  index_type selected_minimum_cardinality(const index_set& sel) const;
  index_type selected_maximum_cardinality(const index_set& sel) const;
  index_type first_minimum_cardinality_set() const;
  index_type first_maxmimum_cardinality_set() const;
  index_type first_superset(const index_set& set) const;
  index_type first_strict_superset(const index_set& set) const;
  index_type first_subset(const index_set& set) const;
  index_type first_strict_subset(const index_set& set) const;
  index_set& union_set(index_set& set) const;
  index_set& selected_union_set(const index_set& sel, index_set& set) const;
  index_set& intersection_set(index_set& set) const;
  void insert_maximal(const index_set& set);
  void insert_minimal(const index_set& set);
  void reduce_to_maximal();
  void reduce_to_minimal();
  void append_if_not_subset(const index_set& set);
  void append_if_not_superset(const index_set& set);
  void append_if_new(const index_set& set);
  void remove_sets_size_le(index_type l);
  void remove_empty_sets();
  void insert_in_all(index_type i);
  void insert_in_all(const index_set& set);
  void subtract_from_all(index_type i);
  void subtract_from_all(const index_set& set);
  void combinations_by_union(const index_set_vec& sv);
  void combinations_by_union(const index_set_vec& sv1,
        const index_set_vec& sv2);
};
template<class T> class matrix : public lvector< lvector<T> >
{
 public:
  typedef lvector<T> row_type;
  matrix()
    : lvector<row_type>() { };
  matrix(const T& _val, index_type r, index_type c)
    : lvector<row_type>(row_type(_val, c), r) { };
  matrix(const matrix& _mat)
    : lvector<row_type>(_mat) { };
  index_type rows() const
  {
    return lvector<row_type>::length();
  };
  index_type columns() const
  {
    if (lvector<row_type>::length() == 0) return 0;
    else return (*this)[0].length();
  };
  void set_size(index_type r, index_type c);
  void assign_value(const T& _val);
  void assign_value(const T& _val, index_type r, index_type c);
};
class bool_matrix : public matrix<bool> {
 public:
  bool_matrix()
    : matrix<bool>() { };
  bool_matrix(const bool& v, index_type r, index_type c)
    : matrix<bool>(v, c, r) { };
  bool_matrix(const bool_matrix& m)
    : matrix<bool>(m) { };
  void complement();
  void insert(const bool_matrix& m);
  void intersect(const bool_matrix& m);
  void subtract(const bool_matrix& m);
  void multiply(const bool_matrix& m0, const bool_matrix& m1);
  void transitive_closure();
};
typedef matrix<index_type> index_matrix;
class mapping : public index_vec
{
 public:
  static void identity_map
    (index_type n, index_vec& map)
    { index_vec_util::fill(map, n); };
  static bool invert_map
    (const index_vec& map, index_vec& inv, index_type m = 0);
  static void delete_index_map
    (index_type n, index_type i, index_vec& map);
  static void compose
    (const index_vec& m0, const index_vec& m1, index_vec& cm);
  static void map_image
    (const index_vec& map, const index_vec& vec, index_vec& img);
  static void inverse_map_image
    (const index_vec& map, index_type x, index_set& img);
  static void inverse_map_image
    (const index_vec& map, const index_set& x, index_set& img);
  static index_type range(const index_vec& map, index_type d);
  mapping()
    : index_vec() { };
  mapping(index_type n)
    : index_vec() { identity_map(n, *this); };
  mapping(index_type n, index_type i, bool out) : index_vec() {
    if (out) delete_index_map(n, i, *this); else assign_value(i, n);
  };
  mapping(const mapping& map)
    : index_vec(map) { };
  void assign_identity(index_type n)
    { identity_map(n, *this); };
  index_type operator()(index_type x) const
    { assert(x < size()); return (*this)[x]; };
  index_vec operator()(const index_vec& vec) const
    { index_vec res; map_image(*this, vec, res); return res; };
  index_vec& inverse(index_type x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  index_vec& inverse(const index_set& x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  bool invert(index_vec& rmap) const
    { return invert_map(*this, rmap); };
  bool invert()
    { index_vec tmp(*this); return invert_map(tmp, *this); };
  index_type range() const
    { return range(*this, length()); };
};
class sparse_mapping : public pair_vec
{
 public:
  static void dense_to_sparse(const index_vec& dm, pair_vec sm);
  static void sparse_to_dense(const pair_vec& sm, index_vec dm);
  static index_type map_image
    (const pair_vec& map, index_type x);
  static void map_image
    (const pair_vec& map, const index_vec& vec, index_vec& img);
  static void inverse_map_image
    (const pair_vec& map, index_type x, index_set& img);
  static void inverse_map_image
    (const pair_vec& map, const index_set& x, index_set& img);
  sparse_mapping()
    : pair_vec() { };
  sparse_mapping(const pair_vec& m)
    : pair_vec(m) { };
  sparse_mapping(const index_vec& m)
    : pair_vec() { dense_to_sparse(m, *this); };
  index_type operator()(index_type x) const
    { return map_image(*this, x); };
  index_vec operator()(const index_vec& vec) const
    { index_vec res; map_image(*this, vec, res); return res; };
  index_set& inverse(index_type x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  index_set& inverse(const index_set& x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
};
class equivalence : public index_vec
{
 public:
  equivalence()
    : index_vec() { };
  equivalence(index_type n)
    : index_vec(no_such_index, n) { index_vec_util::fill(*this, n); };
  equivalence(const equivalence& eq)
    : index_vec(eq) { };
  bool operator()(index_type a, index_type b) const;
  index_type canonical(index_type a) const;
  void extend(index_type a);
  void merge(index_type a, index_type b);
  void merge(const equivalence& eq);
  void merge(const index_set& set);
  void merge(const index_set& sa, const index_set& sb);
  void reset();
  void reset(index_type n);
  void canonical_set(index_set& set) const;
  void canonical_elements(index_set& set) const;
  void class_elements(index_type rep, index_set& set) const;
  index_type n_class_elements(index_type rep) const;
  void classes(index_set_vec& sets) const;
  void make_map(index_vec& map) const;
  index_type n_classes() const;
  index_type n_squeezed() const;
};
class set_hash_function : index_vec
{
 public:
  set_hash_function(index_type n)
    : index_vec() { init(n); };
  void init(index_type n);
  index_type operator()(index_type& i, index_type v) const;
  index_type operator()(const index_set& set) const;
  index_type operator()(const bool_vec& set) const;
  index_type operator()(const bool* set, index_type n) const;
};
template<class T, class N> struct weighted
{
  T value;
  N weight;
  weighted() : weight(0) { };
  weighted(const T& v) : value(v), weight(0) { };
  weighted(const T& v, const N& w) : value(v), weight(w) { };
  weighted(const weighted& w) : value(w.value), weight(w.weight) { };
  ~weighted() { };
  weighted& operator=(const T& v)
  {
    value = v;
    weight = 0;
    return *this;
  };
  weighted& operator=(const weighted& w)
  {
    value = w.value;
    weight = w.weight;
    return *this;
  };
  bool operator==(const weighted& w) const
  {
    return (value == w.value);
  };
  bool operator!=(const weighted& w) const
  {
    return (value != w.value);
  };
  bool operator<(const weighted& w) const
  {
    return (value < w.value);
  };
  bool operator<=(const weighted& w) const
  {
    return (value <= w.value);
  };
  bool operator>(const weighted& w) const
  {
    return (value > w.value);
  };
  bool operator>=(const weighted& w) const
  {
    return (value >= w.value);
  };
};
template<class T, class N> class weighted_vec
: public lvector< weighted<T, N> >
{
 public:
  class decreasing_weight_order : public lvector< weighted<T,N> >::order {
  public:
    virtual bool operator()
      (const weighted<T,N>& v0, const weighted<T,N>& v1) const
      { return (v0.weight > v1.weight); };
  };
  class increasing_weight_order : public lvector< weighted<T,N> >::order {
  public:
    virtual bool operator()
      (const weighted<T,N>& v0, const weighted<T,N>& v1) const
      { return (v0.weight < v1.weight); };
  };
  static class decreasing_weight_order decreasing;
  static class increasing_weight_order increasing;
  void insert_increasing(const weighted<T,N>& v);
  void insert_decreasing(const weighted<T,N>& v);
  void insert_increasing(const T& v, const N& w);
  void insert_decreasing(const T& v, const N& w);
};
template<class T, class N> class weighted_set
: public svector< weighted<T,N> >
{
 public:
  void insert(const T& v, const N& w);
  void insert(const T& v);
  index_type arg_max();
  index_type arg_min();
};
template<class T>
bool lvector<T>::operator==(const lvector& _vec) const
{
  if (lvector<T>::size() != _vec.size()) return false;
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if (!((*this)[k] == _vec[k])) return false;
  return true;
}
template<class T>
bool lvector<T>::operator!=(const lvector& _vec) const
{
  if (*this == _vec) return false;
  else return true;
}
template<class T>
bool lvector<T>::operator<(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return true;
  else if (lvector<T>::size() > vec.size()) return false;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return true;
      else if ((*this)[k] > vec[k]) return false;
    }
    return false;
  }
}
template<class T>
bool lvector<T>::operator<=(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return true;
  else if (lvector<T>::size() > vec.size()) return false;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return true;
      else if ((*this)[k] > vec[k]) return false;
    }
    return true;
  }
}
template<class T>
bool lvector<T>::operator>(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return false;
  else if (lvector<T>::size() > vec.size()) return true;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return false;
      else if ((*this)[k] > vec[k]) return true;
    }
    return false;
  }
}
template<class T>
bool lvector<T>::operator>=(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return false;
  else if (lvector<T>::size() > vec.size()) return true;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return false;
      else if ((*this)[k] > vec[k]) return true;
    }
    return true;
  }
}
template<class T>
bool lvector<T>::contains(const T& v) const
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return true;
  return false;
}
template<class T>
index_type lvector<T>::first(const T& v) const
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return k;
  return no_such_index;
}
template<class T>
index_type lvector<T>::next(const T& v, index_type p) const
{
  for (index_type k = p + 1; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return k;
  return no_such_index;
}
template<class T>
index_type lvector<T>::find(const T& v, bool_vec& s) const
{
  index_type n = 0;
  s.assign_value(false, lvector<T>::size());
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) {
      s[k] = true;
      n += 1;
    }
  return n;
}
template<class T>
index_type lvector<T>::count(const T& v) const
{
  index_type c = 0;
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) c += 1;
  return c;
}
template<class T>
index_type lvector<T>::length() const
{
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::arg_max() const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if ((*this)[k] > (*this)[m]) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_min() const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if ((*this)[k] < (*this)[m]) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_first(const order& o) const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if (o((*this)[k], (*this)[m])) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_last(const order& o) const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if (o((*this)[m], (*this)[k])) m = k;
  return m;
}
template<class T>
index_pair lvector<T>::first_common(const lvector<T>& vec) const
{
  for (index_type i = 0; i < lvector<T>::size(); i++) {
    for (index_type j = 0; j < vec.size(); j++)
      if ((*this)[i] == vec[j]) return index_pair(i, j);
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_pair lvector<T>::next_common(const lvector<T>& vec, index_pair p) const
{
  index_type i = p.first;
  index_type j = p.second + 1;
  while (j < vec.size()) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    j += 1;
  }
  i += 1;
  while (i < lvector<T>::size()) {
    j = 0;
    while (j < vec.size()) {
      if ((*this)[i] == vec[j])
 return index_pair(i, j);
      j += 1;
    }
    i += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
void lvector<T>::difference
(const lvector& v1, lvector& d0, lvector& d1)
{
  d0.assign_copy(*this);
  d1.assign_copy(v1);
  index_type i0 = 0;
  while (i0 < d0.size()) {
    index_type i1 = d1.first(d0[i0]);
    if (i1 != no_such_index) {
      d0.remove(i0);
      d1.remove(i1);
    }
    else {
      i0 += 1;
    }
  }
}
template<class T>
void lvector<T>::assign_copy(const lvector& _vec)
{
  std::vector<T>::resize(_vec.size());
  for (index_type k = 0; k < _vec.size(); k++)
    (*this)[k] = _vec[k];
}
template<class T>
void lvector<T>::assign_copy(const T* _arr, index_type n)
{
  std::vector<T>::resize(n);
  for (index_type k = 0; k < n; k++)
    (*this)[k] = _arr[k];
}
template<class T>
void lvector<T>::assign_value(const T& _val)
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    (*this)[k] = _val;
}
template<class T>
void lvector<T>::assign_value(const T& _val, index_type l)
{
  std::vector<T>::resize(l);
  for (index_type k = 0; k < lvector<T>::size(); k++)
    (*this)[k] = _val;
}
template<class T>
void lvector<T>::assign_remap(const lvector<T>& vec, const index_vec& map)
{
  assert(map.length() == vec.length());
  index_type m = 0;
  for (index_type k = 0; k < vec.length(); k++)
    if (map[k] != no_such_index)
      if (map[k] > m) m = map[k];
  set_length(m + 1);
  for (index_type k = 0; k < vec.length(); k++)
    if (map[k] != no_such_index)
      (*this)[map[k]] = vec[k];
}
template<class T>
void lvector<T>::remap(const index_vec& map)
{
  lvector v0(*this);
  assign_remap(v0, map);
}
template<class T>
void lvector<T>::assign_select(const lvector& _vec, const index_set& s)
{
  set_length(s.length());
  for (index_type k = 0; k < s.length(); k++)
    (*this)[k] = _vec[s[k]];
}
template<class T>
void lvector<T>::assign_select(const lvector& _vec, const bool_vec& s)
{
  clear();
  for (index_type k = 0; k < _vec.length(); k++)
    if (s[k]) append(_vec[k]);
}
template<class T>
const lvector<T>& lvector<T>::operator=(const lvector<T>& _vec)
{
  assign_copy(_vec);
  return _vec;
}
template<class T>
void lvector<T>::set_length(index_type l)
{
  std::vector<T>::resize(l);
}
template<class T>
void lvector<T>::set_length(index_type l, const T& v)
{
  std::vector<T>::resize(l, v);
}
template<class T>
void lvector<T>::inc_length_to(index_type l)
{
  if (std::vector<T>::size() < l)
    std::vector<T>::resize(l);
}
template<class T>
void lvector<T>::inc_length_to(index_type l, const T& v)
{
  if (std::vector<T>::size() < l)
    std::vector<T>::resize(l, v);
}
template<class T>
index_type lvector<T>::inc_length(index_type d)
{
  std::vector<T>::resize(std::vector<T>::size() + d);
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::inc_length(index_type d, const T& v)
{
  std::vector<T>::resize(std::vector<T>::size() + d, v);
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::dec_length(index_type d)
{
  assert(std::vector<T>::size() >= d);
  std::vector<T>::resize(std::vector<T>::size() - d);
  return std::vector<T>::size();
}
template<class T>
void lvector<T>::clear()
{
  std::vector<T>::clear();
}
template<class T>
void lvector<T>::append(const T& v)
{
  std::vector<T>::push_back(v);
}
template<class T>
void lvector<T>::append(const lvector<T>& v)
{
  for (index_type k = 0; k < v.size(); k++) append(v[k]);
}
template<class T>
T& lvector<T>::append()
{
  T v;
  std::vector<T>::push_back(v);
  return (*this)[std::vector<T>::size() - 1];
}
template<class T>
void lvector<T>::insert(const T& v, index_type p)
{
  if (p < lvector<T>::size()) {
    std::vector<T>::insert(std::vector<T>::begin() + p, v);
  }
  else {
    std::vector<T>::resize(p + 1);
    (*this)[p] = v;
  }
}
template<class T>
index_type lvector<T>::insert_ordered(const T& v, const order& o, index_type f)
{
  assert(f <= lvector<T>::size());
  for (index_type k = f; k < lvector<T>::size(); k++) {
    if (o(v, (*this)[k])) {
      insert(v, k);
      return k;
    }
  }
  append(v);
  return (lvector<T>::size() - 1);
}
template<class T>
index_type lvector<T>::insert_ordered(const lvector& vec, const order& o)
{
  if (vec.empty()) return no_such_index;
  index_type p0 = insert_ordered(vec[0], o);
  for (index_type k = 1; k < vec.size(); k++) {
    index_type p1 = insert_ordered(vec[k], o);
    if (p1 < p0) p0 = p1;
  }
  return p0;
}
template<class T>
void lvector<T>::remove(index_type p)
{
  if (p < lvector<T>::size())
    std::vector<T>::erase(std::vector<T>::begin() + p);
}
template<class T>
void lvector<T>::remove(index_type p0, index_type p1)
{
  assert(p0 < p1);
  if (p1 < lvector<T>::size())
    std::vector<T>::erase(std::vector<T>::begin() + p0,
     std::vector<T>::begin() + p1);
  else
    std::vector<T>::erase(std::vector<T>::begin() + p0,
     std::vector<T>::end());
}
template<class T>
void lvector<T>::remove(const bool_vec& s, index_vec& map)
{
  assert(s.size() >= lvector<T>::size());
  index_type scan_p = 0;
  index_type put_p = 0;
  index_vec rm_map(no_such_index, lvector<T>::size());
  while (scan_p < lvector<T>::size()) {
    if (!s[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      rm_map[scan_p] = put_p;
      put_p += 1;
    }
    else {
      rm_map[scan_p] = no_such_index;
    }
    scan_p += 1;
  }
  std::vector<T>::resize(put_p);
  for (index_type k = 0; k < map.size(); k++)
    if (map[k] != no_such_index) {
      assert(map[k] < rm_map.size());
      map[k] = rm_map[map[k]];
    }
}
template<class T>
void lvector<T>::remove(const bool_vec& s)
{
  assert(s.size() >= lvector<T>::size());
  index_type scan_p = 0;
  index_type put_p = 0;
  while (scan_p < lvector<T>::size()) {
    if (!s[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      put_p += 1;
    }
    scan_p += 1;
  }
  std::vector<T>::resize(put_p);
}
template<class T>
void lvector<T>::remove(const index_set& s)
{
  bool_vec s1(s, lvector<T>::size());
  remove(s1);
}
template<class T>
void lvector<T>::remove(const index_set& s, index_vec& map)
{
  bool_vec s1(s, std::vector<T>::size());
  lvector<T>::remove(s1, map);
}
template<class T>
void lvector<T>::remove_duplicate_elements()
{
  equivalence eq(lvector<T>::size());
  for (index_type i = 0; i < lvector<T>::size(); i++)
    for (index_type j = i+1; j < lvector<T>::size(); j++)
      if ((*this)[i] == (*this)[j])
 eq.merge(i, j);
  bool_vec s(false, lvector<T>::size());
  for (index_type i = 0; i < lvector<T>::size(); i++)
    if (eq.canonical(i) != i)
      s[i] = true;
  remove(s);
}
template<class T>
void lvector<T>::swap(index_type i, index_type j)
{
  T tmp = (*this)[i];
  (*this)[i] = (*this)[j];
  (*this)[j] = tmp;
}
template<class T>
void svector<T>::assign_singleton(const T& _val)
{
  lvector<T>::set_length(1);
  (*this)[0] = _val;
}
template<class T>
void svector<T>::assign_values(const lvector<T>& vec)
{
  lvector<T>::clear();
  for (index_type k = 0; k < vec.size(); k++)
    insert(vec[k]);
}
template<class T>
void svector<T>::insert(const T& v) {
  index_type i = 0;
  bool seeking = (i < std::vector<T>::size());
  while (seeking) {
    if ((*this)[i] < v) {
      i += 1;
      if (i >= std::vector<T>::size())
 seeking = false;
    }
    else {
      seeking = false;
    }
  }
  if (i < lvector<T>::size()) {
    if ((*this)[i] == v)
      return;
    else
      lvector<T>::insert(v, i);
  }
  else {
    lvector<T>::append(v);
  }
}
template<class T>
void svector<T>::insert(const lvector<T>& vec)
{
  for (index_type k = 0; k < vec.size(); k++) insert(vec[k]);
}
template<class T>
bool svector<T>::contains(const T& v) const
{
  index_type i = 0;
  while ((i < lvector<T>::size()) &&
  ((*this)[i] < v)) i += 1;
  if (i < lvector<T>::size())
    if ((*this)[i] == v) return true;
  return false;
}
template<class T>
bool svector<T>::contains(const svector& vec) const
{
  index_type v_i = 0;
  index_type i = 0;
  while (v_i < vec.size()) {
    if (i >= lvector<T>::size()) return false;
    if ((*this)[i] == vec[v_i]) {
      v_i += 1;
      i += 1;
    }
    else if ((*this)[i] > vec[v_i]) {
      return false;
    }
    else {
      while ((i < lvector<T>::size()) && ((*this)[i] < vec[v_i]))
 i += 1;
    }
  }
  return true;
}
template<class T>
bool svector<T>::subset(const svector& vec) const
{
  return vec.contains(*this);
}
template<class T>
void svector<T>::intersect(const svector& vec)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if (!vec.contains((*this)[i]))
      lvector<T>::remove(i);
    else
      i += 1;
  }
}
template<class T>
void svector<T>::difference(const svector& vec)
{
  svector d(vec);
  d.subtract(*this);
  subtract(vec);
  insert(d);
}
template<class T>
index_pair svector<T>::first_common(const lvector<T>& vec) const
{
  return lvector<T>::first_common(vec);
}
template<class T>
index_pair svector<T>::next_common(const lvector<T>& vec, index_pair p) const
{
  return lvector<T>::next_common(vec, p);
}
template<class T>
index_pair svector<T>::first_common(const svector<T>& vec) const
{
  index_type i = 0;
  index_type j = 0;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    else if
      ((*this)[i] < vec[j]) i += 1;
    else
      j += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_pair svector<T>::next_common(const svector<T>& vec, index_pair p) const
{
  index_type i = p.first + 1;
  index_type j = p.second + 1;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    else if ((*this)[i] < vec[j])
      i += 1;
    else
      j += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_type svector<T>::count_common(const svector& vec) const
{
  index_type i = 0;
  index_type j = 0;
  index_type c = 0;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j]) {
      c += 1;
      i += 1;
      j += 1;
    }
    else if ((*this)[i] < vec[j])
      i += 1;
    else
      j += 1;
  }
  return c;
}
template<class T>
void svector<T>::subtract(const svector& vec)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if (vec.contains((*this)[i]))
      lvector<T>::remove(i);
    else
      i += 1;
  }
}
template<class T>
void svector<T>::subtract(const T& v)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if ((*this)[i] == v) {
      lvector<T>::remove(i);
      return;
    }
    else {
      i += 1;
    }
  }
}
template<class T>
void matrix<T>::set_size(index_type r, index_type c)
{
  lvector<row_type>::set_length(r);
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].set_length(c);
}
template<class T>
void matrix<T>::assign_value(const T& _val)
{
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].assign_value(_val);
}
template<class T>
void matrix<T>::assign_value(const T& _val, index_type r, index_type c)
{
  lvector<row_type>::set_length(r);
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].assign_value(_val, c);
}
template<class T>
void swapable_pair<T>::swap()
{
  T tmp = this->first;
  this->first = this->second;
  this->second = tmp;
}
template<class T>
void comparable_pair<T>::sort_ascending()
{
  if (this->first > this->second) swapable_pair<T>::swap();
}
template<class T>
void comparable_pair<T>::sort_descending()
{
  if (this->first < this->second) swapable_pair<T>::swap();
}
template<class T, class N>
class weighted_vec<T,N>::decreasing_weight_order
  weighted_vec<T,N>::decreasing;
template<class T, class N>
class weighted_vec<T,N>::increasing_weight_order
  weighted_vec<T,N>::increasing;
template<class T, class N>
void weighted_vec<T,N>::insert_increasing(const weighted<T,N>& v)
{
  insert_ordered(v, increasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_decreasing(const weighted<T,N>& v)
{
  insert_ordered(v, decreasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_increasing(const T& v, const N& w)
{
  insert_ordered(weighted<T,N>(v, w), increasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_decreasing(const T& v, const N& w)
{
  insert_ordered(weighted<T,N>(v, w), decreasing);
}
template<class T, class N>
void weighted_set<T,N>::insert(const T& v, const N& w)
{
  index_type p = svector< weighted<T,N> >::first(v);
  if (p == no_such_index) {
    svector< weighted<T,N> >::insert(weighted<T,N>(v, w));
  }
  else {
    (*this)[p].weight += w;
  }
}
template<class T, class N>
void weighted_set<T,N>::insert(const T& v)
{
  index_type p = svector< weighted<T,N> >::first(v);
  if (p == no_such_index) {
    svector< weighted<T,N> >::insert(weighted<T,N>(v, 1));
  }
  else {
    (*this)[p].weight += 1;
  }
}
template<class T, class N>
index_type weighted_set<T,N>::arg_max()
{
  if (weighted_set<T,N>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < weighted_set<T,N>::size(); k++)
    if ((*this)[k].weight > (*this)[m].weight) m = k;
  return m;
}
template<class T, class N>
index_type weighted_set<T,N>::arg_min()
{
  if (weighted_set<T,N>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < weighted_set<T,N>::size(); k++)
    if ((*this)[k].weight < (*this)[m].weight) m = k;
  return m;
}
template<class T>
inline std::ostream& operator<<(std::ostream& s, const swapable_pair<T>& p)
{
  return s << '(' << p.first << ',' << p.second << ')';
}
template<class T>
::std::ostream& operator<<(::std::ostream& s, const lvector<T>& _vec)
{
  s << '[';
  for (index_type k = 0; k < _vec.size(); k++) {
    if (k > 0) s << ',';
    s << _vec[k];
  }
  s << ']';
  return s;
}
inline std::ostream& operator<<(std::ostream& s, const mapping& m)
{
  s << '{';
  for (index_type k = 0; k < m.length(); k++) {
    if (k > 0) s << ',';
    s << k << '-' << '>';
    if (m[k] == no_such_index)
      s << '_';
    else
      s << m[k];
  }
  return s << '}';
}
inline std::ostream& operator<<(std::ostream& s, const equivalence& eq)
{
  s << '{';
  bool first = true;
  for (index_type k = 0; k < eq.length(); k++) {
    index_type c = eq.canonical(k);
    if (!first) {
      s << ',';
    }
    else {
      first = false;
    }
    s << k << '=' << c;
  }
  return s << '}';
}
template<class T, class N>
std::ostream& operator<<(::std::ostream& s, const weighted<T,N>& w)
{
  s << '<' << w.value << ':' << w.weight << '>';
}
}
namespace hsps {
typedef zero_init_pair<void*> ptr_pair;
class ptr_table {
  void* _key;
  ptr_table* _left;
  ptr_table* _right;
  ptr_table* _up;
  ptr_table* _prev;
  ptr_table* _next;
  index_type _count;
 public:
  void* val;
 private:
  ptr_table(void* k, ptr_table* u, ptr_table* p)
    : _key(k), _left(0), _right(0), _up(u), _prev(p), _next(0),
    _count(1), val(0) { };
 public:
  typedef lvector<void*> key_vec;
  typedef lvector<void*> value_vec;
  typedef lvector<ptr_table*> cell_vec;
  ptr_table()
    : _key(0), _left(0), _right(0), _up(0), _prev(0), _next(0),
    _count(0), val(0) { };
  ~ptr_table();
  void* key() { return _key; };
  ptr_table* enum_key_first();
  ptr_table* enum_key_next();
  void key_sequence(key_vec&);
  key_vec* key_sequence();
  ptr_table* root();
  ptr_table* next() { return _next; };
  ptr_table* insert(void* k);
  ptr_table* insert_next(void* k);
  ptr_table* insert(void** k, index_type l);
  ptr_table* insert(key_vec& k);
  ptr_table* find(void* k);
  ptr_table* find_next(void* k);
  ptr_table* find(void** k, index_type l);
  ptr_table* find(key_vec& k);
  bool contains(void* k);
  bool contains(void** k, index_type l);
  bool contains(key_vec& k);
  void set(void* k, void* v);
  void set(void** k, index_type l, void* v);
  void set(key_vec& k, void* v);
  void* find_val(void** k, index_type l);
  void* find_val(key_vec& k);
  void*& operator[](void* k);
  void*& operator[](key_vec& k);
  void dump(cell_vec& vec);
  index_type count_keys();
  void dump_keys(key_vec& vec);
  key_vec* keys();
  index_type count_values();
  void dump_values(value_vec& vec);
  value_vec* values();
};
inline bool ptr_table::contains(void* k) {
  return (find(k) != 0);
}
inline bool ptr_table::contains(void** k, index_type l) {
  return (find(k) != 0);
}
inline bool ptr_table::contains(key_vec& k) {
  return (find(k) != 0);
}
inline void ptr_table::set(void* k, void* v) {
  insert(k)->val = v;
}
inline void ptr_table::set(void** k, index_type l, void* v) {
  insert(k)->val = v;
}
inline void ptr_table::set(key_vec& k, void* v) {
  insert(k)->val = v;
}
inline void*& ptr_table::operator[](void* k) {
  ptr_table* a = insert(k);
  return a->val;
}
inline void*& ptr_table::operator[](key_vec& k) {
  ptr_table* a = insert(k);
  return a->val;
}
inline void* ptr_table::find_val(void** k, index_type l) {
  ptr_table* a = find(k, l);
  if (a) return a->val;
  else return 0;
}
inline void* ptr_table::find_val(key_vec& k) {
  ptr_table* a = find(k);
  if (a) return a->val;
  else return 0;
}
}
namespace hsps {
class char_map {
 public:
  static const unsigned int _CHAR_COUNT = 256;
 private:
  char _map[_CHAR_COUNT];
 public:
  char_map();
  char_map(const char in[_CHAR_COUNT]);
  void identify(const char _c0, const char _c1);
  char operator[](const char _in) const
    { return _map[(unsigned char)_in]; };
  void apply(char* s) const;
  void apply(char* s, index_type len) const;
  int strcmp(const char *s0, const char *s1) const;
  int strcmp(const char *s0, const char *s1, index_type len) const;
  const char* strchr(const char* s, char c) const;
  const char* strchr(const char* s, index_type len, char c) const;
  char* strcpy(const char *s0, char *s1) const;
  char* strcpy(const char *s0, index_type len, char *s1) const;
  char* strdup(const char *s0) const;
  char* strdup(const char *s0, index_type len) const;
  index_type hash(const char *s) const;
  index_type hash(const char *s, index_type len) const;
};
extern const char lowercase[char_map::_CHAR_COUNT];
extern const char rot13[char_map::_CHAR_COUNT];
extern char_map lowercase_map;
extern char_map rot13_map;
}
namespace hsps {
typedef lvector<char*> string_vec;
typedef lvector<void*> element_vec;
inline ::std::ostream& operator<<(::std::ostream& s, const string_vec& vec) {
  s << '[';
  for (index_type k = 0; k < vec.length(); k++) {
    if (k > 0) s << ',';
    s << '"' << vec[k] << '"';
  }
  s << ']';
  return s;
}
class StringTable {
 public:
  struct Cell {
    index_type bin;
    char* text;
    void* val;
    Cell* next;
    Cell(const char* s, char_map& map, index_type b, Cell* n)
      : bin(b), text(map.strdup(s)), val(0), next(n) { };
    Cell(const char* s, index_type len, char_map& map, index_type b, Cell* n)
      : bin(b), text(map.strdup(s, len)), val(0), next(n) { };
    Cell(const char* s, char_map& map, void* v, index_type b, Cell* n)
      : bin(b), text(map.strdup(s)), val(v), next(n) { };
    Cell(const char* s, index_type len, char_map& map, void* v, index_type b, Cell* n)
      : bin(b), text(map.strdup(s, len)), val(v), next(n) { };
    ~Cell() { delete text; if (next) delete next; };
  };
 private:
  index_type n_bin;
  char_map& map;
  Cell** table;
  index_type n_entries;
 public:
  StringTable(index_type b, char_map& cm);
  ~StringTable();
  StringTable::Cell* inserta(const char* str);
  StringTable::Cell* inserta(const char* str, index_type len);
  StringTable::Cell* gensym(const char* str);
  char* insert(const char* str);
  char* insert(const char* str, index_type len);
  char* set(const char* str, void* val);
  char* set(const char* str, index_type len, void* val);
  char* set(const char* str)
    { return set(str, (void*)0); };
  char* set(const char* str, index_type len)
    { return set(str, len, (void*)0); };
  const StringTable::Cell* find(const char* str) const;
  const StringTable::Cell* find(const char* str, index_type len) const;
  void* find_val(const char* str) const;
  void* find_val(const char* str, index_type len) const;
  const StringTable::Cell* first() const;
  const StringTable::Cell* next(const StringTable::Cell* c) const;
  string_vec* keys();
  element_vec* values();
  index_type table_bins() { return n_bin; };
  index_type table_entries() { return n_entries; };
  char_map& table_char_map() { return map; };
  void apply_map(const char_map& map);
};
}
#include <iostream>
#include <limits.h>
namespace hsps {
long euclid(long n, long k, long& a, long& b);
long gcd(long n, long k);
long lcm(long n, long k);
unsigned long ilog(unsigned long n);
long imag(long n);
class rational {
  long nm;
  long dv;
 public:
  rational();
  rational(long n);
  rational(long n, long d);
  rational(const rational& r);
  struct XR {
    long x_nm;
    long x_dv;
    XR& operator=(const rational r);
  };
  rational(const XR& x);
  long numerator() const;
  long divisor() const;
  long sign() const;
  bool zero() const;
  bool finite() const;
  bool infinite() const;
  bool integral() const;
  static rational reduce(rational r);
  static rational invert(const rational r);
  static rational infinity(const rational r);
  static rational infinity(const long s);
  static rational floor(const rational r);
  static rational floor_to(const rational r, long div);
  static rational ceil(const rational r);
  static rational ceil_to(const rational r, long div);
  static rational frac(const rational r);
  static rational round(const rational r, long div_max);
  static rational min(const rational r0, const rational r1);
  static rational max(const rational r0, const rational r1);
  static rational rgcd(const rational r0, const rational r1);
  static rational dtor(double v);
  static rational ator(const char* s);
  rational reduce() const;
  rational invert() const;
  rational floor() const;
  rational floor_to(long d) const;
  rational ceil() const;
  rational frac() const;
  rational round(long div_max) const;
  rational round() const;
  rational operator=(const rational r);
  rational operator=(long n);
  rational operator+=(const rational r);
  rational operator-=(const rational r);
  rational operator*=(const rational r);
  rational operator/=(const rational r);
  rational operator+=(long n);
  rational operator-=(long n);
  rational operator*=(long n);
  rational operator/=(long n);
  double decimal() const;
};
bool operator==(const rational r0, const rational r1);
bool operator==(const rational r0, long n1);
bool operator==(long n0, const rational r1);
bool operator!=(const rational r0, const rational r1);
bool operator!=(const rational r0, long n1);
bool operator!=(long n0, const rational r1);
bool operator<(const rational r0, const rational r1);
bool operator<=(const rational r0, const rational r1);
bool operator>(const rational r0, const rational r1);
bool operator>=(const rational r0, const rational r1);
rational operator+(const rational r0, const rational r1);
rational operator-(const rational r0, const rational r1);
rational operator*(const rational r0, const rational r1);
rational operator/(const rational r0, const rational r1);
rational operator+(const rational r0, long n1);
rational operator-(const rational r0, long n1);
rational operator*(const rational r0, long n1);
rational operator/(const rational r0, long n1);
rational operator+(long n0, const rational r1);
rational operator-(long n0, const rational r1);
rational operator*(long n0, const rational r1);
rational operator/(long n0, const rational r1);
rational safeadd(const rational r0, const rational r1);
rational safemul(const rational r0, const rational r1);
::std::ostream& operator<<(::std::ostream& s, const rational r);
inline rational::XR& rational::XR::operator=(const rational r)
{
  x_nm = r.numerator();
  x_dv = r.divisor();
  return *this;
}
inline rational::rational()
  : nm(0), dv(1) { }
inline rational::rational(long n)
  : nm(n), dv(1) { }
inline rational::rational(long n, long d)
  : nm(d < 0 ? -1*n : n), dv(d < 0 ? -1*d : d) { }
inline rational::rational(const rational& r)
  : nm(r.nm), dv(r.dv) { }
inline rational::rational(const rational::XR& x)
  : nm(x.x_nm), dv(x.x_dv) { };
inline long rational::numerator() const { return nm; }
inline long rational::divisor() const { return dv; }
inline long rational::sign() const
{
  return (nm < 0 ? -1 : (nm > 0 ? 1 : 0));
}
inline bool rational::zero() const
{
  return nm == 0;
}
inline bool rational::finite() const
{
  return dv != 0;
}
inline bool rational::infinite() const
{
  return dv == 0;
}
inline bool rational::integral() const
{
  return dv == 1;
}
inline rational rational::reduce(rational r)
{
  if (r.infinite()) return infinity(r.sign());
  if (r.sign() == 0) return rational(0,1);
  long c = gcd(r.nm, r.dv);
  return rational(r.nm / c, r.dv / c);
}
inline rational rational::invert(const rational r)
{
  return rational(r.dv, r.nm);
}
inline rational rational::infinity(const long s)
{
  return rational((s < 0 ? -1 : (s > 0 ? 1 : 0)), 0);
}
inline rational rational::infinity(const rational r)
{
  return rational(r.sign(),0);
}
inline rational rational::floor(const rational r)
{
  if (r.infinite()) return r;
  return rational(r.nm / r.dv);
}
inline rational rational::floor_to(const rational r, long d)
{
  if (r.infinite()) return r;
  return rational((r.nm * d) / r.dv, d);
}
inline rational rational::ceil(const rational r)
{
  if (r.infinite()) return r;
  if (r.dv == 1) return r;
  return rational((r.nm / r.dv) + 1, 1);
}
inline rational rational::ceil_to(const rational r, long d)
{
  if (r.infinite()) return r;
  long x = (r.nm * d);
  long y = x / r.dv;
  if ((y * r.dv) == x)
    return rational(y, d);
  else
    return rational(y + 1, d);
}
inline rational rational::frac(const rational r) {
  if (r.infinite()) return r;
  return reduce(rational(r.nm % r.dv, r.dv));
}
inline rational rational::round(const rational r, long d_max)
{
  if (r.infinite()) return r;
  rational s(r);
  while (s.dv > d_max) {
    s.dv = (s.dv / 2);
    s.nm = (s.nm / 2);
    s.reduce();
  }
  return s;
}
inline rational rational::rgcd(const rational r0, const rational r1)
{
  long c = gcd(r0.divisor(), r1.divisor());
  long a0 = r0.numerator() * (r1.divisor() / c);
  long a1 = r1.numerator() * (r0.divisor() / c);
  long d = gcd(a0, a1);
  return rational(d, (r0.divisor() / c) * (r1.divisor() / c) * c).reduce();
}
inline rational rational::min(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    if (r0.sign() < 0) return r0;
    else return r1;
  }
  else if (r1.infinite()) {
    if (r1.sign() < 0) return r1;
    else return r0;
  }
  else if (r0 < r1) return r0;
  else return r1;
}
inline rational rational::max(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    if (r0.sign() > 0) return r0;
    else return r1;
  }
  else if (r1.infinite()) {
    if (r1.sign() > 0) return r1;
    else return r0;
  }
  else if (r0 < r1) return r1;
  else return r0;
}
inline rational rational::reduce() const
{
  return reduce(*this);
}
inline rational rational::invert() const
{
  return invert(*this);
}
inline rational rational::floor() const
{
  return floor(*this);
}
inline rational rational::floor_to(long d) const
{
  return floor_to(*this, d);
}
inline rational rational::ceil() const
{
  return ceil(*this);
}
inline rational rational::frac() const
{
  return frac(*this);
}
inline rational rational::round(long d_max) const
{
  return round(*this, d_max);
}
inline rational rational::round() const
{
  return round(*this, (LONG_MAX/16));
}
inline rational rational::operator=(const rational r)
{
  nm = r.nm;
  dv = r.dv;
  return *this;
}
inline rational rational::operator=(long n)
{
  nm = n;
  dv = 1;
  return *this;
}
inline rational rational::operator+=(const rational r)
{
  return *this = (*this + r);
}
inline rational rational::operator-=(const rational r)
{
  return *this = (*this - r);
}
inline rational rational::operator*=(const rational r)
{
  return *this = (*this * r);
}
inline rational rational::operator/=(const rational r)
{
  return *this = (*this / r);
}
inline rational rational::operator+=(long n)
{
  return *this = (*this + n);
}
inline rational rational::operator-=(long n)
{
  return *this = (*this - n);
}
inline rational rational::operator*=(long n)
{
  return *this = (*this * n);
}
inline rational rational::operator/=(long n)
{
  return *this = (*this / n);
}
inline double rational::decimal() const { return nm/(double)dv; };
inline bool operator==(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite()) return r0.sign() == r1.sign();
  else return ((r0.numerator() == r1.numerator()) &&
        (r0.divisor() == r1.divisor()));
}
inline bool operator==(const rational r0, long n1)
{
  return ((r0.numerator() == n1) && (r0.divisor() == 1));
}
inline bool operator==(long n0, const rational r1)
{
  return ((r1.numerator() == n0) && (r1.divisor() == 1));
}
inline bool operator!=(const rational r0, const rational r1)
{
  return !(r0 == r1);
}
inline bool operator!=(const rational r0, long n1)
{
  return !(r0 == n1);
}
inline bool operator!=(long n0, const rational r1)
{
  return !(n0 == r1);
}
inline bool operator<(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return false;
  else return (r0 - r1).sign() < 0;
}
inline bool operator<=(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return true;
  else return (r0 - r1).sign() <= 0;
}
inline bool operator>(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return false;
  else return (r0 - r1).sign() > 0;
}
inline bool operator>=(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return true;
  else return (r0 - r1).sign() >= 0;
}
inline rational operator+(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() == r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " + " << r1 << " not defined"
           << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() + r1.numerator(), 1);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n = (r0.numerator() * (r1.divisor() / c) +
       r1.numerator() * (r0.divisor() / c));
    long d = ((r0.divisor() / c) * r1.divisor());
    return rational(n, d).reduce();
  }
}
inline rational operator-(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() != r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " - " << r1 << " not defined"
      << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1.sign() * -1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() - r1.numerator(), 1);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n = (r0.numerator() * (r1.divisor() / c) -
       r1.numerator() * (r0.divisor() / c));
    long d = ((r0.divisor() / c) * r1.divisor());
    return rational(n, d).reduce();
  }
}
inline rational operator*(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else if (r1.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() * r1.numerator(), 1);
  }
  else {
    long c0 = gcd(r0.numerator(), r1.divisor());
    long c1 = gcd(r1.numerator(), r0.divisor());
    return rational((r0.numerator() / c0) * (r1.numerator() / c1),
      (r0.divisor() / c1) * (r1.divisor() / c0)).reduce();
  }
}
inline rational operator/(const rational r0, const rational r1)
{
  return (r0 * r1.invert());
}
inline rational operator+(const rational r0, long n1)
{
  return rational(r0.numerator() + (n1 * r0.divisor()), r0.divisor()).reduce();
}
inline rational operator-(const rational r0, long n1)
{
  return rational(r0.numerator() - (n1 * r0.divisor()), r0.divisor()).reduce();
}
inline rational operator*(const rational r0, long n1)
{
  return rational(r0.numerator() * n1, r0.divisor()).reduce();
}
inline rational operator/(const rational r0, long n1)
{
  return rational((n1 < 0 ? r0.numerator() * -1 : r0.numerator()),
    r0.divisor() * (n1 < 0 ? n1 * -1 : n1)).reduce();
}
inline rational operator+(long n0, const rational r1)
{
  return rational(r1.numerator() + (n0 * r1.divisor()), r1.divisor()).reduce();
}
inline rational operator-(long n0, const rational r1)
{
  return rational((n0 * r1.divisor()) - r1.numerator(), r1.divisor()).reduce();
}
inline rational operator*(long n0, const rational r1)
{
  return rational(r1.numerator() * n0, r1.divisor()).reduce();
}
inline rational operator/(long n0, const rational r1)
{
  return (n0 * r1.invert());
}
inline rational safeadd(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() == r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " + " << r1 << " not defined"
      << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n0 = r0.numerator();
    long d0 = r0.divisor() / c;
    long n1 = r1.numerator();
    long d1 = r1.divisor() / c;
    assert(d0 > 0);
    assert(d1 > 0);
    while (((LONG_MAX / (2*d1)) < (imag(n0) + 1)) ||
    ((LONG_MAX / (2*d0)) < (imag(n1) + 1)) ||
    ((LONG_MAX / (d0 * c)) < (d1 + 1))) {
      if ((d1 < 2) && (d0 < 2)) {
 std::cerr << "error: overflow in safeadd(" << r0 << ", " << r1 << ")"
    << std::endl;
 abort();
      }
      if (d0 < 2) {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
      else if (d1 < 2) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else if ((imag(n0) - d0) > (imag(n1) - d1)) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
    }
    long f0 = n0 * d1;
    long f1 = n1 * d0;
    long n = f0 + f1;
    long d = d0 * d1 * c;
    return rational(n, d).reduce();
  }
}
inline rational safemul(const rational r0, const rational r1)
{
  if (r0.infinite() || r1.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else {
    long c0 = gcd(r0.numerator(), r1.divisor());
    long c1 = gcd(r1.numerator(), r0.divisor());
    long n0 = r0.numerator() / c0;
    long n1 = r1.numerator() / c1;
    long d0 = r0.divisor() / c1;
    long d1 = r1.divisor() / c0;
    while (((LONG_MAX / imag(n0)) < (imag(n1) + 1)) ||
    ((LONG_MAX / d0) < (d1 + 1))) {
      if ((d1 < 2) && (d0 < 2)) {
 std::cerr << "error: overflow in safeadd(" << r0 << ", " << r1 << ")"
    << std::endl;
 abort();
      }
      if (d0 < 2) {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
      else if (d1 < 2) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else if ((imag(n0) - d0) > (imag(n1) - d1)) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
    }
    return rational(n0 * n1, d0 * d1).reduce();
  }
}
inline ::std::ostream& operator<<(::std::ostream& s, const rational r)
{
  if (r.infinite()) {
    if (r.sign() < 0) return s << "-INF";
    else return s << "INF";
  }
  else if (r.integral()) {
    return s << r.numerator();
  }
  else {
    return s << r.numerator() << '/' << r.divisor();
  }
}
}
namespace hsps {
class RNG {
 public:
  virtual ~RNG() { };
  virtual void seed(unsigned long s) = 0;
  virtual unsigned long seed_value() = 0;
  virtual unsigned long random() = 0;
  void seed_with_pid();
  void seed_with_time();
  unsigned long random_in_range(unsigned long range);
  unsigned long random_in_range(unsigned long range, unsigned long except);
  double random_double(unsigned long div);
  double normal_sample(double mean, double var);
  unsigned long binomial_sample(unsigned long n, double p);
  index_type select_one_of(const bool_vec& sel);
  index_type select_one_of(const index_vec& sel);
  void select_fixed_set(index_set& s, index_type m, index_type n);
  void select_variable_set(index_set& s, index_type m, index_type n);
  void select_non_empty_variable_set(index_set& s, index_type m, index_type n);
  virtual unsigned long max() = 0;
};
class LC_RNG : public RNG {
  unsigned long a;
  unsigned long b;
  unsigned long mod;
  unsigned long x;
 public:
  LC_RNG()
    : a(23), b(0), mod(100000001), x(100000001 - 1) { };
  LC_RNG(unsigned long _a, unsigned long _b, unsigned long m)
    : a(_a), b(_b), mod(m), x(m - 1) { };
  LC_RNG(unsigned long s)
    : a(23), b(0), mod(100000001), x(s) { };
  LC_RNG(unsigned long _a, unsigned long _b, unsigned long m, unsigned long s)
    : a(_a), b(_b), mod(m), x(s) { };
  virtual ~LC_RNG() { };
  virtual void seed(unsigned long s);
  virtual unsigned long seed_value();
  virtual unsigned long random();
  virtual unsigned long max();
};
}
#include <iostream>
#include <iomanip>
const hsps::rational POS_INF(1,0);
const hsps::rational NEG_INF(-1,0);
const hsps::rational ZERO(0,1);
namespace hsps {
inline hsps::rational random_numeric
(hsps::rational min, hsps::rational max, unsigned long prec, RNG& rng)
{
  hsps::rational d = (max - min);
  hsps::rational s = (d / prec);
  unsigned long r = rng.random_in_range(prec + 1);
  return ((r*s) + min);
}
class amt_vec : public auto_expanding_vector<hsps::rational> {
 public:
  amt_vec()
    : auto_expanding_vector<hsps::rational>() { };
  amt_vec(const hsps::rational& v, index_type l)
    : auto_expanding_vector<hsps::rational>(v, l) { };
  amt_vec(const amt_vec& vec)
    : auto_expanding_vector<hsps::rational>(vec) { };
  int compare(const amt_vec& vec, index_type n);
  int dcompare(const amt_vec& vec, index_type n);
  index_type hash(index_type n);
  void write(std::ostream& s, index_type n);
};
inline int amt_vec::compare(const amt_vec& vec, index_type n)
{
  for (index_type k = 0; k < n; k++) {
    if ((*this)[k] < vec[k]) return -1;
    else if ((*this)[k] > vec[k]) return 1;
  }
  return 0;
}
inline int amt_vec::dcompare(const amt_vec& vec, index_type n)
{
  bool this_less_than_vec = false;
  bool vec_less_than_this = false;
  for (index_type k = 0; k < n; k++) {
    if ((*this)[k] < vec[k]) this_less_than_vec = true;
    else if ((*this)[k] > vec[k]) vec_less_than_this = true;
  }
  if (this_less_than_vec && !vec_less_than_this) return -1;
  else if (!this_less_than_vec && vec_less_than_this) return 1;
  else return 0;
}
inline index_type amt_vec::hash(index_type n)
{
  if (n == 0) return 0;
  if (n == 1) return ((index_type)(((*this)[0]).numerator() - ((*this)[0]).divisor()));
  index_type h = 0;
  for (index_type k = 0; k < n - 1; k++) {
    h += ((index_type)(((((*this)[k]) + 1) * (((*this)[k + 1]) + 1)).numerator() - ((((*this)[k]) + 1) * (((*this)[k + 1]) + 1)).divisor()));
  }
  return h;
}
inline void amt_vec::write(std::ostream& s, index_type n)
{
  s << '[';
  for (index_type k = 0; k < n; k++) {
    if (k > 0) s << ',';
    s << std::resetiosflags(std::ios::scientific) << (((*this)[k]).decimal());
  }
  s << ']';
}
typedef lvector<hsps::rational> cost_vec;
typedef svector<hsps::rational> cost_set;
typedef matrix<hsps::rational> cost_matrix;
class cost_vec_util : public cost_vec
{
 public:
  class decreasing_cost_order : public cost_vec::order {
  public:
    virtual bool operator()
      (const hsps::rational& v0, const hsps::rational& v1) const
      { return (v0 > v1); };
  };
  class increasing_cost_order : public cost_vec::order {
  public:
    virtual bool operator()
      (const hsps::rational& v0, const hsps::rational& v1) const
      { return (v0 < v1); };
  };
  static class decreasing_cost_order decreasing;
  static class increasing_cost_order increasing;
  static hsps::rational max(const cost_vec& v);
  static hsps::rational min(const cost_vec& v);
  hsps::rational max() const { return max(*this); };
  hsps::rational min() const { return min(*this); };
};
struct interval : public comparable_pair<hsps::rational> {
  interval(const hsps::rational& v1, const hsps::rational& v2) :
    comparable_pair<hsps::rational>(v1, v2) { };
  interval(const hsps::rational& v) :
    comparable_pair<hsps::rational>(v) { };
  interval(const interval& p) :
    comparable_pair<hsps::rational>(p) { };
  interval() :
    comparable_pair<hsps::rational>(NEG_INF, POS_INF) { };
};
typedef std::pair<index_type, hsps::rational> index_cost_pair;
typedef lvector<index_cost_pair> index_cost_vec;
inline std::ostream& operator<<(std::ostream& s, const index_cost_pair& p)
{
  s << '(' << p.first << ',' << p.second << ')';
}
inline std::ostream& operator<<(std::ostream& s, const interval& i)
{
  s << '[' << i.first << ',' << i.second << ']';
}
}
#include <string>
#include <iostream>
namespace hsps {
class Name {
 public:
  static const unsigned int NC_DEFAULT = 0;
  static const unsigned int NC_INSTANCE = 1;
  static const unsigned int NC_DOMAIN = 2;
  static const unsigned int NC_PROBLEM = 4;
  static const unsigned int NC_PLAN = 8;
  static const unsigned int NC_ESCAPE = 16 + 32;
  static const unsigned int NC_PDDL = 16;
  static const unsigned int NC_XML = 32;
  static const unsigned int NC_LATEX = 16 + 32;
  static const unsigned int NC_IPC = 64;
  static bool context_is_instance(unsigned int c)
    { return ((c & NC_INSTANCE) == NC_INSTANCE); };
  static bool context_is_domain(unsigned int c)
    { return ((c & NC_DOMAIN) == NC_DOMAIN); };
  static bool context_is_problem(unsigned int c)
    { return ((c & NC_PROBLEM) == NC_PROBLEM); };
  static bool context_is_plan(unsigned int c)
    { return ((c & NC_PLAN) == NC_PLAN); };
  static bool escape_for_pddl(unsigned int c)
    { return ((c & NC_ESCAPE) == NC_PDDL); };
  static bool escape_for_xml(unsigned int c)
    { return ((c & NC_ESCAPE) == NC_XML); };
  static bool escape_for_latex(unsigned int c)
    { return ((c & NC_ESCAPE) == NC_LATEX); };
  static bool conform_to_IPC(unsigned int c)
    { return ((c & NC_IPC) == NC_IPC); };
  virtual ~Name();
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const = 0;
  virtual const Name* cast_to(const char* cname) const;
  ::std::string to_string(unsigned int c = NC_DEFAULT) const;
  char* to_cstring(unsigned int c = NC_DEFAULT) const;
  bool equals(const Name* name) const;
  void write_char_escaped(::std::ostream& s,
     char ch,
     unsigned int c) const;
  void write_string_escaped(::std::ostream& s,
       ::std::string& str,
       unsigned int c) const;
  void write_string_escaped(::std::ostream& s,
       const char* str,
       unsigned int c) const;
};
typedef lvector<const Name*> name_vec;
inline ::std::ostream& operator<<(::std::ostream& s, const Name& n) {
  n.write(s, false);
  return s;
}
inline ::std::ostream& operator<<(::std::ostream& s, const Name* n) {
  n->write(s, false);
  return s;
}
inline void Name::write_char_escaped
(::std::ostream& s, char ch, unsigned int c) const
{
  if (escape_for_latex(c)) {
    if (ch == '_') s << '\\' << '_';
    else if (ch == '%') s << '\\' << '%';
    else if (ch == '#') s << '\\' << '#';
    else s << ch;
  }
  else if (escape_for_xml(c)) {
    if (ch == '<') s << "&lt;";
    else if (ch == '>') s << "&gt;";
    else if (ch == '&') s << "&amp;";
    else if (ch == '"') s << "&quot;";
    else s << ch;
  }
  else if (escape_for_pddl(c)) {
    if (ch == ' ') s << '_';
    else s << ch;
  }
  else {
    s << ch;
  }
}
inline void Name::write_string_escaped
(::std::ostream& s, const char* str, unsigned int c) const
{
  while (*str) {
    write_char_escaped(s, *str, c);
    str++;
  }
}
inline void Name::write_string_escaped
(::std::ostream& s, ::std::string& str, unsigned int c) const
{
  for (index_type i = 0; i < str.length(); i++)
    write_char_escaped(s, str[i], c);
}
class NameWithContext : public Name {
  const Name* name;
  unsigned int c_on;
  unsigned int c_off;
 public:
  NameWithContext(const Name* n, unsigned int on, unsigned int off)
    : name(n), c_on(on), c_off(off) { };
  virtual ~NameWithContext() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class StringName : public Name {
  const char* _string;
  bool _own;
 public:
  StringName(const char* s, bool c = false)
    : _string(c ? strdup(s) : s), _own(c) { };
  virtual ~StringName() { if (_own) delete (char*)_string; };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class ConcatenatedName : public Name {
  name_vec elements;
  char catc;
 public:
  ConcatenatedName() : elements((Name*)0, 0), catc('+') { };
  ConcatenatedName(const Name* n) : elements(n, 1), catc('+') { };
  ConcatenatedName(char c) : elements((Name*)0, 0), catc(c) { };
  ConcatenatedName(const Name* n1, const Name* n2, char c)
    : elements((Name*)0, 0), catc(c)
  {
    elements.append(n1);
    elements.append(n2);
  };
  virtual ~ConcatenatedName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
  void append(const Name* n) { elements.append(n); };
};
class ModName : public Name {
  const char* _mod;
  const Name* _name;
 public:
  ModName(const Name* n, const char* m) : _mod(m), _name(n) { };
  virtual ~ModName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class CopyName : public Name {
  const Name* _name;
  index_type _num;
 public:
  CopyName(const Name* n) : _name(n), _num(no_such_index) { };
  CopyName(const Name* n, index_type m) : _name(n), _num(m) { };
  virtual ~CopyName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class NameAtIndex : public Name {
  const Name* _name;
  index_type _index;
 public:
  NameAtIndex(const Name* n, index_type i) : _name(n), _index(i) { };
  virtual ~NameAtIndex() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class EnumName : public Name {
  const char* prefix;
  index_type index;
 public:
  EnumName(const char* p, index_type i) : prefix(p), index(i) { };
  virtual ~EnumName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
}
#include <map>
#include <iostream>
namespace hsps {
class graph {
 private:
  index_type _size;
  bool_matrix adj;
  index_set_vec in;
  index_set_vec out;
  index_set_vec bi;
  index_vec comp;
  index_type n_comp;
 public:
  graph();
  graph(index_type s);
  graph(const graph& g);
  graph(const graph& g, const index_set& n);
  graph(const graph& g, const equivalence& eq);
  ~graph();
  index_type size() const { return _size; };
  bool adjacent(index_type i, index_type j) const { return adj[i][j]; };
  bool adjacent(index_type i, const index_set& n) const;
  bool adjacent(const index_set& n, index_type i) const;
  bool adjacent(const index_set& n0, const index_set& n1) const;
  bool bi_adjacent(index_type i, index_type j) const
    { return (adj[i][j] && adj[j][i]); };
  bool bi_adjacent(index_type i, const index_set& n) const;
  index_type n_edges() const;
  index_type n_edges(const index_set& from, const index_set& to) const;
  pair_set& edges(pair_set& s) const;
  index_type n_induced_undirected_edges() const;
  index_type n_induced_undirected_edges(const index_set& n0,
     const index_set& n1) const;
  index_type n_bidirectional_edges() const;
  index_type n_bidirectional_edges(const index_set& n0,
       const index_set& n1) const;
  const index_set& successors(index_type i) const { return out[i]; };
  index_type out_degree(index_type i) const { return out[i].length(); };
  const index_set& predecessors(index_type i) const { return in[i]; };
  index_type in_degree(index_type i) const { return in[i].length(); };
  const index_set& bidirectional(index_type i) const { return bi[i]; };
  index_type bi_degree(index_type i) const { return bi[i].length(); };
  pair_set& bidirectional_edges(pair_set& s) const;
  void descendants(index_type n0, bool_vec& s) const;
  void descendants(const index_set& s0, bool_vec& s) const;
  void descendants(index_type n0, index_set& s) const;
  void descendants(const index_set& s0, index_set& s) const;
  void ancestors(index_type n0, bool_vec& s) const;
  void ancestors(const index_set& s0, bool_vec& s) const;
  void ancestors(index_type n0, index_set& s) const;
  void ancestors(const index_set& s0, index_set& s) const;
  index_type max_out_degree() const;
  index_type max_in_degree() const;
  index_type max_bi_degree() const;
  index_type min_out_degree() const;
  index_type min_in_degree() const;
  index_type min_bi_degree() const;
  bool empty() const;
  bool connected() const;
  bool strongly_connected() const;
  bool reachable(index_type n0, index_type n1) const;
  void reachable(bool_vec& v) const;
  index_type count_reachable(index_type n0) const;
  bool acyclic() const;
  bool top_sort(index_vec& s) const;
  index_type first_root() const;
  index_type first_leaf() const;
  void fringe(const index_set& n, index_set& fn) const;
  void bi_fringe(const index_set& n, index_set& fn) const;
  void distance(index_type s0, index_vec& d) const;
  void distance(const index_set& s0, index_vec& d) const;
  index_type distance(index_type s0, index_type s1) const;
  void strongly_connected_components();
  index_type component(index_type i) const { return comp[i]; };
  index_type n_components() const { return n_comp; };
  index_type component_node(index_type i) const;
  index_type component_size(index_type i) const;
  void component_node_set(index_type i, index_set& set) const;
  graph& component_tree(graph& cg) const;
  equivalence& component_partitioning(equivalence& eq) const;
  index_type maximal_non_unit_component() const;
  graph& subgraph(graph& g, const index_set& n) const;
  graph& edge_subgraph(graph& g, const index_set& nodes) const;
  equivalence& induced_partitioning(equivalence& eq) const;
  graph& induced_undirected_graph(graph& g) const;
  graph& minimal_equivalent_digraph(graph& g) const;
  graph& minimal_distance_graph(graph& g, const index_set& s0) const;
  graph& quotient(graph& g, const equivalence& eq) const;
  bool equals(const graph& g) const;
  bool equals(const graph& g, const index_vec& c) const;
  void difference(const graph& g,
    const index_vec& c,
    pair_set& d0,
    pair_set& d1) const;
  void difference(const graph& g,
    pair_set& d0,
    pair_set& d1) const;
  index_type cardinality_of_difference(const graph& g) const;
  void init(index_type s);
  void copy(const graph& g);
  void copy(const graph& g, const index_vec& map);
  void copy_and_rename(const graph& g, const index_vec& map);
  index_type add_node();
  void remove_node(index_type n);
  void add_graph(const graph& g, mapping& m);
  void add_edge(index_type src, index_type dst);
  void add_edge(const index_set& srcs, index_type dst);
  void add_edge(index_type src, const index_set& dsts);
  void add_edge_to_transitive_closure(index_type src,
          index_type dst,
          pair_set& e);
  void remove_edge(index_type src, index_type dst);
  void remove_edges_from(index_type src);
  void remove_edges_to(index_type dst);
  void remove_edges_incident_on(index_type n);
  void remove_edges(const pair_set& e);
  void add_undirected_edge(index_type n0, index_type n1);
  void remove_undirected_edge(index_type n0, index_type n1);
  void remove_undirected_edges(const pair_set& e);
  void clear_edges();
  void recalculate();
  void complement();
  void complement_with_loops();
  void remove_loops();
  void reverse();
  void transitive_closure();
  void missing_transitive_edges(pair_set& e) const;
  void transitive_reduction();
  void intersect(const graph& g);
  void randomize(count_type n, RNG& rnd);
  void randomize_connected(count_type n, RNG& rnd);
  void randomize_strongly_connected(count_type n, RNG& rnd);
  void random_digraph(count_type n, RNG& rnd);
  void random_connected_digraph(count_type n, RNG& rnd);
  void random_strongly_connected_digraph(count_type n, RNG& rnd);
  void random_digraph_with_density(rational density, RNG& rnd);
  void random_tree(RNG& rnd);
  void random_tree(index_type b, index_type d, RNG& rnd);
  bool is_clique(const index_set& nodes) const;
  bool is_independent(const index_set& nodes) const;
  bool is_independent_range(index_type l, index_type u) const;
  void maximal_clique(index_set& clique) const;
  void maximal_clique_including(index_type node, index_set& clique) const;
  void maximal_clique_cover(index_set_vec& sets) const;
  void all_maximal_cliques(index_set_vec& cliques) const;
  void all_maximal_cliques_including(index_type node, index_set_vec& cliques)
    const;
  void apx_independent_set(index_set& set) const;
  void apx_independent_set_including(index_type node, index_set& set) const;
  void apx_independent_set_cover(index_set_vec& sets) const;
  void apx_independent_set_disjoint_cover(index_set_vec& sets) const;
  void all_nondominated_cliques(index_set_vec &cliques) const;
  void all_cliques_geq(index_type k, index_set_vec& cliques) const;
  void write_node_set(::std::ostream& s) const;
  void write_edge_set(::std::ostream& s) const;
  void write_compact(::std::ostream& s) const;
  void write_undirected_edge_set(::std::ostream& s) const;
  void write_adjacency_lists(::std::ostream& s) const;
  void write_digraph(::std::ostream& s,
       bool with_node_indices,
       const char* name) const;
  void write_component_labeled_digraph(::std::ostream& s,
           const char* name) const;
  void write_graph_correspondance(::std::ostream& s,
      const graph& g,
      const index_vec& c,
      const char* name) const;
 public:
  void max_clique(index_set& sel,
    index_type next,
    index_set& clique) const;
  void all_max_cliques(index_set& sel,
         index_type next,
         index_set_vec& cliques) const;
  void all_nondominated_cliques_aux(index_set_vec &cliques,
                                    index_set &current_clique,
                                    const index_set &candidates,
        index_type min) const;
  void ramsey(const index_set& nodes, index_set& I, index_set& C) const;
  void apx_independent_set(const index_set& nodes, index_set& set) const;
  void undirected_dfs(index_type n, bool_vec& visited) const;
  void reachable(index_type n, bool_vec& v) const;
  void reverse_reachable(index_type n, bool_vec& v) const;
 private:
  void scc_first_dfs(index_type n, bool_vec& visited, index_vec& num) const;
  void scc_second_dfs(index_type n, bool_vec& visited, index_type c_id);
};
template<class LS>
void write_labeled_digraph
(std::ostream& s,
 const graph& g,
 const LS& ls,
 bool with_node_indices = false,
 const char* name = 0,
 index_type c_id = no_such_index)
{
  if (c_id != no_such_index) {
    s << "subgraph cluster" << c_id << "{" << std::endl;
  }
  else if (name) {
    s << "digraph \"" << name << "\" {" << ::std::endl;
  }
  s << "node [width=0,height=0];" << ::std::endl;
  for (index_type k = 0; k < g.size(); k++) {
    if (with_node_indices) {
      s << "\t" << k + (c_id == no_such_index ? 0 : c_id)
 << " [label=\"(" << k << ") " << ls[k] << "\"];"
 << ::std::endl;
    }
    else {
      s << "\t" << k + (c_id == no_such_index ? 0 : c_id)
 << " [label=\"" << ls[k] << "\"];"
 << ::std::endl;
    }
  }
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j))
 s << "\t" << i + (c_id == no_such_index ? 0 : c_id)
   << " -> " << j + (c_id == no_such_index ? 0 : c_id)
   << ";" << ::std::endl;
  if ((c_id != no_such_index) || (name != 0)) {
    s << "}" << ::std::endl;
  }
}
typedef lvector<graph> graph_vec;
template<class N, class E> class labeled_graph : public graph {
 public:
  typedef std::map<index_type, N> node_label_map;
  typedef std::map<index_pair, E> edge_label_map;
  typedef lvector<N> node_label_vec;
  typedef lvector<E> edge_label_vec;
 protected:
  node_label_map _node_label;
  edge_label_map _edge_label;
 public:
  labeled_graph();
  labeled_graph(index_type size);
  labeled_graph(const graph& g);
  labeled_graph(const labeled_graph& g);
  labeled_graph(const graph& g, const index_set& nodes);
  labeled_graph(const labeled_graph& g, const index_set& nodes);
  labeled_graph(const graph& g, const equivalence& eq);
  ~labeled_graph();
  N& node_label(index_type n);
  E& edge_label(index_type i, index_type j);
  const N& node_label(index_type n) const;
  const E& edge_label(index_type i, index_type j) const;
  bool node_has_label(index_type n) const;
  bool edge_has_label(index_type i, index_type j) const;
  labeled_graph& subgraph(labeled_graph& g, const index_set& n) const;
  index_type node_with_label(const N& l) const;
  index_pair edge_with_label(const E& l) const;
  void init(index_type size);
  void init(index_type size, const N& n, const E& e);
  void copy(const graph& g);
  void copy(const labeled_graph& g);
  void add_graph(const graph& g, mapping& m);
  void add_graph(const labeled_graph& g, mapping& m);
  void add_edge(index_type src, index_type dst);
  void add_edge(index_type src, index_type dst, const E& lbl);
  void add_edge(const index_set& srcs, index_type dst);
  void add_edge(const index_set& srcs, index_type dst, const E& lbl);
  void add_edge(index_type src, const index_set& dsts);
  void add_edge(index_type src, const index_set& dsts, const E& lbl);
  index_type add_node();
  index_type add_node(const N& l);
  void remove_node(index_type n);
  void remove_edge(index_type src, index_type dst);
  void remove_edges_from(index_type src);
  void remove_edges_to(index_type dst);
  void remove_edges_incident_on(index_type n);
  void remove_undirected_edge(index_type n0, index_type n1);
  void remove_edges(const pair_set& e);
  void remove_undirected_edges(const pair_set& e);
  void clear_edges();
  void clear_node_labels();
  void clear_edge_labels();
  void remove_edges_with_label(const E& l);
  void write_digraph(::std::ostream& s,
       bool with_node_indices,
       bool with_node_labels,
       bool with_edge_labels,
       bool compact_edges,
       const char* name) const;
  void write_matrix(::std::ostream& s,
      const char* unlabeled_edge,
      const char* missing_edge) const;
};
template<class N, class E>
labeled_graph<N,E>::labeled_graph()
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(index_type s)
  : graph(s)
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(const graph& g)
  : graph(g)
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(const labeled_graph& g)
  : graph(g), _node_label(g._node_label), _edge_label(g._edge_label)
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(const graph& g, const index_set& n)
{
  g.subgraph(*this, n);
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph
(const labeled_graph& g, const index_set& n)
{
  g.subgraph(*this, n);
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph
(const graph& g, const equivalence& eq)
{
  g.quotient(*this, eq);
}
template<class N, class E>
labeled_graph<N,E>::~labeled_graph()
{
}
template<class N, class E>
N& labeled_graph<N,E>::node_label(index_type n)
{
  assert(n < size());
  return _node_label[n];
}
template<class N, class E>
E& labeled_graph<N,E>::edge_label(index_type i, index_type j)
{
  assert((i < size()) && (j < size()));
  return _edge_label[index_pair(i, j)];
}
template<class N, class E>
const N& labeled_graph<N,E>::node_label(index_type n) const
{
  assert(node_has_label(n));
  return (_node_label.find(n)->second);
}
template<class N, class E>
const E& labeled_graph<N,E>::edge_label(index_type i, index_type j) const
{
  assert(edge_has_label(i, j));
  return (_edge_label.find(index_pair(i, j))->second);
}
template<class N, class E>
bool labeled_graph<N,E>::node_has_label(index_type n) const
{
  assert(n < size());
  return (_node_label.find(n) != _node_label.end());
}
template<class N, class E>
bool labeled_graph<N,E>::edge_has_label(index_type i, index_type j) const
{
  assert((i < size()) && (j < size()));
  return (_edge_label.find(index_pair(i, j)) != _edge_label.end());
}
template<class N, class E>
void labeled_graph<N,E>::init(index_type s)
{
  graph::init(s);
  _node_label.clear();
  _edge_label.clear();
}
template<class N, class E>
void labeled_graph<N,E>::copy(const labeled_graph& g)
{
  graph::copy(g);
  _node_label = g._node_label;
  _edge_label = g._edge_label;
}
template<class N, class E>
labeled_graph<N,E>& labeled_graph<N,E>::subgraph
(labeled_graph& g, const index_set& n) const
{
  g.init(n.length());
  for (index_type k = 0; k < n.length(); k++) {
    assert(n[k] < size());
    if (node_has_label(n[k])) {
      g.node_label(k) = node_label(n[k]);
    }
  }
  for (index_type i = 0; i < n.length(); i++)
    for (index_type j = 0; j < n.length(); j++)
      if (adjacent(n[i], n[j])) {
 g.add_edge(i, j);
 if (edge_has_label(n[i], n[j])) {
   g.edge_label(i, j) = edge_label(n[i], n[j]);
 }
      }
}
template<class N, class E>
index_type labeled_graph<N,E>::node_with_label(const N& l) const
{
  for (index_type k = 0; k < size(); k++)
    if (node_has_label(k))
      if (node_label(k) == l)
 return k;
  return no_such_index;
}
template<class N, class E>
index_pair labeled_graph<N,E>::edge_with_label(const E& l) const
{
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) && edge_has_label(i, j))
 if (edge_label(i, j) == l)
   return index_pair(i, j);
  return no_such_index;
}
template<class N, class E>
void labeled_graph<N,E>::add_graph
(const graph& g, mapping& m)
{
  graph::add_graph(g, m);
}
template<class N, class E>
void labeled_graph<N,E>::add_graph
(const labeled_graph& g, mapping& m)
{
  graph::add_graph(g, m);
  for (index_type i = 0; i < g.size(); i++) {
    if (g.node_has_label(i))
      node_label(m[i]) = g.node_label(i);
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j) && g.edge_has_label(i, j))
 edge_label(m[i], m[j]) = g.edge_label(i, j);
  }
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, index_type dst)
{
  graph::add_edge(src, dst);
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, index_type dst, const E& lbl)
{
  graph::add_edge(src, dst);
  edge_label(src, dst) = lbl;
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(const index_set& srcs, index_type dst)
{
  graph::add_edge(srcs, dst);
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(const index_set& srcs, index_type dst, const E& lbl)
{
  graph::add_edge(srcs, dst);
  for (index_type k = 0; k < srcs.length(); k++)
    edge_label(srcs[k], dst) = lbl;
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, const index_set& dsts)
{
  graph::add_edge(src, dsts);
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, const index_set& dsts, const E& lbl)
{
  graph::add_edge(src, dsts);
  for (index_type k = 0; k < dsts.length(); k++)
    edge_label(src, dsts[k]) = lbl;
}
template<class N, class E>
index_type labeled_graph<N,E>::add_node()
{
  return graph::add_node();
}
template<class N, class E>
index_type labeled_graph<N,E>::add_node(const N& l)
{
  index_type n = graph::add_node();
  node_label(n) = l;
  return n;
}
template<class N, class E>
void labeled_graph<N,E>::remove_node(index_type n)
{
  assert(n < size());
  labeled_graph g(*this);
  index_set ns;
  ns.fill(size());
  ns.subtract(n);
  g.subgraph(*this, ns);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edge(index_type src, index_type dst)
{
  _edge_label.erase(index_pair(src, dst));
  graph::remove_edge(src, dst);
}
template<class N, class E>
void labeled_graph<N,E>::remove_undirected_edge(index_type n0, index_type n1)
{
  _edge_label.erase(index_pair(n0, n1));
  _edge_label.erase(index_pair(n1, n0));
  graph::remove_undirected_edge(n0, n1);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_from(index_type src)
{
  index_set ns(successors(src));
  for (index_type k = 0; k < ns.length(); k++)
    remove_edge(src, ns[k]);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_to(index_type dst)
{
  index_set ns(predecessors(dst));
  for (index_type k = 0; k < ns.length(); k++)
    remove_edge(ns[k], dst);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_incident_on(index_type n)
{
  remove_edges_from(n);
  remove_edges_to(n);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges(const pair_set& e)
{
  for (index_type k = 0; k < e.length(); k++) {
    remove_edge(e[k].first, e[k].second);
  }
}
template<class N, class E>
void labeled_graph<N,E>::remove_undirected_edges(const pair_set& e)
{
  for (index_type k = 0; k < e.length(); k++) {
    remove_undirected_edge(e[k].first, e[k].second);
  }
}
template<class N, class E>
void labeled_graph<N,E>::clear_edges()
{
  _edge_label.clear();
  graph::clear_edges();
}
template<class N, class E>
void labeled_graph<N,E>::clear_node_labels()
{
  _node_label.clear();
}
template<class N, class E>
void labeled_graph<N,E>::clear_edge_labels()
{
  _edge_label.clear();
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_with_label(const E& l)
{
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) && (edge_label(i, j) == l))
 remove_edge(i, j);
}
template<class N, class E>
void labeled_graph<N,E>::write_digraph
(::std::ostream& s,
 bool with_node_indices,
 bool with_node_labels,
 bool with_edge_labels,
 bool compact_edges,
 const char* name) const
{
  if (strncmp(name, "cluster", 7) == 0)
    s << "subgraph";
  else
    s << "digraph";
  s << " \"" << name << "\"" << ::std::endl << "{" << ::std::endl;
  if (with_node_indices || with_node_labels) {
    s << "\tnode [shape=ellipse];" << ::std::endl;
  }
  else {
    s << "\tnode [shape=point];" << ::std::endl;
  }
  for (index_type i = 0; i < size(); i++) {
    s << "\t" << i;
    if (with_node_indices || with_node_labels) {
      s << " [label=\"";
      if (with_node_indices) {
 if (with_node_labels) {
   s << i << ": ";
   if (node_has_label(i)) {
     s << node_label(i);
   }
 }
 else {
   s << i;
 }
      }
      else {
 if (node_has_label(i)) {
   s << node_label(i);
 }
      }
      s << "\"]";
    }
    s << ";" << std::endl;
  }
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j)) {
 if (adjacent(j, i) && compact_edges) {
   if (i < j) {
     s << "\t" << i << " -> " << j;
     s << " [dir=both";
     if (with_edge_labels &&
  (edge_has_label(i, j) || edge_has_label(j, i))) {
       if (!edge_has_label(i, j)) {
  s << ",label=\"" << edge_label(j, i) << "\"";
       }
       else if (!edge_has_label(j, i)) {
  s << ",label=\"" << edge_label(i, j) << "\"";
       }
       else if (edge_label(i, j) == edge_label(j, i)) {
  s << ",label=\"" << edge_label(i, j) << "\"";
       }
       else {
  s << ",label=\"" << edge_label(i, j) << ", "
    << edge_label(j, i) << "\"";
       }
     }
     s << "]" << ::std::endl;
   }
 }
 else {
   s << "\t" << i << " -> " << j;
   if (with_edge_labels && edge_has_label(i, j)) {
     s << " [label=\"" << edge_label(i, j) << "\"]";
   }
   s << ";" << ::std::endl;
 }
      }
  s << "}" << ::std::endl;
}
template<class N, class E>
void labeled_graph<N,E>::write_matrix
(::std::ostream& s, const char* unlabeled_edge, const char* missing_edge) const
{
  s << '[';
  for (index_type i = 0; i < size(); i++) {
    if (i > 0) s << ' ';
    s << '[';
    for (index_type j = 0; j < size(); j++) {
      if (j > 0) s << ',';
      if (adjacent(i, j)) {
 if (edge_has_label(i, j)) {
   s << edge_label(i, j);
 }
 else {
   s << unlabeled_edge;
 }
      }
      else {
 s << missing_edge;
      }
    }
    s << ']';
    if (i + 1 < size()) {
      s << ',' << '\n';
    }
    else {
      s << ']' << '\n';
    }
  }
}
class index_graph : public labeled_graph<index_type,index_type> {
  static const index_type NODE_SHAPE = 2 + 4 + 8 + 16;
  static const index_type NODE_STYLE = 64 + 128 + 256;
  static const index_type EDGE_STYLE = 64 + 128;
  static const index_type EDGE_DIR = 512 + 1024;
 public:
  static const index_type NS_CIRCLE = 0;
  static const index_type NS_ELLIPSE = 2;
  static const index_type NS_BOX = 4;
  static const index_type NS_POINT = 6;
  static const index_type NS_DIAMOND = 8;
  static const index_type NS_HEXAGON = 10;
  static const index_type NS_OCTAGON = 12;
  static const index_type NS_PLAINTEXT = 14;
  static const index_type NS_NORMAL = 0;
  static const index_type NS_DOUBLE = 32;
  static const index_type NS_BOLD = 64;
  static const index_type NS_DASHED = 128;
  static const index_type NS_DOTTED = 192;
  static const index_type NS_FILLED = 256;
  static const index_type ED_NONE = 0;
  static const index_type ED_FORWARD = 512;
  static const index_type ED_BACK = 1024;
  static const index_type ED_BOTH = ED_FORWARD + ED_BACK;
  static const index_type ES_NORMAL = NS_NORMAL;
  static const index_type ES_BOLD = NS_BOLD;
  static const index_type ES_DASHED = NS_DASHED;
  static const index_type ES_DOTTED = NS_DOTTED;
  static const index_type STYLE_MAX = 2048;
  index_graph()
    : labeled_graph<index_type, index_type>() { };
  index_graph(index_type size)
    : labeled_graph<index_type, index_type>(size) { };
  index_graph(const graph& g)
    : labeled_graph<index_type, index_type>(g) { };
  index_graph(const index_graph& g)
    : labeled_graph<index_type, index_type>(g) { };
  index_graph(const graph& g, const index_set& nodes)
    : labeled_graph<index_type, index_type>(g, nodes) { };
  index_graph(const index_graph& g, const index_set& nodes)
    : labeled_graph<index_type, index_type>(g, nodes) { };
  index_graph(const graph& g, const equivalence& eq)
    : labeled_graph<index_type, index_type>(g, eq) { };
  ~index_graph() { };
  void reverse();
  void reflect();
  static void write_node_style(std::ostream& s, index_type l);
  static void write_edge_style(std::ostream& s, index_type l);
  void write_styled_digraph(std::ostream& s,
       bool with_node_indices = false,
       const char* name = 0,
       index_type c_id = no_such_index) const;
  void write_matrix(std::ostream& s) const;
  void write_MATLAB(std::ostream& s,
      const char* n,
      const char* t) const;
};
template<class LS>
void write_styled_digraph
(std::ostream& s,
 const index_graph& g,
 const LS& ls,
 bool with_node_indices = false,
 const char* name = 0,
 index_type c_id = no_such_index)
{
  if (c_id != no_such_index) {
    s << "subgraph cluster" << c_id << " {" << std::endl;
    s << "node [width=0.5,height=0.5];" << ::std::endl;
  }
  else if (name) {
    s << "digraph \"" << name << "\" {" << std::endl;
    s << "node [width=0.5,height=0.5];" << ::std::endl;
  }
  for (index_type k = 0; k < g.size(); k++) {
    s << "\t" << k + (c_id != no_such_index ? c_id : 0) << " [";
    index_graph::write_node_style(s, g.node_has_label(k) ? g.node_label(k) : 0);
    if (with_node_indices)
      s << ",label=\"(" << k << ") " << ls[k] << "\"];" << std::endl;
    else
      s << ",label=\"" << ls[k] << "\"];" << std::endl;
  }
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j)) {
 s << "\t" << i + (c_id != no_such_index ? c_id : 0)
   << " -> " << j + (c_id != no_such_index ? c_id : 0) << " [";
 index_graph::write_edge_style(s, g.edge_has_label(i, j) ? g.edge_label(i, j) : 0);
 s << "];" << std::endl;
      }
  if ((c_id != no_such_index) || (name != 0)) {
    s << "}" << ::std::endl;
  }
}
class weighted_graph : public labeled_graph<hsps::rational,hsps::rational> {
 public:
  weighted_graph() { };
  weighted_graph(index_type s)
    : labeled_graph<hsps::rational,hsps::rational>(s) { };
  weighted_graph(const graph& g)
    : labeled_graph<hsps::rational,hsps::rational>(g) { };
  weighted_graph(const weighted_graph& g)
    : labeled_graph<hsps::rational,hsps::rational>(g) { };
  weighted_graph(const graph& g, const index_set& n)
    : labeled_graph<hsps::rational,hsps::rational>(g, n) { };
  weighted_graph(const weighted_graph& g, const index_set& n)
    : labeled_graph<hsps::rational,hsps::rational>(g, n) { };
  weighted_graph(const graph& g, const equivalence& eq)
    : labeled_graph<hsps::rational,hsps::rational>(g, eq) { };
  weighted_graph(const weighted_graph& g, const equivalence& eq);
  ~weighted_graph() { };
  weighted_graph& quotient(weighted_graph& g, const equivalence& eq) const;
  hsps::rational apx_weighted_independent_set_1(index_set& set) const;
  hsps::rational apx_weighted_independent_set_2(index_set& set) const;
  hsps::rational apx_weighted_independent_set(index_set& set) const;
  void add_edge(index_type src, index_type dst);
  void add_edge(index_type src, index_type dst, hsps::rational w);
  void add_undirected_edge(index_type n0, index_type n1);
  void add_undirected_edge(index_type n0, index_type n1, hsps::rational w);
  hsps::rational weight(index_type n) const;
  hsps::rational weight(index_type n0, index_type n1) const;
  hsps::rational weight(const index_set& ns) const;
  void set_weight(index_type n, hsps::rational w);
  void set_weight(index_type n0, index_type n1, hsps::rational w);
  void increment_edge_weight(index_type src, index_type dst, hsps::rational w);
  hsps::rational max_node_weight() const;
  void transitive_closure();
  hsps::rational critical_path(cost_vec& s);
  hsps::rational max_flow(index_type s, index_type t);
  hsps::rational max_flow(index_type s, index_type t, weighted_graph& rg);
  hsps::rational max_flow(index_type s, index_type t, cost_matrix& f);
  hsps::rational min_cut(index_type s, index_type t, bool_vec& s_set);
  hsps::rational min_cut(index_type s, index_type t, pair_set& e_set);
  index_pair max_weight_edge() const;
  void min_and_max_edges(const index_set& nodes,
    pair_set& e_min, hsps::rational& w_min,
    pair_set& e_max, hsps::rational& w_max) const;
  hsps::rational maximal_matching(weighted_graph& matching);
  hsps::rational apx_matching(bool_vec& nodes);
  void write_node_set(::std::ostream& s) const;
  void write_edge_set(::std::ostream& s) const;
  void write_compact(::std::ostream& s) const;
  void write_matrix(::std::ostream& s) const;
 private:
  hsps::rational augmenting_path(index_type s, index_type t, const cost_matrix& f,
   pair_vec& p);
};
class index_set_graph : public labeled_graph<index_set,index_set> {
 public:
  index_set_graph() { };
  index_set_graph(index_type s)
    : labeled_graph<index_set,index_set>(s) { };
  index_set_graph(const graph& g)
    : labeled_graph<index_set,index_set>(g) { };
  index_set_graph(const index_set_graph& g)
    : labeled_graph<index_set,index_set>(g) { };
  index_set_graph(const graph& g, const index_set& n)
    : labeled_graph<index_set,index_set>(g, n) { };
  index_set_graph(const index_set_graph& g, const index_set& n)
    : labeled_graph<index_set,index_set>(g, n) { };
  index_set_graph(const graph& g, const equivalence& eq);
  index_set_graph(const index_set_graph& g, const equivalence& eq);
  ~index_set_graph() { };
  void union_reachable();
  void merge_labels(const index_set& ns);
  void merge_labels_upwards();
  void merge_labels_downwards();
  index_set_graph& quotient(index_set_graph& g, const equivalence& eq) const;
  index_set_graph& union_reachable(index_set_graph& g) const;
  index_set_graph& subgraph_set_size_gt(index_set_graph& g, index_type l);
  void write_edge_set(::std::ostream& s) const;
  void write_digraph(::std::ostream& s, const char* name) const;
};
inline ::std::ostream& operator<<(::std::ostream& s, const graph& g)
{
  g.write_compact(s);
  return s;
};
inline ::std::ostream& operator<<(::std::ostream& s, const weighted_graph& g)
{
  g.write_compact(s);
  return s;
};
inline ::std::ostream& operator<<(::std::ostream& s, const index_set_graph& g)
{
  g.write_edge_set(s);
  return s;
};
}
namespace hsps {
class Heuristic;
struct rule {
  index_set antecedent;
  index_type consequent;
  rule() : antecedent(EMPTYSET), consequent(no_such_index) { };
  rule(index_type c) : antecedent(EMPTYSET), consequent(c) { };
  rule(const index_set& a, index_type c) : antecedent(a), consequent(c) { };
  rule(const rule& r) : antecedent(r.antecedent), consequent(r.consequent) { };
  rule& operator=(const rule& r) {
    antecedent = r.antecedent;
    consequent = r.consequent;
    return *this;
  };
  bool operator==(const rule& r) const {
    return ((antecedent == r.antecedent) && (consequent == r.consequent));
  };
  bool operator!=(const rule& r) const {
    return (!(*this == r));
  };
  bool operator<(const rule& r) const {
    return ((consequent < r.consequent) ||
     ((consequent == r.consequent) && (antecedent < r.antecedent)));
  };
  bool operator>(const rule& r) const {
    return ((consequent > r.consequent) ||
     ((consequent == r.consequent) && (antecedent > r.antecedent)));
  };
};
class rule_set : public svector<rule> {
 public:
  index_type find_rule(index_type c) const;
  void compute_dependency_graph(index_type n, index_graph& g) const;
  void remove(const bool_vec& set, index_vec& map);
  void remove(const bool_vec& set, index_graph& g);
  void remove(const bool_vec& set);
  void make_acyclic(index_graph& g);
  void make_post_unique(index_graph& g);
};
typedef svector<const char*> string_set;
class Instance {
  bool xrf;
 public:
  static bool write_negation;
  static bool write_DKEL;
  static bool write_PDDL2;
  static bool write_time;
  static bool write_PDDL3;
  static bool write_metric;
  static bool write_extra;
  static bool write_resource_constraints_at_start;
  static bool always_write_parameters;
  static bool always_write_requirements;
  static bool always_write_precondition;
  static bool always_write_effect;
  static bool always_write_conjunction;
  static bool write_atom_set_with_symbolic_names;
  static bool write_action_set_with_symbolic_names;
  static const char* goal_atom_name;
  static const char* goal_action_name;
  static hsps::rational goal_action_cost;
  static const char* pc_name;
  static index_type pc_count;
  struct Atom {
    const Name* name;
    index_type index;
    index_type neg;
    bool init;
    hsps::rational init_t;
    bool goal;
    hsps::rational goal_t;
    bool irrelevant;
    void* src;
    index_vec req_by;
    index_vec add_by;
    index_vec del_by;
    Atom() : name(0), index(no_such_index), neg(no_such_index),
  init(false), init_t(0), goal(false), goal_t(POS_INF),
  irrelevant(false), src(0), req_by(no_such_index, 0),
  add_by(no_such_index, 0), del_by(no_such_index, 0) { };
    Atom(const Name* n) : name(n), index(0), neg(no_such_index),
  init(false), init_t(0), goal(false), goal_t(POS_INF),
  irrelevant(false), src(0), req_by(no_such_index, 0),
  add_by(no_such_index, 0), del_by(no_such_index, 0) { };
    Atom(const Name* n, index_type i) : name(n), index(i),
  neg(no_such_index), init(false), init_t(0), goal(false),
  goal_t(POS_INF),
  irrelevant(false), req_by(no_such_index, 0),
  add_by(no_such_index, 0), del_by(no_such_index, 0) { };
    Atom& operator=(const Atom& a) {
      name = a.name;
      index = a.index;
      neg = a.neg;
      init = a.init;
      init_t = a.init_t;
      goal = a.goal;
      goal_t = a.goal_t;
      irrelevant = a.irrelevant;
      src = a.src;
      req_by = a.req_by;
      add_by = a.add_by;
      del_by = a.del_by;
      return *this;
    };
    bool operator==(const Atom& a) {
      return (index == a.index);
    };
  };
  struct Resource {
    const Name* name;
    index_type index;
    hsps::rational init;
    void* src;
    bool consumed;
    bool used;
    Resource() : name(0), index(no_such_index), init(0), src(0),
  consumed(false), used(false) { };
    Resource(const Name* n) : name(n), index(no_such_index), init(0), src(0),
  consumed(false), used(false) { };
    Resource(const Name* n, index_type i) : name(n), index(i), init(0),
  src(0), consumed(false), used(false) { };
    Resource& operator=(const Resource& r) {
      name = r.name;
      index = r.index;
      init = r.init;
      src = r.src;
      consumed = r.consumed;
      used = r.used;
      return *this;
    };
    bool operator==(const Resource& r) {
      return (index == r.index);
    };
    bool reusable() const { return (used && !consumed); };
    bool consumable() const { return (consumed); };
  };
  struct Action {
    const Name* name;
    index_type index;
    bool sel;
    index_set pre;
    index_set add;
    index_set del;
    index_set lck;
    amt_vec use;
    amt_vec cons;
    hsps::rational dur;
    hsps::rational dmin;
    hsps::rational dmax;
    hsps::rational cost;
    const char* assoc;
    void* src;
    index_set ncw_atms;
    Action()
      : name(0), index(no_such_index), sel(true), pre(), add(), del(),
        lck(), use(ZERO, 0), cons(ZERO, 0), dur(1), dmin(1), dmax(1), cost(1),
  assoc(0), src(0), ncw_atms() { };
    Action(const Name* n)
      : name(n), index(no_such_index), sel(true), pre(), add(), del(),
        lck(), use(ZERO, 0), cons(ZERO, 0), dur(1), dmin(1), dmax(1), cost(1),
 assoc(0), src(0), ncw_atms() { };
    Action& operator=(const Action& a) {
      name = a.name;
      index = a.index;
      sel = a.sel;
      pre = a.pre;
      add = a.add;
      del = a.del;
      lck = a.lck;
      use = a.use;
      cons = a.cons;
      dur = a.dur;
      dmin = a.dmin;
      dmax = a.dmax;
      cost = a.cost;
      assoc = a.assoc;
      src = a.src;
      ncw_atms = a.ncw_atms;
      return *this;
    };
    bool operator==(const Action& a) {
      return (index == a.index);
    };
    hsps::rational req(index_type r) const { return use[r] + cons[r]; };
    bool e_deletes(index_type p, Heuristic* inc) const;
    bool e_deletes(const index_set& s, Heuristic* inc) const;
  };
  struct Constraint {
    const Name* name;
    index_type index;
    index_set set;
    index_type lim;
    bool exact;
    void* src;
    bool verified;
    Constraint() : name(0), index(no_such_index), set(), lim(0),
  exact(false), src(0), verified(false) { };
    Constraint(const Name* n) : name(n), index(no_such_index),
  set(), lim(0), exact(false), src(0), verified(false) { };
    Constraint(index_set s, index_type n, bool e) : name(0),
  index(no_such_index), set(s), lim(n), exact(e), src(0),
  verified(false) { };
    Constraint& operator=(const Constraint& c) {
      name = c.name;
      index = c.index;
      set = c.set;
      lim = c.lim;
      exact = c.exact;
      src = c.src;
      verified = c.verified;
      return *this;
    };
    bool operator==(const Constraint& c) {
      return ((set == c.set) && (lim == c.lim) && (exact == c.exact));
    };
  };
  typedef lvector<Atom> atom_vec;
  typedef lvector<Resource> resource_vec;
  typedef lvector<Action> action_vec;
  typedef lvector<Constraint> constraint_vec;
  typedef atom_vec::element_reference atom_ref;
  typedef resource_vec::element_reference resource_ref;
  typedef action_vec::element_reference action_ref;
  typedef constraint_vec::element_reference constraint_ref;
  const Name* name;
  atom_vec atoms;
  action_vec actions;
  resource_vec resources;
  constraint_vec invariants;
  index_set init_atoms;
  index_set goal_atoms;
  index_type max_pre, max_add, max_del, max_lck,
               max_add_by, max_del_by, max_req_by;
  hsps::rational min_dur, max_dur, min_cost, max_cost;
  set_hash_function atom_set_hash;
  set_hash_function action_set_hash;
  static int default_trace_level;
  int trace_level;
  Instance();
  Instance(const Name* n);
  Instance(const Instance& ins);
  ~Instance() { };
  Atom& new_atom(const Name* name);
  Resource& new_resource(const Name* name);
  Action& new_action(const Name* name);
  Action& copy_action(index_type a);
  Constraint& new_invariant();
  Constraint& new_invariant(const Name* name);
  Constraint& new_invariant(const index_set& s, index_type l, bool e);
  void copy(const Instance& ins);
  Instance* copy() const;
  void clear();
  void restricted_copy(const Instance& ins, const index_set& atms,
         const index_set& rc, index_set& acts, index_vec& map);
  void restricted_copy(const Instance& ins, const index_set& acts,
         index_vec& map);
  void abstracted_copy(const Instance& ins, const index_set& atms,
         index_vec& atm_map, index_vec& act_map);
  void reverse_copy(const Instance& ins);
  void delete_relax(const index_set& x_atms);
  void delete_relax_less(const index_set& x_atms);
  void assign_unique_action_names();
  void remove_actions(const bool_vec& set, index_vec& map);
  void remove_atoms(const bool_vec& set, index_vec& map);
  void remove_invariants(const bool_vec& set, index_vec& map);
  void remap_set(index_set& set, const index_vec& map);
  void remap_sets(index_set_vec& sets, const index_vec& map);
  void set_initial(const index_set& init);
  void set_goal(const index_set& goal);
  void set_DNF_goal(const index_set_vec& goal);
  void replace_atom_by_conjunction(index_type p, const index_set& c);
  void set_cost_bound(hsps::rational b);
  void create_composite_resource(const index_set& set);
  void create_total_resource();
  void extract_atom_negations_from_invariants();
  index_type complete_atom_negation(index_type a);
  void complete_atom_negations(const index_set& s);
  void complete_atom_negations();
  index_type create_history_atom(index_type a);
  void add_all_negation_invariants();
  void add_missing_negation_invariants();
  index_type compile_pc_always(const index_set& f, const Name* n);
  index_type compile_pc_sometime(const index_set& f, const Name* n);
  index_type compile_pc_at_most_once(const index_set& f, const Name* n);
  index_type compile_pc_sometime_before(const index_set& f_t,
     const index_set& f_c,
     const Name* n);
  void enforce_pc_always(const index_set& f, const Name* n);
  void enforce_pc_sometime(const index_set& f, const Name* n);
  void enforce_pc_at_most_once(const index_set& f, const Name* n);
  void enforce_pc_sometime_before(const index_set& f_t,
      const index_set& f_c,
      const Name* n);
  void compute_iff_axioms(rule_set& ax);
  void cross_reference();
  void clear_cross_reference();
  bool cross_referenced() const;
  bool verify_invariant(Constraint& inv);
  void verify_invariants();
  void save_durations(cost_vec& out) const;
  void set_durations(const cost_vec& in);
  void set_durations(const cost_vec& in, cost_vec& out);
  void assign_unit_durations(hsps::rational unit = hsps::rational(1));
  void discretize_durations(hsps::rational interval_width);
  void quantize_durations(index_type n_intervals);
  void round_durations_up();
  void round_durations_down();
  void round_durations();
  void assign_unit_costs(cost_vec& save);
  void restore_costs(const cost_vec& saved);
  void assign_unlimited_resources(cost_vec& save);
  void restore_resources(const cost_vec& saved);
  index_type n_atoms() const { return atoms.length(); };
  index_type n_resources() const { return resources.length(); };
  index_type n_reusable_resources() const;
  index_type n_consumable_resources() const;
  index_type n_actions() const { return actions.length(); };
  index_type n_invariants() const { return invariants.length(); };
  index_type n_verified_invariants() const;
  void atom_names(name_vec& names) const;
  void action_names(name_vec& names) const;
  void coadd_graph(graph& g) const;
  void cochange_graph(graph& g) const;
  void causal_graph(graph& g) const;
  void partitioning_graph(const index_set& goal,
     index_set_graph& g,
     index_set& n_goal) const;
  void make_graph_representation(index_graph& g, name_vec& nn);
  bool non_interfering(index_type a0, index_type a1) const;
  bool lock_compatible(index_type a0, index_type a1) const;
  bool resource_compatible(index_type a0, index_type a1) const;
  bool commutative(const Action& a0, const Action& a1) const;
  bool commutative(index_type a0, index_type a1) const;
  bool additive(index_type p0, index_type p1) const;
  bool cochanged(index_type p0, index_type p1) const;
  bool eval_invariant_in_partial_state(const index_set& s,
           const Constraint& inv);
  bool eval_invariant_in_partial_state(const bool_vec& s,
           const Constraint& inv);
  bool eval_invariant_in_complete_state(const index_set& s,
     const Constraint& inv);
  bool eval_invariant_in_complete_state(const bool_vec& s,
     const Constraint& inv);
  void negation_atom_set(const index_set& pset, index_set& nset) const;
  void write_atom_set(::std::ostream& s,
        const index_vec& set,
        unsigned int c = Name::NC_DEFAULT) const;
  void write_atom_set(::std::ostream& s,
        const bool_vec& set,
        unsigned int c = Name::NC_DEFAULT) const;
  void write_atom_sets(::std::ostream& s,
         const index_set_vec& sets,
         unsigned int c = Name::NC_DEFAULT) const;
  void write_action_set(::std::ostream& s,
   const index_vec& set,
   unsigned int c = Name::NC_DEFAULT) const;
  void write_action_set(::std::ostream& s,
   const bool_vec& set,
   unsigned int c = Name::NC_DEFAULT) const;
  void write_iff_axiom(::std::ostream& s, const rule& r) const;
  void write_iff_axiom_set(::std::ostream& s, const rule_set& rset) const;
  void write_atom_digraph(::std::ostream& s,
     const graph& g,
     const index_set& atomset,
     const bool_vec& mark_shaded,
     const bool_vec& mark_dashed,
     const char* label) const;
  void write_atom_digraph(::std::ostream& s,
     const graph& g,
     const char* label) const;
  void write_atom_action_digraph(::std::ostream& s,
     const graph& g,
     const index_set& atomset,
     const index_set& actionset,
     const bool_vec& mark_shaded,
     const bool_vec& mark_bold,
     const bool_vec& mark_dashed,
     const char* label) const;
  void write_atom_set_digraph(::std::ostream& s,
         const index_set_graph& g,
         const char* label) const;
  void write_atom_set_graph(::std::ostream& s,
       const index_set_graph& g,
       const char* label) const;
  void write_axiom_dependency_graph(::std::ostream& s,
        const index_graph& g,
        const char* label) const;
  virtual void write_PDDL_action
    (::std::ostream& s, const Action& act) const;
  virtual void write_DKEL_invariant_item
    (::std::ostream& s, const Constraint& inv, string_set& tags) const;
  virtual void write_DKEL_irrelevant_atom_item
    (::std::ostream& s, const Atom& atm, string_set& tags) const;
  virtual void write_DKEL_irrelevant_action_item
    (::std::ostream& s, const Action& act, string_set& tags) const;
  virtual void write_domain_atom_set
    (::std::ostream& s, const index_set& set) const;
  virtual void write_domain_action_set
    (::std::ostream& s, const index_set& set) const;
  virtual void write_domain_action_set
    (::std::ostream& s, const index_set& set, const Name* name) const;
  virtual void write_domain(::std::ostream& s) const;
  virtual void write_domain_init(::std::ostream& s) const;
  virtual void write_domain_declarations(::std::ostream& s) const;
  virtual void write_domain_actions(::std::ostream& s) const;
  virtual void write_domain_DKEL_items(::std::ostream& s) const;
  virtual void write_problem(::std::ostream& s) const;
  virtual void write_problem_init(::std::ostream& s) const;
  virtual void write_problem_goal(::std::ostream& s) const;
  virtual void write_problem_metric(::std::ostream& s) const;
  void print_atom(::std::ostream& s, const Atom& a) const;
  void print_resource(::std::ostream& s, const Resource& r) const;
  void print_action(::std::ostream& s, const Action& a) const;
  void print_invariant(::std::ostream& s, const Constraint& c) const;
  virtual void print(::std::ostream& s) const;
 private:
  void create_atom_negation(index_type a);
};
typedef lvector<Instance*> instance_vec;
class PreconditionEvaluator {
  enum eval_node_type { positive_leaf,
   undecided_leaf,
   no_test,
   test_invariant,
   test_atom };
  Instance& instance;
  eval_node_type node_type;
  index_type i_test;
  lvector<PreconditionEvaluator*> next;
  PreconditionEvaluator* prev;
  index_type n_positive;
  index_set acts;
  static void construct(Instance& ins,
   PreconditionEvaluator* p,
   bool_vec& s,
   bool_vec& ua,
   index_type n_ua,
   index_type n_pos,
   bool_vec& rem_invs,
   bool_vec& rem_atoms,
   hsps::rational T);
 public:
  PreconditionEvaluator(Instance& ins);
  ~PreconditionEvaluator();
  static PreconditionEvaluator* construct(Instance& ins, hsps::rational T);
  PreconditionEvaluator* node(const bool_vec& s);
  index_type eval(const bool_vec& s,
    const bool_vec& a,
    index_type* app,
    index_type c);
  void write_graph(std::ostream& s, bool root = true);
};
inline ::std::ostream& operator<<(::std::ostream& s, const rule& r)
{
  return s << r.antecedent << "->" << r.consequent;
};
inline ::std::ostream& operator<<(::std::ostream& s, const rule_set& r)
{
  s << '{';
  for (index_type k = 0; k < r.length(); k++) {
    if (k > 0) s << ',';
    s << r[k];
  }
  s << '}';
  return s;
};
}
namespace hsps {
class Search;
class Plan;
class State {
 protected:
  State* pre;
 public:
  State() : pre(0) { };
  State(const State& s) : pre(s.pre) { };
  virtual ~State();
  virtual const State* predecessor() const;
  virtual State* predecessor();
  virtual void set_predecessor(State* p);
  virtual bool is_encapsulated();
  virtual hsps::rational delta_cost() = 0;
  virtual hsps::rational acc_cost();
  virtual index_type depth() const;
  virtual hsps::rational est_cost() = 0;
  virtual bool is_final() = 0;
  virtual bool is_max() = 0;
  virtual hsps::rational expand(Search& s, hsps::rational bound) = 0;
  virtual void store(hsps::rational cost, bool opt) = 0;
  virtual void reevaluate() = 0;
  virtual int compare(const State& s) = 0;
  virtual index_type hash() = 0;
  virtual State* copy() = 0;
  virtual void insert(Plan& p) = 0;
  virtual void insert_path(Plan& p) = 0;
  virtual void write(::std::ostream& s) = 0;
  virtual void write_plan(::std::ostream& s) = 0;
  virtual void write_eval(::std::ostream& s, char* p = 0, bool e = true);
  State* copy_path();
  void delete_path();
  int compare_path(const State* s);
  void write_path(::std::ostream& s);
  virtual void write_path_as_graph(::std::ostream& s);
};
inline bool operator==(State& s0, State& s1) {
  return (s0.compare(s1) == 0);
}
inline bool operator<(State& s0, State& s1) {
  return (s0.compare(s1) < 0);
}
inline bool operator<=(State& s0, State& s1) {
  return (s0.compare(s1) <= 0);
}
inline bool operator>(State& s0, State& s1) {
  return (s0.compare(s1) > 0);
}
inline bool operator>=(State& s0, State& s1) {
  return (s0.compare(s1) >= 0);
}
inline ::std::ostream& operator<<(::std::ostream& s, State& state) {
  state.write(s);
  return s;
}
class ProgressionState : public State {
 public:
  ProgressionState() { };
  ProgressionState(const ProgressionState& s) : State(s) { };
  virtual ~ProgressionState() { };
  virtual void insert_path(Plan& p);
};
class RegressionState : public State {
 public:
  RegressionState() { };
  RegressionState(const RegressionState& s) : State(s) { };
  virtual ~RegressionState() { };
  virtual void insert_path(Plan& p);
};
typedef lvector<State*> state_vec;
class PlanTrait {
 public:
  PlanTrait() { };
  virtual ~PlanTrait();
  virtual const PlanTrait* cast_to(const char* class_name) const;
};
typedef lvector<PlanTrait*> plan_trait_vec;
class Plan {
 public:
  virtual ~Plan();
  virtual void protect(index_type atom) = 0;
  virtual void insert(index_type act) = 0;
  virtual void advance(hsps::rational delta) = 0;
  virtual void end() = 0;
  virtual void output(Plan& to);
  virtual void set_name(const Name* n);
  virtual void set_optimal(bool o);
  virtual void add_trait(PlanTrait* t);
};
class Search {
 public:
  virtual ~Search();
  virtual hsps::rational new_state(State& s, hsps::rational bound) = 0;
  virtual bool solved() const = 0;
  virtual bool optimal() const = 0;
  virtual bool done() const = 0;
};
class NoSearch : public Search {
  bool _solved;
 public:
  NoSearch() : _solved(false) { };
  virtual ~NoSearch();
  void reset();
  virtual hsps::rational new_state(State& s, hsps::rational bound);
  virtual bool solved() const;
  virtual bool optimal() const;
  virtual bool done() const;
};
class Transitions : public state_vec, public Search {
  State* target_state;
  hsps::rational delta_bound;
  bool bound_is_exact;
 public:
  Transitions();
  Transitions(State* from, State* to, hsps::rational db);
  virtual ~Transitions();
  void clear();
  bool find(State* from, State* to, hsps::rational d, bool x);
  virtual hsps::rational new_state(State& s, hsps::rational bound);
  virtual bool solved() const;
  virtual bool optimal() const;
  virtual bool done() const;
};
class StateFactory {
 public:
  virtual ~StateFactory();
  virtual State* new_state(const index_set& s, State* pre) = 0;
  virtual State* new_state(const bool_vec& s, State* pre) = 0;
};
class PlanSet {
 public:
  virtual ~PlanSet();
  virtual Plan* new_plan() = 0;
  virtual void output(PlanSet& to);
  virtual void output(PlanSet& to, const bool_vec& s);
};
}
namespace hsps {
extern const double D_INF;
class Stopwatch {
  double start_t;
  double current_t;
  double total_t;
  static constexpr double TIME_OUT_TOLERANCE = 1.1;
  static bool interrupt_signal_trapped;
  static volatile bool interrupt_signal_raised;
  static bool alarm_signal_trapped;
  static volatile bool alarm_signal_raised;
  bool interrupt_enabled;
  bool time_out_enabled;
  double time_out_t;
  bool memory_limit_enabled;
  unsigned long memory_limit;
  bool stack_limit_enabled;
  unsigned long stack_limit;
  static void alarm_handler(int sig);
  static void interrupt_handler(int sig);
  static void check_stack();
  void set_interrupt();
  void clear_interrupt();
  void set_alarm(double t);
  void clear_alarm();
  void check_signals();
  static unsigned long peak_mem;
  static unsigned long peak_size;
  static unsigned long peak_stack;
  static unsigned long init_stack;
 protected:
  bool interrupt_flag;
  bool time_out_flag;
  bool out_of_memory_flag;
  bool out_of_stack_flag;
  bool error_flag;
  count_type running;
  bool terminate_on_interrupt;
  bool terminate_on_time_out;
  bool terminate_on_out_of_memory;
  bool terminate_on_out_of_stack;
  bool terminate_on_error;
 public:
  static const long FLAG_INTERRUPTED = 1;
  static const long FLAG_TIME_OUT = 2;
  static const long FLAG_OUT_OF_MEMORY = 4;
  static const long FLAG_OUT_OF_STACK = 8;
  static const long FLAG_ERROR = 16;
  Stopwatch();
  ~Stopwatch();
  static double seconds();
  void enable_interrupt(bool terminate);
  void disable_interrupt();
  void enable_time_out(double t, bool terminate);
  void disable_time_out();
  void enable_memory_limit(unsigned long l, bool terminate);
  void disable_memory_limit();
  void enable_stack_limit(unsigned long l, bool terminate);
  void disable_stack_limit();
  void set_terminate_flags(bool on_interrupt,
      bool on_time_out,
      bool on_out_of_memory,
      bool on_out_of_stack,
      bool on_error);
  bool interrupt_raised();
  bool time_out_raised();
  bool out_of_memory_raised();
  bool out_of_stack_raised();
  bool error_raised();
  double remaining();
  bool break_signal_raised();
  virtual void interrupt();
  virtual void time_out();
  virtual void out_of_memory();
  virtual void out_of_stack();
  virtual void error();
  virtual void start();
  virtual void stop();
  virtual void reset();
  count_type run_level() { return running; };
  void add(Stopwatch& s);
  void add_total(Stopwatch& s);
  double time();
  double total_time();
  unsigned long peak_memory() const;
  unsigned long peak_total_size() const;
  unsigned long peak_stack_size() const;
  unsigned long flags();
  void print(::std::ostream& s);
};
class Statistics : public Stopwatch {
  count_type min_nodes_created;
  count_type max_nodes_created;
  count_type min_nodes_expanded;
  count_type max_nodes_expanded;
  count_type iterations_started;
  count_type iterations_finished;
  count_type total_min_nodes_created;
  count_type total_max_nodes_created;
  count_type total_min_nodes_expanded;
  count_type total_max_nodes_expanded;
  count_type total_iterations_started;
  count_type total_iterations_finished;
  index_type max_depth;
  hsps::rational max_lb;
  count_type nodes_to_prove_lb;
 public:
  static bool long_print_format;
  static bool running_print_max;
  Statistics()
    : min_nodes_created(0), max_nodes_created(0),
    min_nodes_expanded(0), max_nodes_expanded(0),
    iterations_started(0), iterations_finished(0),
    total_min_nodes_created(0), total_max_nodes_created(0),
    total_min_nodes_expanded(0), total_max_nodes_expanded(0),
    total_iterations_started(0), total_iterations_finished(0),
    max_depth(0), max_lb(0), nodes_to_prove_lb(0)
    { };
  void create_node(State& s);
  void expand_node(State& s);
  void current_lower_bound(hsps::rational b);
  void begin_iteration();
  void end_iteration();
  virtual void start();
  virtual void stop();
  virtual void reset();
  virtual void time_out();
  virtual void interrupt();
  virtual void out_of_memory();
  virtual void out_of_stack();
  void add(Statistics& s);
  void add_nodes(Statistics& s);
  void add_total(Statistics& s);
  void add_nodes_total(Statistics& s);
  double branching_factor() const {
    return ((min_nodes_created + max_nodes_created)/
     ((double)(min_nodes_expanded + max_nodes_expanded)));
  };
  count_type nodes() const {
    return (min_nodes_expanded + max_nodes_expanded);
  };
  count_type total_nodes() const {
    if (running)
      return (total_min_nodes_expanded + total_max_nodes_expanded +
       min_nodes_expanded + max_nodes_expanded);
    else
      return (total_min_nodes_expanded + total_max_nodes_expanded);
  };
  count_type total_min_nodes() const {
    if (running) return (total_min_nodes_expanded + min_nodes_expanded);
    else return total_min_nodes_expanded;
  };
  count_type total_max_nodes() const {
    if (running) return (total_max_nodes_expanded + max_nodes_expanded);
    else return total_max_nodes_expanded;
  };
  hsps::rational max_lower_bound() const {
    return max_lb;
  };
  count_type nodes_at_max_lower_bound() const {
    return nodes_to_prove_lb;
  };
  count_type iterations() {
    return iterations_started;
  };
  count_type complete_iterations() {
    return iterations_finished;
  };
  count_type total_iterations() {
    if (running) return iterations_started + total_iterations_started;
    else return total_iterations_started;
  };
  count_type total_complete_iterations() {
    if (running) return iterations_finished + total_iterations_finished;
    else return total_iterations_finished;
  };
  void print_brief(::std::ostream& s, const char* p = 0);
  void print(::std::ostream& s, const char* p = 0);
  void print_total(::std::ostream& s, const char* p = 0);
};
inline ::std::ostream& operator<<(::std::ostream& s, Stopwatch& t) {
  return s << t.total_time();
}
inline ::std::ostream& operator<<(::std::ostream& s, Statistics& t) {
  if (Statistics::long_print_format) {
    t.print_total(s);
    return s;
  }
  else {
    return s << t.total_nodes() << " nodes, "
      << t.total_time() << " seconds, "
      << t.peak_memory() << "k heap, "
      << t.peak_stack_size() << "k stack";
  }
}
}
namespace hsps {
class ACF {
 public:
  virtual ~ACF() { };
  virtual hsps::rational operator()(index_type a) const = 0;
  virtual hsps::rational min_cost(index_type n) const;
  virtual hsps::rational max_cost(index_type n) const;
  virtual hsps::rational avg_cost(index_type n) const;
  virtual hsps::rational cost_gcd(index_type n) const;
};
class Heuristic {
 protected:
  Instance& instance;
  int trace_level;
 public:
  static count_type eval_count;
  static int default_trace_level;
  Heuristic(Instance& ins)
    : instance(ins), trace_level(default_trace_level) { };
  virtual ~Heuristic();
  virtual void set_trace_level(int level);
  virtual hsps::rational eval(const index_set& s) = 0;
  virtual hsps::rational eval(const bool_vec& s) = 0;
  virtual void write_eval(const index_set& s,
     ::std::ostream& st,
     char* p = 0,
     bool e = true);
  virtual void write_eval(const bool_vec& s,
     ::std::ostream& st,
     char* p = 0,
     bool e = true);
  virtual hsps::rational eval_precondition(const Instance::Action& a);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
  virtual void store(const index_set& s, hsps::rational v, bool opt);
  virtual void store(const bool_vec& s, hsps::rational v, bool opt);
  hsps::rational eval(index_type atom);
  void compute_heuristic_graph(const ACF& cost, graph& g);
};
class ZeroHeuristic : public Heuristic {
 public:
  ZeroHeuristic(Instance& ins) : Heuristic(ins) { };
  virtual ~ZeroHeuristic() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
};
class EvalActionCache : public Heuristic {
  Heuristic& base_h;
  cost_vec cache;
 public:
  EvalActionCache(Instance& ins, Heuristic& h);
  virtual ~EvalActionCache() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational eval_precondition(const Instance::Action& a);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class RegressionInvariantCheck : public Heuristic {
  Heuristic& base_h;
  bool verified_invariants_only;
 public:
  RegressionInvariantCheck(Instance& ins, Heuristic& h, bool v)
    : Heuristic(ins), base_h(h), verified_invariants_only(v) { };
  virtual ~RegressionInvariantCheck() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class ForwardReachabilityCheck : public Heuristic {
  index_set goals;
  bool_vec r;
  bool_vec f;
  bool_vec d;
  hsps::rational compute();
 public:
  ForwardReachabilityCheck(Instance& i, const index_set& g);
  virtual ~ForwardReachabilityCheck();
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
};
class Combine2ByMax : public Heuristic {
  Heuristic& h0;
  Heuristic& h1;
 public:
  Combine2ByMax(Instance& ins, Heuristic& _h0, Heuristic& _h1)
    : Heuristic(ins), h0(_h0), h1(_h1) { };
  virtual ~Combine2ByMax() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class CombineNByMax : public Heuristic {
  lvector<Heuristic*> h_vec;
 public:
  CombineNByMax(Instance& ins)
    : Heuristic(ins), h_vec((Heuristic*)0, 0) { };
  virtual ~CombineNByMax() { };
  void add(Heuristic* h) { h_vec.append(h); };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class CombineNBySum : public Heuristic {
  lvector<Heuristic*> h_vec;
 public:
  CombineNBySum(Instance& ins)
    : Heuristic(ins), h_vec((Heuristic*)0, 0) { };
  virtual ~CombineNBySum() { };
  void add(Heuristic* h) { h_vec.append(h); };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class RoundUp : public Heuristic {
  Heuristic& h;
  long d;
 public:
  RoundUp(Instance& ins, Heuristic& h0)
    : Heuristic(ins), h(h0), d(1) { };
  RoundUp(Instance& ins, Heuristic& h0, long d0)
    : Heuristic(ins), h(h0), d(d0) { };
  virtual ~RoundUp() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class HX : public Heuristic {
  Heuristic& h0;
  index_set X;
 public:
  HX(Instance& ins, Heuristic& h, const index_set& x)
    : Heuristic(ins), h0(h), X(x) { };
  HX(Instance& ins, Heuristic& h)
    : Heuristic(ins), h0(h) { };
  virtual ~HX() { };
  void setX(const index_set& x) { X = x; };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual void write_eval(const index_set& s,
     ::std::ostream& st,
     char* p = 0,
     bool e = true);
  virtual void write_eval(const bool_vec& s,
     ::std::ostream& st,
     char* p = 0,
     bool e = true);
};
class AtomMapAdapter : public Heuristic {
  index_vec map;
  Heuristic& base_h;
 public:
  AtomMapAdapter(Instance& i, const index_vec& m, Heuristic& h)
    : Heuristic(i), map(m), base_h(h)
  { assert(map.length() == instance.n_atoms()); };
  virtual ~AtomMapAdapter() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
};
class CompleteNegationAdapter : public Heuristic {
  Heuristic& h_base;
  pair_vec pn_map;
  bool_vec sc;
 public:
  CompleteNegationAdapter(Instance& ins, const pair_vec& p, Heuristic& h);
  virtual ~CompleteNegationAdapter();
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
};
class CompareEval : public Heuristic {
  Heuristic& base_h;
  Heuristic& alt_h;
  bool max_h_val;
 public:
  static count_type lower;
  static count_type equal;
  static count_type higher;
  CompareEval(Instance& i, Heuristic& h0, Heuristic& h1)
    : Heuristic(i), base_h(h0), alt_h(h1) { }
  virtual ~CompareEval() { };
  void set_maximal_heuristic_value(bool on) { max_h_val = on; };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
};
class UnitACF : public ACF {
 public:
  UnitACF() { };
  virtual ~UnitACF() { };
  virtual hsps::rational operator()(index_type a) const;
  virtual hsps::rational min_cost(index_type n) const;
  virtual hsps::rational max_cost(index_type n) const;
  virtual hsps::rational avg_cost(index_type n) const;
};
class ZeroACF : public ACF {
 public:
  ZeroACF() { };
  virtual ~ZeroACF() { };
  virtual hsps::rational operator()(index_type a) const;
  virtual hsps::rational min_cost(index_type n) const;
  virtual hsps::rational max_cost(index_type n) const;
  virtual hsps::rational avg_cost(index_type n) const;
};
class CostACF : public ACF {
  Instance& instance;
 public:
  CostACF(Instance& i) : instance(i) { };
  virtual ~CostACF() { };
  virtual hsps::rational operator()(index_type a) const;
};
class FracACF : public ACF {
  const ACF& baseACF;
  cost_vec df;
 public:
  FracACF(const ACF& b, index_type l);
  FracACF(const ACF& b, index_type l, hsps::rational f);
  virtual ~FracACF();
  void set(index_type a, hsps::rational f);
  void set(const index_set& d, hsps::rational f);
  virtual hsps::rational operator()(index_type a) const;
};
class DiscountACF : public ACF {
  const ACF& baseACF;
  bool_vec discounted;
 public:
  DiscountACF(const ACF& b, index_type l)
    : baseACF(b), discounted(false, l) { };
  DiscountACF(const ACF& b, const index_set& d, index_type l)
    : baseACF(b), discounted(d, l) { };
  DiscountACF(const ACF& b, const bool_vec& d)
    : baseACF(b), discounted(d) { };
  virtual ~DiscountACF() { };
  void discount(index_type a) { discounted[a] = true; };
  void discount(const index_set& d) { discounted.insert(d); };
  void discount(const bool_vec& d) { discounted.insert(d); };
  void count(index_type a) { discounted[a] = false; };
  void count(const index_set& d) { discounted.subtract(d); };
  void count(const bool_vec& d) { discounted.subtract(d); };
  void count_only(const bool_vec& d);
  const bool_vec& discounted_actions() { return discounted; };
  virtual hsps::rational operator()(index_type a) const;
};
class MakespanACF : public ACF {
  Instance& instance;
 public:
  MakespanACF(Instance& i) : instance(i) { };
  virtual ~MakespanACF() { };
  virtual hsps::rational operator()(index_type a) const;
};
class ResourceConsACF : public ACF {
  Instance& instance;
  index_type resource_id;
 public:
  ResourceConsACF(Instance& i, index_type r);
  virtual ~ResourceConsACF() { };
  virtual hsps::rational operator()(index_type a) const;
};
class ResourceReqACF : public ACF {
  Instance& instance;
  index_type resource_id;
 public:
  ResourceReqACF(Instance& i, index_type r);
  virtual ~ResourceReqACF() { };
  virtual hsps::rational operator()(index_type a) const;
};
}
namespace hsps {
class SearchResult {
 public:
  SearchResult() { };
  virtual ~SearchResult();
  virtual void solution(State& s, hsps::rational cost) = 0;
  virtual void no_more_solutions(hsps::rational cost) = 0;
  virtual bool more() = 0;
};
class Result : public SearchResult {
 public:
  enum stop_condition { stop_at_first,
   stop_at_nth,
   stop_at_all_optimal,
   stop_at_all };
 private:
  stop_condition sc;
  count_type find_n;
  PlanSet* plans;
  count_type n_found;
  hsps::rational min_cost;
  hsps::rational max_ex;
 public:
  Result() : sc(stop_at_first), find_n(1), plans(0), n_found(0),
    min_cost(POS_INF), max_ex(NEG_INF) { };
  Result(PlanSet* s) : sc(stop_at_first), find_n(1), plans(s), n_found(0),
    min_cost(POS_INF), max_ex(NEG_INF) { };
  virtual ~Result() { };
  void set_stop_condition(stop_condition c);
  void set_n_to_find(count_type n);
  void set_plan_set(PlanSet* s);
  count_type solution_count();
  bool search_space_exhausted();
  void reset();
  virtual void solution(State& s, hsps::rational cost);
  virtual void no_more_solutions(hsps::rational cost);
  virtual bool more();
};
class SearchStats : public Search {
 protected:
  Statistics& stats;
  hsps::rational cost_limit;
  count_type node_limit;
  count_type node_count;
  count_type work_limit;
  count_type work_count;
  count_type zero_eval_count;
  void start_count();
  void stop_count();
  void reset();
 public:
  SearchStats(Statistics& s);
  SearchStats(Statistics& s, hsps::rational limit);
  virtual ~SearchStats();
  void set_cost_limit(hsps::rational c_max);
  hsps::rational get_cost_limit() const;
  bool cost_limit_reached() const;
  void set_node_limit(count_type n);
  count_type get_node_limit() const;
  bool node_limit_reached() const;
  void set_work_limit(count_type n);
  count_type get_work_limit() const;
  bool work_limit_reached() const;
  bool break_signal_raised() const;
  virtual hsps::rational cost() const = 0;
  count_type work() const;
};
class SearchAlgorithm : public SearchStats {
  bool is_solved;
  bool is_optimal;
 protected:
  SearchResult& result;
  const Name* problem_name;
  int trace_level;
  void set_solved(bool s, bool o);
  void set_solved(bool s);
  void reset();
 public:
  static int default_trace_level;
  void set_problem_name(const Name* n);
  void set_trace_level(int level);
  SearchAlgorithm(Statistics& s, SearchResult& r);
  SearchAlgorithm(Statistics& s, SearchResult& r, hsps::rational limit);
  virtual ~SearchAlgorithm();
  virtual hsps::rational start(State& s, hsps::rational b) = 0;
  virtual hsps::rational start(State& s) = 0;
  virtual bool solved() const;
  virtual bool optimal() const;
  virtual bool done() const;
};
class SingleSearchAlgorithm : public SearchAlgorithm {
 public:
  SingleSearchAlgorithm(Statistics& s, SearchResult& r)
    : SearchAlgorithm(s, r) { };
  SingleSearchAlgorithm(Statistics& s, SearchResult& r, hsps::rational limit)
    : SearchAlgorithm(s, r, limit) { };
  virtual ~SingleSearchAlgorithm() { };
  virtual hsps::rational resume() = 0;
};
class MultiSearchAlgorithm : public SearchAlgorithm {
 public:
  MultiSearchAlgorithm(Statistics& s, SearchResult& r)
    : SearchAlgorithm(s, r) { };
  MultiSearchAlgorithm(Statistics& s, SearchResult& r, hsps::rational limit)
    : SearchAlgorithm(s, r, limit) { };
  virtual ~MultiSearchAlgorithm() { };
  virtual hsps::rational resume(State& s, hsps::rational b) = 0;
  virtual hsps::rational resume(State& s);
};
}
namespace hsps {
typedef lvector<Heuristic*> estimator_vec;
class BasicResourceState {
 protected:
  Instance& instance;
  estimator_vec& estimators;
  amt_vec amt_consumed;
 public:
  BasicResourceState(Instance& i, estimator_vec& est);
  BasicResourceState(Instance& i, estimator_vec& est, const amt_vec& ac);
  BasicResourceState(const BasicResourceState& s);
  virtual ~BasicResourceState();
  hsps::rational available(index_type r) const;
  hsps::rational available_for_consumption(index_type r) const;
  bool applicable(Instance::Action& a);
  bool sufficient_consumable(const index_set& s);
  bool sufficient_consumable(const bool_vec& s);
  void apply(Instance::Action& a);
  bool is_root();
  int compare(const BasicResourceState& s);
  index_type hash();
  BasicResourceState* new_state();
  BasicResourceState* copy();
  void write(std::ostream& s);
};
class RegressionResourceState : public BasicResourceState {
 protected:
  amt_vec max_required;
 public:
  RegressionResourceState(Instance& i, estimator_vec& est);
  RegressionResourceState(Instance& i, estimator_vec& est, const amt_vec& ac);
  RegressionResourceState(const RegressionResourceState& s);
  ~RegressionResourceState();
  hsps::rational available(index_type r) const;
  hsps::rational available_for_consumption(index_type r) const;
  bool applicable(Instance::Action& a);
  bool applicable(Instance::Action& a, const index_vec& c);
  bool applicable(Instance::Action& a, const index_cost_vec& c);
  bool applicable(Instance::Action& a,
    const index_cost_vec& c1,
    const index_vec& c2);
  bool sufficient_consumable(const index_set& s);
  bool sufficient_consumable(const bool_vec& s);
  bool sufficient_consumable(const index_set& s, const Instance::Action& cact);
  bool sufficient_consumable(const bool_vec& s, const Instance::Action& cact);
  bool sufficient_consumable(const index_set& s, const index_cost_vec& cacts);
  bool sufficient_consumable(const bool_vec& s, const index_cost_vec& cacts);
  void apply(Instance::Action& a);
  void reserve_as_required(const amt_vec& req);
  bool is_root();
  int compare(const RegressionResourceState& s);
  index_type hash();
  RegressionResourceState* new_state();
  RegressionResourceState* copy();
  void write(std::ostream& s);
};
}
namespace hsps {
class IterativeEnumerator {
 public:
  IterativeEnumerator() { };
  virtual ~IterativeEnumerator();
  virtual bool first() = 0;
  virtual bool next() = 0;
};
class RecursiveEnumerator {
 protected:
  virtual bool done() = 0;
 public:
  RecursiveEnumerator() { };
  virtual ~RecursiveEnumerator();
};
class SubsetEnumerator : public IterativeEnumerator {
 protected:
  index_type n;
  bool_vec in;
 public:
  SubsetEnumerator(index_type _n);
  virtual ~SubsetEnumerator() { };
  virtual bool first();
  virtual bool next();
  const bool_vec& current_set() const;
  void current_set(const index_set& elements, index_set& set);
  void current_set(index_set& set);
  index_type current_set_size();
  void all_sets(index_set_vec& sets);
};
class mSubsetEnumerator : public SubsetEnumerator {
 protected:
  index_type m;
 public:
  mSubsetEnumerator(index_type _n, index_type _m);
  virtual ~mSubsetEnumerator() { };
  count_type m_of_n();
  virtual bool first();
  virtual bool next();
};
class kAssignmentEnumerator : public IterativeEnumerator {
 protected:
  index_type n;
  index_type k;
  index_vec a;
 public:
  kAssignmentEnumerator(index_type _n, index_type _k);
  virtual ~kAssignmentEnumerator() { };
  virtual bool first();
  virtual bool next();
  void current_assignment(index_set_vec& sets);
};
class CorrespondanceEnumerator : public IterativeEnumerator {
 protected:
  const index_vec& a;
  const index_vec& b;
  mapping c;
  bool_vec f;
  index_type first_free(index_type x,
   const index_vec& vec,
   const bool_vec& f_vec);
  index_type next_free(index_type x,
         const index_vec& vec,
         const bool_vec& f_vec,
         index_type starting_from);
  bool find(index_type p);
 public:
  CorrespondanceEnumerator(const index_vec& v0, const index_vec& v1);
  virtual ~CorrespondanceEnumerator() { };
  virtual bool first();
  virtual bool next();
  const mapping& current() const { return c; };
};
void write_correspondance(::std::ostream& s, const index_vec& c);
class PermutationEnumerator : public IterativeEnumerator {
 protected:
  CorrespondanceEnumerator e;
 public:
  PermutationEnumerator(index_type n);
  virtual ~PermutationEnumerator() { };
  virtual bool first();
  virtual bool next();
  const mapping& current() const { return e.current(); };
};
class RecursivekPartitionEnumerator {
  index_vec ass;
 protected:
  index_type n;
  index_type k;
  index_set_vec sets;
  bool done;
  void partition(index_type n, index_type k);
  void construct();
  void construct(const index_set& set);
  virtual void solution();
 public:
  RecursivekPartitionEnumerator(index_type _n, index_type _k);
  virtual ~RecursivekPartitionEnumerator();
  void partition();
};
class RecursivePartitionEnumerator : public RecursivekPartitionEnumerator {
 public:
  RecursivePartitionEnumerator(index_type _n);
  virtual ~RecursivePartitionEnumerator() { };
  void partition();
  void partition_bounded(index_type min, index_type max);
};
class CountPartitions : public RecursivePartitionEnumerator {
  index_type c;
 protected:
  virtual void solution();
 public:
  CountPartitions(index_type _n) : RecursivePartitionEnumerator(_n) { };
  virtual ~CountPartitions() { };
  index_type count();
};
class PrintPartitions : public RecursivePartitionEnumerator {
 protected:
  virtual void solution();
 public:
  PrintPartitions(index_type _n) : RecursivePartitionEnumerator(_n) { };
  virtual ~PrintPartitions() { };
};
}
namespace hsps {
class ExecError {
 public:
  enum ErrorType { error_unknown,
     error_unsatisfied_precondition,
     error_incompatible_actions,
     error_resource_conflict,
     error_resource_shortage,
     error_unachieved_goal,
     warning_redundant_action
  };
  enum ErrorSeverity { severity_none = 0,
         severity_warning = 1,
         severity_plan_failure = 2,
         severity_execution_failure = 3
  };
 protected:
  ErrorType toe;
  hsps::rational at;
  index_type step;
 public:
  static const char* error_type_string(ErrorType t);
  static const char* error_severity_string(ErrorSeverity s);
  ExecError() : toe(error_unknown), at(0), step(no_such_index) { };
  ExecError(ErrorType e, hsps::rational t) : toe(e), at(t), step(no_such_index) { };
  ExecError(ErrorType e, hsps::rational t, index_type s) : toe(e), at(t), step(s) { };
  virtual ~ExecError();
  void remap_step(const index_vec& map);
  ErrorType type_of_error() const { return toe; };
  ErrorSeverity severity_of_error() const;
  hsps::rational time_of_error() const { return at; };
  index_type step_of_error() const { return step; };
  virtual ExecError* copy() const;
  virtual void write(::std::ostream& s) const;
};
typedef lvector<ExecError*> exec_error_vec;
typedef svector<ExecError::ErrorType> error_type_set;
typedef svector<ExecError::ErrorSeverity> error_severity_set;
class ExecErrorSet : public exec_error_vec {
  index_type current_step;
  error_type_set ignored_error_types;
 public:
  ExecErrorSet()
    : exec_error_vec((ExecError*)0, 0),
    current_step(no_such_index),
    ignored_error_types() { };
  ~ExecErrorSet();
  void ignore_error_type(ExecError::ErrorType t);
  void ignore_error_severity(ExecError::ErrorSeverity s);
  void clear_ignored_error_types();
  void new_error(ExecError* e);
  bool ignore(ExecError::ErrorType t);
  void remap_steps(const index_vec& map);
  hsps::rational earliest_time_of_error();
  ExecError::ErrorSeverity greatest_error_severity();
  bool executable();
  bool valid();
  index_type count_of_type(ExecError::ErrorType t);
  ExecErrorSet* earliest();
  ExecErrorSet* all_of_type(ExecError::ErrorType t);
  ExecErrorSet* all_of_severity(ExecError::ErrorSeverity s);
  ExecErrorSet* earliest_of_type(ExecError::ErrorType t);
  virtual void write(::std::ostream& s) const;
};
class UnsatisfiedPreconditionError : public ExecError {
  Instance& ins;
  index_type act;
  index_type pre;
  index_set holds;
 public:
  UnsatisfiedPreconditionError(Instance& i,
          index_type a,
          index_type p,
          hsps::rational at)
    : ExecError(ExecError::error_unsatisfied_precondition, at),
    ins(i), act(a), pre(p) { };
  UnsatisfiedPreconditionError(Instance& i,
          index_type a,
          index_type p,
          const index_set& h,
          hsps::rational at)
    : ExecError(ExecError::error_unsatisfied_precondition, at),
    ins(i), act(a), pre(p), holds(h) { };
  UnsatisfiedPreconditionError(Instance& i,
          index_type a,
          index_type p,
          hsps::rational at,
          index_type s)
    : ExecError(ExecError::error_unsatisfied_precondition, at, s),
    ins(i), act(a), pre(p) { };
  UnsatisfiedPreconditionError(Instance& i,
          index_type a,
          index_type p,
          const index_set& h,
          hsps::rational at,
          index_type s)
    : ExecError(ExecError::error_unsatisfied_precondition, at, s),
    ins(i), act(a), pre(p), holds(h) { };
  virtual ~UnsatisfiedPreconditionError() { };
  const Instance::Action& action() { return ins.actions[act]; };
  const Instance::Atom& precondition() { return ins.atoms[pre]; };
  const index_set& true_atoms() { return holds; };
  virtual ExecError* copy();
  virtual void write(::std::ostream& s) const;
};
class IncompatibleActionError : public ExecError {
  Instance& ins;
  index_type act0;
  index_type act1;
 public:
  IncompatibleActionError(Instance& i, index_type a0, index_type a1, hsps::rational at)
    : ExecError(ExecError::error_incompatible_actions, at),
    ins(i), act0(a0), act1(a1) { };
  IncompatibleActionError(Instance& i, index_type a0, index_type a1,
     hsps::rational at, index_type s)
    : ExecError(ExecError::error_incompatible_actions, at, s),
    ins(i), act0(a0), act1(a1) { };
  virtual ~IncompatibleActionError() { };
  const Instance::Action& action() { return ins.actions[act0]; };
  const Instance::Action& incompatible_action() { return ins.actions[act1]; };
  virtual ExecError* copy();
  virtual void write(::std::ostream& s) const;
};
class ResourceConflictError : public ExecError {
  Instance& ins;
  index_type res;
  index_set c_acts;
  index_set c_steps;
 public:
  ResourceConflictError(Instance& i,
   index_type r,
   const index_set& as,
   const index_set& ss,
   hsps::rational at) :
    ExecError(ExecError::error_resource_conflict, at), ins(i), res(r),
    c_acts(as), c_steps(ss) { };
  ResourceConflictError(Instance& i,
   index_type r,
   hsps::rational at) :
    ExecError(ExecError::error_resource_conflict, at), ins(i), res(r) { };
  ResourceConflictError(Instance& i,
   index_type r,
   const index_set& as,
   const index_set& ss,
   hsps::rational at,
   index_type s) :
    ExecError(ExecError::error_resource_conflict, at, s), ins(i), res(r),
    c_acts(as), c_steps(ss) { };
  ResourceConflictError(Instance& i,
   index_type r,
   hsps::rational at,
   index_type s) :
    ExecError(ExecError::error_resource_conflict, at, s), ins(i), res(r) { };
  void add_action(index_type a)
    { c_acts.insert(a); };
  void add_action(index_type a, index_type s)
    { c_acts.insert(a); c_steps.insert(s); };
  virtual ~ResourceConflictError() { };
  const Instance::Resource& resource() { return ins.resources[res]; };
  const index_set& conflict_actions() { return c_acts; };
  const index_set& conflict_steps() { return c_steps; };
  virtual ExecError* copy();
  virtual void write(::std::ostream& s) const;
};
class ResourceShortageError : public ExecError {
  Instance& ins;
  index_type res;
  hsps::rational avail;
  index_type act;
 public:
  ResourceShortageError(Instance& i,
   index_type r,
   hsps::rational v,
   index_type a,
   hsps::rational at) :
    ExecError(ExecError::error_resource_shortage, at), ins(i), res(r),
    avail(v), act(a) { };
  ResourceShortageError(Instance& i,
   index_type r,
   hsps::rational v,
   index_type a,
   hsps::rational at,
   index_type s) :
    ExecError(ExecError::error_resource_shortage, at, s), ins(i), res(r),
    avail(v), act(a) { };
  virtual ~ResourceShortageError() { };
  const Instance::Resource& resource() { return ins.resources[res]; };
  hsps::rational available() { return avail; };
  const Instance::Action& action() { return ins.actions[act]; };
  virtual ExecError* copy();
  virtual void write(::std::ostream& s) const;
};
class UnachievedGoalError : public ExecError {
  Instance& ins;
  index_type atom;
 public:
  UnachievedGoalError(Instance& i, index_type g, hsps::rational at)
    : ExecError(ExecError::error_unachieved_goal, at), ins(i), atom(g) { };
  UnachievedGoalError(Instance& i, index_type g, hsps::rational at, index_type s)
    : ExecError(ExecError::error_unachieved_goal, at, s), ins(i), atom(g) { };
  virtual ~UnachievedGoalError() { };
  const Instance::Atom& goal() { return ins.atoms[atom]; };
  virtual ExecError* copy();
  virtual void write(::std::ostream& s) const;
};
class RedundantActionWarning : public ExecError {
  Instance& ins;
  index_type act;
 public:
  RedundantActionWarning(Instance& i, index_type a, hsps::rational at) :
    ExecError(ExecError::warning_redundant_action, at), ins(i), act(a) { };
  RedundantActionWarning(Instance& i, index_type a, hsps::rational at, index_type s) :
    ExecError(ExecError::warning_redundant_action, at, s), ins(i), act(a) { };
  virtual ~RedundantActionWarning() { };
  const Instance::Action& action() { return ins.actions[act]; };
  virtual ExecError* copy();
  virtual void write(::std::ostream& s) const;
};
class ExecState : public ProgressionState {
 protected:
  Instance& instance;
  bool_vec atoms;
  amt_vec res;
  struct exec_act {
    index_type act;
    hsps::rational rem;
    index_type step;
    ExecState* start_state;
    exec_act() :
      act(no_such_index), rem(ZERO), step(no_such_index), start_state(0) { };
    exec_act(index_type a, hsps::rational r) :
      act(a), rem(r), step(no_such_index), start_state(0) { };
    exec_act(index_type a, hsps::rational r, index_type s) :
      act(a), rem(r), step(s), start_state(0) { };
    exec_act(const exec_act& e) :
      act(e.act), rem(e.rem), step(e.step), start_state(e.start_state) { };
    exec_act& operator=(const exec_act& e) {
      act = e.act;
      rem = e.rem;
      step = e.step;
      start_state = e.start_state;
    };
  };
  typedef lvector<exec_act> exec_act_vec;
  exec_act_vec actions;
  hsps::rational abs_t;
  hsps::rational delta_t;
  hsps::rational dur;
  int trace_level;
  void apply_conditional_delete_effects
    (Instance::Action& a, const ExecState* start_state, bool_vec& to);
  void active_conditional_add_effects
    (Instance::Action& a, const ExecState* start_state, bool_vec& eff);
 public:
  ExecState(Instance& i);
  ExecState(Instance& i, index_set g);
  ExecState(Instance& i, const bool_vec& g);
  ExecState(const ExecState& s);
  virtual ~ExecState();
  static bool extended_action_definition;
  void set_trace_level(int level);
  virtual hsps::rational delta_cost();
  virtual hsps::rational est_cost();
  virtual bool is_final();
  virtual bool is_max();
  virtual hsps::rational expand(Search& s, hsps::rational bound);
  virtual void store(hsps::rational cost, bool opt);
  virtual void reevaluate();
  virtual int compare(const State& s);
  virtual index_type hash();
  virtual State* new_state(index_set& s);
  virtual State* copy();
  virtual void insert(Plan& p);
  virtual void write_plan(::std::ostream& s);
  virtual void write(::std::ostream& s);
  hsps::rational current_time() const;
  hsps::rational end_time() const;
  void current_atoms(index_set& atms) const;
  const bool_vec& current_atoms() const;
  void current_actions(index_set& acts) const;
  index_type n_current_actions() const;
  void starting_actions(index_set& acts) const;
  void finishing_actions(index_set& acts) const;
  hsps::rational min_delta() const;
  hsps::rational max_delta() const;
  void current_resource_levels
    (amt_vec& avail, amt_vec& in_use) const;
  void current_resource_levels
    (index_type r, hsps::rational& avail, hsps::rational& in_use) const;
  void current_resource_use(amt_vec& res) const;
  bool check_atoms(const index_set& set) const;
  bool check_atoms(const index_set& set, index_set& holds) const;
  bool is_final(ExecErrorSet* errors);
  bool applicable(Instance::Action& act,
    ExecErrorSet* errors,
    index_type step);
  void apply(Instance::Action& act,
      ExecErrorSet* errors,
      index_type step);
  void advance(hsps::rational dt,
        ExecErrorSet* errors);
  void finish(ExecErrorSet* errors);
  void clip(hsps::rational at_t);
  void intersect(const bool_vec& atms);
};
class Timeline {
 public:
  virtual ~Timeline();
  virtual index_type n_intervals() = 0;
  virtual index_type n_points() = 0;
  virtual index_type interval_start_point(index_type i) = 0;
  virtual index_type interval_end_point(index_type i) = 0;
  virtual hsps::rational point_time(index_type i) = 0;
  virtual hsps::rational interval_start_time(index_type i) = 0;
  virtual hsps::rational interval_end_time(index_type i) = 0;
  hsps::rational total_time();
};
class ExecTrace : public Timeline, public lvector<ExecState*> {
  Instance& instance;
 public:
  ExecTrace(Instance& ins);
  ~ExecTrace();
  virtual index_type n_intervals();
  virtual index_type n_points();
  virtual index_type interval_start_point(index_type i);
  virtual index_type interval_end_point(index_type i);
  virtual hsps::rational point_time(index_type i);
  virtual hsps::rational interval_start_time(index_type i);
  virtual hsps::rational interval_end_time(index_type i);
  ExecState* final_state();
  ExecTrace* copy();
  ExecTrace* necessary_trace();
  void peak_resource_use(amt_vec& res);
  bool test_always(index_type p);
  bool test_sometime(index_type p);
  bool test_sometime_after(index_type p, index_type q);
  bool test_sometime_before(index_type p, index_type q);
  bool test_at_most_once(index_type p);
  void extract_always_within(bool_matrix& c, cost_matrix& t);
  void clip_last_state(hsps::rational at_t);
  void write(::std::ostream& s);
};
class BasicTimeline : public Timeline {
 protected:
  cost_vec points;
  bool open_start;
  bool open_end;
  void set_point(hsps::rational t);
  void clip_start(hsps::rational t);
  void clip_end(hsps::rational t);
 public:
  BasicTimeline();
  virtual ~BasicTimeline();
  virtual index_type n_intervals();
  virtual index_type n_points();
  virtual index_type interval_start_point(index_type i);
  virtual index_type interval_end_point(index_type i);
  virtual hsps::rational point_time(index_type i);
  virtual hsps::rational interval_start_time(index_type i);
  virtual hsps::rational interval_end_time(index_type i);
  void write(::std::ostream& s);
};
class ResourceProfile : public BasicTimeline {
 protected:
  Instance& instance;
  index_type res;
  amt_vec avail;
  amt_vec in_use;
  index_set_vec a_start;
  index_set_vec a_finish;
  hsps::rational max_req;
 public:
  ResourceProfile(Instance& ins, index_type r, ExecTrace& trace);
  virtual ~ResourceProfile();
  void set_makespan(hsps::rational t);
  const Name* resource_name() const { return instance.resources[res].name; };
  hsps::rational amount_available(index_type i);
  hsps::rational amount_in_use(index_type i);
  hsps::rational amount_free(index_type i);
  index_type first_use_interval(index_type i);
  index_type first_min_free_interval(index_type i);
  hsps::rational possible_unexpected_loss_to(index_type i);
  hsps::rational min_free_from(index_type i);
  hsps::rational min_free();
  hsps::rational peak_use();
  hsps::rational min_peak_use();
  hsps::rational tolerable_unexpected_loss();
  hsps::rational total_consumption();
  void writeGantt(::std::ostream& s);
  static double GANTT_EXTRA_WIDTH;
  static double GANTT_EXTRA_HEIGHT;
  void write(::std::ostream& s);
};
class Schedule : public Plan {
 public:
  struct step {
    index_type act;
    hsps::rational at;
    index_type track;
    step() : act(no_such_index), at(0), track(no_such_index) { };
    step(index_type a, hsps::rational t) : act(a), at(t), track(no_such_index) { };
    step& operator=(const step& s) {
      act = s.act;
      at = s.at;
      return *this;
    };
    bool operator==(const step& s) {
      return ((act == s.act) && (at == s.at));
    };
  };
  typedef lvector<step> step_vec;
 private:
  Instance& instance;
  step_vec steps;
  hsps::rational end_t;
  index_set action_set;
  index_vec action_vec;
  index_type n_tracks;
  const Name* ann_name;
  bool ann_optimal;
  int trace_level;
  hsps::rational current_t;
  bool finished;
  void insert_step(hsps::rational at, index_type act);
  hsps::rational next_start_time(hsps::rational t) const;
  hsps::rational next_finish_time(hsps::rational t) const;
  hsps::rational last_finish_time() const;
  void compute_action_set_and_vec();
  void assign_tracks();
  enum s_status { s_pending, s_ready, s_executing, s_finished };
  bool construct_minimal_makespan(const index_vec& acts,
      graph& prec,
      const index_set& c,
      hsps::rational& best,
      index_vec& sindex);
 public:
  static bool write_traits;
  Schedule(Instance& i);
  Schedule(const Schedule& s);
  virtual ~Schedule();
  void set_trace_level(int level) { trace_level = level; };
  index_type length() const;
  hsps::rational makespan() const;
  hsps::rational cost() const;
  index_type n_steps() const { return steps.length(); };
  const step_vec& plan_steps() const { return steps; };
  const index_set& plan_actions() const { return action_set; };
  const index_vec& step_actions() const { return action_vec; };
  void step_action_names(name_vec& nv);
  bool step_in_interval(index_type s, hsps::rational i_start, hsps::rational i_end) const;
  index_type step_action(index_type s) const;
  const Name* plan_name() const;
  bool plan_is_optimal() const;
  plan_trait_vec traits;
  const PlanTrait* find_trait(const char* cn);
  virtual void protect(index_type atom);
  virtual void insert(index_type act);
  virtual void advance(hsps::rational delta);
  virtual void end();
  void set_start_time(hsps::rational at);
  void reduce(ExecErrorSet* warnings);
  void clear();
  virtual void set_name(const Name* n);
  virtual void set_optimal(bool o);
  virtual void add_trait(PlanTrait* t);
  virtual void output(Plan& plan) const;
  virtual void output(Plan& plan, const index_vec& act_map) const;
  void write(::std::ostream& s, unsigned int c = Name::NC_DEFAULT) const;
  void write_step_set(::std::ostream& s, const index_set& set) const;
  void write_steps(::std::ostream& s) const;
  void writeXML(::std::ostream& s,
  ExecErrorSet* errors = 0,
  ExecTrace* trace = 0,
  graph* prec = 0,
  index_type id = 0) const;
  void writeGantt(::std::ostream& s) const;
  static double GANTT_UNIT_WIDTH;
  static double GANTT_UNIT_HEIGHT;
  static double GANTT_TEXT_XOFF;
  static double GANTT_TEXT_YOFF;
  static hsps::rational GANTT_TIME_MARK_INTERVAL;
  static bool GANTT_ACTION_NAMES_ON_CHART;
  bool simulate(ExecTrace* trace = 0,
  ExecErrorSet* errors = 0,
  bool finish = false) const;
  bool simulate_low_resolution(ExecTrace* trace = 0,
          ExecErrorSet* errors = 0,
          bool finish = false) const;
  bool simulate(index_set& achieved,
  ExecErrorSet* errors = 0) const;
  bool simulate(amt_vec& rtl) const;
  void deorder(graph& prec) const;
  void deorder(weighted_graph& prec) const;
  void base_precedence_graph(graph& prec) const;
  bool equivalent(const Schedule& s, index_vec* c = 0) const;
  bool schedule(const index_vec& acts,
  const graph& prec,
  index_vec* map = 0);
  bool construct_conflict_free(const index_vec& acts,
          const graph& prec,
          index_set& cs,
          index_vec& map);
  bool construct_minimal_makespan(const index_vec& acts,
      const graph& prec,
      index_vec& map);
  bool random_sequence(index_type ln_max,
         index_type ln_avg,
         bool continue_from_goal,
         ExecTrace* trace,
         RNG& rnd);
};
typedef lvector<Schedule*> plan_vec;
class ScheduleSet : public plan_vec, public PlanSet {
 protected:
  struct ScheduleProperties {
    bool valid;
    ExecTrace* trace;
    index_type n_resources;
    amt_vec total_consumption;
    amt_vec peak_use;
    amt_vec tolerable_loss;
    hsps::rational makespan;
    ScheduleProperties()
      : valid(true), trace(0), n_resources(0), total_consumption(0, 0),
 peak_use(0, 0), tolerable_loss(POS_INF, 0), makespan(0) { };
    ScheduleProperties(index_type n)
      : valid(true), trace(0), n_resources(n), total_consumption(0, n),
 peak_use(0, n), tolerable_loss(POS_INF, n), makespan(0) { };
    bool dominates(const ScheduleProperties& p);
  };
  typedef lvector<ScheduleProperties*> prop_vec;
  Instance& instance;
  prop_vec props;
  int trace_level;
  ScheduleProperties* compute_properties(Schedule* s);
  void cache_properties(index_type i, ScheduleProperties* p);
  bool dominated(const ScheduleProperties& p, prop_vec& pv);
  void dominated(prop_vec& pv, bool_vec& dom);
  bool dominated(const ScheduleProperties& p);
  void replace_schedule_with_properties
    (index_type i, Schedule* s, ScheduleProperties* p);
  void add_schedule_with_properties
    (Schedule* s, ScheduleProperties* p);
 public:
  ScheduleSet(Instance& i);
  ScheduleSet(ScheduleSet& s, const bool_vec& sel);
  ~ScheduleSet();
  void set_trace_level(int level);
  void add_schedule(Schedule* s);
  void add_schedule_if_different(Schedule* s);
  void reduce_plans();
  void filter_invalid_plans();
  void filter_unschedulable_plans();
  void filter_equivalent_plans();
  void add_distinguishing_traits_1();
  void add_distinguishing_traits_2();
  bool common_precedence_constraints(graph& prec);
  bool separating_precedence_constraints
    (ScheduleSet& s, pair_set& d0, pair_set& d1);
  void write_deordered_graphs(::std::ostream& s, bool w_names = true);
  void writeXML(::std::ostream& s);
  virtual Plan* new_plan();
  virtual void output(PlanSet& to);
  virtual void output(PlanSet& to, const bool_vec& s);
  void remove(bool_vec& set);
  void clear();
};
class ScheduleTrait : public PlanTrait {
 protected:
  Schedule* plan;
  ScheduleSet* plan_set;
  bool is_min;
  bool is_max;
  bool is_unique;
  void write_meta_short(::std::ostream& s) const;
  void write_meta_attributes(::std::ostream& s) const;
 public:
  ScheduleTrait(Schedule* p)
    : plan(p), plan_set(0), is_min(false), is_max(false), is_unique(false) { };
  ScheduleTrait(Schedule* p, ScheduleSet* s)
    : plan(p), plan_set(s), is_min(false), is_max(false), is_unique(false) { };
  virtual ~ScheduleTrait();
  void set_min() { is_min = true; };
  void set_max() { is_max = true; };
  void set_unique() { is_unique = true; };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const = 0;
  virtual void write_detail(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const = 0;
};
class EquivalentTo : public ScheduleTrait {
  Schedule* s_eq;
  index_vec cor;
 public:
  EquivalentTo(Schedule* p, ScheduleSet* ss, Schedule* s, const index_vec& c)
    : ScheduleTrait(p, ss), s_eq(s), cor(c) { };
  virtual ~EquivalentTo() { };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const;
  virtual void write_detail(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const;
};
class DerivedFrom : public ScheduleTrait {
  Schedule* s_src;
  pair_set e_prec;
 public:
  DerivedFrom(Schedule* p, ScheduleSet* ss, Schedule* s, const pair_set& e)
    : ScheduleTrait(p, ss), s_src(s), e_prec(e) { };
  DerivedFrom(Schedule* p, ScheduleSet* ss, Schedule* s, const index_pair& e)
    : ScheduleTrait(p, ss), s_src(s) { e_prec.assign_singleton(e); };
  DerivedFrom(Schedule* p, ScheduleSet* ss,
       DerivedFrom* a, const index_vec& m,
       const index_pair& e);
  virtual ~DerivedFrom() { };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const;
  virtual void write_detail(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const;
};
class PlanPrecedenceRelation : public ScheduleTrait {
  graph prec;
 public:
  PlanPrecedenceRelation(Schedule* s, const graph& p)
    : ScheduleTrait(s), prec(p) { };
  PlanPrecedenceRelation(Schedule* s, const graph& p, const index_vec& m)
    : ScheduleTrait(s) { prec.copy_and_rename(p, m); };
  virtual ~PlanPrecedenceRelation() { };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const;
  const graph& precedence_relation() const { return prec; };
};
class PlanActionOccurs : public ScheduleTrait {
  Instance& instance;
  index_type act;
  index_type n_of_times;
 public:
  PlanActionOccurs(Schedule* p, Instance& i, index_type a, index_type n)
    : ScheduleTrait(p), instance(i), act(a), n_of_times(n) { };
  virtual ~PlanActionOccurs() { };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const;
};
class PlanStepOrder : public ScheduleTrait {
  Instance& instance;
  index_pair order;
 public:
  PlanStepOrder(Schedule* p, Instance& i, const index_pair& o)
    : ScheduleTrait(p), instance(i), order(o) { };
  virtual ~PlanStepOrder() { };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const;
  const index_pair& precedence() const { return order; };
};
class PlanFeatureValue : public ScheduleTrait {
 public:
  enum plan_feature_type { makespan,
      cost,
      resource_peak_use,
      resource_total_consumption,
      resource_tolerable_loss };
 private:
  plan_feature_type ftype;
  Instance& instance;
  index_type index;
  hsps::rational value;
 public:
  PlanFeatureValue(Schedule* p,
     plan_feature_type t,
     Instance& i,
     index_type x,
     hsps::rational v) :
    ScheduleTrait(p), ftype(t), instance(i), index(x), value(v) { };
  virtual ~PlanFeatureValue() { };
  virtual const PlanTrait* cast_to(const char* class_name) const;
  virtual void write_short(::std::ostream& s) const;
  virtual void writeXML(::std::ostream& s) const;
};
bool feasible(Instance& ins,
       const index_vec& acts,
       const graph& prec,
       graph_vec* rfps = 0,
       index_type* rff = 0);
bool feasible(Instance& ins,
       const index_vec& acts,
       index_type r,
       graph& uc,
       graph_vec* rfps = 0,
       index_type* rff = 0);
bool feasible(Instance& ins,
       const index_vec& acts,
       index_type r,
       const index_set& a,
       index_type i,
       graph& uc,
       graph_vec* rfps = 0,
       index_type* rff = 0);
bool feasible(Instance& ins,
       const index_vec& acts,
       index_type r,
       const index_set& a,
       index_type i_a,
       const index_set& b,
       index_type i_b,
       hsps::rational c_max,
       graph& uc,
       graph_vec* rfps = 0,
       index_type* rff = 0);
class PlanName : public Name {
  const Name* src;
  const char* desc;
  index_type index;
 public:
  PlanName(const char* s, index_type i)
    : src(0), desc(s), index(i) { };
  PlanName(const Name* n, const char* s, index_type i)
    : src(n), desc(s), index(i) { };
  virtual ~PlanName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
::std::ostream& operator<<(::std::ostream& s, ExecError::ErrorType t);
::std::ostream& operator<<(::std::ostream& s, ExecError::ErrorSeverity sev);
}
#include <list>
namespace hsps {
class SoftInstance : public Instance {
 public:
  struct SoftGoal {
    Name* name;
    index_set atoms;
    hsps::rational weight;
    void* src;
    SoftGoal() : name(0), atoms(EMPTYSET), weight(0), src(0) { };
    SoftGoal& operator=(const SoftGoal& g) {
      name = g.name;
      atoms = g.atoms;
      weight = g.weight;
      src = g.src;
      return *this;
    };
    bool operator==(const SoftGoal& g) const {
      return ((atoms == g.atoms) &&
       (weight == g.weight));
    };
    bool is_sat(const bool* s) const {
      for (index_type k = 0; k < atoms.length(); k++)
 if (!s[atoms[k]]) return false;
      return true;
    };
    bool is_sat_init(const Instance& ins) const {
      for (index_type k = 0; k < atoms.length(); k++)
 if (!ins.atoms[k].init) return false;
      return true;
    };
    bool is_sat(const index_set& s) const {
      for (index_type k = 0; k < atoms.length(); k++)
 if (!s.contains(atoms[k])) return false;
      return true;
    };
  };
  typedef lvector<SoftGoal> soft_goal_vec;
  soft_goal_vec soft;
  index_set hard;
  hsps::rational null_value;
  SoftInstance();
  SoftInstance(Name* n);
  ~SoftInstance() { };
  SoftGoal& new_soft_goal();
  index_type n_soft() const { return soft.length(); };
  index_type n_hard() const { return hard.length(); };
  bool empty_plan_valid();
  hsps::rational empty_plan_value();
  void remap_hard_goals(const index_vec& atom_map);
  void remap_soft_goals(const index_vec& atom_map);
  void compile(Instance& ins);
  void create_decision_problem(const bool_vec& sel, Instance& ins);
  void create_decision_problem(const bool_vec& sel, hsps::rational b, Instance& ins);
  hsps::rational compute_epsilon();
  hsps::rational eval_goal_state(const index_set& s);
  hsps::rational eval_goal_state(const index_set& s, index_set& g);
  hsps::rational eval_plan(Schedule& s);
  void eval_plan_set(ScheduleSet& s, cost_vec& v);
  virtual void write_problem_goal(std::ostream& s) const;
  virtual void write_problem_metric(std::ostream& s) const;
  void write_goal_value_expression(std::ostream& s) const;
  void write_soft_goal_set(std::ostream& s, const index_set& set) const;
  void write_soft_goal_set(std::ostream& s, const bool_vec& set) const;
  virtual void print(std::ostream& s) const;
};
class DecisionProblemEnumerator : public IterativeEnumerator {
  SoftInstance& instance;
  SubsetEnumerator selected;
  Heuristic& h_cost;
  hsps::rational nb_min;
  index_set g_sel;
  index_set a_sel;
  hsps::rational v_sel;
  hsps::rational c_sel;
  hsps::rational nb_sel;
  bool find_next(bool more);
 public:
  DecisionProblemEnumerator(SoftInstance& ins, Heuristic& h, hsps::rational b);
  virtual ~DecisionProblemEnumerator();
  virtual bool first();
  virtual bool next();
  hsps::rational current_value() const;
  hsps::rational current_min_cost() const;
  hsps::rational current_max_cost() const;
  hsps::rational current_min_nb() const;
  hsps::rational current_max_nb() const;
  const index_set& current_soft_goals() const;
  const index_set& current_goal_atoms() const;
  void create_decision_problem(Instance& ins);
};
class MaxValueSearch {
 protected:
  struct option {
    hsps::rational goal_value;
    hsps::rational est_cost;
    index_set goals;
    State* root;
    option() : goal_value(0), est_cost(0), goals(EMPTYSET), root(0) { };
    index_type n_goals() const { goals.length(); };
    hsps::rational est_value() const { return (goal_value - est_cost); };
  };
  typedef std::list<option> option_list;
  typedef option_list::iterator option_p;
  SoftInstance& instance;
  ACF& cost;
  Statistics& stats;
  Result& res;
  MultiSearchAlgorithm* search;
  option_list options;
  hsps::rational lb;
  bool solved_flag;
  int trace_level;
  void insert_option_in_list(const option& o);
  void init_option_list();
  void make_empty_plan();
  virtual void init_option(const index_set& selected, option& o) = 0;
  virtual hsps::rational explore_next_option() = 0;
 public:
  MaxValueSearch(SoftInstance& i, ACF& c, Statistics& s, Result& r);
  MaxValueSearch(SoftInstance& i, ACF& c, Statistics& s, Result& r,
   index_type tt_size, bool use_cc);
  ~MaxValueSearch();
  static index_type print_options_max;
  void print_option_list(std::ostream& s);
  index_type n_options() const { return options.size(); };
  hsps::rational best_option_estimated_value();
  index_type best_option_size();
  void init();
  hsps::rational main();
  bool solved() { return solved_flag; }
};
class MaxNetBenefit : public MaxValueSearch {
  Heuristic& heuristic;
  RegressionResourceState* root_rs;
 protected:
  virtual void init_option(const index_set& selected, option& o);
  virtual hsps::rational explore_next_option();
 public:
  MaxNetBenefit(SoftInstance& i, ACF& c, Statistics& s, Result& r,
  Heuristic& h)
    : MaxValueSearch(i, c, s, r), heuristic(h), root_rs(0)
    { };
  MaxNetBenefit(SoftInstance& i, ACF& c, Statistics& s, Result& r,
  Heuristic& h, index_type tt_size, bool use_cc)
    : MaxValueSearch(i, c, s, r, tt_size, use_cc), heuristic(h), root_rs(0)
    { };
  MaxNetBenefit(SoftInstance& i, ACF& c, Statistics& s, Result& r,
  Heuristic& h, RegressionResourceState* rs)
    : MaxValueSearch(i, c, s, r), heuristic(h), root_rs(rs)
    { };
  MaxNetBenefit(SoftInstance& i, ACF& c, Statistics& s, Result& r,
  Heuristic& h, RegressionResourceState* rs,
  index_type tt_size, bool use_cc)
    : MaxValueSearch(i, c, s, r, tt_size, use_cc), heuristic(h), root_rs(rs)
    { };
  ~MaxNetBenefit() { };
};
}
namespace hsps {
class PDDL_Name;
class PDDL_Base {
 public:
  static bool use_default_function_value;
  static hsps::rational default_function_value;
  static bool use_strict_borrow_definition;
  static bool use_extended_borrow_definition;
  static bool del_before_add_semantics;
  static bool compact_resource_effects;
  static bool compile_away_disjunctive_preconditions;
  static bool check_precondition_consistency;
  static bool compile_away_conditional_effects;
  static bool compile_away_plan_constraints;
  static bool compile_away_object_functions;
  static bool compile_for_validator;
  static bool create_all_atoms;
  static bool create_all_actions;
  static bool number_multiple_action_instances;
  static bool exclude_all_dkel_items;
  static string_set excluded_dkel_tags;
  static string_set required_dkel_tags;
  static bool strict_set_export;
  static bool best_effort;
  static bool write_PDDL31;
  static bool write_warnings;
  static bool write_info;
  static bool write_trace;
  static bool trace_print_context;
  static bool name_instance_by_problem_file;
  static const char* instance_name_prefix;
  enum symbol_class {
    sym_object,
    sym_typename,
    sym_predicate,
    sym_object_function,
    sym_function,
    sym_action,
    sym_variable,
    sym_misc,
    sym_preference,
    sym_set,
    sym_meta_variable
  };
  enum metric_class {
    metric_none,
    metric_makespan,
    metric_minimize,
    metric_maximize
  };
  enum mode_keyword {
    md_none,
    md_start,
    md_end,
    md_all,
    md_init,
    md_pos_goal,
    md_neg_goal
  };
  enum partial_value { p_false, p_true, p_unknown };
  enum expression_class {
    exp_fun,
    exp_list,
    exp_const,
    exp_add,
    exp_sub,
    exp_mul,
    exp_div,
    exp_time,
    exp_preference
  };
  enum relation_type {
    rel_equal,
    rel_greater,
    rel_greater_equal,
    rel_less,
    rel_less_equal
  };
  enum formula_class { fc_false,
         fc_true,
         fc_atom,
         fc_equality,
         fc_negation,
         fc_conjunction,
         fc_disjunction,
         fc_equivalence,
         fc_implication,
         fc_universal,
         fc_existential,
         fc_list
  };
  struct Symbol;
  struct TypeSymbol;
  struct Atom;
  struct FTerm;
  struct FChangeAtom;
  struct SetOf;
  struct ListExpression;
  struct ActionSymbol;
  struct Reference;
  struct IrrelevantItem;
  typedef lvector<TypeSymbol*> type_vec;
  typedef lvector<Atom*> atom_vec;
  typedef lvector<FChangeAtom*> ch_atom_vec;
  typedef lvector<SetOf*> atom_set_vec;
  typedef lvector<Reference*> ref_vec;
  typedef lvector<IrrelevantItem*> irrelevant_vec;
  struct TypeSet : public type_vec {
    TypeSet() : type_vec(0, 0) { };
    TypeSet(const TypeSet& s) : type_vec(s) { };
    TypeSet(TypeSymbol* t) : type_vec(t, 1) { };
    index_type n_elements() const;
    Symbol* get_element(index_type n);
    bool is_object() const;
    bool subtype_or_equal(const TypeSet& s) const;
    bool subtype_or_equal(TypeSymbol* t) const;
    void print(std::ostream& s) const;
    void write_type(std::ostream& s) const;
  };
  struct Symbol {
    symbol_class sym_class;
    char* print_name;
    TypeSet sym_types;
    bool defined_in_problem;
    bool visible;
    Symbol(symbol_class c, char* n)
      : sym_class(c), print_name(n), defined_in_problem(false), visible(true) { };
    Symbol(char* n)
      : sym_class(sym_object), print_name(n), defined_in_problem(false), visible(true) { };
    void print(std::ostream& s) const;
  };
  typedef zero_init_pair<Symbol*> symbol_pair;
  typedef lvector<Symbol*> symbol_vec;
  typedef svector<Symbol*> symbol_set;
  typedef lvector<symbol_pair> symbol_pair_vec;
  static bool extend_substitution(Symbol* out, Symbol* in, symbol_pair_vec& u);
  static bool print_substitution(std::ostream& s, const symbol_pair_vec& u);
  static bool print_inequality(std::ostream& s, const symbol_pair_vec& neq);
  static bool substitution_violates_inequality(const symbol_pair_vec& neq,
            const symbol_pair_vec& u);
  static index_type find_matching_atom(Atom* a, atom_vec& v);
  static index_type find_matching_atom(Atom* a, mode_keyword m, atom_vec& v);
  static index_type find_matching_fluent_atom
    (FChangeAtom* a, mode_keyword m, ch_atom_vec& v);
  struct TypeSymbol : public Symbol {
    symbol_vec elements;
    bool is_base_type;
    TypeSymbol(char* n) : Symbol(sym_typename, n), elements(0, 0),
  is_base_type(false) { };
    void add_element(Symbol* e);
    bool is_object() const { return (strcmp(print_name, "object") == 0); };
    bool subtype_or_equal(TypeSymbol* t) const;
    bool subtype_or_equal(const TypeSet& t) const;
    void print(std::ostream& s) const;
  };
  struct VariableSymbol : public Symbol {
    Symbol* value;
    FTerm* binding;
    VariableSymbol(char* n) : Symbol(sym_variable, n), value(0), binding(0) {};
    bool equality_type_check(Symbol* s);
    void print(std::ostream& s);
  };
  typedef lvector<VariableSymbol*> variable_vec;
  struct ParamSymbol : public Symbol {
    variable_vec param;
    ParamSymbol(symbol_class c, char* n) : Symbol(c, n), param(0, 0) { };
  };
  struct PredicateSymbol : public ParamSymbol {
    bool pos_pre;
    bool neg_pre;
    bool added;
    bool deleted;
    bool locked;
    bool modded;
    ptr_table init;
    ptr_table pos_goal;
    ptr_table neg_goal;
    ptr_table pos_prop;
    ptr_table neg_prop;
    irrelevant_vec irr_ins;
    PredicateSymbol(char* n) : ParamSymbol(sym_predicate, n),
  pos_pre(false), neg_pre(false), added(false), deleted(false),
  locked(false), modded(false), irr_ins(0, 0) { };
    bool is_static() const { return !modded; };
    bool is_equality() const { return (strcmp(print_name, "=") == 0); };
    void instantiate(Instance& ins);
    void initialise_missing(const symbol_vec& p,
       atom_vec* created,
       index_type i = 0);
    void write_prototype(std::ostream& s);
    void print(std::ostream& s);
  };
  struct ObjectFunctionSymbol : public ParamSymbol {
    bool modded;
    ptr_table init;
    ObjectFunctionSymbol(char* n)
      : ParamSymbol(sym_object_function, n), modded(false) { };
    bool is_static() const { return !modded; };
    void print(std::ostream& s);
  };
  struct FunctionSymbol : public ParamSymbol {
    bool modified;
    bool integral;
    bool linear;
    bool conditioned;
    bool increased;
    bool decreased;
    bool assigned;
    bool borrowed;
    ptr_table init;
    FunctionSymbol(char* n) : ParamSymbol(sym_function, n),
  modified(false), integral(true), linear(true), conditioned(false),
  increased(false), decreased(false), assigned(false), borrowed(false)
    { };
    bool is_static() const
    { return !modified; };
    bool is_reusable() const
    { return borrowed && !increased && !decreased && !assigned; };
    bool is_consumable() const
    { return !borrowed && !increased && decreased && !assigned; };
    interval eval_init_bounds(ptr_table* p, index_type i, ListExpression* r);
    void print(std::ostream& s);
  };
  struct AtomBase {
    symbol_vec param;
    mode_keyword at;
    hsps::rational at_time;
    AtomBase() : param(0, 0), at(md_none), at_time(0) { };
    AtomBase(mode_keyword t) : param(0, 0), at(t), at_time(0) { };
    AtomBase(AtomBase* b);
    bool equals(AtomBase& b);
    void free_variables(variable_vec& v);
    bool occurs(Symbol* s);
    void fill_in_args(AtomBase* b);
    void collect_bound_variables(variable_vec& v);
    void insert(ptr_table& t);
    static bool print_bindings;
    void print(std::ostream& s) const;
    void print_instance(std::ostream& s);
  };
  typedef lvector<AtomBase*> atom_base_vec;
  struct Atom : AtomBase {
    PredicateSymbol* pred;
    Atom(PredicateSymbol* p) : pred(p) { };
    Atom(PredicateSymbol* p, mode_keyword t) : AtomBase(t), pred(p) { };
    Atom(PredicateSymbol* p, variable_vec& a, bool as_value)
      : pred(p)
    {
      param.set_length(a.length());
      for (index_type k = 0; k < a.length(); k++)
 param[k] = (as_value ? a[k]->value : a[k]);
    };
    Atom(PredicateSymbol* p, Symbol* a0)
      : pred(p)
    {
      param.append(a0);
    };
    Atom(Atom* a) : AtomBase(a), pred(a->pred) { };
    bool equals(Atom& a);
    bool is_static() const {
      return ((at == md_init) ||
       (at == md_pos_goal) ||
       (at == md_neg_goal) ||
       pred->is_static());
    };
    bool check();
    Instance::Atom* find_prop(Instance& ins, bool neg, bool create);
    void build(Instance& ins, bool neg, index_type p);
    Atom* instantiate_partially();
    partial_value partial_eval(ptr_table* r, index_type p);
    partial_value partial_eval();
    bool initial_value();
    bool instance_of(Atom* a, symbol_pair_vec& u);
    bool instance_of(Atom* a, const symbol_pair_vec& neq, symbol_pair_vec& u);
    bool unify(Atom* a, symbol_pair_vec& u);
    bool unify(Atom* a, const symbol_pair_vec& neq, symbol_pair_vec& u);
    void print(std::ostream& s, bool neg) const;
    void print(std::ostream& s) const { print(s, false); };
  };
  struct CAtom : public Atom {
    symbol_pair_vec neq;
    CAtom(Atom* a) : Atom(a), neq(symbol_pair(0, 0), 0) { };
    CAtom(CAtom* s) : Atom(s), neq(s->neq) { };
    CAtom(const Atom* a, symbol_pair_vec& u);
    CAtom(const Atom* a, symbol_pair_vec& n, symbol_pair_vec& u);
    bool instance_of(Atom* a, symbol_pair_vec& u);
    bool instance_of(Atom* a, const symbol_pair_vec& neq, symbol_pair_vec& u);
    bool instance_of(CAtom* a, symbol_pair_vec& u);
    bool unify(Atom* a, symbol_pair_vec& u);
    bool unify(CAtom* a, symbol_pair_vec& u);
    void print(std::ostream& s);
  };
  typedef lvector<CAtom*> catom_vec;
  struct FTerm : AtomBase {
    ObjectFunctionSymbol* fun;
    FTerm(ObjectFunctionSymbol* f) : fun(f) { };
    bool equals(FTerm& a);
    void print(std::ostream& s) const;
  };
  struct OInitAtom : AtomBase {
    ObjectFunctionSymbol* fun;
    Symbol* val;
    OInitAtom(ObjectFunctionSymbol* f) : fun(f), val(0) { };
    void print(std::ostream& s);
  };
  typedef lvector<OInitAtom*> obj_init_atom_vec;
  struct FInitAtom : AtomBase {
    FunctionSymbol* fun;
    hsps::rational val;
    Instance::resource_ref res;
    FInitAtom(FunctionSymbol* f) : fun(f), val(0) { };
    FInitAtom(FChangeAtom* a);
    bool is_static() const { return fun->is_static(); };
    void print(std::ostream& s);
  };
  typedef lvector<FInitAtom*> fun_init_atom_vec;
  struct Expression;
  typedef lvector<Expression*> exp_vec;
  struct Expression {
    expression_class exp_class;
    Expression(expression_class c) : exp_class(c) { };
    static bool print_nary;
    bool is_static();
    bool is_constant();
    bool is_integral();
    hsps::rational eval_static();
    bool eval_partial(hsps::rational& val);
    interval eval_bounds();
    hsps::rational eval_init();
    hsps::rational eval_delta(ch_atom_vec& incs, ch_atom_vec& decs);
    hsps::rational eval_delta(Symbol* preference, hsps::rational p_value, hsps::rational d_value);
    Expression* copy();
    Expression* simplify();
    void collect_constants(exp_vec& c);
    void mark_functions_in_condition();
    hsps::rational integrify();
    void substitute_for_time(Expression* e);
    Expression* substitute_for_preference(Symbol* n, Expression* e);
    bool equals(Expression* e);
    void print_sum(std::ostream& s, bool grnd);
    void print_product(std::ostream& s, bool grnd);
    void print(std::ostream& s, bool grnd);
  };
  struct ListExpression : public Expression {
    Symbol* sym;
    ListExpression* rest;
    ListExpression(Symbol* s, ListExpression* r) :
      Expression(exp_list), sym(s), rest(r) { };
    bool match(AtomBase* atom);
  };
  struct FunctionExpression : public Expression {
    FunctionSymbol* fun;
    ListExpression* args;
    FunctionExpression(FunctionSymbol* f, ListExpression* a) :
      Expression(exp_fun), fun(f), args(a) { };
    bool match(FChangeAtom* atom);
    hsps::rational eval_delta(ch_atom_vec& incs, ch_atom_vec& decs);
    FChangeAtom* make_atom_base();
  };
  struct ConstantExpression : public Expression {
    hsps::rational val;
    ConstantExpression(hsps::rational v) :
      Expression(exp_const), val(v) { };
  };
  struct TimeExpression : public Expression {
    Expression* time_exp;
    TimeExpression() :
      Expression(exp_time), time_exp(0) { };
    TimeExpression(Expression* e) :
      Expression(exp_time), time_exp(e) { };
  };
  struct BinaryExpression : public Expression {
    Expression* first;
    Expression* second;
    BinaryExpression(expression_class c, Expression* e1, Expression* e2) :
      Expression(c), first(e1), second(e2) { };
  };
  struct PreferenceExpression : public Expression {
    Symbol* name;
    PreferenceExpression(Symbol* n) :
      Expression(exp_preference), name(n) { };
  };
  struct Relation {
    relation_type rel;
    mode_keyword at;
    Expression* first;
    Expression* second;
    Relation(relation_type r, Expression* e1, Expression* e2) :
      rel(r), at(md_none), first(e1), second(e2) { };
    Relation(relation_type r, mode_keyword m, Expression* e1, Expression* e2) :
      rel(r), at(m), first(e1), second(e2) { };
    Expression* match_gteq_constant(FChangeAtom* atom);
    FunctionExpression* match_lteq_fun(FChangeAtom* atom);
    bool is_static();
    partial_value partial_eval();
    void print(std::ostream& s, bool grnd);
  };
  typedef lvector<Relation*> relation_vec;
  struct FChangeAtom : AtomBase {
    FunctionSymbol* fun;
    Expression* val;
    FChangeAtom(FunctionSymbol* f) :
      fun(f), val(0) { };
    FChangeAtom(FunctionSymbol* f, mode_keyword t) :
      AtomBase(t), fun(f), val(0) { };
    FChangeAtom(FChangeAtom* a, hsps::rational v) :
      AtomBase(a), fun(a->fun), val(new ConstantExpression(v)) { };
    bool equals(FChangeAtom& a);
    bool fluent_equals(FChangeAtom& a);
    bool fluent_and_mode_equals(FChangeAtom& a);
    FChangeAtom* find_fluent_equals(ch_atom_vec& vec);
    Instance::Resource* find_resource(Instance& ins);
    void print(std::ostream& s);
  };
  struct Formula {
    formula_class fc;
    Formula(formula_class c) : fc(c) { };
    void rename_variables_1(PDDL_Base::symbol_pair_vec& sub);
    void rename_variables_2(PDDL_Base::symbol_pair_vec& sub);
    void rename_predicates_1(PDDL_Base::symbol_pair_vec& sub);
    void rename_predicates_2(PDDL_Base::symbol_pair_vec& sub);
    Formula* simplify();
    void write_otter(std::ostream& s) const;
    void print(std::ostream& s) const;
    void untype(PDDL_Base* base);
  };
  typedef lvector<Formula*> formula_vec;
  struct AFormula : public Formula, public Atom {
    AFormula(Atom* a) :
      Formula(fc_atom), Atom(a) { };
    AFormula(PredicateSymbol* p) :
      Formula(fc_atom), Atom(p) { };
    AFormula(PredicateSymbol* p, variable_vec& a) :
      Formula(fc_atom), Atom(p, a, false) { };
    void print(std::ostream& s) const;
    void write_otter(std::ostream& s) const;
  };
  struct EqFormula : public Formula {
    Symbol* t1;
    Symbol* t2;
    EqFormula(Symbol* s1, Symbol* s2) :
      Formula(fc_equality), t1(s1), t2(s2) { };
    void write_otter(std::ostream& s) const;
  };
  struct NFormula : public Formula {
    Formula* f;
    NFormula(Formula* g) : Formula(fc_negation), f(g) { };
  };
  struct BFormula : public Formula {
    Formula* f1;
    Formula* f2;
    BFormula(formula_class c, Formula* g1, Formula* g2) :
      Formula(c), f1(g1), f2(g2) { };
  };
  struct CFormula : public Formula {
    formula_vec parts;
    CFormula(formula_class c) : Formula(c), parts(0, 0) { };
    CFormula(formula_class c, Formula* f1, Formula* f2) :
      Formula(c), parts(0, 0)
    {
      parts.append(f1);
      parts.append(f2);
    };
    void add(Formula* f) { parts.append(f); };
    void add(formula_vec& f) { parts.append(f); };
    void write_otter(std::ostream& s) const;
  };
  struct QFormula : public Formula {
    variable_vec vars;
    Formula* f;
    QFormula(formula_class c) : Formula(c), vars(0, 0), f(0) { };
    QFormula(formula_class c, Formula* g) : Formula(c), vars(0, 0), f(g) { };
    QFormula(formula_class c, variable_vec& v, Formula* g) :
      Formula(c), vars(0, 0), f(g)
    {
      for (index_type k = 0; k < v.length(); k++) vars.append(v[k]);
    };
    void add(PDDL_Base::VariableSymbol* v) { vars.append(v); };
    void add(PDDL_Base::variable_vec& v) { vars.append(v); };
    void write_otter(std::ostream& s) const;
  };
  struct TypeConstraint {
    VariableSymbol* var;
    TypeSymbol* typ;
    TypeConstraint(VariableSymbol* v, TypeSymbol* t) : var(v), typ(t) { };
    bool is_true();
    partial_value partial_eval();
    void print(std::ostream& s);
  };
  typedef lvector<TypeConstraint*> type_constraint_vec;
  struct Context {
    variable_vec param;
    atom_vec pos_con;
    atom_vec neg_con;
    type_constraint_vec type_con;
    Context() : param(0, 0), pos_con(0, 0), neg_con(0, 0), type_con(0, 0) { };
    Context(const Context* c) : param(c->param), pos_con(c->pos_con),
  neg_con(c->neg_con), type_con(c->type_con) { };
    bool context_is_static() const;
    bool occurs_in_context(Symbol* s);
    void clear_arguments();
    void set_mode(mode_keyword m);
    bool is_true();
    partial_value partial_eval();
    void print(std::ostream& s);
    void print_assignment(std::ostream& s);
    void untype(PDDL_Base* base);
  };
  struct DKEL_Item : public Context {
    char* item_name;
    Symbol* name;
    string_set item_tags;
    bool defined_in_problem;
    bool included;
    DKEL_Item(char* name) : item_name(name), name(0),
  defined_in_problem(false), included(true) { };
    DKEL_Item(const DKEL_Item* i) : Context(i), item_name(i->item_name),
  name(i->name), item_tags(i->item_tags),
  defined_in_problem(i->defined_in_problem), included(i->included) { };
    bool item_is_included(string_set& ex_tags, string_set& req_tags);
    void print_begin(std::ostream& s);
    void print_end(std::ostream& s);
    void print(std::ostream& s);
    void write_dkel(std::ostream& s);
  };
  struct SetOf : public Context {
    atom_vec pos_atoms;
    atom_vec neg_atoms;
    SetOf() : pos_atoms(0, 0), neg_atoms(0, 0) { };
    SetOf(const SetOf* s)
      : Context(s), pos_atoms(s->pos_atoms), neg_atoms(s->neg_atoms)
    { };
    SetOf(Atom* a)
    { pos_atoms.append(a); };
    SetOf(Atom* a, bool n)
    { if (n) neg_atoms.append(a); else pos_atoms.append(a); };
    bool is_static() const;
    void set_mode(mode_keyword m);
    partial_value partial_eval(bool as_disjunction = false);
    partial_value partial_eval(index_type p, bool as_disjunction = false);
    void instantiate_as_set(Instance& ins, index_set& s);
    void instantiate_as_effect(Instance& ins, index_set& s_add,
          index_set& s_del);
    void instantiate_conditional(Instance& ins, rule_set& s_pos,
     rule_set& s_neg);
    SetOf* instantiate_partially();
    void compile(atom_vec& pos_ins, atom_vec& neg_ins, index_type p);
    void compile_non_static(atom_set_vec& ins, index_type p);
    void print(std::ostream& s);
    void print_as_disjunction(std::ostream& s);
    void build_set(Instance& ins, index_set& s, index_type p);
    void build_effect(Instance& ins, index_set& s_add, index_set& s_del,
        index_type p);
    void build_conditional(Instance& ins, rule_set& s_pos, rule_set& s_neg,
      index_type p);
  };
  struct QCNumericEffect : public Context {
    FChangeAtom* atom;
    QCNumericEffect() : atom(0) { };
    QCNumericEffect(FChangeAtom* a) : atom(a) { };
    void print(std::ostream& s);
  };
  typedef lvector<QCNumericEffect*> qc_numeric_effect_vec;
  enum set_constraint_keyword { sc_at_least, sc_at_most, sc_exactly };
  struct SetConstraint : public DKEL_Item {
    set_constraint_keyword sc_type;
    index_type sc_count;
    atom_vec pos_atoms;
    atom_vec neg_atoms;
    atom_set_vec atom_sets;
    SetConstraint() : DKEL_Item(":invariant"), sc_type(sc_at_least),
  sc_count(0), pos_atoms(0, 0), neg_atoms(0, 0), atom_sets(0, 0) { };
    SetConstraint(const DKEL_Item* item) : DKEL_Item(item),
  sc_type(sc_at_least), sc_count(0), pos_atoms(0, 0), neg_atoms(0, 0),
  atom_sets(0, 0) { };
    void build(Instance& ins, index_type p);
    void instantiate(Instance& ins);
    void print(std::ostream& s);
    void write_dkel(std::ostream& s);
    void untype(PDDL_Base* base);
  };
  struct InvariantFormula : public DKEL_Item {
    Formula* f;
    InvariantFormula(Formula* g)
      : DKEL_Item(":invariant"), f(g) { };
    InvariantFormula(const DKEL_Item* item, Formula* g)
      : DKEL_Item(item), f(g) { };
    void write_dkel(std::ostream& s);
    void untype(PDDL_Base* base);
  };
  struct Reference : public AtomBase {
    Symbol* name;
    bool neg;
    bool has_args;
    index_set index;
    Reference(Symbol* n) : name(n), neg(false), has_args(true) { };
    Reference(Symbol* n, bool ng, bool ha)
      : name(n), neg(ng), has_args(ha) { };
    bool match(symbol_vec& args);
    bool match(variable_vec& args);
    void* find_action();
    void find(const name_vec& names, index_set& ind);
    Reference* instantiate_partially();
    void print(std::ostream& s);
  };
  struct IrrelevantItem : public DKEL_Item {
    Reference* entity;
    IrrelevantItem() : DKEL_Item(":irrelevant"), entity(0) { };
    bool match(symbol_vec& args);
    bool match(variable_vec& args);
    IrrelevantItem* instantiate_partially();
    void print(std::ostream& s);
    void write_dkel(std::ostream& s);
  };
  struct SequentialTaskNet : public Context {
    ref_vec tasks;
    ActionSymbol* abs_act;
    SequentialTaskNet() : tasks(0, 0), abs_act(0) { };
    void print(std::ostream& s);
  };
  typedef lvector<SequentialTaskNet*> task_net_vec;
  struct SetSymbol : public Symbol {
    ptr_table set_table;
    lvector<index_set*> sets;
    name_vec names;
    SetSymbol(char* n) : Symbol(sym_set, n), sets(0, 0), names(0, 0) { };
  };
  struct SetName : public AtomBase {
    SetSymbol* sym;
    SetName(SetSymbol* s) : sym(s) { };
    index_set* find();
    SetName* instantiate_partially();
    void print(std::ostream& s);
    void print_instance(std::ostream& s);
  };
  struct ActionSymbol : public ParamSymbol {
    atom_vec pos_pre;
    atom_vec neg_pre;
    atom_set_vec set_pre;
    atom_set_vec dis_pre;
    relation_vec num_pre;
    atom_vec adds;
    atom_vec dels;
    atom_set_vec set_eff;
    atom_vec cons;
    atom_set_vec cond_eff;
    atom_vec locks;
    atom_vec enables;
    ch_atom_vec reqs;
    ch_atom_vec incs;
    ch_atom_vec decs;
    ch_atom_vec fass;
    qc_numeric_effect_vec qc_incs;
    qc_numeric_effect_vec qc_decs;
    qc_numeric_effect_vec qc_fass;
    Expression* dmin;
    Expression* dmax;
    irrelevant_vec irr_ins;
    ref_vec refs;
    task_net_vec exps;
    ptr_table instances;
    SetName* part;
    const char* assoc;
    ActionSymbol(char* n) : ParamSymbol(sym_action, n), pos_pre(0, 0),
  neg_pre(0, 0), set_pre(0, 0), dis_pre(0, 0), num_pre(0, 0),
  adds(0, 0), dels(0, 0), set_eff(0, 0), cons(0, 0), cond_eff(0, 0),
  locks(0, 0), enables(0, 0), reqs(0, 0), incs(0, 0), decs(0, 0),
  fass(0, 0), qc_incs(0, 0), qc_decs(0, 0), qc_fass(0, 0), dmin(0),
  dmax(0), irr_ins(0, 0), refs(0, 0), exps(0, 0), part(0), assoc(0) { };
    void build(Instance& ins, index_type p, Expression* cost_exp);
    Instance::Action& build_action(Instance& ins,
       PDDL_Name* name,
       index_type& count,
       const index_set& pre,
       const index_set& add,
       const index_set& del,
       const index_set& lck,
       const index_cost_vec& r_use,
       const index_cost_vec& r_cons,
       hsps::rational dmin,
       hsps::rational dmax,
       hsps::rational dur,
       hsps::rational cost);
    void build_actions_with_dc(Instance& ins,
          PDDL_Name* name,
          index_type& count,
          const index_set& pre,
          const index_set& add,
          const index_set& del,
          const index_set& lck,
          const index_cost_vec& r_use,
          const index_cost_vec& r_cons,
          hsps::rational dmin,
          hsps::rational dmax,
          hsps::rational dur,
          hsps::rational cost,
          const index_set_vec& dc,
          index_vec& s,
          index_type p);
    void build_actions_with_dc(Instance& ins,
          PDDL_Name* name,
          index_type& count,
          const index_set& pre,
          const index_set& add,
          const index_set& del,
          const index_set& lck,
          const index_cost_vec& r_use,
          const index_cost_vec& r_cons,
          hsps::rational dmin,
          hsps::rational dmax,
          hsps::rational dur,
          hsps::rational cost,
          const index_set_vec& dc);
    void build_actions_with_dc_and_ce(Instance& ins,
          PDDL_Name* name,
          index_type& count,
          const index_set& pre,
          const index_set& add,
          const index_set& del,
          const index_set& lck,
          const index_cost_vec& r_use,
          const index_cost_vec& r_cons,
          hsps::rational dmin,
          hsps::rational dmax,
          hsps::rational dur,
          hsps::rational cost,
          const index_set_vec& dc,
          const rule_set& pce,
          const rule_set& nce,
          const bool_vec& ece);
    index_type param_index(VariableSymbol* p);
    void get_param_inequalities(symbol_pair_vec& neq);
    void set_arguments(const symbol_vec& args);
    void set_arguments(const ptr_table::key_vec& args);
    void clear_arguments();
    void* find_instance();
    bool is_abstract();
    void post_process();
    void instantiate(Instance& ins, Expression* cost_exp);
    void write_prototype(std::ostream& s);
    void print(std::ostream& s);
    void untype(PDDL_Base* base);
  };
  struct InputPlanStep {
    Reference* act;
    hsps::rational start_time;
    InputPlanStep() : act(0), start_time(0) { };
    InputPlanStep(Reference* a, hsps::rational t) : act(a), start_time(t) { };
  };
  struct InputPlan {
    Symbol* name;
    bool is_opt;
    lvector<InputPlanStep*> steps;
    InputPlan() : name(0), is_opt(false), steps(0, 0) { };
    bool export_to_instance(Instance& ins, const index_vec& map, Plan& p);
    void print(std::ostream& s);
  };
  struct HTableEntry {
    atom_vec atoms;
    bool_vec neg;
    hsps::rational cost;
    bool opt;
    HTableEntry() : atoms(0, 0), neg(false, 0), cost(0), opt(false) { };
  };
  struct SimpleReferenceSet : public Context {
    Reference* ref;
    SimpleReferenceSet(Reference* r) : ref(r) { };
    bool build(const name_vec& names, index_set& set, index_type p);
    void print(std::ostream& s);
  };
  typedef lvector<SimpleReferenceSet*> refs_vec;
  struct ReferenceSet : public Context {
    refs_vec refs;
    Symbol* name;
    ReferenceSet() : refs(0, 0), name(0) { };
    void add(SimpleReferenceSet* ref) { refs.append(ref); };
    void build(const name_vec& names, index_set_vec& sets, index_type p);
    void print(std::ostream& s);
  };
  struct CPG {
    atom_vec atoms;
    index_vec atom_first_arg;
    bool_vec neg;
    symbol_vec args;
    type_vec arg_types;
    CPG() : atoms(0, 0), neg(false, 0), args(0, 0), arg_types(0, 0) { };
    CPG(CPG& g, index_vec& s);
    void make_key(ptr_table::key_vec& key);
    void make_typed_key(ptr_table::key_vec& key);
    void make_parameters(variable_vec& params);
    ListExpression* make_argument_list(index_type first);
    void add_asserting_effects(ActionSymbol* act,
          PredicateSymbol* p,
          bool p_val,
          PredicateSymbol* g,
          FunctionSymbol* f,
          Expression* f_val,
          bool strict);
    void add_destroying_effects(ActionSymbol* act,
    ParamSymbol* pf,
    PredicateSymbol* p,
    bool p_val,
    PredicateSymbol* g,
    FunctionSymbol* f,
    Expression* f_val,
    bool strict);
    bool initial_value();
    void add_asserting_effects(index_type c_atom,
          ActionSymbol* act,
          index_type c_eff,
          bool_vec& sat,
          PredicateSymbol* p,
          bool p_val,
          PredicateSymbol* g,
          FunctionSymbol* f,
          Expression* f_val,
          symbol_pair_vec& eq,
          symbol_pair_vec& neq,
          bool strict);
    void add_propositional_effect(ActionSymbol* act,
      PredicateSymbol* p, bool p_val,
      index_type c_atom, Atom* a_eff,
      bool strict);
    void add_fluent_effect(ActionSymbol* act,
      FunctionSymbol* f, Expression* f_val,
      index_type c_atom, Atom* a_eff);
    void add_effect_conditions(Context* e, ParamSymbol* pf, bool_vec& sat,
          symbol_vec& subs, symbol_pair_vec& eq,
          symbol_pair_vec& neq);
  };
  enum goal_class { goal_pos_atom, goal_neg_atom, goal_relation, goal_task,
      goal_conjunction, goal_disjunction, goal_forall,
      goal_exists, goal_always, goal_sometime,
      goal_at_most_once, goal_within, goal_always_within,
      goal_sometime_before, goal_sometime_after };
  struct Goal {
    goal_class g_class;
    Goal(goal_class c) : g_class(c) { };
    bool is_state();
    bool is_propositional();
    bool is_singular();
    bool makeCPG(CPG& g);
    bool makeCPG(CPG& g, index_vec& s);
    void instantiate(Instance& ins, hsps::rational deadline);
    void instantiate(Instance& ins, index_set& set, Symbol* p, index_type i);
    void print(std::ostream& s);
  };
  typedef lvector<Goal*> goal_vec;
  struct AtomicGoal : public Goal {
    Atom* atom;
    AtomicGoal(Atom* a, bool neg)
      : Goal(neg ? goal_neg_atom : goal_pos_atom), atom(a) { };
    void print(std::ostream& s);
  };
  struct NumericGoal : public Goal {
    Relation* rel;
    NumericGoal(Relation* r) : Goal(goal_relation), rel(r) { };
    void print(std::ostream& s);
  };
  struct TaskGoal : public Goal {
    Reference* task;
    TaskGoal(Reference* r) : Goal(goal_task), task(r) { };
    void print(std::ostream& s);
  };
  struct ConjunctiveGoal : public Goal {
    goal_vec goals;
    ConjunctiveGoal() : Goal(goal_conjunction), goals(0, 0) { };
    ConjunctiveGoal(goal_class gc) : Goal(gc), goals(0, 0) { };
    void print(std::ostream& s);
  };
  struct DisjunctiveGoal : public ConjunctiveGoal {
    DisjunctiveGoal() : ConjunctiveGoal(goal_disjunction) { };
    void print(std::ostream& s);
  };
  struct QuantifiedGoal : public Goal, public Context {
    Goal* goal;
    QuantifiedGoal() : Goal(goal_forall), goal(0) { };
    QuantifiedGoal(goal_class gc) : Goal(gc), goal(0) { };
    void print(std::ostream& s);
  };
  struct SimpleSequenceGoal : public Goal {
    Goal* constraint;
    SimpleSequenceGoal(goal_class c, Goal* g) : Goal(c), constraint(g) { };
    void print(std::ostream& s);
  };
  struct TriggeredSequenceGoal : public Goal {
    Goal* trigger;
    Goal* constraint;
    TriggeredSequenceGoal(goal_class c, Goal* t, Goal* g)
      : Goal(c), trigger(t), constraint(g) { };
    void print(std::ostream& s);
  };
  struct DeadlineGoal : public Goal {
    Goal* goal;
    hsps::rational at;
    DeadlineGoal(hsps::rational t, Goal* g) : Goal(goal_within), goal(g), at(t) { };
    void print(std::ostream& s);
  };
  struct TriggeredDeadlineGoal : public Goal {
    Goal* trigger;
    Goal* goal;
    hsps::rational delay;
    TriggeredDeadlineGoal(Goal* t, hsps::rational d, Goal* g)
      : Goal(goal_always_within), trigger(t), delay(d), goal(g) { };
    void print(std::ostream& s);
  };
  struct Preference {
    Symbol* name;
    Goal* goal;
    Preference() : name(0), goal(0) { };
    Preference(Symbol* n) : name(n), goal(0) { };
    Preference(Symbol* n, Goal* g) : name(n), goal(g) { };
    bool is_state() { return goal->is_state(); };
    bool is_propositional() { return goal->is_propositional(); };
    hsps::rational value(metric_class metric_type, Expression* m);
    void instantiate(SoftInstance& ins,
       metric_class metric_type,
       Expression* m);
    void print(std::ostream& s);
  };
  typedef lvector<Preference*> preference_vec;
  char* domain_name;
  char* problem_name;
  char* domain_file;
  char* problem_file;
  bool ready_to_instantiate;
  char* problem_file_basename();
  char* enum_problem_filename(const char* s, index_type i);
  StringTable& tab;
  type_vec dom_types;
  type_vec dom_base_types;
  TypeSymbol* dom_top_type;
  symbol_vec dom_constants;
  PredicateSymbol* dom_eq_pred;
  PredicateSymbol* dom_assign_pred;
  Symbol* dom_undefined_obj;
  static PredicateSymbol* current_eq_predicate;
  lvector<PredicateSymbol*> dom_predicates;
  lvector<ObjectFunctionSymbol*> dom_object_functions;
  lvector<FunctionSymbol*> dom_functions;
  lvector<ActionSymbol*> dom_actions;
  lvector<SetConstraint*> dom_sc_invariants;
  lvector<InvariantFormula*> dom_f_invariants;
  lvector<IrrelevantItem*> dom_irrelevant;
  atom_vec dom_init;
  obj_init_atom_vec dom_obj_init;
  fun_init_atom_vec dom_fun_init;
  goal_vec dom_goals;
  preference_vec dom_preferences;
  ref_vec goal_tasks;
  metric_class metric_type;
  Expression* metric;
  hsps::rational serial_length;
  hsps::rational parallel_length;
  lvector<InputPlan*> input_plans;
  lvector<HTableEntry*> h_table;
  lvector<ReferenceSet*> input_sets;
  lvector<SetSymbol*> partitions;
  static ActionSymbol* src_action_symbol(ptr_pair* p);
  TypeSymbol* find_type(const char* name);
  PredicateSymbol* find_predicate(const char* name);
  FunctionSymbol* find_function(const char* name);
  bool find_initial_fact(const char* pname, const symbol_vec& arg);
  hsps::rational find_function_value(const char* fname, const symbol_vec& arg);
  index_type find_element_satisfying(const symbol_vec& elements,
         const char* pname,
         symbol_vec& arg,
         index_type element_arg_p);
  void find_elements_satisfying(const symbol_vec& elements,
    const char* pname,
    symbol_vec& arg,
    index_type element_arg_p,
    index_set& sats);
  Atom* goal_to_atom(Goal* g);
  bool goal_to_atom_vec(Goal* g, atom_vec& av);
  PDDL_Base(StringTable& t);
  ~PDDL_Base();
  void set_variable_type(variable_vec& vec, TypeSymbol* t);
  void set_variable_type(variable_vec& vec, const TypeSet& t);
  void set_type_type(type_vec& vec, TypeSymbol* t);
  void set_constant_type(symbol_vec& vec, TypeSymbol* t);
  void clear_context(variable_vec& vec);
  void clear_context(variable_vec& vec, index_type n_min, index_type n_max);
  bool merge_type_vectors(type_vec& v0, type_vec& v1);
  void make_parameters(type_vec& t, const char* prefix, variable_vec& v);
  Atom* make_atom_from_prop(ptr_pair& src, bool& neg);
  Symbol* gensym(symbol_class c, const char* p, const TypeSet& t);
  Symbol* gensym(symbol_class c, const char* p, TypeSymbol* t);
  Symbol* gensym_i(symbol_class c, const char* p, index_type i, TypeSymbol* t);
  Symbol* gensym_s(symbol_class c, const char* p, const Symbol* s, TypeSymbol* t);
  Symbol* gensym_n(symbol_class c, const char* p, const Name* n, TypeSymbol* t);
  void new_variable_substitution(Atom* a,
     symbol_pair_vec& u,
     symbol_pair_vec& new_u);
  Atom* new_meta_atom(PredicateSymbol* p);
  CAtom* new_CAtom(Atom* a, symbol_pair_vec& u);
  CAtom* new_CAtom(Atom* a, symbol_pair_vec& n, symbol_pair_vec& u);
  void extend_cc(CAtom* l, catom_vec& m, catom_vec& nm,
   lvector< swapable_pair<catom_vec> >& x,
   index_type d);
  void find_cc();
  void post_process();
  void instantiate(Instance& ins);
  void instantiate_soft(SoftInstance& ins);
  void instantiate_atom_set(Instance& ins, atom_vec& a, index_set& s);
  index_type n_plans() const { return input_plans.length(); };
  bool export_plan(index_type i, Instance& ins, const index_vec& map, Plan& p);
  bool export_plan(index_type i, Instance& ins, Plan& p);
  void export_heuristic(Instance& ins,
   const index_vec& map,
   bool opt_maximize,
   Heuristic& h);
  void export_sets(const name_vec& names, index_set_vec& sets);
  void export_action_partitions(name_vec& names, index_set_vec& sets);
  void lift_DKEL_Items(const Instance& ins);
  PredicateSymbol* find_type_predicate(Symbol* type_sym);
  void untype();
  void compile_preferences();
  void compile_constraints_1();
  void compile_constraints_2();
  void select_preferences(const bool_vec& sel);
  void metric_to_goal(hsps::rational bound);
  void compile_set_conditions_and_effects();
  void compile_object_functions();
  Expression* replace_violations_1(Expression* exp,
       CPG* cpg[],
       FunctionSymbol* f_violated[]);
  Goal* compile_constraint_1(Goal* g, index_type i, const Symbol* n,
        symbol_vec& aut_states, index_type n_ra);
  AtomicGoal* make_automaton_type_a(CPG& f, index_type i, const Symbol* n,
        symbol_vec& aut_state, index_type n_ra);
  AtomicGoal* make_automaton_type_e(CPG& f, index_type i, const Symbol* n,
        symbol_vec& aut_state, index_type n_ra);
  AtomicGoal* make_automaton_type_o(CPG& f, index_type i, const Symbol* n,
        symbol_vec& aut_state, index_type n_ra);
  AtomicGoal* make_automaton_type_sb(CPG& f, CPG& g,
         index_type i, const Symbol* n,
         symbol_vec& aut_state, index_type n_ra);
  AtomicGoal* make_automaton_type_sa(CPG& f, CPG& g,
         index_type i, const Symbol* n,
         symbol_vec& aut_state, index_type n_ra);
  void make_automaton_transition(Symbol* s_from,
     Symbol* s_to,
     bool is_accept,
     CPG* f, bool neg_f,
     CPG* g, bool neg_g,
     PredicateSymbol* p_state,
     PredicateSymbol* p_accept,
     PredicateSymbol* p_synch);
  void add_precondition_formula(ActionSymbol* a, CPG* f, bool is_neg);
  Goal* compile_constraint_2(Goal* g, const Symbol* n);
  Goal* compile_always_constraint(SimpleSequenceGoal* g, const Symbol* n);
  Goal* compile_sometime_constraint(SimpleSequenceGoal* g, const Symbol* n);
  Goal* compile_at_most_once_constraint(SimpleSequenceGoal* g,
     const Symbol* n);
  Goal* compile_sometime_before_constraint(TriggeredSequenceGoal* g,
        const Symbol* n);
  void compile_set_conditions_and_effects(ActionSymbol* act);
  void compile_set_conditions_and_effects(ActionSymbol* act,
       variable_vec& i_param,
       variable_vec& d_param,
       index_type p);
  Atom* make_binding_atom(VariableSymbol* v);
  void compile_object_functions(ActionSymbol* act, Symbol* undefined_value);
  void compile_object_functions_for_validator(ActionSymbol* act);
  Goal* compile_object_functions(Goal* g);
  void write_declarations(std::ostream& s);
  void write_action(std::ostream& s, ActionSymbol* act);
  void write_set_precondition(std::ostream& s, SetOf* set);
  void write_disjunctive_set_precondition(std::ostream& s, SetOf* set);
  void write_set_effect(std::ostream& s, SetOf* set);
  void write_QCN_effect(std::ostream& s, const char* effect_type, QCNumericEffect* qcn);
  void write_objects(std::ostream& s, bool defined_in_problem);
  void write_init(std::ostream& s);
  void write_goal(std::ostream& s);
  void write_metric(std::ostream& s);
  void write_dkel_items(std::ostream& s, bool defined_in_problem);
  void write_domain_begin(std::ostream& s);
  void write_problem_begin(std::ostream& s);
  void write_end(std::ostream& s);
  void write_dkel_domain(std::ostream& s, bool leave_open);
  void write_dkel_problem(std::ostream& s, bool leave_open);
  void write_plans(std::ostream& s);
  void write_heuristic_table(std::ostream& s);
  void write_sets(std::ostream& s);
  void print(std::ostream& s);
};
class InstanceName : public Name {
  char* domain_name;
  char* problem_name;
 public:
  InstanceName(char* d, char* p) : domain_name(d), problem_name(p) { };
  virtual ~InstanceName() { };
  virtual void write(std::ostream& s, unsigned int c) const;
  virtual const Name* cast_to(const char* cname) const;
};
class PDDL_Name : public Name {
 protected:
  bool neg;
  PDDL_Base::Symbol* sym;
  PDDL_Base::symbol_vec arg;
  bool vis;
  bool_vec avis;
 public:
  static char catc;
  static bool obscure_symbol_names;
  PDDL_Name(PDDL_Base::Symbol* s)
    : neg(false), sym(s), arg(0, 0), vis(true), avis(true, 0) { };
  PDDL_Name(PDDL_Base::Symbol* s, bool n)
    : neg(n), sym(s), arg(0, 0), vis(true), avis(true, 0) { };
  PDDL_Name(PDDL_Base::Symbol* s, PDDL_Base::symbol_vec a, bool n)
    : neg(n), sym(s), arg(a), vis(true), avis(true, a.length()) { };
  PDDL_Name(PDDL_Base::Symbol* s, PDDL_Base::variable_vec a, bool n);
  void add(PDDL_Base::Symbol* s);
  void add(PDDL_Base::Symbol* s, bool v);
  PDDL_Base::Symbol* symbol() { return sym; };
  PDDL_Base::symbol_vec& args() { return arg; };
  index_type argc() { return arg.length(); };
  bool is_neg() { return neg; };
  virtual ~PDDL_Name() { };
  virtual void write(std::ostream& s, unsigned int c) const;
  virtual const Name* cast_to(const char* cname) const;
};
class Numbered_PDDL_Name : public PDDL_Name {
  index_type copy;
 public:
  Numbered_PDDL_Name(PDDL_Base::Symbol* sym, index_type c)
    : PDDL_Name(sym), copy(c) { };
  Numbered_PDDL_Name(PDDL_Name* n, index_type c);
  virtual ~Numbered_PDDL_Name() { };
  virtual void write(std::ostream& s, unsigned int c) const;
};
}
#include <stdlib.h>
#include <sstream>
namespace hsps {
bool PDDL_Base::use_default_function_value = true;
hsps::rational PDDL_Base::default_function_value(0);
bool PDDL_Base::use_strict_borrow_definition = false;
bool PDDL_Base::use_extended_borrow_definition = false;
bool PDDL_Base::del_before_add_semantics = false;
bool PDDL_Base::compact_resource_effects = true;
bool PDDL_Base::compile_away_disjunctive_preconditions = true;
bool PDDL_Base::check_precondition_consistency = true;
bool PDDL_Base::compile_away_conditional_effects = true;
bool PDDL_Base::compile_away_plan_constraints = true;
bool PDDL_Base::compile_away_object_functions = true;
bool PDDL_Base::compile_for_validator = false;
bool PDDL_Base::create_all_atoms = false;
bool PDDL_Base::create_all_actions = false;
bool PDDL_Base::number_multiple_action_instances = false;
bool PDDL_Base::exclude_all_dkel_items = false;
string_set PDDL_Base::excluded_dkel_tags;
string_set PDDL_Base::required_dkel_tags;
bool PDDL_Base::strict_set_export = true;
bool PDDL_Base::write_PDDL31 = true;
bool PDDL_Base::best_effort = true;
bool PDDL_Base::write_warnings = true;
bool PDDL_Base::write_info = false;
bool PDDL_Base::write_trace = false;
bool PDDL_Base::name_instance_by_problem_file = false;
const char* PDDL_Base::instance_name_prefix = 0;
bool PDDL_Base::trace_print_context = false;
bool PDDL_Base::AtomBase::print_bindings = false;
bool PDDL_Base::Expression::print_nary = false;
PDDL_Base::PredicateSymbol* PDDL_Base::current_eq_predicate = 0;
char* PDDL_Base::problem_file_basename()
{
  if (problem_file) {
    char* p0 = strdup(problem_file);
    char* p1 = strrchr(p0, '/');
    char* p2 = strrchr(p0, '.');
    if ((p1 != 0) && (p2 != 0) && (p1 < p2)) {
      *p2 = '\0';
    }
    else if ((p1 == 0) && (p2 != 0)) {
      *p2 = '\0';
    }
    if (p1)
      return p1 + 1;
    else
      return p0;
  }
  else {
    return 0;
  }
}
char* PDDL_Base::enum_problem_filename(const char* s, index_type i)
{
  std::ostringstream fname;
  char* b = problem_file_basename();
  if (b) {
    fname << b << "-" << s << i << ".pddl";
  }
  else {
    fname << s << i << ".pddl";
  }
  return strdup(fname.str().c_str());
}
index_type PDDL_Base::TypeSet::n_elements() const
{
  index_type n = 0;
  for (index_type k = 0; k < length(); k++)
    n += (*this)[k]->elements.length();
  return n;
}
PDDL_Base::Symbol* PDDL_Base::TypeSet::get_element
(index_type n)
{
  index_type k = 0;
  while (k < length()) {
    if (n < (*this)[k]->elements.length())
      return (*this)[k]->elements[n];
    n -= (*this)[k]->elements.length();
    k += 1;
  }
  std::cerr << "error: index out of range in get_element ";
  print(std::cerr);
  exit(255);
}
bool PDDL_Base::TypeSet::is_object() const
{
  for (index_type k = 0; k < length(); k++)
    if ((*this)[k]->is_object()) return true;
  return false;
}
bool PDDL_Base::TypeSet::subtype_or_equal(const TypeSet& s) const
{
  if (s.length() == 0) return true;
  if (length() == 0) {
    for (index_type l = 0; l < s.length(); l++)
      if (s[l]->is_object()) return true;
    return false;
  }
  else {
    for (index_type k = 0; k < length(); k++) {
      bool ok = false;
      for (index_type l = 0; (l < s.length()) && !ok; l++)
 if ((*this)[k]->subtype_or_equal(s[l]))
   ok = true;
      if (!ok) return false;
    }
    return true;
  }
}
bool PDDL_Base::TypeSet::subtype_or_equal(TypeSymbol* t) const
{
  if (length() == 0) {
    if (t->is_object()) return true;
    return false;
  }
  else {
    for (index_type k = 0; k < length(); k++) {
      if (!(*this)[k]->subtype_or_equal(t))
 return false;
    }
    return true;
  }
}
void PDDL_Base::TypeSet::print(std::ostream& s) const
{
  if (length() > 1) {
    s << "(either";
    for (index_type k = 0; k < length(); k++) {
      s << " ";
      (*this)[k]->print(s);
    }
    s << ")";
  }
  else if (length() == 1) {
    (*this)[0]->print(s);
  }
}
void PDDL_Base::TypeSet::write_type(std::ostream& s) const
{
  if (length() > 1) {
    s << " - (either";
    for (index_type k = 0; k < length(); k++) {
      s << " " << (*this)[k]->print_name;
    }
    s << ")";
  }
  else if (length() == 1) {
    s << " - " << (*this)[0]->print_name;
  }
  else {
    s << " - object";
  }
}
PDDL_Base::TypeSymbol* PDDL_Base::find_type(const char* name)
{
  for (index_type k = 0; k < dom_types.length(); k++)
    if (tab.table_char_map().strcmp(dom_types[k]->print_name, name) == 0)
      return dom_types[k];
  return 0;
}
PDDL_Base::PredicateSymbol* PDDL_Base::find_predicate(const char* name)
{
  for (index_type k = 0; k < dom_predicates.length(); k++)
    if (tab.table_char_map().strcmp(dom_predicates[k]->print_name, name) == 0)
      return dom_predicates[k];
  return 0;
}
PDDL_Base::FunctionSymbol* PDDL_Base::find_function(const char* name)
{
  for (index_type k = 0; k < dom_functions.length(); k++)
    if (tab.table_char_map().strcmp(dom_functions[k]->print_name, name) == 0)
      return dom_functions[k];
  return 0;
}
bool PDDL_Base::find_initial_fact(const char* pname, const symbol_vec& arg)
{
  PredicateSymbol* pred = find_predicate(pname);
  if (pred == 0) {
    std::cerr << "error: can't check static fact " << pname << arg
       << " - no such predicate" << std::endl;
    exit(255);
  }
  ptr_table* r = &(pred->init);
  for (index_type k = 0; (k < arg.length()) && r; k++) {
    if (arg[k]->sym_class == sym_variable) {
      if (((VariableSymbol*)arg[k])->value == 0) {
 std::cerr << "error: can't evaluate " << pname << arg
    << " - " << arg[k]->print_name << " not set"
    << std::endl;
 exit(255);
      }
      r = r->find_next(((VariableSymbol*)arg[k])->value);
    }
    else {
      r = r->find_next(arg[k]);
    }
  }
  if (r) {
    if (r->val) return true;
  }
  return false;
}
hsps::rational PDDL_Base::find_function_value(const char* fname, const symbol_vec& arg)
{
  FunctionSymbol* fun = find_function(fname);
  if (fun == 0) {
    std::cerr << "error: can't eval static exp " << fname << arg
       << " - no such function" << std::endl;
    exit(255);
  }
  if (!fun->is_static()) {
    std::cerr << "error: can't eval static exp " << fname << arg
       << " - function not static" << std::endl;
    exit(255);
  }
  ptr_table* r = &(fun->init);
  for (index_type k = 0; (k < arg.length()) && r; k++) {
    if (arg[k]->sym_class == sym_variable) {
      if (((VariableSymbol*)arg[k])->value == 0) {
 std::cerr << "error: can't evaluate " << fname << arg
    << " - " << arg[k]->print_name << " not set"
    << std::endl;
 exit(255);
      }
      r = r->find_next(((VariableSymbol*)arg[k])->value);
    }
    else {
      r = r->find_next(arg[k]);
    }
  }
  if (r) {
    if (r->val) {
      return ((FInitAtom*)r->val)->val;
    }
  }
  if (use_default_function_value) {
    return default_function_value;
  }
  else {
    std::cerr << "error: " << fname << arg << " has no value" << std::endl;
    exit(255);
  }
}
index_type PDDL_Base::find_element_satisfying
(const symbol_vec& elements,
 const char* pname,
 symbol_vec& arg,
 index_type element_arg_p)
{
  for (index_type k = 0; k < elements.length(); k++) {
    arg[element_arg_p] = elements[k];
    if (find_initial_fact(pname, arg))
      return k;
  }
  return no_such_index;
}
void PDDL_Base::find_elements_satisfying
(const symbol_vec& elements,
 const char* pname,
 symbol_vec& arg,
 index_type element_arg_p,
 index_set& sats)
{
  sats.clear();
  for (index_type k = 0; k < elements.length(); k++) {
    arg[element_arg_p] = elements[k];
    if (find_initial_fact(pname, arg))
      sats.insert(k);
  }
}
PDDL_Base::Atom* PDDL_Base::goal_to_atom(Goal* g)
{
  if ((g->g_class == goal_pos_atom) || (g->g_class == goal_neg_atom))
    return ((AtomicGoal*)g)->atom;
  else
    return 0;
}
bool PDDL_Base::goal_to_atom_vec(Goal* g, atom_vec& av)
{
  av.clear();
  if ((g->g_class == goal_pos_atom) || (g->g_class == goal_neg_atom)) {
    av.append(((AtomicGoal*)g)->atom);
    return true;
  }
  else if (g->g_class == goal_conjunction) {
    ConjunctiveGoal* cg = (ConjunctiveGoal*)g;
    for (index_type k = 0; k < cg->goals.length(); k++) {
      Atom* g_k = goal_to_atom(cg->goals[k]);
      if (g_k == 0) return false;
      av.append(g_k);
    }
    return true;
  }
  else {
    return false;
  }
}
PDDL_Base::ActionSymbol* PDDL_Base::src_action_symbol(ptr_pair* p)
{
  PDDL_Base::ActionSymbol* act = (PDDL_Base::ActionSymbol*)p->first;
  ptr_table* ins = (ptr_table*)p->second;
  ptr_table::key_vec* args = ins->key_sequence();
  for (index_type k = 0; k < act->param.length(); k++)
    act->param[k]->value = (PDDL_Base::Symbol*)((*args)[k + 1]);
  delete args;
  return act;
}
PDDL_Base::PDDL_Base(StringTable& t)
  : domain_name(0),
    problem_name(0),
    domain_file(0),
    problem_file(0),
    ready_to_instantiate(false),
    tab(t),
    dom_types(0, 0),
    dom_top_type(0),
    dom_constants(0, 0),
    dom_predicates(0, 0),
    dom_object_functions(0, 0),
    dom_functions(0, 0),
    dom_actions(0, 0),
    dom_sc_invariants(0, 0),
    dom_f_invariants(0, 0),
    dom_irrelevant(0, 0),
    dom_init(0, 0),
    dom_fun_init(0, 0),
    dom_obj_init(0, 0),
    dom_goals(0, 0),
    dom_preferences(0, 0),
    goal_tasks(0, 0),
    metric_type(metric_none),
    metric(0),
    serial_length(POS_INF),
    parallel_length(POS_INF),
    input_plans(0, 0),
    h_table(0, 0),
    input_sets(0, 0),
    partitions(0, 0)
{
  StringTable::Cell* sc = tab.inserta("object");
  dom_top_type = new TypeSymbol(sc->text);
  sc->val = dom_top_type;
  sc = tab.inserta("=");
  dom_eq_pred = new PredicateSymbol(sc->text);
  dom_eq_pred->param.append(new VariableSymbol("?x"));
  dom_eq_pred->param.append(new VariableSymbol("?y"));
  sc = tab.inserta("assign");
  dom_assign_pred = new PredicateSymbol(sc->text);
  dom_assign_pred->param.append(new VariableSymbol("?x"));
  dom_assign_pred->param.append(new VariableSymbol("?y"));
  sc->val = dom_assign_pred;
  sc = tab.inserta("undefined");
  dom_undefined_obj = new Symbol(sc->text);
  sc->val = dom_undefined_obj;
}
PDDL_Base::~PDDL_Base()
{
}
void PDDL_Base::set_variable_type(variable_vec& vec, TypeSymbol* t)
{
  for (index_type k = vec.length(); k > 0; k--) {
    if (vec[k - 1]->sym_types.length() > 0) return;
    vec[k - 1]->sym_types.append(t);
    if (trace_print_context) {
      std::cerr << "set type of " << k - 1 << "th variable ";
      vec[k - 1]->print(std::cerr);
      std::cerr << " to ";
      t->print(std::cerr);
      std::cerr << std::endl;
    }
  }
}
void PDDL_Base::set_variable_type(variable_vec& vec, const TypeSet& t)
{
  for (index_type k = vec.length(); k > 0; k--) {
    if (vec[k - 1]->sym_types.length() > 0) return;
    vec[k - 1]->sym_types.assign_copy(t);
    if (trace_print_context) {
      std::cerr << "set type of " << k - 1 << "th variable ";
      vec[k - 1]->print(std::cerr);
      std::cerr << " to ";
      t.print(std::cerr);
      std::cerr << std::endl;
    }
  }
}
void PDDL_Base::set_type_type(type_vec& vec, TypeSymbol* t)
{
  for (index_type k = vec.length(); k > 0; k--) {
    if (vec[k - 1]->sym_types.length() > 0) return;
    vec[k - 1]->sym_types.append(t);
  }
}
void PDDL_Base::set_constant_type(symbol_vec& vec, TypeSymbol* t)
{
  for (index_type k = vec.length(); k > 0; k--) {
    if (vec[k - 1]->sym_types.length() > 0) return;
    vec[k - 1]->sym_types.append(t);
    t->add_element(vec[k - 1]);
  }
}
void PDDL_Base::clear_context(variable_vec& vec)
{
  for (index_type k = 0; k < vec.length(); k++) {
    tab.set(vec[k]->print_name, (void*)0);
    if (trace_print_context) {
      std::cerr << k << "th variable ";
      vec[k]->print(std::cerr);
      std::cerr << " cleared from context"
  << std::endl;
    }
  }
}
void PDDL_Base::clear_context
(variable_vec& vec, index_type n_min, index_type n_max)
{
  assert((n_min <= n_max) && n_max <= vec.length());
  for (index_type k = n_min; k < n_max; k++) {
    tab.set(vec[k]->print_name, (void*)0);
    if (trace_print_context) {
      std::cerr << k << "th variable ";
      vec[k]->print(std::cerr);
      std::cerr << " cleared from context"
  << std::endl;
    }
  }
}
bool PDDL_Base::merge_type_vectors
(type_vec& v0, type_vec& v1)
{
  if (v0.length() != v1.length()) return false;
  bool_vec set(false, v0.length());
  for (index_type k = 0; k < v0.length(); k++) {
    if (v1[k]->subtype_or_equal(v0[k])) {
      set[k] = false;
    }
    else if (v0[k]->subtype_or_equal(v1[k])) {
      set[k] = true;
    }
    else {
      return false;
    }
  }
  for (index_type k = 0; k < v0.length(); k++)
    if (set[k]) v0[k] = v1[k];
  return true;
}
void PDDL_Base::make_parameters
(type_vec& t, const char* prefix, variable_vec& v)
{
  v.set_length(t.length());
  for (index_type k = 0; k < t.length(); k++) {
    EnumName v_name(prefix, k);
    v[k] = new VariableSymbol(v_name.to_cstring(Name::NC_INSTANCE));
    v[k]->sym_types.assign_value(t[k], 1);
  }
}
PDDL_Base::Symbol* PDDL_Base::gensym
(symbol_class c, const char* p, const TypeSet& t)
{
  StringTable::Cell* sc = tab.inserta(p);
  index_type i = 0;
  while (sc->val) {
    std::ostringstream s;
    s << p << i++;
    sc = tab.inserta(s.str().c_str());
  }
  Symbol* s = 0;
  switch (c) {
  case sym_action:
    s = new ActionSymbol(sc->text);
    break;
  case sym_predicate:
    s = new PredicateSymbol(sc->text);
    break;
  case sym_variable:
    s = new VariableSymbol(sc->text);
    break;
  case sym_typename:
    s = new TypeSymbol(sc->text);
    break;
  default:
    s = new Symbol(c, sc->text);
  }
  sc->val = s;
  s->sym_types = t;
  return s;
}
PDDL_Base::Symbol* PDDL_Base::gensym
(symbol_class c, const char* p, TypeSymbol* t)
{
  assert(t != 0);
  TypeSet v(t);
  return gensym(c, p, v);
}
PDDL_Base::Symbol* PDDL_Base::gensym_i
(symbol_class c, const char* p, index_type i, TypeSymbol* t)
{
  std::ostringstream s;
  s << p << i;
  return gensym(c, s.str().c_str(), t);
}
PDDL_Base::Symbol* PDDL_Base::gensym_n
(symbol_class c, const char* p, const Name* n, TypeSymbol* t)
{
  std::ostringstream s;
  s << p << n;
  return gensym(c, s.str().c_str(), t);
}
PDDL_Base::Symbol* PDDL_Base::gensym_s
(symbol_class c, const char* p, const Symbol* s, TypeSymbol* t)
{
  std::ostringstream ss;
  ss << p << s->print_name;
  return gensym(c, ss.str().c_str(), t);
}
PDDL_Base::Atom* PDDL_Base::new_meta_atom(PredicateSymbol* p)
{
  Atom* a = new Atom(p);
  a->param.set_length(p->param.length());
  for (index_type k = 0; k < p->param.length(); k++) {
    a->param[k] = gensym(sym_meta_variable, "V", p->param[k]->sym_types);
  }
  return a;
}
void PDDL_Base::new_variable_substitution
(Atom* a, symbol_pair_vec& u, symbol_pair_vec& new_u)
{
  for (index_type k = 0; k < u.length(); k++) {
    if (u[k].second->sym_class == sym_variable) {
      new_u.append(symbol_pair(u[k].first,
          gensym(sym_variable,
          u[k].second->print_name,
          u[k].second->sym_types)));
    }
    else {
      new_u.append(u[k]);
    }
  }
  for (index_type k = 0; k < a->param.length(); k++)
    if (a->param[k]->sym_class == sym_variable) {
      bool found = false;
      for (index_type i = 0; (i < new_u.length()) && !found; i++)
 if (new_u[i].first == a->param[k]) found = true;
      if (!found) {
 new_u.append(symbol_pair(a->param[k],
     gensym(sym_variable,
     a->param[k]->print_name,
     a->param[k]->sym_types)));
      }
    }
}
PDDL_Base::CAtom* PDDL_Base::new_CAtom
(Atom* a, symbol_pair_vec& u)
{
  symbol_pair_vec new_u;
  new_variable_substitution(a, u, new_u);
  return new CAtom(a, new_u);
}
PDDL_Base::CAtom* PDDL_Base::new_CAtom
(Atom* a, symbol_pair_vec& n, symbol_pair_vec& u)
{
  symbol_pair_vec new_u;
  new_variable_substitution(a, u, new_u);
  return new CAtom(a, n, new_u);
}
PDDL_Base::CAtom::CAtom(const Atom* a, symbol_pair_vec& u)
  : Atom(a->pred), neq(0, 0)
{
  param.set_length(a->param.length());
  for (index_type k = 0; k < a->param.length(); k++) {
    bool found = false;
    for (index_type i = 0; (i < u.length()) && !found; i++)
      if (a->param[k] == u[i].first) {
 param[k] = u[i].second;
 found = true;
      }
    if (!found) {
      param[k] = a->param[k];
    }
  }
}
PDDL_Base::CAtom::CAtom(const Atom* a, symbol_pair_vec& n, symbol_pair_vec& u)
  : Atom(a->pred), neq(0, 0)
{
  param.set_length(a->param.length());
  for (index_type k = 0; k < a->param.length(); k++) {
    bool found = false;
    for (index_type i = 0; (i < u.length()) && !found; i++)
      if (a->param[k] == u[i].first) {
 param[k] = u[i].second;
 found = true;
      }
    if (!found) {
      param[k] = a->param[k];
    }
  }
  for (index_type k = 0; k < n.length(); k++) {
    Symbol* s1 = 0;
    Symbol* s2 = 0;
    for (index_type i = 0; i < u.length(); i++) {
      if ((s1 == 0) && (u[i].first == n[k].first)) s1 = u[i].second;
      if ((s2 == 0) && (u[i].first == n[k].second)) s2 = u[i].second;
    }
    if (s1 == 0) s1 = n[k].first;
    if (s2 == 0) s2 = n[k].second;
    neq.append(symbol_pair(s1, s2));
  }
}
void PDDL_Base::extend_cc
(CAtom* lit,
 catom_vec& m,
 catom_vec& nm,
 lvector< swapable_pair<catom_vec> >& q,
 index_type d)
{
  symbol_pair_vec u;
  if (write_info) {
    std::cerr << "[" << d << "] extend_cc: lit = ";
    lit->print(std::cerr);
    std::cerr << ", m = {";
    for (index_type k = 0; k < m.length(); k++) {
      if (k > 0) std::cerr << ", ";
      m[k]->print(std::cerr);
    }
    std::cerr << "}, nm = {";
    for (index_type k = 0; k < nm.length(); k++) {
      if (k > 0) std::cerr << ", ";
      nm[k]->print(std::cerr);
    }
    std::cerr << "}, |q| = " << q.length()
       << std::endl;
  }
  for (index_type k = 0; k < nm.length(); k++) {
    if (lit->unify(nm[k], u)) {
      if (write_info) {
 std::cerr << "[" << d << "] cut (1) due to ";
 nm[k]->print(std::cerr);
 std::cerr << ", ";
 print_substitution(std::cerr, u);
 std::cerr << std::endl;
      }
      return;
    }
  }
  bool lit_subsumed = false;
  for (index_type k = 0; (k < m.length()) && !lit_subsumed; k++)
    if (lit->instance_of(m[k], u)) {
      if (write_info) {
 std::cerr << "[" << d << "] ";
 lit->print(std::cerr);
 std::cerr << " subsumed by ";
 m[k]->print(std::cerr);
 std::cerr << ", ";
 print_substitution(std::cerr, u);
 std::cerr << std::endl;
      }
      lit_subsumed = true;
    }
  index_type reset_m_to = m.length();
  index_type reset_q_to = q.length();
  if (!lit_subsumed) {
    symbol_pair_vec actneq;
    for (index_type k = 0; k < dom_actions.length(); k++) {
      dom_actions[k]->get_param_inequalities(actneq);
      for (index_type i = 0; i < dom_actions[k]->adds.length(); i++) {
 if (lit->instance_of(dom_actions[k]->adds[i], actneq, u)) {
   if (write_info) {
     std::cerr << "[" << d << "] match with ";
     dom_actions[k]->adds[i]->print(std::cerr);
     std::cerr << " of " << dom_actions[k]->print_name << ", ";
     print_inequality(std::cerr, actneq);
     std::cerr << ", ";
     print_substitution(std::cerr, u);
     std::cerr << std::endl;
   }
   swapable_pair<catom_vec> e;
   for (index_type j = 0; j < dom_actions[k]->cons.length(); j++) {
     CAtom* xa = new_CAtom(dom_actions[k]->cons[j], actneq, u);
     e.first.append(xa);
   }
   for (index_type j = 0; j < dom_actions[k]->adds.length(); j++) if (j != i) {
     CAtom* nxa = new_CAtom(dom_actions[k]->adds[j], actneq, u);
     e.second.append(nxa);
   }
   q.append(e);
 }
      }
    }
    m.append(lit);
  }
  if (q.length() == 0) {
    if (write_info) {
      std::cerr << "info: found invariant {";
      for (index_type k = 0; k < m.length(); k++) {
 if (k > 0) std::cerr << ", ";
 m[k]->print(std::cerr);
      }
      std::cerr << "}" << std::endl;
    }
    graph lsg(m.length());
    for (index_type i = 0; i < m.length(); i++)
      for (index_type j = 0; j < m.length(); j++) if (i != j) {
 if (m[i]->instance_of(m[j], u))
   lsg.add_edge(j, i);
      }
    graph lsg_tree;
    lsg.strongly_connected_components();
    lsg.component_tree(lsg_tree);
    catom_vec mprime(0, 0);
    for (index_type k = 0; k < lsg_tree.size(); k++)
      if (lsg_tree.in_degree(k) == 0) {
 index_type i = lsg.component_node(k);
 mprime.append(m[i]);
      }
    bool is_exclusive = true;
    for (index_type i = 0; (i < mprime.length()) && is_exclusive; i++)
      for (index_type j = i + 1; (j < mprime.length()) && is_exclusive; j++)
 if (mprime[i]->unify(mprime[j], u))
   is_exclusive = false;
    if (write_info) {
      std::cerr << "info: invariant reduced to {";
      for (index_type k = 0; k < mprime.length(); k++) {
 if (k > 0) std::cerr << ", ";
 mprime[k]->print(std::cerr);
      }
      std::cerr << "}" << std::endl;
    }
    symbol_set meta_vars;
    for (index_type k = 0; k < mprime.length(); k++)
      for (index_type p = 0; p < mprime[k]->param.length(); p++)
 if (mprime[k]->param[p]->sym_class == sym_meta_variable)
   meta_vars.insert(mprime[k]->param[p]);
    SetConstraint* c = new SetConstraint();
    for (index_type k = 0; k < meta_vars.length(); k++)
      c->param.append((VariableSymbol*)gensym(sym_variable, "?v", meta_vars[k]->sym_types));
    for (index_type k = 0; k < mprime.length(); k++) {
      bool is_set = false;
      for (index_type i = 0; i < mprime[k]->param.length(); i++)
 if (mprime[k]->param[i]->sym_class == sym_variable)
   is_set = true;
      if (is_set) {
 SetOf* s = new SetOf();
 s->pos_atoms.append(new Atom(mprime[k]->pred));
 for (index_type i = 0; i < mprime[k]->param.length(); i++) {
   if (mprime[k]->param[i]->sym_class == sym_meta_variable) {
     index_type j = meta_vars.first(mprime[k]->param[i]);
     assert(j < c->param.length());
     s->pos_atoms[0]->param.append(c->param[j]);
   }
   else {
     if (mprime[k]->param[i]->sym_class == sym_variable) {
       s->param.append((VariableSymbol*)mprime[k]->param[i]);
     }
     s->pos_atoms[0]->param.append(mprime[k]->param[i]);
   }
 }
 for (index_type i = 0; i < mprime[k]->neq.length(); i++) {
   if ((mprime[k]->neq[i].first->sym_class == sym_variable) ||
       (mprime[k]->neq[i].second->sym_class == sym_variable)) {
     if (mprime[k]->neq[i].first->sym_class == sym_meta_variable) {
       index_type j1 = meta_vars.first(mprime[k]->neq[i].first);
       index_type j2 = s->param.first((VariableSymbol*)mprime[k]->neq[i].second);
       if ((j1 < c->param.length()) && (j2 != no_such_index)) {
  Atom* q = new Atom(dom_eq_pred);
  q->param.append(c->param[j1]);
  q->param.append(mprime[k]->neq[i].second);
  s->neg_con.append(q);
       }
     }
     else if (mprime[k]->neq[i].second->sym_class == sym_meta_variable) {
       index_type j1 = s->param.first((VariableSymbol*)mprime[k]->neq[i].first);
       index_type j2 = meta_vars.first(mprime[k]->neq[i].second);
       if ((j1 != no_such_index) && (j2 < c->param.length())) {
  Atom* q = new Atom(dom_eq_pred);
  q->param.append(mprime[k]->neq[i].first);
  q->param.append(c->param[j2]);
  s->neg_con.append(q);
       }
     }
     else {
       index_type j1 = s->param.first((VariableSymbol*)mprime[k]->neq[i].first);
       index_type j2 = s->param.first((VariableSymbol*)mprime[k]->neq[i].second);
       if (((j1 != no_such_index) ||
     (mprime[k]->neq[i].first->sym_class == sym_object)) &&
    ((j2 != no_such_index) ||
     (mprime[k]->neq[i].second->sym_class == sym_object))) {
  Atom* q = new Atom(dom_eq_pred);
  q->param.append(mprime[k]->neq[i].first);
  q->param.append(mprime[k]->neq[i].second);
  s->neg_con.append(q);
       }
     }
   }
 }
 c->atom_sets.append(s);
      }
      else {
 Atom* a = new Atom(mprime[k]->pred);
 for (index_type i = 0; i < mprime[k]->param.length(); i++) {
   if (mprime[k]->param[i]->sym_class == sym_meta_variable) {
     index_type j = meta_vars.first(mprime[k]->param[i]);
     assert(j < c->param.length());
     a->param.append(c->param[j]);
   }
   else {
     assert(mprime[k]->param[i]->sym_class == sym_object);
     a->param.append(mprime[k]->param[i]);
   }
 }
 c->pos_atoms.append(a);
 for (index_type i = 0; i < mprime[k]->neq.length(); i++) {
   index_type j1 = meta_vars.first(mprime[k]->neq[i].first);
   index_type j2 = meta_vars.first(mprime[k]->neq[i].second);
   if ((j1 < c->param.length()) && (j2 < c->param.length())) {
     Atom* q = new Atom(dom_eq_pred);
     q->param.append(c->param[j1]);
     q->param.append(c->param[j2]);
     c->neg_con.append(q);
   }
 }
      }
    }
    c->sc_type = sc_at_most;
    c->sc_count = 1;
    c->item_tags.append((char*)"c-constraint");
    if (is_exclusive) {
      c->item_tags.append((char*)"is-exclusive");
    }
    if ((c->atom_sets.length() > 0) || (c->pos_atoms.length() > 1)) {
      dom_sc_invariants.append(c);
    }
    else if (write_info) {
      std::cerr << "info: useless invariant {";
      for (index_type k = 0; k < mprime.length(); k++) {
 if (k > 0) std::cerr << ", ";
 mprime[k]->print(std::cerr);
      }
      std::cerr << "} ignored" << std::endl;
    }
    m.set_length(reset_m_to);
    q.set_length(reset_q_to);
    return;
  }
  index_type last = q.length() - 1;
  catom_vec x(q[last].first);
  catom_vec not_x(q[last].second);
  if (write_info) {
    std::cerr << "[" << d << "] next: x = {";
    for (index_type k = 0; k < x.length(); k++) {
      if (k > 0) std::cerr << ", ";
      x[k]->print(std::cerr);
    }
    std::cerr << "}, nx = {";
    for (index_type k = 0; k < not_x.length(); k++) {
      if (k > 0) std::cerr << ", ";
      not_x[k]->print(std::cerr);
    }
    std::cerr << "}" << std::endl;
  }
  for (index_type k = 0; k < not_x.length(); k++)
    for (index_type i = 0; i < m.length(); i++)
      if (not_x[k]->unify(m[i], u)) {
 if (write_info) {
   std::cerr << "[" << d << "] cut (2) due to ";
   not_x[k]->print(std::cerr);
   std::cerr << ", ";
   m[i]->print(std::cerr);
   std::cerr << ", ";
   print_substitution(std::cerr, u);
   std::cerr << std::endl;
 }
 m.set_length(reset_m_to);
 q.set_length(reset_q_to);
 return;
      }
  q.dec_length();
  index_type reset_nm_to = nm.length();
  nm.append(not_x);
  index_type local_reset_nm_to = nm.length();
  for (index_type k = 0; k < x.length(); k++) {
    bool ok = true;
    for (index_type i = 0; (i < x.length()) && ok; i++) if (i != k) {
      for (index_type j = 0; (j < m.length()) && ok; j++)
 if (x[i]->unify(m[j], u)) ok = false;
      if (ok) nm.append(x[i]);
    }
    if (ok) {
      extend_cc(x[k], m, nm, q, d + 1);
    }
    nm.set_length(local_reset_nm_to);
  }
  m.set_length(reset_m_to);
  nm.set_length(reset_nm_to);
  q.append(swapable_pair<catom_vec>(x, not_x));
  q.set_length(reset_q_to);
  if (write_info) {
    std::cerr << "[" << d << "] finished" << std::endl;
  }
}
void PDDL_Base::find_cc()
{
  catom_vec m(0, 0);
  catom_vec nm(0, 0);
  lvector< swapable_pair<catom_vec> > q;
  for (index_type k = 0; k < dom_predicates.length(); k++) {
    if (!dom_predicates[k]->is_static()) {
      CAtom* lit = new CAtom(new_meta_atom(dom_predicates[k]));
      m.assign_value(0, 0);
      nm.assign_value(0, 0);
      q.set_length(0);
      extend_cc(lit, m, nm, q, 0);
    }
  }
}
void PDDL_Base::TypeSymbol::add_element(Symbol* e)
{
  elements.append(e);
  for (index_type k = 0; k < sym_types.length(); k++)
    sym_types[k]->add_element(e);
}
bool PDDL_Base::TypeSymbol::subtype_or_equal(TypeSymbol* t) const
{
  if (t == 0) return true;
  if (t == this) return true;
  if (sym_types.subtype_or_equal(t))
    return true;
  return false;
}
bool PDDL_Base::TypeSymbol::subtype_or_equal(const TypeSet& t) const
{
  if (t.length() == 0) return true;
  for (index_type k = 0; k < t.length(); k++)
    if (!subtype_or_equal(t[k]))
      return false;
  return true;
}
bool PDDL_Base::VariableSymbol::equality_type_check(Symbol* s)
{
  if ((sym_types.length() > 0) && (s->sym_types.length() > 0)) {
    for (index_type i = 0; i < sym_types.length(); i++) {
      for (index_type j = 0; j < s->sym_types.length(); j++) {
 if (sym_types[i]->subtype_or_equal(s->sym_types[j]))
   return true;
 if (s->sym_types[j]->subtype_or_equal(sym_types[i]))
   return true;
      }
    }
    return false;
  }
  else {
    return true;
  }
}
bool PDDL_Base::Expression::is_static()
{
  switch (exp_class) {
  case exp_fun:
    {
      FunctionSymbol* fun = ((FunctionExpression*)this)->fun;
      return fun->is_static();
    }
  case exp_list:
  case exp_time:
    {
      std::cerr << "error (is_static): expression ";
      print(std::cerr, false);
      std::cerr << " can not be evaluated" << std::endl;
      exit(255);
    }
  case exp_const:
    {
      return true;
    }
  case exp_add:
  case exp_sub:
  case exp_mul:
  case exp_div:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      return (bexp->first->is_static() && bexp->second->is_static());
    }
  case exp_preference:
    return false;
  }
  assert(0);
}
bool PDDL_Base::Expression::is_constant()
{
  switch (exp_class) {
  case exp_fun:
    {
      FunctionSymbol* fun = ((FunctionExpression*)this)->fun;
      return (fun->is_static() && (((FunctionExpression*)this)->args == 0));
    }
  case exp_list:
  case exp_time:
    {
      std::cerr << "error (is_constant): expression ";
      print(std::cerr, false);
      std::cerr << " can not be evaluated" << std::endl;
      exit(255);
    }
  case exp_const:
    {
      return true;
    }
  case exp_add:
  case exp_sub:
  case exp_mul:
  case exp_div:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      return (bexp->first->is_constant() && bexp->second->is_constant());
    }
  case exp_preference:
    return false;
  }
  assert(0);
}
bool PDDL_Base::Expression::is_integral()
{
  switch (exp_class) {
  case exp_fun:
    {
      FunctionSymbol* fun = ((FunctionExpression*)this)->fun;
      return fun->integral;
    }
  case exp_list:
  case exp_time:
    {
      std::cerr << "error (is_integral): expression ";
      print(std::cerr, false);
      std::cerr << " can not be evaluated" << std::endl;
      exit(255);
    }
  case exp_const:
    {
      return (((ConstantExpression*)this)->val).integral();
    }
  case exp_add:
  case exp_sub:
  case exp_mul:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      return (bexp->first->is_integral() && bexp->second->is_integral());
    }
  case exp_div:
    return false;
  case exp_preference:
    return true;
  }
  assert(0);
}
PDDL_Base::Expression* PDDL_Base::Expression::copy()
{
  switch (exp_class) {
  case exp_fun:
    {
      FunctionExpression* f_exp = (FunctionExpression*)this;
      if (f_exp->args) {
 ListExpression* args = (ListExpression*)f_exp->args->copy();
 return new FunctionExpression(f_exp->fun, args);
      }
      else {
 return new FunctionExpression(f_exp->fun, 0);
      }
    }
  case exp_list:
    {
      ListExpression* l_exp = (ListExpression*)this;
      if (l_exp->rest) {
 ListExpression* rest = (ListExpression*)l_exp->rest->copy();
 return new ListExpression(l_exp->sym, rest);
      }
      else {
 return new ListExpression(l_exp->sym, 0);
      }
    }
  case exp_time:
    {
      TimeExpression* t_exp = (TimeExpression*)this;
      if (t_exp->time_exp == 0)
 return new TimeExpression();
      else
 return new TimeExpression(t_exp->time_exp->copy());
    }
  case exp_const:
    {
      ConstantExpression* c_exp = (ConstantExpression*)this;
      return new ConstantExpression(c_exp->val);
    }
  case exp_add:
  case exp_sub:
  case exp_mul:
  case exp_div:
    {
      BinaryExpression* b_exp = (BinaryExpression*)this;
      return new BinaryExpression(exp_class, b_exp->first->copy(),
      b_exp->second->copy());
    }
  case exp_preference:
    {
      PreferenceExpression* p_exp = (PreferenceExpression*)this;
      return new PreferenceExpression(p_exp->name);
    }
  }
  assert(0);
}
void PDDL_Base::Expression::substitute_for_time(Expression* e)
{
  switch (exp_class) {
  case exp_time:
    {
      ((TimeExpression*)this)->time_exp = e;
      break;
    }
  case exp_add:
  case exp_sub:
  case exp_mul:
  case exp_div:
    {
      BinaryExpression* b_exp = (BinaryExpression*)this;
      b_exp->first->substitute_for_time(e);
      b_exp->second->substitute_for_time(e);
    }
  }
}
PDDL_Base::Expression* PDDL_Base::Expression::substitute_for_preference
(Symbol* n, Expression* e)
{
  switch (exp_class) {
  case exp_preference:
    {
      PreferenceExpression* p_exp = (PreferenceExpression*)this;
      if (p_exp->name == n) {
 return e;
      }
      else {
 return this;
      }
    }
  case exp_add:
  case exp_sub:
  case exp_mul:
  case exp_div:
    {
      BinaryExpression* b_exp = (BinaryExpression*)this;
      b_exp->first = b_exp->first->substitute_for_preference(n, e);
      b_exp->second = b_exp->second->substitute_for_preference(n, e);
      return this;
    }
  default:
    return this;
  }
}
hsps::rational PDDL_Base::Expression::eval_static()
{
  switch (exp_class) {
  case exp_fun:
    {
      FunctionSymbol* fun = ((FunctionExpression*)this)->fun;
      if (!fun->is_static()) {
 std::cerr << "error: function " << fun->print_name
    << " is not static" << std::endl;
 exit(255);
      }
      ListExpression* args = ((FunctionExpression*)this)->args;
      ptr_table* r = &(fun->init);
      while (args && r) {
 if (args->sym->sym_class == sym_variable) {
   if (((VariableSymbol*)args->sym)->value == 0) {
     std::cerr << "error: unbound variable "
        << args->sym->print_name << " in ";
     print(std::cerr, true);
     std::cerr << " - uncompiled object function?"
        << std::endl;
     exit(255);
   }
   r = r->find_next(((VariableSymbol*)args->sym)->value);
 }
 else {
   r = r->find_next(args->sym);
 }
 if (!r) {
   if (use_default_function_value) {
     return default_function_value;
   }
   else {
     std::cerr << "error: ";
     print(std::cerr, true);
     std::cerr << " is undefined" << std::endl;
     exit(255);
   }
 }
 args = args->rest;
      }
      if (!r->val) {
 if (use_default_function_value) {
   return default_function_value;
 }
 else {
   std::cerr << "error: ";
   this->print(std::cerr, true);
   std::cerr << " has no value (2)" << std::endl;
   exit(255);
 }
      }
      return ((FInitAtom*)r->val)->val;
    }
  case exp_list:
    {
      std::cerr << "error: expression ";
      print(std::cerr, false);
      std::cerr << " can not be evaluated" << std::endl;
      exit(255);
    }
  case exp_time:
    {
      TimeExpression* texp = (TimeExpression*)this;
      if (texp->time_exp == 0) {
 std::cerr << "error (eval_static): expression ";
 print(std::cerr, false);
 std::cerr << " can not be evaluated" << std::endl;
 exit(255);
      }
      return texp->time_exp->eval_static();
    }
  case exp_const:
    {
      ConstantExpression* cexp = (ConstantExpression*)this;
      return cexp->val;
    }
  case exp_add:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1 = bexp->first->eval_static();
      hsps::rational v2 = bexp->second->eval_static();
      return v1 + v2;
    }
  case exp_sub:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1 = bexp->first->eval_static();
      hsps::rational v2 = bexp->second->eval_static();
      return v1 - v2;
    }
  case exp_mul:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1 = bexp->first->eval_static();
      hsps::rational v2 = bexp->second->eval_static();
      return v1 * v2;
    }
  case exp_div:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1 = bexp->first->eval_static();
      hsps::rational v2 = bexp->second->eval_static();
      return v1 / v2;
    }
  case exp_preference:
    {
      return 0;
    }
  }
  assert(0);
}
bool PDDL_Base::Expression::eval_partial(hsps::rational& val)
{
  switch (exp_class) {
  case exp_fun:
    {
      FunctionSymbol* fun = ((FunctionExpression*)this)->fun;
      if (!fun->is_static()) {
 return false;
      }
      ListExpression* args = ((FunctionExpression*)this)->args;
      ptr_table* r = &(fun->init);
      while (args && r) {
 if (args->sym->sym_class == sym_variable) {
   if (((VariableSymbol*)args->sym)->value == 0) {
     std::cerr << "error: unbound variable "
        << args->sym->print_name << " in ";
     print(std::cerr, true);
     std::cerr << " - uncompiled object function?"
        << std::endl;
     exit(255);
   }
   r = r->find_next(((VariableSymbol*)args->sym)->value);
 }
 else {
   r = r->find_next(args->sym);
 }
 if (!r) {
   return false;
 }
 args = args->rest;
      }
      if (!r->val) {
 return false;
      }
      val = ((FInitAtom*)r->val)->val;
      return true;
    }
  case exp_list:
    {
      std::cerr << "error: expression ";
      print(std::cerr, false);
      std::cerr << " can not be evaluated" << std::endl;
      exit(255);
    }
  case exp_time:
    {
      TimeExpression* texp = (TimeExpression*)this;
      if (texp->time_exp == 0) {
 std::cerr << "error (eval_partial): expression ";
 print(std::cerr, false);
 std::cerr << " can not be evaluated" << std::endl;
 exit(255);
      }
      return texp->time_exp->eval_partial(val);
    }
  case exp_const:
    {
      ConstantExpression* cexp = (ConstantExpression*)this;
      val = cexp->val;
      return true;
    }
  case exp_add:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1;
      if (!bexp->first->eval_partial(v1)) return false;
      hsps::rational v2;
      if (!bexp->first->eval_partial(v2)) return false;
      val = (v1 + v2);
      return true;
    }
  case exp_sub:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1;
      if (!bexp->first->eval_partial(v1)) return false;
      hsps::rational v2;
      if (!bexp->first->eval_partial(v2)) return false;
      val = (v1 - v2);
      return true;
    }
  case exp_mul:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1;
      if (!bexp->first->eval_partial(v1)) return false;
      hsps::rational v2;
      if (!bexp->first->eval_partial(v2)) return false;
      val = (v1 * v2);
      return true;
    }
  case exp_div:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1;
      if (!bexp->first->eval_partial(v1)) return false;
      hsps::rational v2;
      if (!bexp->first->eval_partial(v2)) return false;
      val = (v1 / v2);
      return true;
    }
  case exp_preference:
    {
      return false;
    }
  }
  assert(0);
}
interval PDDL_Base::FunctionSymbol::eval_init_bounds
(ptr_table* p, index_type i, ListExpression* r)
{
  if (!p) {
    if (use_default_function_value) {
      return interval(default_function_value);
    }
    else {
      return interval(NEG_INF, POS_INF);
    }
  }
  if (r == 0) {
    if (!p->val) {
      ptr_table::key_vec* k = p->key_sequence();
      std::cerr << "error: key sequence " << k
  << " stored without value in function ";
      print(std::cerr);
      std::cerr << " init table"
  << std::endl;
      exit(255);
    }
    return interval(((FInitAtom*)p->val)->val);
  }
  else if (r->sym->sym_class == sym_variable) {
    if (((VariableSymbol*)r->sym)->value) {
      return eval_init_bounds(p->find_next(((VariableSymbol*)r->sym)->value), i + 1, r->rest);
    }
    else {
      hsps::rational v_min = POS_INF;
      hsps::rational v_max = NEG_INF;
      for (index_type k = 0; k < param[i]->sym_types.n_elements(); k++) {
 interval v =
   eval_init_bounds(p->find_next(param[i]->sym_types.get_element(k)),
      i + 1, r->rest);
 v_min = hsps::rational::min(v_min,v.first);
 v_max = hsps::rational::max(v_max,v.second);
      }
      return interval(v_min, v_max);
    }
  }
  else {
    return eval_init_bounds(p->find_next(r->sym), i + 1, r->rest);
  }
}
interval PDDL_Base::Expression::eval_bounds()
{
  switch (exp_class) {
  case exp_fun:
    {
      FunctionSymbol* fun = ((FunctionExpression*)this)->fun;
      if (!fun->is_static()) {
 return interval(NEG_INF, POS_INF);
      }
      ListExpression* args = ((FunctionExpression*)this)->args;
      ptr_table* p = &(fun->init);
      return fun->eval_init_bounds(p, 0, args);
    }
  case exp_list:
    {
      std::cerr << "error: expression ";
      print(std::cerr, false);
      std::cerr << " can not be evaluated" << std::endl;
      exit(255);
    }
  case exp_time:
    {
      TimeExpression* texp = (TimeExpression*)this;
      if (texp->time_exp == 0) {
 std::cerr << "error (eval_bounds): expression ";
 print(std::cerr, false);
 std::cerr << " can not be evaluated" << std::endl;
 exit(255);
      }
      return texp->time_exp->eval_bounds();
    }
  case exp_const:
    {
      ConstantExpression* cexp = (ConstantExpression*)this;
      return interval(cexp->val);
    }
  case exp_add:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      interval v1 = bexp->first->eval_bounds();
      interval v2 = bexp->second->eval_bounds();
      return interval(v1.first + v2.first, v1.second + v2.second);
    }
  case exp_sub:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      interval v1 = bexp->first->eval_bounds();
      interval v2 = bexp->second->eval_bounds();
      return interval(v1.first - v2.second, v1.second - v2.first);
    }
  case exp_mul:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      interval v1 = bexp->first->eval_bounds();
      interval v2 = bexp->second->eval_bounds();
      return interval(hsps::rational::min(hsps::rational::min(v1.first * v2.first,v1.first * v2.second),hsps::rational::min(v1.second * v2.first,v1.second * v2.second)),
        hsps::rational::max(hsps::rational::max(v1.first * v2.first,v1.first * v2.second),hsps::rational::max(v1.second * v2.first,v1.second * v2.second)));
    }
  case exp_div:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      if (bexp->second->is_static()) {
 interval v1 = bexp->first->eval_bounds();
 hsps::rational v2 = bexp->second->eval_static();
 return interval(v1.first / v2, v1.second / v2);
      }
      else if (bexp->first->is_static()) {
 hsps::rational v1 = bexp->first->eval_static();
 interval v2 = bexp->second->eval_bounds();
 return interval(v1 / v2.second, v1 / v2.first);
      }
      else {
 std::cerr << "error: in eval_bounds(";
 bexp->print(std::cerr, false);
 std::cerr << "): interval division not implemented"
    << std::endl;
 exit(255);
      }
    }
  case exp_preference:
    {
      std::cerr << "error: eval_bounds(PreferenceExpression) not implemented"
  << std::endl;
      exit(255);
    }
  }
  assert(0);
}
hsps::rational PDDL_Base::Expression::eval_init()
{
  switch (exp_class) {
  case exp_fun:
    {
      FunctionSymbol* fun = ((FunctionExpression*)this)->fun;
      ListExpression* args = ((FunctionExpression*)this)->args;
      ptr_table* r = &(fun->init);
      while (args && r) {
 if (args->sym->sym_class == sym_variable) {
   if (((VariableSymbol*)args->sym)->value == 0) {
     std::cerr << "error: unbound variable "
        << args->sym->print_name << " in ";
     print(std::cerr, true);
     std::cerr << " - uncompiled object function?"
        << std::endl;
     exit(255);
   }
   r = r->find_next(((VariableSymbol*)args->sym)->value);
 }
 else {
   r = r->find_next(args->sym);
 }
 if (!r) {
   if (use_default_function_value) {
     return default_function_value;
   }
   else {
     std::cerr << "error: ";
     print(std::cerr, true);
     std::cerr << " is undefined" << std::endl;
     exit(255);
   }
 }
 args = args->rest;
      }
      if (!r->val) {
 if (use_default_function_value) {
   return default_function_value;
 }
 else {
   std::cerr << "error: ";
   this->print(std::cerr, true);
   std::cerr << " has no value (2)" << std::endl;
   exit(255);
 }
      }
      return ((FInitAtom*)r->val)->val;
    }
  case exp_list:
    {
      std::cerr << "error: expression ";
      print(std::cerr, false);
      std::cerr << " can not be evaluated" << std::endl;
      exit(255);
    }
  case exp_time:
    {
      TimeExpression* texp = (TimeExpression*)this;
      if (texp->time_exp == 0) {
 std::cerr << "error (eval_static): expression ";
 print(std::cerr, false);
 std::cerr << " can not be evaluated" << std::endl;
 exit(255);
      }
      return texp->time_exp->eval_static();
    }
  case exp_const:
    {
      ConstantExpression* cexp = (ConstantExpression*)this;
      return cexp->val;
    }
  case exp_add:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1 = bexp->first->eval_init();
      hsps::rational v2 = bexp->second->eval_init();
      return v1 + v2;
    }
  case exp_sub:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1 = bexp->first->eval_init();
      hsps::rational v2 = bexp->second->eval_init();
      return v1 - v2;
    }
  case exp_mul:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1 = bexp->first->eval_init();
      hsps::rational v2 = bexp->second->eval_init();
      return v1 * v2;
    }
  case exp_div:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1 = bexp->first->eval_init();
      hsps::rational v2 = bexp->second->eval_init();
      return v1 / v2;
    }
  case exp_preference:
    {
      return 0;
    }
  }
  assert(0);
}
hsps::rational PDDL_Base::Expression::eval_delta
(ch_atom_vec& incs, ch_atom_vec& decs)
{
  switch (exp_class) {
  case exp_fun:
    {
      return ((FunctionExpression*)this)->eval_delta(incs, decs);
    }
  case exp_list:
    {
      std::cerr << "error (eval_delta): expression ";
      print(std::cerr, false);
      std::cerr << " can not be evaluated" << std::endl;
      exit(255);
    }
  case exp_time:
    {
      return 0;
    }
  case exp_const:
    {
      return 0;
    }
  case exp_add:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1 = bexp->first->eval_delta(incs, decs);
      hsps::rational v2 = bexp->second->eval_delta(incs, decs);
      return v1 + v2;
    }
  case exp_sub:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1 = bexp->first->eval_delta(incs, decs);
      hsps::rational v2 = bexp->second->eval_delta(incs, decs);
      return v1 - v2;
    }
  case exp_mul:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      if (bexp->first->is_static()) {
 if (bexp->second->is_static()) {
   return 0;
 }
 else {
   hsps::rational v1 = bexp->first->eval_static();
   hsps::rational v2 = bexp->second->eval_delta(incs, decs);
   return v1 * v2;
 }
      }
      else if (bexp->second->is_static()) {
 hsps::rational v1 = bexp->first->eval_delta(incs, decs);
 hsps::rational v2 = bexp->second->eval_static();
 return v1 * v2;
      }
      else {
 std::cerr << "error (eval_delta): expression ";
 print(std::cerr, false);
 std::cerr << " is non-linear" << std::endl;
 exit(255);
      }
    }
  case exp_div:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      if (bexp->first->is_static()) {
 if (bexp->second->is_static()) {
   return 0;
 }
 else {
   hsps::rational v1 = bexp->first->eval_static();
   hsps::rational v2 = bexp->second->eval_delta(incs, decs);
   return v1 / v2;
 }
      }
      else if (bexp->second->is_static()) {
 hsps::rational v1 = bexp->first->eval_delta(incs, decs);
 hsps::rational v2 = bexp->second->eval_static();
 return v1 / v2;
      }
      else {
 std::cerr << "error (eval_delta): expression ";
 print(std::cerr, false);
 std::cerr << " is non-linear" << std::endl;
 exit(255);
      }
    }
  case exp_preference:
    return 0;
  }
  assert(0);
}
hsps::rational PDDL_Base::Expression::eval_delta
(Symbol* preference, hsps::rational p_value, hsps::rational d_value)
{
  switch (exp_class) {
  case exp_fun:
    {
      FunctionSymbol* fun = ((FunctionExpression*)this)->fun;
      ListExpression* args = ((FunctionExpression*)this)->args;
      ptr_table* r = &(fun->init);
      while (args && r) {
 if (args->sym->sym_class == sym_variable) {
   if (((VariableSymbol*)args->sym)->value == 0) {
     std::cerr << "error: unbound variable "
        << args->sym->print_name << " in ";
     print(std::cerr, true);
     std::cerr << " - uncompiled object function?"
        << std::endl;
     exit(255);
   }
   r = r->find_next(((VariableSymbol*)args->sym)->value);
 }
 else {
   r = r->find_next(args->sym);
 }
 if (!r) {
   std::cerr << "error: ";
   print(std::cerr, true);
   std::cerr << " has no value (1)" << std::endl;
   exit(255);
 }
 args = args->rest;
      }
      if (!r->val) {
 std::cerr << "error: ";
 this->print(std::cerr, true);
 std::cerr << " has no value (2)" << std::endl;
 exit(255);
      }
      return ((FInitAtom*)r->val)->val;
    }
  case exp_list:
    {
      std::cerr << "error (eval_delta): expression ";
      print(std::cerr, false);
      std::cerr << " can not be evaluated" << std::endl;
      exit(255);
    }
  case exp_time:
    {
      TimeExpression* texp = (TimeExpression*)this;
      if (texp->time_exp == 0) {
 std::cerr << "error (eval_static): expression ";
 print(std::cerr, false);
 std::cerr << " can not be evaluated" << std::endl;
 exit(255);
      }
      return texp->time_exp->eval_static();
    }
  case exp_const:
    {
      ConstantExpression* cexp = (ConstantExpression*)this;
      return cexp->val;
    }
  case exp_add:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1 = bexp->first->eval_delta(preference, p_value, d_value);
      hsps::rational v2 = bexp->second->eval_delta(preference, p_value, d_value);
      return v1 + v2;
    }
  case exp_sub:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      hsps::rational v1 = bexp->first->eval_delta(preference, p_value, d_value);
      hsps::rational v2 = bexp->second->eval_delta(preference, p_value, d_value);
      return v1 - v2;
    }
  case exp_mul:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      if (bexp->first->is_static()) {
 if (bexp->second->is_static()) {
   hsps::rational v1 = bexp->first->eval_static();
   hsps::rational v2 = bexp->second->eval_static();
   return v1 * v2;
 }
 else {
   hsps::rational v1 = bexp->first->eval_static();
   hsps::rational v2 = bexp->second->eval_delta(preference, p_value, d_value);
   return v1 * v2;
 }
      }
      else if (bexp->second->is_static()) {
 hsps::rational v1 = bexp->first->eval_delta(preference, p_value, d_value);
 hsps::rational v2 = bexp->second->eval_static();
 return v1 * v2;
      }
      else {
 std::cerr << "error (eval_delta): expression ";
 print(std::cerr, false);
 std::cerr << " is non-linear" << std::endl;
 exit(255);
      }
    }
  case exp_div:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      if (bexp->first->is_static()) {
 if (bexp->second->is_static()) {
   hsps::rational v1 = bexp->first->eval_static();
   hsps::rational v2 = bexp->second->eval_static();
   return v1 / v2;
 }
 else {
   hsps::rational v1 = bexp->first->eval_static();
   hsps::rational v2 = bexp->second->eval_delta(preference, p_value, d_value);
   return v1 / v2;
 }
      }
      else if (bexp->second->is_static()) {
 hsps::rational v1 = bexp->first->eval_delta(preference, p_value, d_value);
 hsps::rational v2 = bexp->second->eval_static();
 return v1 / v2;
      }
      else {
 std::cerr << "error (eval_delta): expression ";
 print(std::cerr, false);
 std::cerr << " is non-linear" << std::endl;
 exit(255);
      }
    }
  case exp_preference:
    {
      PreferenceExpression* pexp = (PreferenceExpression*)this;
      if (pexp->name == preference) {
 return p_value;
      }
      else {
 return d_value;
      }
    }
  }
  assert(0);
}
bool PDDL_Base::Expression::equals(PDDL_Base::Expression* exp)
{
  if (!exp) return false;
  if (exp_class != exp->exp_class) return false;
  switch (exp_class) {
  case exp_fun:
    {
      FunctionExpression* f_this = (FunctionExpression*)this;
      FunctionExpression* f_exp = (FunctionExpression*)exp;
      if (f_this->fun != f_exp->fun) return false;
      if (f_this->args)
 return f_this->args->equals(f_exp->args);
      else
 return f_exp->args == 0;
    }
  case exp_list:
    {
      ListExpression* l_this = (ListExpression*)this;
      ListExpression* l_exp = (ListExpression*)exp;
      if (l_this->sym != l_exp->sym) return false;
      if (l_this->rest)
 return l_this->rest->equals(l_exp->rest);
      else
 return l_exp->rest == 0;
    }
  case exp_const:
    {
      ConstantExpression* c_this = (ConstantExpression*)this;
      ConstantExpression* c_exp = (ConstantExpression*)exp;
      return c_this->val == c_exp->val;
    }
  case exp_time:
    {
      TimeExpression* t_this = (TimeExpression*)this;
      TimeExpression* t_exp = (TimeExpression*)exp;
      return t_this->time_exp == t_exp->time_exp;
    }
  case exp_add:
  case exp_sub:
  case exp_mul:
  case exp_div:
    {
      BinaryExpression* b_this = (BinaryExpression*)this;
      BinaryExpression* b_exp = (BinaryExpression*)exp;
      return (b_this->first->equals(b_exp->first) &&
       b_this->second->equals(b_exp->second));
    }
  }
}
PDDL_Base::Expression* PDDL_Base::Expression::simplify()
{
  switch (exp_class) {
  case exp_fun:
  case exp_list:
  case exp_time:
  case exp_const:
  case exp_preference:
    return this;
  case exp_add:
    {
      if (is_static()) return new ConstantExpression(eval_static());
      BinaryExpression* b_exp = (BinaryExpression*)this;
      b_exp->first = b_exp->first->simplify();
      b_exp->second = b_exp->second->simplify();
      if ((b_exp->first->exp_class == exp_add) &&
   (b_exp->second->exp_class == exp_add)) {
 BinaryExpression* b1 = (BinaryExpression*)(b_exp->first);
 BinaryExpression* b2 = (BinaryExpression*)(b_exp->second);
 if (b1->first->is_static()) {
   if (b2->first->is_static()) {
     hsps::rational v1 = b1->first->eval_static();
     hsps::rational v2 = b2->first->eval_static();
     b1->first = b2->second;
     b_exp->second = new ConstantExpression(v1 + v2);
   }
   else if (b2->second->is_static()) {
     hsps::rational v1 = b1->first->eval_static();
     hsps::rational v2 = b2->second->eval_static();
     b1->first = b2->first;
     b_exp->second = new ConstantExpression(v1 + v2);
   }
 }
 else if (b1->second->is_static()) {
   if (b2->first->is_static()) {
     hsps::rational v1 = b1->second->eval_static();
     hsps::rational v2 = b2->first->eval_static();
     b1->second = b2->second;
     b_exp->second = new ConstantExpression(v1 + v2);
   }
   else if (b2->second->is_static()) {
     hsps::rational v1 = b1->second->eval_static();
     hsps::rational v2 = b2->second->eval_static();
     b1->second = b2->first;
     b_exp->second = new ConstantExpression(v1 + v2);
   }
 }
      }
      else if ((b_exp->first->exp_class == exp_add) &&
        (b_exp->second->is_static())) {
 BinaryExpression* b1 = (BinaryExpression*)(b_exp->first);
 if (b1->first->is_static()) {
   hsps::rational v1 = b1->first->eval_static();
   hsps::rational v2 = b_exp->second->eval_static();
   b_exp->first = b1->second;
   b_exp->second = new ConstantExpression(v1 + v2);
 }
 else if (b1->second->is_static()) {
   hsps::rational v1 = b1->second->eval_static();
   hsps::rational v2 = b_exp->second->eval_static();
   b_exp->first = b1->first;
   b_exp->second = new ConstantExpression(v1 + v2);
 }
      }
      else if ((b_exp->second->exp_class == exp_add) &&
        (b_exp->first->is_static())) {
 BinaryExpression* b1 = (BinaryExpression*)(b_exp->second);
 if (b1->first->is_static()) {
   hsps::rational v1 = b1->first->eval_static();
   hsps::rational v2 = b_exp->first->eval_static();
   b_exp->first = b1->second;
   b_exp->second = new ConstantExpression(v1 + v2);
 }
 else if (b1->second->is_static()) {
   hsps::rational v1 = b1->second->eval_static();
   hsps::rational v2 = b_exp->first->eval_static();
   b_exp->first = b1->first;
   b_exp->second = new ConstantExpression(v1 + v2);
 }
      }
      return this;
    }
  case exp_sub:
    {
      if (is_static()) return new ConstantExpression(eval_static());
      BinaryExpression* b_exp = (BinaryExpression*)this;
      Expression* second =
 new BinaryExpression(exp_mul,
        new ConstantExpression(-1),
        b_exp->second->simplify());
      Expression* e =
 new BinaryExpression(exp_add,
        b_exp->first->simplify(),
        second->simplify());
      return e->simplify();
    }
  case exp_mul:
    {
      if (is_static()) return new ConstantExpression(eval_static());
      BinaryExpression* b_exp = (BinaryExpression*)this;
      b_exp->first = b_exp->first->simplify();
      b_exp->second = b_exp->second->simplify();
      if (b_exp->first->exp_class == exp_add) {
 BinaryExpression* b1 = (BinaryExpression*)(b_exp->first);
 Expression* e1 =
   new BinaryExpression(exp_mul, b1->first, b_exp->second);
 Expression* e2 =
   new BinaryExpression(exp_mul, b1->second, b_exp->second);
 Expression* e =
   new BinaryExpression(exp_add, e1->simplify(), e2->simplify());
 return e->simplify();
      }
      else if (b_exp->second->exp_class == exp_add) {
 BinaryExpression* b1 = (BinaryExpression*)(b_exp->second);
 Expression* e1 =
   new BinaryExpression(exp_mul, b1->first, b_exp->first);
 Expression* e2 =
   new BinaryExpression(exp_mul, b1->second, b_exp->first);
 Expression* e =
   new BinaryExpression(exp_add, e1->simplify(), e2->simplify());
 return e->simplify();
      }
      else {
 if ((b_exp->first->exp_class == exp_mul) &&
     (b_exp->second->exp_class == exp_mul)) {
   BinaryExpression* b1 = (BinaryExpression*)(b_exp->first);
   BinaryExpression* b2 = (BinaryExpression*)(b_exp->second);
   if (b1->first->is_static()) {
     if (b2->first->is_static()) {
       hsps::rational v1 = b1->first->eval_static();
       hsps::rational v2 = b2->first->eval_static();
       if ((v1 * v2) == 1) {
  b_exp->first = b1->second;
  b_exp->second = b2->second;
       }
       else {
  b1->first = b2->second;
  b_exp->second = new ConstantExpression(v1 * v2);
       }
     }
     else if (b2->second->is_static()) {
       hsps::rational v1 = b1->first->eval_static();
       hsps::rational v2 = b2->second->eval_static();
       if ((v1 * v2) == 1) {
  b_exp->first = b1->second;
  b_exp->second = b2->first;
       }
       else {
  b1->first = b2->first;
  b_exp->second = new ConstantExpression(v1 * v2);
       }
     }
   }
   else if (b1->second->is_static()) {
     if (b2->first->is_static()) {
       hsps::rational v1 = b1->second->eval_static();
       hsps::rational v2 = b2->first->eval_static();
       if ((v1 * v2) == 1) {
  b_exp->first = b1->first;
  b_exp->second = b2->second;
       }
       else {
  b1->second = b2->second;
  b_exp->second = new ConstantExpression(v1 * v2);
       }
     }
     else if (b2->second->is_static()) {
       hsps::rational v1 = b1->second->eval_static();
       hsps::rational v2 = b2->second->eval_static();
       if ((v1 * v2) == 1) {
  b_exp->first = b1->first;
  b_exp->second = b2->first;
       }
       else {
  b1->second = b2->first;
  b_exp->second = new ConstantExpression(v1 * v2);
       }
     }
   }
 }
 else if ((b_exp->first->exp_class == exp_mul) &&
   (b_exp->second->is_static())) {
   BinaryExpression* b1 = (BinaryExpression*)(b_exp->first);
   if (b1->first->is_static()) {
     hsps::rational v1 = b1->first->eval_static();
     hsps::rational v2 = b_exp->second->eval_static();
     if ((v1 * v2) == 1) {
       return b1->second;
     }
     else {
       b_exp->first = b1->second;
       b_exp->second = new ConstantExpression(v1 * v2);
     }
   }
   else if (b1->second->is_static()) {
     hsps::rational v1 = b1->second->eval_static();
     hsps::rational v2 = b_exp->second->eval_static();
     if ((v1 * v2) == 1) {
       return b1->first;
     }
     else {
       b_exp->first = b1->first;
       b_exp->second = new ConstantExpression(v1 * v2);
     }
   }
 }
 else if ((b_exp->second->exp_class == exp_mul) &&
   (b_exp->first->is_static())) {
   BinaryExpression* b1 = (BinaryExpression*)(b_exp->second);
   if (b1->first->is_static()) {
     hsps::rational v1 = b1->first->eval_static();
     hsps::rational v2 = b_exp->first->eval_static();
     if ((v1 * v2) == 1) {
       return b1->second;
     }
     else {
       b_exp->first = b1->second;
       b_exp->second = new ConstantExpression(v1 * v2);
     }
   }
   else if (b1->second->is_static()) {
     hsps::rational v1 = b1->second->eval_static();
     hsps::rational v2 = b_exp->first->eval_static();
     if ((v1 * v2) == 1) {
       return b1->first;
     }
     else {
       b_exp->first = b1->first;
       b_exp->second = new ConstantExpression(v1 * v2);
     }
   }
 }
 return this;
      }
    }
  case exp_div:
    {
      if (is_static()) return new ConstantExpression(eval_static());
      BinaryExpression* b_exp = (BinaryExpression*)this;
      b_exp->first = b_exp->first->simplify();
      b_exp->second = b_exp->second->simplify();
      if (b_exp->first->exp_class == exp_add) {
 BinaryExpression* b1 = (BinaryExpression*)(b_exp->first);
 Expression* e1 =
   new BinaryExpression(exp_div, b1->first, b_exp->second);
 Expression* e2 =
   new BinaryExpression(exp_div, b1->second, b_exp->second);
 Expression* e =
   new BinaryExpression(exp_add, e1->simplify(), e2->simplify());
 return e->simplify();
      }
      else if (b_exp->second->exp_class == exp_add) {
 BinaryExpression* b1 = (BinaryExpression*)(b_exp->second);
 Expression* e1 =
   new BinaryExpression(exp_div, b1->first, b_exp->first);
 Expression* e2 =
   new BinaryExpression(exp_div, b1->second, b_exp->first);
 Expression* e =
   new BinaryExpression(exp_add, e1->simplify(), e2->simplify());
 return e->simplify();
      }
      else {
 return this;
      }
    }
  }
  assert(0);
}
void PDDL_Base::Expression::collect_constants(exp_vec& c)
{
  switch (exp_class) {
  case exp_const:
    c.append(this);
    break;
  case exp_add:
  case exp_sub:
  case exp_mul:
  case exp_div:
    ((BinaryExpression*)this)->first->collect_constants(c);
    ((BinaryExpression*)this)->second->collect_constants(c);
    break;
  }
}
void PDDL_Base::Expression::mark_functions_in_condition()
{
  switch (exp_class) {
  case exp_fun:
    ((FunctionExpression*)this)->fun->conditioned = true;
    break;
  case exp_add:
  case exp_sub:
  case exp_mul:
  case exp_div:
    ((BinaryExpression*)this)->first->mark_functions_in_condition();
    ((BinaryExpression*)this)->second->mark_functions_in_condition();
    break;
  }
}
hsps::rational PDDL_Base::Expression::integrify()
{
  exp_vec cexp(0, 0);
  collect_constants(cexp);
  if (cexp.length() == 0) return 1;
  svector<long> factors;
  for (index_type k = 0; k < cexp.length(); k++)
    factors.insert(((ConstantExpression*)cexp[k])->val.divisor());
  long common_m = factors[0];
  for (index_type k = 1; k < factors.length(); k++) {
    std::cerr << "lcm(" << common_m << ", " << factors[k] << ") = "
       << lcm(common_m, factors[k]) << std::endl;
    common_m = lcm(common_m, factors[k]);
  }
  std::cerr << "factors = " << factors
     << ", lcm = " << common_m
     << std::endl;
  for (index_type k = 0; k < cexp.length(); k++) {
    hsps::rational v0 = ((ConstantExpression*)cexp[k])->val;
    index_type i = factors.first(v0.divisor());
    assert(i < factors.length());
    hsps::rational v1(v0.numerator() * (common_m / v0.divisor()), 1);
    std::cerr << "replacing " << v0 << " by " << v1 << std::endl;
    ((ConstantExpression*)cexp[k])->val = v1;
  }
  return common_m;
}
bool PDDL_Base::ListExpression::match(AtomBase* atom)
{
  ListExpression* f = this;
  index_type n = 0;
  while (f && (n < atom->param.length())) {
    if (f->sym->sym_class == sym_variable) {
      if (atom->param[n]->sym_class == sym_variable) {
 if (f->sym != atom->param[n]) return false;
      }
      else {
 if (((VariableSymbol*)f->sym)->value != atom->param[n]) return false;
      }
    }
    else {
      if (atom->param[n]->sym_class == sym_variable) {
 if (f->sym != ((VariableSymbol*)atom->param[n])->value) return false;
      }
      else {
 if (f->sym != atom->param[n]) return false;
      }
    }
    f = f->rest;
    n += 1;
  }
  return ((f == 0) && (n == atom->param.length()));
}
bool PDDL_Base::FunctionExpression::match(FChangeAtom* atom)
{
  if (fun != atom->fun) return false;
  if (args) {
    return args->match(atom);
  }
  else {
    return (atom->param.length() == 0);
  }
}
hsps::rational PDDL_Base::FunctionExpression::eval_delta
(ch_atom_vec& incs, ch_atom_vec& decs)
{
  hsps::rational delta(0);
  for (index_type k = 0; k < incs.length(); k++) {
    if (match(incs[k])) delta += incs[k]->val->eval_static();
  }
  for (index_type k = 0; k < decs.length(); k++) {
    if (match(decs[k])) delta -= decs[k]->val->eval_static();
  }
  return delta;
}
PDDL_Base::FChangeAtom* PDDL_Base::FunctionExpression::make_atom_base()
{
  FChangeAtom* atom = new FChangeAtom(fun);
  for (ListExpression* l = args; l != 0; l = l->rest) {
    atom->param.append(l->sym);
  }
  return atom;
}
PDDL_Base::Expression* PDDL_Base::Relation::match_gteq_constant
(FChangeAtom* atom)
{
  if ((at == md_all) && (rel == rel_greater_equal)) {
    if (first->exp_class != exp_fun) return 0;
    if (!((FunctionExpression*)first)->match(atom)) return 0;
    if (!second->is_constant()) return 0;
    return second;
  }
  else if ((at == md_all) && (rel == rel_greater_equal)) {
    if (second->exp_class != exp_fun) return 0;
    if (!((FunctionExpression*)second)->match(atom)) return 0;
    if (!first->is_constant()) return 0;
    return first;
  }
  else {
    return 0;
  }
}
PDDL_Base::FunctionExpression* PDDL_Base::Relation::match_lteq_fun
(FChangeAtom* atom)
{
  if ((at == md_start) &&
      (rel == rel_less_equal) &&
      (first->exp_class == exp_fun) &&
      (second->exp_class == exp_sub)) {
    FunctionExpression* lhs = (FunctionExpression*)first;
    BinaryExpression* rhs = (BinaryExpression*)second;
    if (!lhs->match(atom)) return 0;
    if (!rhs->second->equals(atom->val)) return 0;
    if (rhs->first->exp_class != exp_fun) return 0;
    return (FunctionExpression*)(rhs->first);
  }
  else if ((at == md_start) &&
    (rel == rel_less) &&
    (first->exp_class == exp_fun) &&
    (second->exp_class == exp_fun)) {
    FunctionExpression* lhs = (FunctionExpression*)first;
    FunctionExpression* rhs = (FunctionExpression*)second;
    if (!lhs->match(atom)) return 0;
    if (!atom->fun->integral) return 0;
    if (!atom->val->is_constant()) return 0;
    if (!(atom->val->eval_static() == 1)) return 0;
    return rhs;
  }
  else if ((at == md_all) &&
    (rel == rel_less_equal) &&
    (first->exp_class == exp_fun) &&
    (second->exp_class == exp_fun)) {
    FunctionExpression* lhs = (FunctionExpression*)first;
    FunctionExpression* rhs = (FunctionExpression*)second;
    if (!lhs->match(atom)) return 0;
    return rhs;
  }
  else {
    return 0;
  }
}
bool PDDL_Base::Relation::is_static()
{
  return (first->is_static() && second->is_static());
}
PDDL_Base::partial_value PDDL_Base::Relation::partial_eval()
{
  hsps::rational v1;
  if (!first->eval_partial(v1)) {
    return p_unknown;
  }
  hsps::rational v2;
  if (!second->eval_partial(v2)) {
    return p_unknown;
  }
  switch (rel) {
  case rel_equal:
    {
      if (v1 == v2)
 return p_true;
      else
 return p_false;
    }
  case rel_greater:
    {
      if (v1 > v2)
 return p_true;
      else
 return p_false;
    }
  case rel_greater_equal:
    {
      if (v1 >= v2)
 return p_true;
      else
 return p_false;
    }
  case rel_less:
    {
      if (v1 < v2)
 return p_true;
      else
 return p_false;
    }
  case rel_less_equal:
    {
      if (v1 <= v2)
 return p_true;
      else
 return p_false;
    }
  default:
    {
      std::cerr << "program error: invalid relation " << rel
  << " in ";
      print(std::cerr, true);
      std::cerr << std::endl;
      exit(255);
    }
  }
}
PDDL_Base::AtomBase::AtomBase(AtomBase* b)
  : param(b->param), at(b->at), at_time(b->at_time)
{
}
bool PDDL_Base::AtomBase::equals(AtomBase& b)
{
  if (param.length() != b.param.length()) return false;
  for (index_type k = 0; k < param.length(); k++) {
    if (param[k] != b.param[k]) {
      if ((param[k]->sym_class == sym_variable) &&
   (b.param[k]->sym_class == sym_variable)) {
 VariableSymbol* v1 = (VariableSymbol*)param[k];
 VariableSymbol* v2 = (VariableSymbol*)b.param[k];
 if ((v1->binding != 0) && (v2->binding != 0)) {
   if (!(v1->binding->equals(*(v2->binding))))
     return false;
 }
 else {
   return false;
 }
      }
      else {
 return false;
      }
    }
  }
  return true;
}
void PDDL_Base::AtomBase::free_variables(variable_vec& v)
{
  for (index_type k = 0; k < param.length(); k++)
    if (param[k]->sym_class == sym_variable)
      v.append((VariableSymbol*)param[k]);
}
bool PDDL_Base::AtomBase::occurs(Symbol* s)
{
  for (index_type k = 0; k < param.length(); k++)
    if (param[k] == s) return true;
  return false;
}
void PDDL_Base::AtomBase::fill_in_args(AtomBase* b)
{
  b->param.set_length(0);
  for (index_type k = 0; k < param.length(); k++)
    if (param[k]->sym_class == sym_variable)
      if (((VariableSymbol*)param[k])->value != 0)
 b->param.append(((VariableSymbol*)param[k])->value);
      else
 b->param.append(param[k]);
    else
      b->param.append(param[k]);
}
void PDDL_Base::AtomBase::collect_bound_variables(variable_vec& v)
{
  for (index_type k = 0; k < param.length(); k++)
    if (param[k]->sym_class == sym_variable)
      if (((VariableSymbol*)param[k])->binding != 0) {
 v.append((VariableSymbol*)param[k]);
 ((VariableSymbol*)param[k])->binding->collect_bound_variables(v);
      }
}
bool PDDL_Base::Atom::check()
{
  if (pred->param.length() != param.length()) {
    if (write_warnings || !best_effort) {
      std::cerr << "warning: wrong number of arguments for ";
      pred->print(std::cerr);
      std::cerr << " in ";
      print(std::cerr);
      std::cerr << std::endl;
      if (!best_effort) exit(1);
    }
    return false;
  }
  for (index_type k = 0; k < pred->param.length(); k++)
    if (!pred->param[k]->equality_type_check(param[k])) {
      if (write_warnings || !best_effort) {
 std::cerr << "warning: argument " << k << " in ";
 print(std::cerr);
 std::cerr << " has wrong type for ";
 pred->print(std::cerr);
 std::cerr << std::endl;
 if (!best_effort) exit(1);
      }
      return false;
    }
  return true;
}
PDDL_Base::Atom* PDDL_Base::Atom::instantiate_partially()
{
  Atom* a = new Atom(pred, at);
  fill_in_args(a);
  return a;
}
bool PDDL_Base::Atom::equals(Atom& a)
{
  if (pred != a.pred) return false;
  return AtomBase::equals(a);
}
PDDL_Base::partial_value PDDL_Base::Atom::partial_eval
(ptr_table* r, index_type p)
{
  if (!r) return p_false;
  if (p == param.length()) {
    if (r->val) return p_true;
    else return p_false;
  }
  if (param[p]->sym_class == sym_variable) {
    VariableSymbol* v = (VariableSymbol*)param[p];
    if (v->value) {
      ptr_table* n = r->find_next(v->value);
      if (n) return partial_eval(n, p+1);
      else return p_false;
    }
    else {
      bool poss_false = false;
      bool poss_true = false;
      for (index_type k = 0; k < v->sym_types.n_elements(); k++) {
 ptr_table* n = r->find_next(v->sym_types.get_element(k));
 if (n) {
   partial_value nv = partial_eval(n, p+1);
   if (nv == p_unknown) return p_unknown;
   if (nv == p_false) {
     poss_false = true;
     if (poss_true) return p_unknown;
   }
   if (nv == p_true) {
     poss_true = true;
     if (poss_false) return p_unknown;
   }
 }
 else {
   poss_false = true;
   if (poss_true) return p_unknown;
 }
      }
      if (poss_true && !poss_false) return p_true;
      else if (poss_false && !poss_true) return p_false;
      else return p_unknown;
    }
  }
  else {
    ptr_table* n = r->find_next(param[p]);
    if (n) return partial_eval(n, p+1);
    else return p_false;
  }
  return p_false;
}
PDDL_Base::partial_value PDDL_Base::Atom::partial_eval()
{
  if (at == md_pos_goal) {
    return partial_eval(&(pred->pos_goal), 0);
  }
  else if (at == md_neg_goal) {
    return partial_eval(&(pred->neg_goal), 0);
  }
  else {
    return partial_eval(&(pred->init), 0);
  }
}
bool PDDL_Base::Atom::initial_value()
{
  ptr_table* r = &(pred->init);
  for (index_type k = 0; (k < param.length()) && r; k++) {
    if (param[k]->sym_class == sym_variable) {
      if (((VariableSymbol*)param[k])->value == 0) {
 std::cerr << "error: can't evaluate ";
 print(std::cerr);
 std::cerr << " in initial state because "
    << param[k]->print_name << " not set"
    << std::endl;
 exit(255);
      }
      r = r->find_next(((VariableSymbol*)param[k])->value);
    }
    else {
      r = r->find_next(param[k]);
    }
  }
  if (r) {
    if (r->val) return true;
  }
  return false;
}
Instance::Atom* PDDL_Base::Atom::find_prop
(Instance& ins, bool neg, bool create)
{
  ptr_table* r = (neg ? &(pred->neg_prop) : &(pred->pos_prop));
  for (index_type k = 0; k < param.length(); k++) {
    if (param[k]->sym_class == sym_variable) {
      if (((VariableSymbol*)param[k])->value == 0) {
 std::cerr << "error: unbound variable "
    << param[k]->print_name << " in ";
 print(std::cerr);
 std::cerr << " - uncompiled object function?"
    << std::endl;
 exit(255);
      }
      r = r->insert_next(((VariableSymbol*)param[k])->value);
    }
    else {
      r = r->insert_next(param[k]);
    }
  }
  if (!r->val) {
    if (!create) return 0;
    ptr_table* ri = &(pred->init);
    PDDL_Name* a_name = new PDDL_Name(pred, neg);
    for (index_type k = 0; k < param.length(); k++) {
      if (param[k]->sym_class == sym_variable) {
 assert(((VariableSymbol*)param[k])->value != 0);
 a_name->add(((VariableSymbol*)param[k])->value);
 if (ri) ri = ri->find_next(((VariableSymbol*)param[k])->value);
      }
      else {
 a_name->add(param[k]);
 if (ri) ri = ri->find_next(param[k]);
      }
    }
    Instance::Atom& p = ins.new_atom(a_name);
    bool init_val = false;
    hsps::rational init_t = 0;
    if (ri) {
      if (ri->val) {
 init_val = true;
 init_t = ((Atom*)(ri->val))->at_time;
      }
    }
    p.init = (init_val != neg);
    p.init_t = init_t;
    p.src = new ptr_pair(pred, r);
    r->val = new Instance::atom_ref(ins.atoms, p.index);
    Instance::Atom* not_p = find_prop(ins, !neg, false);
    if (not_p) {
      if (not_p->neg != no_such_index) {
 std::cerr << "wierd error: negation of atom "
    << not_p->index << "." << not_p->name << " is atom "
    << not_p->neg << "." << ins.atoms[not_p->neg].name
    << " and new atom " << p.index << "." << p.name
    << std::endl;
 exit(255);
      }
      p.neg = not_p->index;
      not_p->neg = p.index;
    }
    for (index_type k = 0; k < pred->irr_ins.length(); k++)
      if (pred->irr_ins[k]->included) {
 if (pred->irr_ins[k]->context_is_static()) {
   if (pred->irr_ins[k]->match(param)) {
     if (write_info) {
       std::cerr << "DKEL: atom " << a_name << " marked irrelevant by"
   << std::endl;
       pred->irr_ins[k]->print(std::cerr);
     }
     p.irrelevant = true;
   }
 }
 else if (write_warnings || !best_effort) {
   std::cerr << "warning: ignoring :irrelevant ";
   pred->irr_ins[k]->entity->print(std::cerr);
   std::cerr << " with non-static context" << std::endl;
   if (!best_effort) exit(1);
 }
      }
  }
  Instance::atom_ref* a = (Instance::atom_ref*)r->val;
  return *a;
}
bool PDDL_Base::FTerm::equals(FTerm& ft)
{
  if (fun != ft.fun) return false;
  return AtomBase::equals(ft);
}
bool PDDL_Base::extend_substitution
(Symbol* out, Symbol* in, symbol_pair_vec& u)
{
  for (index_type k = 0; k < u.length(); k++) if (u[k].first == out) {
    if (u[k].second == in) {
      return true;
    }
    else {
      return false;
    }
  }
  u.append(symbol_pair(out, in));
  return true;
}
bool PDDL_Base::substitution_violates_inequality
(const symbol_pair_vec& neq, const symbol_pair_vec& u)
{
  for (index_type k = 0; k < neq.length(); k++) {
    Symbol* s1 = 0;
    Symbol* s2 = 0;
    for (index_type i = 0; i < u.length(); i++) {
      if ((s1 == 0) && (u[i].first == neq[k].first)) s1 = u[i].second;
      if ((s2 == 0) && (u[i].first == neq[k].second)) s2 = u[i].second;
    }
    if (s1 == 0) s1 = neq[k].first;
    if (s2 == 0) s2 = neq[k].second;
    if (s1 == s2) {
      return true;
    }
  }
  return false;
}
bool PDDL_Base::print_substitution
(std::ostream& s, const symbol_pair_vec& u)
{
  s << "{";
  for (index_type k = 0; k < u.length(); k++) {
    if (k > 0) s << ", ";
    s << u[k].first->print_name << "\\" << u[k].second->print_name;
  }
  s << "}";
}
bool PDDL_Base::print_inequality
(std::ostream& s, const symbol_pair_vec& neq)
{
  s << "{";
  for (index_type k = 0; k < neq.length(); k++) {
    if (k > 0) s << ", ";
    s << neq[k].first->print_name << " =/= " << neq[k].second->print_name;
  }
  s << "}";
}
bool PDDL_Base::Atom::instance_of(Atom* a, symbol_pair_vec& u)
{
  u.clear();
  if (a->pred != pred) return false;
  if (a->param.length() != param.length()) {
    std::cerr << "error: atom ";
    a->print(std::cerr);
    std::cerr << " and atom schema ";
    print(std::cerr);
    std::cerr << " have same predicate and different number of arguments"
       << std::endl;
    return false;
  }
  for (index_type k = 0; k < param.length(); k++) if (param[k] != a->param[k]) {
    if (param[k]->sym_class == sym_variable) {
      if (a->param[k]->sym_class == sym_variable) {
 if (param[k]->sym_types.subtype_or_equal(a->param[k]->sym_types)) {
   if (!extend_substitution(a->param[k], param[k], u)) return false;
 }
 else {
   return false;
 }
      }
      else {
 return false;
      }
    }
    else {
      if (a->param[k]->sym_class == sym_variable) {
 if (((VariableSymbol*)a->param[k])->equality_type_check(param[k])) {
   if (!extend_substitution(a->param[k], param[k], u)) return false;
 }
 else {
   return false;
 }
      }
      else {
 if (a->param[k] != param[k]) return false;
      }
    }
  }
  return true;
}
bool PDDL_Base::Atom::instance_of
(Atom* a, const symbol_pair_vec& neq, symbol_pair_vec& u)
{
  if (!instance_of(a, u)) return false;
  if (substitution_violates_inequality(neq, u)) return false;
  return true;
}
bool PDDL_Base::Atom::unify
(Atom* a, symbol_pair_vec& u)
{
  u.clear();
  if (a->pred != pred) return false;
  if (a->param.length() != param.length()) {
    std::cerr << "error: atom ";
    a->print(std::cerr);
    std::cerr << " and atom ";
    print(std::cerr);
    std::cerr << " have same predicate but different #arguments"
       << std::endl;
    return false;
  }
  for (index_type k = 0; k < param.length(); k++) if (param[k] != a->param[k]) {
    if (param[k]->sym_class == sym_variable) {
      if (a->param[k]->sym_class == sym_variable) {
 if (param[k]->sym_types.subtype_or_equal(a->param[k]->sym_types)) {
   if (!extend_substitution(a->param[k], param[k], u)) return false;
 }
 else if (a->param[k]->sym_types.subtype_or_equal(param[k]->sym_types)) {
   if (!extend_substitution(param[k], a->param[k], u)) return false;
 }
 else {
   return false;
 }
      }
      else {
 if (((VariableSymbol*)param[k])->equality_type_check(a->param[k])) {
   if (!extend_substitution(param[k], a->param[k], u)) return false;
 }
 else {
   return false;
 }
      }
    }
    else {
      if (a->param[k]->sym_class == sym_variable) {
 if (((VariableSymbol*)a->param[k])->equality_type_check(param[k])) {
   if (!extend_substitution(a->param[k], param[k], u)) return false;
 }
 else {
   return false;
 }
      }
      else {
 if (a->param[k] != param[k]) return false;
      }
    }
  }
  return true;
}
bool PDDL_Base::Atom::unify
(Atom* a, const symbol_pair_vec& neq, symbol_pair_vec& u)
{
  if (!unify(a, u)) return false;
  if (substitution_violates_inequality(neq, u)) return false;
  return true;
}
bool PDDL_Base::CAtom::instance_of(Atom* a, symbol_pair_vec& u)
{
  return Atom::instance_of(a, u);
}
bool PDDL_Base::CAtom::instance_of(CAtom* a, symbol_pair_vec& u)
{
  return Atom::instance_of(a, a->neq, u);
}
bool PDDL_Base::CAtom::instance_of
(Atom* a, const symbol_pair_vec& neq, symbol_pair_vec& u)
{
  return Atom::instance_of(a, neq, u);
}
bool PDDL_Base::CAtom::unify(Atom* a, symbol_pair_vec& u)
{
  return Atom::unify(a, neq, u);
}
bool PDDL_Base::CAtom::unify(CAtom* a, symbol_pair_vec& u)
{
  if (!Atom::unify(a, u)) {
    return false;
  }
  if (substitution_violates_inequality(a->neq, u)) {
    return false;
  }
  if (substitution_violates_inequality(neq, u)) {
    return false;
  }
  return true;
}
void PDDL_Base::CAtom::print(std::ostream& s)
{
  if (neq.length() > 0) {
    s << "{";
    Atom::print(s);
    s << " |";
    for (index_type k = 0; k < neq.length(); k++) {
      s << " ";
      neq[k].first->print(s);
      s << " =/= ";
      neq[k].second->print(s);
    }
    s << "}";
  }
  else {
    Atom::print(s);
  }
}
PDDL_Base::Formula* PDDL_Base::Formula::simplify()
{
  switch (fc) {
  case fc_false:
    {
      return this;
    }
  case fc_true:
    {
      return this;
    }
  case fc_atom:
    {
      return this;
    }
  case fc_equality:
    {
      return this;
    }
  case fc_negation:
    {
      ((NFormula*)this)->f = ((NFormula*)this)->f->simplify();
      if (((NFormula*)this)->f->fc == fc_true) {
 return new Formula(fc_false);
      }
      else if (((NFormula*)this)->f->fc == fc_false) {
 return new Formula(fc_true);
      }
      else if (((NFormula*)this)->f->fc == fc_negation) {
 return ((NFormula*)((NFormula*)this)->f)->f;
      }
      else {
 return this;
      }
    }
  case fc_conjunction:
    {
      formula_vec sp(0, 0);
      for (index_type k = 0; k < ((CFormula*)this)->parts.length(); k++)
 sp.append(((CFormula*)this)->parts[k]->simplify());
      ((CFormula*)this)->parts.assign_value(0, 0);
      for (index_type k = 0; k < sp.length(); k++) {
 if (sp[k]->fc == fc_false) {
   return new Formula(fc_false);
 }
 else if (sp[k]->fc == fc_conjunction) {
   for (index_type i = 0; i < ((CFormula*)sp[k])->parts.length(); i++)
     sp.append(((CFormula*)sp[k])->parts[i]);
 }
 else if (sp[k]->fc != fc_true) {
   ((CFormula*)this)->parts.append(sp[k]);
 }
      }
      if (((CFormula*)this)->parts.length() == 0) {
 return new Formula(fc_true);
      }
      else if (((CFormula*)this)->parts.length() == 1) {
 return ((CFormula*)this)->parts[0];
      }
      else {
 return this;
      }
    }
  case fc_disjunction:
    {
      formula_vec sp(0, 0);
      for (index_type k = 0; k < ((CFormula*)this)->parts.length(); k++)
 sp.append(((CFormula*)this)->parts[k]->simplify());
      ((CFormula*)this)->parts.assign_value(0, 0);
      for (index_type k = 0; k < sp.length(); k++) {
 if (sp[k]->fc == fc_true) {
   return new Formula(fc_true);
 }
 else if (sp[k]->fc == fc_disjunction) {
   for (index_type i = 0; i < ((CFormula*)sp[k])->parts.length(); i++)
     sp.append(((CFormula*)sp[k])->parts[i]);
 }
 else if (sp[k]->fc != fc_false) {
   ((CFormula*)this)->parts.append(sp[k]);
 }
      }
      if (((CFormula*)this)->parts.length() == 0) {
 return new Formula(fc_false);
      }
      else if (((CFormula*)this)->parts.length() == 1) {
 return ((CFormula*)this)->parts[0];
      }
      else {
 return this;
      }
    }
  case fc_implication:
    {
      ((BFormula*)this)->f1 = ((BFormula*)this)->f1->simplify();
      ((BFormula*)this)->f2 = ((BFormula*)this)->f2->simplify();
      if (((BFormula*)this)->f1->fc == fc_true) {
 return ((BFormula*)this)->f2;
      }
      else if (((BFormula*)this)->f1->fc == fc_false) {
 return new Formula(fc_true);
      }
      else {
 if (((BFormula*)this)->f2->fc == fc_true) {
   return new Formula(fc_true);
 }
 else if (((BFormula*)this)->f2->fc == fc_false) {
   if (((BFormula*)this)->f1->fc == fc_negation) {
     return ((NFormula*)((BFormula*)this)->f1)->f;
   }
   else {
     return new NFormula(((BFormula*)this)->f1);
   }
 }
 else {
   return this;
 }
      }
    }
  case fc_equivalence:
    {
      ((BFormula*)this)->f1 = ((BFormula*)this)->f1->simplify();
      ((BFormula*)this)->f2 = ((BFormula*)this)->f2->simplify();
      return this;
    }
  case fc_universal:
    {
      ((QFormula*)this)->f = ((QFormula*)this)->f->simplify();
      return this;
    }
  case fc_existential:
    {
      ((QFormula*)this)->f = ((QFormula*)this)->f->simplify();
      return this;
    }
  }
  assert(0);
}
void PDDL_Base::Formula::rename_variables_1(symbol_pair_vec& sub)
{
  switch (fc) {
  case fc_atom:
    {
      AFormula* f = (AFormula*)this;
      for (index_type k = 0; k < f->param.length(); k++) {
 bool found = false;
 for (index_type i = 0; (i < sub.length()) && !found; i++)
   if (f->param[k] == sub[i].first) {
     f->param[k] = sub[i].second;
     found = true;
   }
      }
      return;
    }
  case fc_equality:
    {
      EqFormula* f = (EqFormula*)this;
      bool found = false;
      for (index_type i = 0; (i < sub.length()) && !found; i++)
 if (f->t1 == sub[i].first) {
   f->t1 = sub[i].second;
   found = true;
 }
      found = false;
      for (index_type i = 0; (i < sub.length()) && !found; i++)
 if (f->t2 == sub[i].first) {
   f->t2 = sub[i].second;
   found = true;
 }
      return;
    }
  case fc_negation:
    {
      NFormula* f = (NFormula*)this;
      f->f->rename_variables_1(sub);
      return;
    }
  case fc_conjunction:
  case fc_disjunction:
    {
      CFormula* f = (CFormula*)this;
      for (index_type k = 0; k < f->parts.length(); k++) {
 f->parts[k]->rename_variables_1(sub);
      }
      return;
    }
  case fc_implication:
  case fc_equivalence:
    {
      BFormula* f = (BFormula*)this;
      f->f1->rename_variables_1(sub);
      f->f2->rename_variables_1(sub);
      return;
    }
  case fc_universal:
  case fc_existential:
    {
      QFormula* f = (QFormula*)this;
      for (index_type k = 0; k < f->vars.length(); k++) {
 bool found = false;
 for (index_type i = 0; (i < sub.length()) && !found; i++)
   if (f->vars[k] == sub[i].first) {
     f->vars[k] = (VariableSymbol*)sub[i].second;
     found = true;
   }
      }
      f->f->rename_variables_1(sub);
      return;
    }
  }
  assert(0);
}
void PDDL_Base::Formula::rename_variables_2(symbol_pair_vec& sub)
{
  symbol_pair_vec rsub;
  for (index_type i = 0; i < sub.length(); i++)
    rsub.append(symbol_pair(sub[i].second, sub[i].first));
  rename_variables_1(rsub);
}
void PDDL_Base::Formula::rename_predicates_1(symbol_pair_vec& sub)
{
  switch (fc) {
  case fc_atom:
    {
      AFormula* f = (AFormula*)this;
      for (index_type i = 0; i < sub.length(); i++)
 if (f->pred == sub[i].first) {
   f->pred = (PredicateSymbol*)sub[i].second;
   return;
 }
      return;
    }
  case fc_negation:
    {
      NFormula* f = (NFormula*)this;
      f->f->rename_predicates_1(sub);
      return;
    }
  case fc_conjunction:
  case fc_disjunction:
    {
      CFormula* f = (CFormula*)this;
      for (index_type k = 0; k < f->parts.length(); k++) {
 f->parts[k]->rename_predicates_1(sub);
      }
      return;
    }
  case fc_implication:
  case fc_equivalence:
    {
      BFormula* f = (BFormula*)this;
      f->f1->rename_predicates_1(sub);
      f->f2->rename_predicates_1(sub);
      return;
    }
  case fc_universal:
  case fc_existential:
    {
      QFormula* f = (QFormula*)this;
      f->f->rename_predicates_1(sub);
      return;
    }
  }
  assert(0);
}
void PDDL_Base::Formula::rename_predicates_2(symbol_pair_vec& sub)
{
  symbol_pair_vec rsub;
  for (index_type i = 0; i < sub.length(); i++)
    rsub.append(symbol_pair(sub[i].second, sub[i].first));
  rename_predicates_1(rsub);
}
void PDDL_Base::Formula::print(std::ostream& s) const
{
  switch (fc) {
  case fc_false:
    {
      s << "false";
      return;
    }
  case fc_true:
    {
      s << "true";
      return;
    }
  case fc_atom:
    {
      ((PDDL_Base::AFormula*)this)->print(s);
      return;
    }
  case fc_equality:
    {
      s << "(= ";
      ((EqFormula*)this)->t1->print(s);
      s << " ";
      ((EqFormula*)this)->t2->print(s);
      s << ")";
      return;
    }
  case fc_negation:
    {
      s << "(not ";
      ((NFormula*)this)->f->print(s);
      s << ")";
      return;
    }
  case fc_conjunction:
    {
      s << "(and";
      for (index_type k = 0; k < ((CFormula*)this)->parts.length(); k++) {
 s << " ";
 ((CFormula*)this)->parts[k]->print(s);
      }
      s << ")";
      return;
    }
  case fc_disjunction:
    {
      s << "(or";
      for (index_type k = 0; k < ((CFormula*)this)->parts.length(); k++) {
 s << " ";
 ((CFormula*)this)->parts[k]->print(s);
      }
      s << ")";
      return;
    }
  case fc_implication:
    {
      s << "(imply ";
      ((BFormula*)this)->f1->print(s);
      s << " ";
      ((BFormula*)this)->f2->print(s);
      s << ")";
      return;
    }
  case fc_equivalence:
    {
      s << "(iff ";
      ((BFormula*)this)->f1->print(s);
      s << " ";
      ((BFormula*)this)->f2->print(s);
      s << ")";
      return;
    }
  case fc_universal:
    {
      s << "(forall (";
      for (index_type k = 0; k < ((QFormula*)this)->vars.length(); k++) {
 if (k > 0) s << " ";
 ((QFormula*)this)->vars[k]->print(s);
      }
      s << ") ";
      ((QFormula*)this)->f->print(s);
      s << ")";
      return;
    }
  case fc_existential:
    {
      s << "(exists (";
      for (index_type k = 0; k < ((QFormula*)this)->vars.length(); k++) {
 if (k > 0) s << " ";
 ((QFormula*)this)->vars[k]->print(s);
      }
      s << ") ";
      ((QFormula*)this)->f->print(s);
      s << ")";
      return;
    }
  }
  assert(0);
}
void PDDL_Base::AFormula::print(std::ostream& s) const
{
  PDDL_Base::Atom::print(s, false);
}
void PDDL_Base::Formula::write_otter(std::ostream& s) const
{
  switch (fc) {
  case fc_false:
    {
      s << "$F";
      return;
    }
  case fc_true:
    {
      s << "$T";
      return;
    }
  case fc_atom:
    {
      ((PDDL_Base::AFormula*)this)->write_otter(s);
      return;
    }
  case fc_equality:
    {
      ((EqFormula*)this)->write_otter(s);
      return;
    }
  case fc_negation:
    {
      s << "-(";
      ((NFormula*)this)->f->write_otter(s);
      s << ")";
      return;
    }
  case fc_conjunction:
  case fc_disjunction:
    {
      ((CFormula*)this)->write_otter(s);
      return;
    }
  case fc_implication:
    {
      s << "->(";
      ((BFormula*)this)->f1->write_otter(s);
      s << ",";
      ((BFormula*)this)->f2->write_otter(s);
      s << ")";
      return;
    }
  case fc_equivalence:
    {
      s << "<->(";
      ((BFormula*)this)->f1->write_otter(s);
      s << ",";
      ((BFormula*)this)->f2->write_otter(s);
      s << ")";
      return;
    }
  case fc_universal:
  case fc_existential:
    {
      ((QFormula*)this)->write_otter(s);
      return;
    }
  }
  assert(0);
}
void PDDL_Base::AFormula::write_otter(std::ostream& s) const
{
  s << pred->print_name << "(";
  for (index_type k = 0; k < param.length(); k++) {
    if (k > 0) s << ",";
    if (param[k]->sym_class == sym_variable) {
      s << (param[k]->print_name + 1);
    }
    else {
      s << param[k]->print_name;
    }
  }
  s << ")";
}
void PDDL_Base::EqFormula::write_otter(std::ostream& s) const
{
  s << "=(";
  if (t1->sym_class == sym_variable) {
    s << (t1->print_name + 1);
  }
  else {
    s << t1->print_name;
  }
  s << ",";
  if (t2->sym_class == sym_variable) {
    s << (t2->print_name + 1);
  }
  else {
    s << t2->print_name;
  }
  s << ")";
}
void PDDL_Base::CFormula::write_otter(std::ostream& s) const
{
  if (fc == fc_conjunction) s << "&(";
  else if (fc == fc_disjunction) s << "|(";
  else {
    std::cerr << "error: invalide class " << fc
       << " for composite formula"
       << std::endl;
    exit(255);
  }
  for (index_type k = 0; k < parts.length(); k++) {
    if (k > 0) s << ",";
    parts[k]->write_otter(s);
  }
  s << ")";
}
void PDDL_Base::QFormula::write_otter(std::ostream& s) const
{
  if (fc == fc_universal) s << "$Quantified(all";
  else if (fc == fc_existential) s << "$Quantified(exists";
  else {
    std::cerr << "error: invalide class " << fc
       << " for quantified formula"
       << std::endl;
    exit(255);
  }
  for (index_type k = 0; k < vars.length(); k++) {
    s << "," << (vars[k]->print_name + 1);
  }
  s << ",";
  f->write_otter(s);
  s << ")";
}
PDDL_Base::FInitAtom::FInitAtom(FChangeAtom* a)
  : AtomBase(a), fun(a->fun), val(0)
{
}
bool PDDL_Base::FChangeAtom::equals(FChangeAtom& a)
{
  if (fun != a.fun) return false;
  if (!AtomBase::equals(a)) return false;
  return val->equals(a.val);
}
bool PDDL_Base::FChangeAtom::fluent_equals(FChangeAtom& a)
{
  if (fun != a.fun) return false;
  if (!AtomBase::equals(a)) return false;
  return true;
}
bool PDDL_Base::FChangeAtom::fluent_and_mode_equals(FChangeAtom& a)
{
  if (at != a.at) return false;
  return fluent_equals(a);
}
PDDL_Base::FChangeAtom* PDDL_Base::FChangeAtom::find_fluent_equals
(ch_atom_vec& vec)
{
  for (index_type k = 0; k < vec.length(); k++)
    if (fluent_equals(*vec[k])) return vec[k];
  return 0;
}
Instance::Resource* PDDL_Base::FChangeAtom::find_resource(Instance& ins)
{
  ptr_table* r = &(fun->init);
  for (index_type k = 0; k < param.length(); k++) {
    if (param[k]->sym_class == sym_variable) {
      if (((VariableSymbol*)param[k])->value == 0) {
 std::cerr << "error: unbound variable "
    << param[k]->print_name << " in ";
 print(std::cerr);
 std::cerr << " - uncompiled object function?"
    << std::endl;
 exit(255);
      }
      r = r->insert_next(((VariableSymbol*)param[k])->value);
    }
    else {
      r = r->insert_next(param[k]);
    }
  }
  if (!r->val) {
    r->val = new FInitAtom(this);
  }
  FInitAtom* a = (FInitAtom*)(r->val);
  if (!a->res) {
    PDDL_Name* fa_name = new PDDL_Name(fun, false);
    for (index_type k = 0; k < param.length(); k++) {
      if (param[k]->sym_class == sym_variable)
 fa_name->add(((VariableSymbol*)param[k])->value);
      else
 fa_name->add(param[k]);
    }
    Instance::Resource& i = ins.new_resource(fa_name);
    i.init = a->val;
    i.src = new ptr_pair(fun, r);
    a->res = Instance::resource_ref(ins.resources, i.index);
  }
  return (a->res);
}
void PDDL_Base::AtomBase::insert(ptr_table& t)
{
  ptr_table* r = &t;
  for (index_type k = 0; k < param.length(); k++) {
    assert(param[k] != 0);
    r = r->insert_next(param[k]);
  }
  r->val = this;
}
index_type PDDL_Base::find_matching_atom(Atom* a, atom_vec& v)
{
  for (index_type i = 0; i < v.length(); i++)
    if (a->equals(*v[i]))
      return i;
  return no_such_index;
}
index_type PDDL_Base::find_matching_atom(Atom* a, mode_keyword m, atom_vec& v)
{
  for (index_type i = 0; i < v.length(); i++)
    if (a->equals(*v[i]) && (v[i]->at == m))
      return i;
  return no_such_index;
}
index_type PDDL_Base::find_matching_fluent_atom
(FChangeAtom* a, mode_keyword m, ch_atom_vec& v)
{
  for (index_type i = 0; i < v.length(); i++)
    if (a->equals(*v[i]) && (v[i]->at == m))
      return i;
  return no_such_index;
}
void PDDL_Base::ActionSymbol::post_process()
{
  if (write_trace) {
    std::cerr << "post processing action " << print_name << "..." << std::endl;
  }
  for (index_type k = 0; k < pos_pre.length(); k++)
    pos_pre[k]->pred->pos_pre = true;
  for (index_type k = 0; k < neg_pre.length(); k++)
    neg_pre[k]->pred->neg_pre = true;
  for (index_type k = 0; k < set_eff.length(); k++)
    if (!set_eff[k]->context_is_static()) {
      cond_eff.append(set_eff[k]);
      set_eff.remove(k);
      k -= 1;
    }
  for (index_type k = 0; k < dels.length(); k++)
    if (dels[k]->at == md_start) {
      index_type add_i = find_matching_atom(dels[k], md_end, adds);
      index_type pre_i = find_matching_atom(dels[k], md_start, pos_pre);
      if ((add_i != no_such_index) && (pre_i != no_such_index)) {
 locks.append(dels[k]);
 locks[locks.length() - 1]->at = md_all;
 dels.remove(k);
 adds.remove(add_i);
      }
    }
  for (index_type k = 0; k < adds.length(); k++)
    if (adds[k]->at == md_start) {
      index_type del_i = find_matching_atom(adds[k], md_end, dels);
      if (del_i != no_such_index) {
 enables.append(adds[k]);
 enables[enables.length() - 1]->at = md_all;
 adds.remove(k);
 dels.remove(del_i);
      }
    }
  cons.set_length(0);
  for (index_type k = 0; k < dels.length(); k++) {
    index_type pre_i = find_matching_atom(dels[k], pos_pre);
    if (pre_i != no_such_index)
      cons.append(dels[k]);
  }
  for (index_type k = 0; k < adds.length(); k++)
    adds[k]->pred->added = true;
  for (index_type k = 0; k < dels.length(); k++)
    dels[k]->pred->deleted = true;
  for (index_type k = 0; k < locks.length(); k++)
    locks[k]->pred->locked = true;
  if (compact_resource_effects) {
    for (index_type k = 0; k < decs.length(); k++)
      if (decs[k]->val->exp_class == exp_const) {
 index_type i = k + 1;
 while (i < decs.length()) {
   if (decs[i]->fluent_and_mode_equals(*decs[k]) &&
       (decs[i]->val->exp_class == exp_const)) {
     if (write_info) {
       std::cerr << "info: collapsing effects decrease ";
       decs[k]->print(std::cerr);
       std::cerr << " and decrease ";
       decs[i]->print(std::cerr);
       std::cerr << " in action " << print_name
   << std::endl;
     }
     ((ConstantExpression*)decs[k]->val)->val +=
       ((ConstantExpression*)decs[i]->val)->val;
     decs.remove(i);
   }
   else {
     if (write_trace) {
       std::cerr << "debug: effects ";
       decs[k]->print(std::cerr);
       std::cerr << " and ";
       decs[i]->print(std::cerr);
       std::cerr << " in action " << print_name << " do not match"
   << std::endl;
     }
     i += 1;
   }
 }
 i = 0;
 while (i < incs.length()) {
   if (incs[i]->fluent_and_mode_equals(*decs[k]) &&
       (incs[i]->val->exp_class == exp_const)) {
     if (((ConstantExpression*)decs[k]->val)->val >
  ((ConstantExpression*)incs[i]->val)->val) {
       if (write_info) {
  std::cerr << "info: collapsing effects decrease ";
  decs[k]->print(std::cerr);
  std::cerr << " and increase ";
  incs[i]->print(std::cerr);
  std::cerr << " in action " << print_name
     << std::endl;
       }
       ((ConstantExpression*)decs[k]->val)->val -=
  ((ConstantExpression*)incs[i]->val)->val;
       decs.remove(i);
     }
     else {
       if (write_trace) {
  std::cerr << "debug: effects decrease ";
  decs[k]->print(std::cerr);
  std::cerr << " and increase ";
  incs[i]->print(std::cerr);
  std::cerr << " in action " << print_name
     << " should not be collapsed to a decrease effect"
     << std::endl;
       }
       i += 1;
     }
   }
   else {
     if (write_trace) {
       std::cerr << "debug: effects ";
       decs[k]->print(std::cerr);
       std::cerr << " and ";
       incs[i]->print(std::cerr);
       std::cerr << " in action " << print_name << " do not match"
   << std::endl;
     }
     i += 1;
   }
 }
      }
    for (index_type k = 0; k < incs.length(); k++)
      if (incs[k]->val->exp_class == exp_const) {
 index_type i = k + 1;
 while (i < incs.length()) {
   if (incs[i]->fluent_and_mode_equals(*incs[k]) &&
       (incs[i]->val->exp_class == exp_const)) {
     if (write_info) {
       std::cerr << "info: collapsing effects increase ";
       incs[k]->print(std::cerr);
       std::cerr << " and increase ";
       incs[i]->print(std::cerr);
       std::cerr << " in action " << print_name
   << std::endl;
     }
     ((ConstantExpression*)incs[k]->val)->val +=
       ((ConstantExpression*)incs[i]->val)->val;
     incs.remove(i);
   }
   else {
     if (write_trace) {
       std::cerr << "debug: effects ";
       incs[k]->print(std::cerr);
       std::cerr << " and ";
       incs[i]->print(std::cerr);
       std::cerr << " in action " << print_name << " do not match"
   << std::endl;
     }
     i += 1;
   }
 }
 i = 0;
 while (i < decs.length()) {
   if (decs[i]->fluent_and_mode_equals(*incs[k]) &&
       (decs[i]->val->exp_class == exp_const)) {
     if (((ConstantExpression*)incs[k]->val)->val >
  ((ConstantExpression*)decs[i]->val)->val) {
       if (write_info) {
  std::cerr << "info: collapsing effects increase ";
  incs[k]->print(std::cerr);
  std::cerr << " and decrease ";
  decs[i]->print(std::cerr);
  std::cerr << " in action " << print_name
     << std::endl;
       }
       ((ConstantExpression*)incs[k]->val)->val -=
  ((ConstantExpression*)decs[i]->val)->val;
       decs.remove(i);
     }
     else {
       if (write_trace) {
  std::cerr << "debug: effects increase ";
  incs[k]->print(std::cerr);
  std::cerr << " and decrease ";
  decs[i]->print(std::cerr);
  std::cerr << " in action " << print_name
     << " should not be collapsed to an increase effect"
     << std::endl;
       }
       i += 1;
     }
   }
   else {
     if (write_trace) {
       std::cerr << "debug: effects ";
       incs[k]->print(std::cerr);
       std::cerr << " and ";
       decs[i]->print(std::cerr);
       std::cerr << " in action " << print_name << " do not match"
   << std::endl;
     }
     i += 1;
   }
 }
      }
  }
  for (index_type k = 0; k < decs.length(); k++)
    if (decs[k]->at == md_start) {
      index_type inc_i = find_matching_fluent_atom(decs[k], md_end, incs);
      if (inc_i != no_such_index) {
 if (use_strict_borrow_definition) {
   bool check = false;
   for (index_type i = 0; (i < num_pre.length()) && check; i++) {
     Expression* f = num_pre[i]->match_gteq_constant(decs[k]);
     if (f) {
       if (f->eval_static() == 0) check = true;
     }
   }
   if (!check) inc_i = no_such_index;
 }
 if (inc_i != no_such_index) {
   decs[k]->at = md_all;
   reqs.append(decs[k]);
   decs.remove(k);
   incs.remove(inc_i);
   k -= 1;
 }
      }
      else if (decs[k]->val->exp_class == exp_const) {
 for (index_type i = 0;
      ((i < incs.length()) && (inc_i == no_such_index)); i++)
   if (decs[k]->fluent_equals(*incs[i]) &&
       (incs[i]->at == md_end) &&
       (incs[i]->val->exp_class == exp_const))
     if (((ConstantExpression*)incs[i]->val)->val <
  ((ConstantExpression*)decs[k]->val)->val) {
       inc_i = i;
     }
 if (inc_i != no_such_index) {
   if (use_strict_borrow_definition) {
     bool check = false;
     for (index_type i = 0; (i < num_pre.length()) && check; i++) {
       Expression* f = num_pre[i]->match_gteq_constant(decs[k]);
       if (f) {
  if (f->eval_static() == 0) check = true;
       }
     }
     if (!check) inc_i = no_such_index;
   }
   if (inc_i != no_such_index) {
     hsps::rational c = (((ConstantExpression*)decs[k]->val)->val -
         ((ConstantExpression*)incs[inc_i]->val)->val);
     hsps::rational u = ((ConstantExpression*)incs[inc_i]->val)->val;
     FChangeAtom* r_atom = new FChangeAtom(decs[k], u);
     r_atom->at = md_all;
     reqs.append(r_atom);
     ((ConstantExpression*)decs[k]->val)->val = c;
     incs.remove(inc_i);
   }
 }
      }
    }
  if (use_extended_borrow_definition) {
    for (index_type k = 0; k < incs.length(); k++)
      if (incs[k]->at == md_start) {
 index_type dec_i = find_matching_fluent_atom(incs[k], md_end, decs);
 FunctionExpression* f = 0;
 if (dec_i != no_such_index) {
   for (index_type i = 0; (i < num_pre.length()) && (f == 0); i++)
     f = num_pre[i]->match_lteq_fun(incs[k]);
 }
 if ((dec_i != no_such_index) && (f != 0)) {
   FChangeAtom* r_atom = f->make_atom_base();
   r_atom->at = md_all;
   r_atom->val = incs[k]->val;
   reqs.append(r_atom);
   incs.remove(k);
   decs.remove(dec_i);
   k -= 1;
 }
      }
  }
  for (index_type k = 0; k < reqs.length(); k++) {
    reqs[k]->fun->borrowed = true;
    if (!reqs[k]->val->is_static())
      reqs[k]->fun->linear = false;
  }
  for (index_type k = 0; k < incs.length(); k++) {
    incs[k]->fun->increased = true;
    if (!incs[k]->val->is_static())
      incs[k]->fun->linear = false;
  }
  for (index_type k = 0; k < decs.length(); k++) {
    decs[k]->fun->decreased = true;
    if (!decs[k]->val->is_static())
      decs[k]->fun->linear = false;
  }
  for (index_type k = 0; k < fass.length(); k++) {
    fass[k]->fun->assigned = true;
    fass[k]->fun->linear = false;
  }
}
void PDDL_Base::post_process()
{
  if (compile_away_object_functions) {
    compile_object_functions();
  }
  if (write_trace) {
    std::cerr << "trace: post processing PDDL definition..." << std::endl;
  }
  dom_base_types.assign_value(0, 0);
  for (index_type k = 0; k < dom_types.length(); k++) {
    dom_types[k]->is_base_type = true;
    for (index_type i = 0;
  (i < dom_types.length()) && dom_types[k]->is_base_type; i++)
      if (dom_types[i]->sym_types.contains(dom_types[k]))
 dom_types[k]->is_base_type = false;
    if (dom_types[k]->is_base_type)
      dom_base_types.append(dom_types[k]);
  }
  for (index_type k = 0; k < dom_actions.length(); k++) {
    dom_actions[k]->post_process();
  }
  ready_to_instantiate = true;
}
bool PDDL_Base::Goal::makeCPG(CPG& g)
{
  if ((g_class == goal_pos_atom) || (g_class == goal_neg_atom)) {
    AtomicGoal* a = (AtomicGoal*)this;
    g.atoms.append(a->atom);
    if (g_class == goal_neg_atom)
      g.neg.append(true);
    else
      g.neg.append(false);
    g.atom_first_arg.append(g.args.length());
    assert((g.atoms.length() == g.neg.length()) &&
    (g.atoms.length() == g.atom_first_arg.length()));
    assert(a->atom->param.length() == a->atom->pred->param.length());
    for (index_type k = 0; k < a->atom->param.length(); k++) {
      g.args.append(a->atom->param[k]);
      assert(a->atom->param[k]->sym_types.length() == 1);
      g.arg_types.append(a->atom->param[k]->sym_types[0]);
    }
    assert(g.args.length() == g.arg_types.length());
    return true;
  }
  else if (g_class == goal_conjunction) {
    ConjunctiveGoal* c = (ConjunctiveGoal*)this;
    for (index_type i = 0; i < c->goals.length(); i++) {
      if (!c->goals[i]->makeCPG(g)) return false;
    }
    return true;
  }
  std::cerr << "error: can't make CPG from goal ";
  print(std::cerr);
  std::cerr << std::endl;
  return false;
}
bool PDDL_Base::Goal::makeCPG(CPG& g, index_vec& s)
{
  if ((g_class == goal_pos_atom) || (g_class == goal_neg_atom)) {
    AtomicGoal* a = (AtomicGoal*)this;
    index_type i = no_such_index;
    for (index_type k = 0; (k < g.atoms.length()) && (i == no_such_index); k++)
      if ((g.atoms[k]->equals(*(a->atom))) &&
   (((g_class == goal_pos_atom) && !g.neg[k]) ||
    ((g_class == goal_neg_atom) && g.neg[k])))
 i = k;
    if (i == no_such_index) {
      g.atoms.append(a->atom);
      if (g_class == goal_neg_atom)
 g.neg.append(true);
      else
 g.neg.append(false);
      g.atom_first_arg.append(g.args.length());
      assert((g.atoms.length() == g.neg.length()) &&
      (g.atoms.length() == g.atom_first_arg.length()));
      assert(a->atom->param.length() == a->atom->pred->param.length());
      for (index_type k = 0; k < a->atom->param.length(); k++) {
 g.args.append(a->atom->param[k]);
 assert(a->atom->param[k]->sym_types.length() == 1);
 g.arg_types.append(a->atom->param[k]->sym_types[0]);
      }
      assert(g.args.length() == g.arg_types.length());
      s.append(g.atoms.length() - 1);
    }
    else {
      s.append(i);
    }
    return true;
  }
  else if (g_class == goal_conjunction) {
    ConjunctiveGoal* c = (ConjunctiveGoal*)this;
    for (index_type i = 0; i < c->goals.length(); i++) {
      if (!c->goals[i]->makeCPG(g)) return false;
    }
    return true;
  }
  std::cerr << "error: can't make CPG from goal ";
  print(std::cerr);
  std::cerr << std::endl;
  return false;
}
PDDL_Base::CPG::CPG(CPG& g, index_vec& s)
  : atoms(0, 0), neg(false, 0), args(g.args), arg_types(g.arg_types)
{
  for (index_type k = 0; k < s.length(); k++) {
    assert(s[k] < g.atoms.length());
    atoms.append(g.atoms[s[k]]);
    assert(s[k] < g.atom_first_arg.length());
    atom_first_arg.append(g.atom_first_arg[s[k]]);
    assert(s[k] < g.neg.length());
    neg.append(g.neg[s[k]]);
  }
}
void PDDL_Base::CPG::make_key(ptr_table::key_vec& key)
{
  key.clear();
  for (index_type k = 0; k < atoms.length(); k++)
    key.append(atoms[k]->pred);
}
void PDDL_Base::CPG::make_typed_key(ptr_table::key_vec& key)
{
  key.clear();
  for (index_type k = 0; k < atoms.length(); k++)
    key.append(atoms[k]->pred);
  for (index_type k = 0; k < args.length(); k++) {
    assert(args[k]->sym_types.length() == 1);
    key.append(args[k]->sym_types[0]);
  }
}
void PDDL_Base::CPG::make_parameters(variable_vec& param)
{
  param.set_length(args.length());
  for (index_type k = 0; k < args.length(); k++) {
    EnumName v_name("?arg", k);
    VariableSymbol* v = new VariableSymbol(v_name.to_cstring());
    v->sym_types.assign_value(arg_types[k]);
    param[k] = v;
  }
}
PDDL_Base::ListExpression* PDDL_Base::CPG::make_argument_list
(index_type first)
{
  if (first < args.length()) {
    return new ListExpression(args[first], make_argument_list(first + 1));
  }
  else {
    return 0;
  }
}
bool PDDL_Base::CPG::initial_value()
{
  for (index_type k = 0; k < atoms.length(); k++) {
    bool atom_init_val = atoms[k]->initial_value();
    if (atom_init_val == neg[k]) return false;
  }
  return true;
}
void PDDL_Base::CPG::add_effect_conditions
(Context* e, ParamSymbol* pf, bool_vec& sat, symbol_vec& subs,
 symbol_pair_vec& eq, symbol_pair_vec& neq)
{
  for (index_type k = 0; k < eq.length(); k++) {
    index_type p = pf->param.first((VariableSymbol*)eq[k].first);
    assert(p != no_such_index);
    Atom* eq_atom = new Atom(PDDL_Base::current_eq_predicate);
    if (subs[p]) {
      eq_atom->param.append(subs[p]);
    }
    else {
      eq_atom->param.append(eq[k].first);
    }
    eq_atom->param.append(eq[k].second);
    e->pos_con.append(eq_atom);
  }
  for (index_type k = 0; k < neq.length(); k++) {
    index_type p = pf->param.first((VariableSymbol*)neq[k].first);
    assert(p != no_such_index);
    Atom* neq_atom = new Atom(PDDL_Base::current_eq_predicate);
    if (subs[p]) {
      neq_atom->param.append(subs[p]);
    }
    else {
      neq_atom->param.append(neq[k].first);
    }
    neq_atom->param.append(neq[k].second);
    e->neg_con.append(neq_atom);
  }
  for (index_type k = 0; k < atoms.length(); k++) if (!sat[k]) {
    PredicateSymbol* pred = atoms[k]->pred;
    Atom* atom = new Atom(pred);
    atom->param.set_length(pred->param.length());
    for (index_type i = 0; i < pred->param.length(); i++) {
      if (subs[atom_first_arg[k] + i]) {
 atom->param[i] = subs[atom_first_arg[k] + i];
      }
      else {
 atom->param[i] = pf->param[atom_first_arg[k] + i];
      }
    }
    if (neg[k]) {
      e->neg_con.append(atom);
    }
    else {
      e->pos_con.append(atom);
    }
  }
}
void PDDL_Base::CPG::add_asserting_effects
(ActionSymbol* act, PredicateSymbol* p, bool p_val, PredicateSymbol* g,
 FunctionSymbol* f, Expression* f_val, bool strict)
{
  bool_vec sat(false, atoms.length());
  symbol_pair_vec eq;
  symbol_pair_vec neq;
  add_asserting_effects(0, act, 0, sat, p, p_val, g, f, f_val,
   eq, neq, strict);
}
void PDDL_Base::CPG::add_asserting_effects
(index_type c_atom, ActionSymbol* act, index_type c_eff, bool_vec& sat,
 PredicateSymbol* p, bool p_val, PredicateSymbol* g,
 FunctionSymbol* f, Expression* f_val,
 symbol_pair_vec& eq, symbol_pair_vec& neq, bool strict)
{
  assert((p == 0) || (f == 0));
  ParamSymbol* pf = (p ? (ParamSymbol*)p : (ParamSymbol*)f);
  assert(pf != 0);
  if (c_atom < atoms.length()) {
    if (c_eff < act->adds.length()) {
      if (atoms[c_atom]->pred == act->adds[c_eff]->pred) {
 if (neg[c_atom]) {
   bool threat = true;
   for (index_type k = 0; k < act->adds[c_eff]->param.length(); k++)
     if (!pf->param[atom_first_arg[c_atom] + k]->
  equality_type_check(act->adds[c_eff]->param[k]))
       threat = false;
   if (threat) {
     for (index_type k = 0; k < act->adds[c_eff]->param.length(); k++) {
       bool poss = true;
       for (index_type i = 0; i < eq.length(); i++)
  if ((eq[i].first == pf->param[atom_first_arg[c_atom] + k]) &&
      (eq[i].second == act->adds[c_eff]->param[k]))
    poss = false;
       if (poss) {
  neq.append(symbol_pair(pf->param[atom_first_arg[c_atom] + k],
           act->adds[c_eff]->param[k]));
  add_asserting_effects(c_atom, act, c_eff + 1, sat,
          p, p_val, g, f, f_val, eq, neq, strict);
  neq.dec_length();
       }
     }
   }
   else {
     add_asserting_effects(c_atom, act, c_eff + 1, sat,
      p, p_val, g, f, f_val, eq, neq, strict);
   }
 }
 else {
   if (!sat[c_atom]) {
     bool poss = true;
     for (index_type k = 0; (k < act->adds[c_eff]->param.length()) && poss; k++) {
       for (index_type i = 0; (i < neq.length()) && poss; i++)
  if ((neq[i].first == pf->param[atom_first_arg[c_atom] + k]) &&
      (neq[i].second == act->adds[c_eff]->param[k]))
    poss = false;
       if (!pf->param[atom_first_arg[c_atom] + k]->
    equality_type_check(act->adds[c_eff]->param[k]))
  poss = false;
     }
     if (poss) {
       for (index_type k = 0; k < act->adds[c_eff]->param.length(); k++)
  eq.append(symbol_pair(pf->param[atom_first_arg[c_atom] + k],
          act->adds[c_eff]->param[k]));
       sat[c_atom] = true;
       add_asserting_effects(c_atom, act, c_eff + 1, sat,
        p, p_val, g, f, f_val, eq, neq, strict);
       sat[c_atom] = false;
       eq.dec_length(act->adds[c_eff]->param.length());
     }
   }
   add_asserting_effects(c_atom, act, c_eff + 1, sat,
    p, p_val, g, f, f_val, eq, neq, strict);
 }
      }
      else {
 add_asserting_effects(c_atom, act, c_eff + 1, sat,
         p, p_val, g, f, f_val, eq, neq, strict);
      }
    }
    else if (c_eff < (act->adds.length() + act->dels.length())) {
      index_type d_eff = c_eff - act->adds.length();
      if (atoms[c_atom]->pred == act->dels[d_eff]->pred) {
 if (!neg[c_atom]) {
   bool threat = true;
   for (index_type k = 0; k < act->dels[d_eff]->param.length(); k++)
     if (!pf->param[atom_first_arg[c_atom] + k]->
  equality_type_check(act->dels[d_eff]->param[k]))
       threat = false;
   if (threat) {
     for (index_type k = 0; k < act->dels[d_eff]->param.length(); k++) {
       bool poss = true;
       for (index_type i = 0; i < eq.length(); i++)
  if ((eq[i].first == pf->param[atom_first_arg[c_atom] + k]) &&
      (eq[i].second == act->dels[d_eff]->param[k]))
    poss = false;
       if (poss) {
  neq.append(symbol_pair(pf->param[atom_first_arg[c_atom] + k],
           act->dels[d_eff]->param[k]));
  add_asserting_effects(c_atom, act, c_eff + 1, sat,
          p, p_val, g, f, f_val, eq, neq, strict);
  neq.dec_length();
       }
     }
   }
   else {
     add_asserting_effects(c_atom, act, c_eff + 1, sat,
      p, p_val, g, f, f_val, eq, neq, strict);
   }
 }
 else {
   if (!sat[c_atom]) {
     bool poss = true;
     for (index_type k = 0; (k < act->dels[d_eff]->param.length()) && poss; k++) {
       for (index_type i = 0; (i < neq.length()) && poss; i++)
  if ((neq[i].first == pf->param[atom_first_arg[c_atom] + k]) &&
      (neq[i].second == act->dels[d_eff]->param[k]))
    poss = false;
       if (!pf->param[atom_first_arg[c_atom] + k]->
    equality_type_check(act->adds[c_eff]->param[k]))
  poss = false;
     }
     if (poss) {
       for (index_type k = 0; k < act->dels[d_eff]->param.length(); k++)
  eq.append(symbol_pair(pf->param[atom_first_arg[c_atom] + k],
          act->dels[d_eff]->param[k]));
       sat[c_atom] = true;
       add_asserting_effects(c_atom, act, c_eff + 1, sat,
        p, p_val, g, f, f_val, eq, neq, strict);
       sat[c_atom] = false;
       eq.dec_length(act->dels[d_eff]->param.length());
     }
   }
   add_asserting_effects(c_atom, act, c_eff + 1, sat,
    p, p_val, g, f, f_val, eq, neq, strict);
 }
      }
      else {
 add_asserting_effects(c_atom, act, c_eff + 1, sat,
         p, p_val, g, f, f_val, eq, neq, strict);
      }
    }
    else {
      add_asserting_effects(c_atom + 1, act, 0, sat,
       p, p_val, g, f, f_val, eq, neq, strict);
    }
  }
  else {
    index_type n_sat = sat.count(true);
    if (n_sat > 0) {
      symbol_vec subs(0, args.length());
      index_type n_sub = 0;
      symbol_pair_vec rem_eq;
      for (index_type k = 0; k < eq.length(); k++) {
 index_type i = pf->param.first((VariableSymbol*)eq[k].first);
 assert(i != no_such_index);
 assert(i < subs.length());
 if (subs[i] == 0) {
   subs[i] = eq[k].second;
   n_sub += 1;
 }
 else {
   rem_eq.append(eq[k]);
 }
      }
      if (p) {
 index_type i = sat.first(true);
 bool done = false;
 while (!done) {
   SetOf* e = new SetOf();
   Atom* a = new Atom(p);
   a->param.set_length(args.length());
   for (index_type k = 0; k < args.length(); k++) {
     if (subs[k]) {
       a->param[k] = subs[k];
     }
     else {
       a->param[k] = p->param[k];
       e->param.append(p->param[k]);
     }
   }
   if (p_val)
     e->neg_atoms.append(a);
   else
     e->pos_atoms.append(a);
   add_effect_conditions(e, p, sat, subs, rem_eq, neq);
   if (strict) {
     PredicateSymbol* pred = atoms[i]->pred;
     Atom* atom = new Atom(pred);
     atom->param.set_length(pred->param.length());
     for (index_type j = 0; j < pred->param.length(); j++) {
       if (subs[atom_first_arg[i] + j]) {
  atom->param[j] = subs[atom_first_arg[i] + j];
       }
       else {
  atom->param[j] = p->param[atom_first_arg[i] + j];
       }
     }
     if (neg[i]) {
       e->pos_con.append(atom);
     }
     else {
       e->neg_con.append(atom);
     }
   }
   if (g) {
     Atom* g_atom = new Atom(g);
     g_atom->param.set_length(args.length());
     for (index_type k = 0; k < args.length(); k++) {
       if (subs[k]) {
  g_atom->param[k] = subs[k];
       }
       else {
  g_atom->param[k] = p->param[k];
       }
     }
     e->pos_con.append(g_atom);
   }
   if (e->context_is_static()) {
     act->set_eff.append(e);
     if (write_info) {
       std::cerr << "info: added set effect ";
       e->print(std::cerr);
       std::cerr << " to action " << act->print_name << std::endl;
     }
   }
   else {
     act->cond_eff.append(e);
     if (write_info) {
       std::cerr << "info: added conditional effect ";
       e->print(std::cerr);
       std::cerr << " to action " << act->print_name << std::endl;
     }
   }
   if (strict) {
     i = sat.next(true, i);
     if (i == no_such_index) done = true;
   }
   else {
     done = true;
   }
 }
      }
      if (f) {
 FChangeAtom* a = new FChangeAtom(f);
 QCNumericEffect* e = new QCNumericEffect(a);
 a->param.set_length(args.length());
 for (index_type k = 0; k < args.length(); k++) {
   if (subs[k]) {
     a->param[k] = subs[k];
   }
   else {
     a->param[k] = f->param[k];
     e->param.append(f->param[k]);
   }
 }
 a->val = f_val->copy();
 add_effect_conditions(e, p, sat, subs, rem_eq, neq);
 act->qc_fass.append(e);
 if (write_info) {
   std::cerr << "info: added assignment ";
   e->print(std::cerr);
   std::cerr << " to action " << act->print_name << std::endl;
 }
      }
    }
  }
}
void PDDL_Base::CPG::add_propositional_effect
(ActionSymbol* act, PredicateSymbol* p, bool p_val,
 index_type c_atom, Atom* a_eff, bool strict)
{
  SetOf* e = new SetOf();
  Atom* a = new Atom(p);
  a->param.set_length(args.length());
  for (index_type k = 0; k < atoms.length(); k++) {
    if (k == c_atom) {
      for (index_type i = 0; i < atoms[k]->param.length(); i++)
 a->param[atom_first_arg[k] + i] = a_eff->param[i];
    }
    else {
      for (index_type i = 0; i < atoms[k]->param.length(); i++) {
 a->param[atom_first_arg[k] + i] =
   p->param[atom_first_arg[k] + i];
 e->param.append(p->param[atom_first_arg[k] + i]);
      }
    }
  }
  if (p_val)
    e->neg_atoms.append(a);
  else
    e->pos_atoms.append(a);
  if (strict) {
    for (index_type k = 0; k < atoms.length(); k++) {
      a = new Atom(atoms[k]->pred);
      a->param.set_length(args.length());
      if (k == c_atom) {
 for (index_type i = 0; i < atoms[k]->param.length(); i++)
   a->param[atom_first_arg[k] + i] = a_eff->param[i];
      }
      else {
 for (index_type i = 0; i < atoms[k]->param.length(); i++) {
   a->param[atom_first_arg[k] + i] = p->param[atom_first_arg[k] + i];
 }
      }
      if (neg[k]) {
 e->neg_con.append(a);
      }
      else {
 e->pos_con.append(a);
      }
    }
  }
  if (!e->context_is_static()) {
    act->cond_eff.append(e);
    if (write_info) {
      std::cerr << "info: added conditional effect ";
      e->print(std::cerr);
      std::cerr << " to action " << act->print_name << std::endl;
    }
  }
  else {
    act->set_eff.append(e);
    if (write_info) {
      std::cerr << "info: added set effect ";
      e->print(std::cerr);
      std::cerr << " to action " << act->print_name << std::endl;
    }
  }
}
void PDDL_Base::CPG::add_fluent_effect
(ActionSymbol* act, FunctionSymbol* f, Expression* f_val,
 index_type c_atom, Atom* a_eff)
{
  FChangeAtom* a = new FChangeAtom(f);
  a->param.set_length(args.length());
  QCNumericEffect* e = new QCNumericEffect(a);
  for (index_type k = 0; k < atoms.length(); k++) {
    if (k == c_atom) {
      for (index_type i = 0; i < atoms[k]->param.length(); i++)
 a->param[atom_first_arg[k] + i] = a_eff->param[i];
    }
    else {
      for (index_type i = 0; i < atoms[k]->param.length(); i++) {
 a->param[atom_first_arg[k] + i] =
   f->param[atom_first_arg[k] + i];
 e->param.append(f->param[atom_first_arg[k] + i]);
      }
    }
  }
  a->val = f_val->copy();
  act->qc_fass.append(e);
  if (write_info) {
    std::cerr << "info: added assignment ";
    e->print(std::cerr);
    std::cerr << " to action " << act->print_name << std::endl;
  }
}
void PDDL_Base::CPG::add_destroying_effects
(ActionSymbol* act, ParamSymbol* pf,
 PredicateSymbol* p, bool p_val, PredicateSymbol* g,
 FunctionSymbol* f, Expression* f_val, bool strict)
{
  for (index_type c_atom = 0; c_atom < atoms.length(); c_atom++) {
    if (neg[c_atom]) {
      for (index_type c_eff = 0; c_eff < act->adds.length(); c_eff++)
 if (atoms[c_atom]->pred == act->adds[c_eff]->pred) {
   bool poss = true;
   for (index_type k = 0; k < act->adds[c_eff]->param.length(); k++)
     if (!pf->param[atom_first_arg[c_atom] + k]->
  equality_type_check(act->adds[c_eff]->param[k]))
       poss = false;
   if (poss) {
     if (p) {
       add_propositional_effect(act, p, p_val, c_atom, act->adds[c_eff], strict);
     }
     if (f) {
       assert(!strict);
       add_fluent_effect(act, f, f_val, c_atom, act->adds[c_eff]);
     }
   }
 }
    }
    else {
      for (index_type c_eff = 0; c_eff < act->dels.length(); c_eff++)
 if (atoms[c_atom]->pred == act->dels[c_eff]->pred) {
   bool poss = true;
   for (index_type k = 0; k < act->dels[c_eff]->param.length(); k++)
     if (!pf->param[atom_first_arg[c_atom] + k]->
  equality_type_check(act->dels[c_eff]->param[k]))
       poss = false;
   if (poss) {
     if (p) {
       add_propositional_effect(act, p, p_val, c_atom, act->dels[c_eff], strict);
     }
     if (f) {
       assert(!strict);
       add_fluent_effect(act, f, f_val, c_atom, act->dels[c_eff]);
     }
   }
 }
    }
  }
}
PDDL_Base::Expression* PDDL_Base::replace_violations_1
(Expression* exp, CPG* cpg[], FunctionSymbol* f_violated[])
{
  switch (exp->exp_class) {
  case exp_fun:
  case exp_list:
  case exp_const:
    return exp;
  case exp_add:
  case exp_sub:
  case exp_mul:
  case exp_div:
    {
      BinaryExpression* b_exp = (BinaryExpression*)exp;
      Expression* first =
 replace_violations_1(b_exp->first, cpg, f_violated);
      Expression* second =
 replace_violations_1(b_exp->second, cpg, f_violated);
      return new BinaryExpression(exp->exp_class, first, second);
    }
  case exp_time:
    return exp;
  case exp_preference:
    {
      PreferenceExpression* p_exp = (PreferenceExpression*)exp;
      index_type p = no_such_index;
      for (index_type k = 0;
    (k < dom_preferences.length()) && (p == no_such_index); k++)
 if (dom_preferences[k]->name == p_exp->name) p = k;
      if (p == no_such_index) {
 std::cerr << "error: undefined preference in expression ";
 p_exp->print(std::cerr, false);
 std::cerr << std::endl;
 exit(255);
      }
      if (cpg[p]) {
 ListExpression* args = cpg[p]->make_argument_list(0);
 FunctionExpression* f_exp =
   new FunctionExpression(f_violated[p], args);
 if (write_info) {
   std::cerr << "info: replaced ";
   p_exp->print(std::cerr, false);
   std::cerr << " by ";
   f_exp->print(std::cerr, false);
   std::cerr << " in :metric" << std::endl;
 }
 return f_exp;
      }
      else {
 return p_exp;
      }
    }
  default:
    std::cerr << "error: invalid expression class (" << exp->exp_class << ")"
       << std::endl;
    exit(255);
  }
}
void PDDL_Base::compile_preferences()
{
  if (dom_preferences.length() == 0) return;
  current_eq_predicate = dom_eq_pred;
  CPG* cpg[dom_preferences.length()];
  FunctionSymbol* f_violated[dom_preferences.length()];
  ptr_table signatures;
  ptr_table* signature[dom_preferences.length()];
  bool_vec compilable(false, dom_preferences.length());
  index_type n_compilable = 0;
  index_type n_signatures = 0;
  for (index_type p = 0; p < dom_preferences.length(); p++) {
    CPG* g = new CPG();
    if (dom_preferences[p]->goal->makeCPG(*g)) {
      cpg[p] = g;
      ptr_table::key_vec sig;
      g->make_key(sig);
      signature[p] = signatures.insert(sig);
      compilable[p] = true;
      n_compilable += 1;
    }
    else {
      cpg[p] = 0;
      signature[p] = 0;
    }
    f_violated[p] = 0;
  }
  if (write_info) {
    std::cerr << "info: " << n_compilable << " compilable preferences found"
       << std::endl;
  }
  if ((n_compilable < dom_preferences.length()) &&
      (write_warnings || !best_effort)) {
    std::cerr << "warning: " << (dom_preferences.length() - n_compilable)
       << " preferences can not be compiled"
       << std::endl;
    if (!best_effort) exit(1);
  }
  if (n_compilable == 0) return;
  for (index_type p = 0; p < dom_preferences.length(); p++) if (cpg[p]) {
    if (write_info) {
      std::cerr << "info: compiling ";
      dom_preferences[p]->print(std::cerr);
      std::cerr << std::endl;
    }
    if (f_violated[p] == 0) {
      EnumName f_name("violated", n_signatures);
      f_violated[p] = new FunctionSymbol(f_name.to_cstring());
      index_type f_arity = cpg[p]->args.length();
      type_vec f_types(cpg[p]->arg_types);
      for (index_type q = p + 1; q < dom_preferences.length(); q++)
 if (signature[q] == signature[p])
   if (merge_type_vectors(f_types, cpg[q]->arg_types))
     f_violated[q] = f_violated[p];
      make_parameters(f_types, "?arg", f_violated[p]->param);
      f_violated[p]->modified = true;
      f_violated[p]->integral = true;
      f_violated[p]->linear = false;
      f_violated[p]->assigned = true;
      dom_functions.append(f_violated[p]);
      if (write_info) {
 std::cerr << "info: created CPG function ";
 f_violated[p]->print(std::cerr);
      }
      Expression* exp0 = new ConstantExpression(0);
      Expression* exp1 = new ConstantExpression(1);
      for (index_type a = 0; a < dom_actions.length(); a++) {
 bool_vec sat(false, cpg[p]->atoms.length());
 symbol_pair_vec eq;
 symbol_pair_vec neq;
 cpg[p]->add_asserting_effects(0, dom_actions[a], 0, sat,
          0, false, 0, f_violated[p], exp0,
          eq, neq, false);
 cpg[p]->add_destroying_effects(dom_actions[a], f_violated[p],
           0, false, 0, f_violated[p], exp1, false);
      }
      n_signatures += 1;
    }
    FInitAtom* f_init = new FInitAtom(f_violated[p]);
    f_init->param = cpg[p]->args;
    if (cpg[p]->initial_value()) {
      f_init->val = 0;
    }
    else {
      f_init->val = 1;
    }
    f_init->insert(f_violated[p]->init);
    dom_fun_init.append(f_init);
  }
  else {
    if (write_info) {
      std::cerr << "info: ";
      dom_preferences[p]->print(std::cerr);
      std::cerr << " can not be compiled" << std::endl;
    }
  }
  metric = replace_violations_1(metric, cpg, f_violated);
  dom_preferences.remove(compilable);
  if (write_info) {
    std::cerr << "info: "
       << n_compilable << " preferences compiled, "
       << n_signatures << " CPG functions created, "
       << dom_preferences.length() << " preferences remain"
       << std::endl;
  }
}
void PDDL_Base::add_precondition_formula
(ActionSymbol* a, CPG* f, bool is_neg)
{
  assert(f);
  if (is_neg) {
    if (f->atoms.length() > 1) {
      SetOf* d = new SetOf();
      for (index_type k = 0; k < f->atoms.length(); k++) {
 if (f->neg[k])
   d->pos_atoms.append(new Atom(f->atoms[k]));
 else
   d->neg_atoms.append(new Atom(f->atoms[k]));
      }
      a->dis_pre.append(d);
    }
    else if (f->atoms.length() == 1) {
      if (f->neg[0])
 a->pos_pre.append(new Atom(f->atoms[0]));
      else
 a->neg_pre.append(new Atom(f->atoms[0]));
    }
  }
  else {
    for (index_type k = 0; k < f->atoms.length(); k++) {
      if (f->neg[k])
 a->neg_pre.append(new Atom(f->atoms[k]));
      else
 a->pos_pre.append(new Atom(f->atoms[k]));
    }
  }
}
void PDDL_Base::make_automaton_transition
(Symbol* s_from, Symbol* s_to, bool is_accept,
 CPG* f, bool neg_f, CPG* g, bool neg_g,
 PredicateSymbol* p_state, PredicateSymbol* p_accept,
 PredicateSymbol* p_synch)
{
  ActionSymbol* a_trans = (ActionSymbol*)gensym(sym_action, "trans", 0);
  a_trans->pos_pre.append(new Atom(p_state, s_from));
  a_trans->neg_pre.append(new Atom(p_synch));
  if (f) {
    add_precondition_formula(a_trans, f, neg_f);
  }
  if (g) {
    add_precondition_formula(a_trans, g, neg_g);
  }
  if (s_to != s_from) {
    a_trans->dels.append(new Atom(p_state, s_from));
    a_trans->adds.append(new Atom(p_state, s_to));
  }
  if (is_accept)
    a_trans->adds.append(new Atom(p_accept));
  else
    a_trans->dels.append(new Atom(p_accept));
  a_trans->adds.append(new Atom(p_synch));
  dom_actions.append(a_trans);
}
PDDL_Base::AtomicGoal* PDDL_Base::make_automaton_type_a
(CPG& f, index_type i, const Symbol* n, symbol_vec& aut_state, index_type n_ra)
{
  assert(aut_state.length() >= 2);
  assert(n_ra <= dom_actions.length());
  PredicateSymbol* p_state = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "state-", n, 0) :
     gensym_i(sym_predicate, "state-c", i, 0));
  VariableSymbol* param0 =
    (VariableSymbol*)gensym(sym_variable, "?s", aut_state[0]->sym_types);
  p_state->param.append(param0);
  p_state->pos_pre = true;
  p_state->added = true;
  p_state->deleted = true;
  p_state->modded = true;
  PredicateSymbol* p_accept = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "accepting-", n, 0) :
     gensym_i(sym_predicate, "accepting-c", i, 0));
  p_accept->pos_pre = true;
  p_accept->added = true;
  p_accept->deleted = true;
  p_accept->modded = true;
  PredicateSymbol* p_synch = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "updated-", n, 0) :
     gensym_i(sym_predicate, "updated-c", i, 0));
  p_synch->pos_pre = true;
  p_synch->neg_pre = true;
  p_synch->added = true;
  p_synch->deleted = true;
  p_synch->modded = true;
  dom_predicates.append(p_state);
  dom_predicates.append(p_accept);
  dom_predicates.append(p_synch);
  make_automaton_transition(aut_state[0], aut_state[1], true,
       &f, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[0], aut_state[2], false,
       0, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[1], aut_state[1], true,
       &f, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[1], aut_state[2], false,
       0, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[2], aut_state[2], false,
       0, false, 0, false,
       p_state, p_accept, p_synch);
  for (index_type k = 0; k < n_ra; k++) {
    dom_actions[k]->pos_pre.append(new Atom(p_synch));
    dom_actions[k]->dels.append(new Atom(p_synch));
  }
  Atom* a_synch = new Atom(p_synch);
  a_synch->insert(p_synch->pos_goal);
  dom_goals.append(new AtomicGoal(a_synch, false));
  Atom* a_init = new Atom(p_state);
  a_init->param.append(aut_state[0]);
  a_init->insert(p_state->init);
  dom_init.append(a_init);
  Atom* a_accept = new Atom(p_accept);
  a_accept->insert(p_accept->pos_goal);
  return new AtomicGoal(a_accept, false);
}
PDDL_Base::AtomicGoal* PDDL_Base::make_automaton_type_e
(CPG& f, index_type i, const Symbol* n, symbol_vec& aut_state, index_type n_ra)
{
  assert(aut_state.length() >= 2);
  assert(n_ra <= dom_actions.length());
  PredicateSymbol* p_state = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "state-", n, 0) :
     gensym_i(sym_predicate, "state-c", i, 0));
  VariableSymbol* param0 =
    (VariableSymbol*)gensym(sym_variable, "?s", aut_state[0]->sym_types);
  p_state->param.append(param0);
  p_state->pos_pre = true;
  p_state->added = true;
  p_state->deleted = true;
  p_state->modded = true;
  PredicateSymbol* p_accept = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "accepting-", n, 0) :
     gensym_i(sym_predicate, "accepting-c", i, 0));
  p_accept->pos_pre = true;
  p_accept->added = true;
  p_accept->deleted = true;
  p_accept->modded = true;
  PredicateSymbol* p_synch = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "updated-", n, 0) :
     gensym_i(sym_predicate, "updated-c", i, 0));
  p_synch->pos_pre = true;
  p_synch->neg_pre = true;
  p_synch->added = true;
  p_synch->deleted = true;
  p_synch->modded = true;
  dom_predicates.append(p_state);
  dom_predicates.append(p_accept);
  dom_predicates.append(p_synch);
  make_automaton_transition(aut_state[0], aut_state[1], false,
       0, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[0], aut_state[2], true,
       &f, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[1], aut_state[1], false,
       0, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[1], aut_state[2], true,
       &f, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[2], aut_state[3], true,
       0, false, 0, false,
       p_state, p_accept, p_synch);
  for (index_type k = 0; k < n_ra; k++) {
    dom_actions[k]->pos_pre.append(new Atom(p_synch));
    dom_actions[k]->dels.append(new Atom(p_synch));
  }
  Atom* a_synch = new Atom(p_synch);
  a_synch->insert(p_synch->pos_goal);
  dom_goals.append(new AtomicGoal(a_synch, false));
  Atom* a_init = new Atom(p_state);
  a_init->param.append(aut_state[0]);
  a_init->insert(p_state->init);
  dom_init.append(a_init);
  Atom* a_accept = new Atom(p_accept);
  a_accept->insert(p_accept->pos_goal);
  return new AtomicGoal(a_accept, false);
}
PDDL_Base::AtomicGoal* PDDL_Base::make_automaton_type_o
(CPG& f, index_type i, const Symbol* n, symbol_vec& aut_state, index_type n_ra)
{
  assert(aut_state.length() >= 2);
  assert(n_ra <= dom_actions.length());
  PredicateSymbol* p_state = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "state-", n, 0) :
     gensym_i(sym_predicate, "state-c", i, 0));
  VariableSymbol* param0 =
    (VariableSymbol*)gensym(sym_variable, "?s", aut_state[0]->sym_types);
  p_state->param.append(param0);
  p_state->pos_pre = true;
  p_state->added = true;
  p_state->deleted = true;
  p_state->modded = true;
  PredicateSymbol* p_accept = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "accepting-", n, 0) :
     gensym_i(sym_predicate, "accepting-c", i, 0));
  p_accept->pos_pre = true;
  p_accept->added = true;
  p_accept->deleted = true;
  p_accept->modded = true;
  PredicateSymbol* p_synch = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "updated-", n, 0) :
     gensym_i(sym_predicate, "updated-c", i, 0));
  p_synch->pos_pre = true;
  p_synch->neg_pre = true;
  p_synch->added = true;
  p_synch->deleted = true;
  p_synch->modded = true;
  dom_predicates.append(p_state);
  dom_predicates.append(p_accept);
  dom_predicates.append(p_synch);
  make_automaton_transition(aut_state[0], aut_state[1], true,
       &f, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[0], aut_state[2], true,
       &f, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[1], aut_state[1], true,
       &f, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[1], aut_state[2], true,
       &f, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[2], aut_state[2], true,
       &f, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[2], aut_state[3], true,
       &f, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[3], aut_state[3], true,
       &f, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[3], aut_state[4], false,
       0, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[4], aut_state[4], false,
       0, false, 0, false,
       p_state, p_accept, p_synch);
  for (index_type k = 0; k < n_ra; k++) {
    dom_actions[k]->pos_pre.append(new Atom(p_synch));
    dom_actions[k]->dels.append(new Atom(p_synch));
  }
  Atom* a_synch = new Atom(p_synch);
  a_synch->insert(p_synch->pos_goal);
  dom_goals.append(new AtomicGoal(a_synch, false));
  Atom* a_init = new Atom(p_state);
  a_init->param.append(aut_state[0]);
  a_init->insert(p_state->init);
  dom_init.append(a_init);
  Atom* a_accept = new Atom(p_accept);
  a_accept->insert(p_accept->pos_goal);
  return new AtomicGoal(a_accept, false);
}
PDDL_Base::AtomicGoal* PDDL_Base::make_automaton_type_sb
(CPG& f, CPG& g, index_type i, const Symbol* n, symbol_vec& aut_state,
 index_type n_ra)
{
  assert(aut_state.length() >= 2);
  assert(n_ra <= dom_actions.length());
  PredicateSymbol* p_state = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "state-", n, 0) :
     gensym_i(sym_predicate, "state-c", i, 0));
  VariableSymbol* param0 =
    (VariableSymbol*)gensym(sym_variable, "?s", aut_state[0]->sym_types);
  p_state->param.append(param0);
  p_state->pos_pre = true;
  p_state->added = true;
  p_state->deleted = true;
  p_state->modded = true;
  PredicateSymbol* p_accept = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "accepting-", n, 0) :
     gensym_i(sym_predicate, "accepting-c", i, 0));
  p_accept->pos_pre = true;
  p_accept->added = true;
  p_accept->deleted = true;
  p_accept->modded = true;
  PredicateSymbol* p_synch = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "updated-", n, 0) :
     gensym_i(sym_predicate, "updated-c", i, 0));
  p_synch->pos_pre = true;
  p_synch->neg_pre = true;
  p_synch->added = true;
  p_synch->deleted = true;
  p_synch->modded = true;
  dom_predicates.append(p_state);
  dom_predicates.append(p_accept);
  dom_predicates.append(p_synch);
  make_automaton_transition(aut_state[0], aut_state[1], true,
       &f, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[0], aut_state[2], true,
       &f, true, &g, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[0], aut_state[4], false,
       0, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[1], aut_state[1], true,
       &f, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[1], aut_state[2], true,
       &f, true, &g, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[1], aut_state[4], false,
       0, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[2], aut_state[3], true,
       0, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[3], aut_state[3], true,
       0, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[4], aut_state[4], false,
       0, true, 0, false,
       p_state, p_accept, p_synch);
  for (index_type k = 0; k < n_ra; k++) {
    dom_actions[k]->pos_pre.append(new Atom(p_synch));
    dom_actions[k]->dels.append(new Atom(p_synch));
  }
  Atom* a_synch = new Atom(p_synch);
  a_synch->insert(p_synch->pos_goal);
  dom_goals.append(new AtomicGoal(a_synch, false));
  Atom* a_init = new Atom(p_state);
  a_init->param.append(aut_state[0]);
  a_init->insert(p_state->init);
  dom_init.append(a_init);
  Atom* a_accept = new Atom(p_accept);
  a_accept->insert(p_accept->pos_goal);
  return new AtomicGoal(a_accept, false);
}
PDDL_Base::AtomicGoal* PDDL_Base::make_automaton_type_sa
(CPG& f, CPG& g, index_type i, const Symbol* n, symbol_vec& aut_state,
 index_type n_ra)
{
  assert(aut_state.length() >= 2);
  assert(n_ra <= dom_actions.length());
  PredicateSymbol* p_state = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "state-", n, 0) :
     gensym_i(sym_predicate, "state-c", i, 0));
  VariableSymbol* param0 =
    (VariableSymbol*)gensym(sym_variable, "?s", aut_state[0]->sym_types);
  p_state->param.append(param0);
  p_state->pos_pre = true;
  p_state->added = true;
  p_state->deleted = true;
  p_state->modded = true;
  PredicateSymbol* p_accept = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "accepting-", n, 0) :
     gensym_i(sym_predicate, "accepting-c", i, 0));
  p_accept->pos_pre = true;
  p_accept->added = true;
  p_accept->deleted = true;
  p_accept->modded = true;
  PredicateSymbol* p_synch = (PredicateSymbol*)
    (n ? gensym_s(sym_predicate, "updated-", n, 0) :
     gensym_i(sym_predicate, "updated-c", i, 0));
  p_synch->pos_pre = true;
  p_synch->neg_pre = true;
  p_synch->added = true;
  p_synch->deleted = true;
  p_synch->modded = true;
  dom_predicates.append(p_state);
  dom_predicates.append(p_accept);
  dom_predicates.append(p_synch);
  make_automaton_transition(aut_state[0], aut_state[1], true,
       0, false, &g, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[0], aut_state[2], false,
       &f, false, &g, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[0], aut_state[3], true,
       &f, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[1], aut_state[1], true,
       0, false, &g, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[1], aut_state[2], false,
       0, false, &g, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[1], aut_state[3], true,
       &f, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[2], aut_state[1], true,
       0, false, &g, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[2], aut_state[4], false,
       0, false, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[3], aut_state[1], true,
       0, false, &g, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[3], aut_state[2], false,
       0, false, &g, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[3], aut_state[3], true,
       &f, true, 0, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[4], aut_state[1], true,
       0, false, &g, false,
       p_state, p_accept, p_synch);
  make_automaton_transition(aut_state[2], aut_state[4], false,
       0, false, 0, false,
       p_state, p_accept, p_synch);
  for (index_type k = 0; k < n_ra; k++) {
    dom_actions[k]->pos_pre.append(new Atom(p_synch));
    dom_actions[k]->dels.append(new Atom(p_synch));
  }
  Atom* a_synch = new Atom(p_synch);
  a_synch->insert(p_synch->pos_goal);
  dom_goals.append(new AtomicGoal(a_synch, false));
  Atom* a_init = new Atom(p_state);
  a_init->param.append(aut_state[0]);
  a_init->insert(p_state->init);
  dom_init.append(a_init);
  Atom* a_accept = new Atom(p_accept);
  a_accept->insert(p_accept->pos_goal);
  return new AtomicGoal(a_accept, false);
}
PDDL_Base::Goal* PDDL_Base::compile_constraint_1
(PDDL_Base::Goal* g, index_type i, const Symbol* n,
 symbol_vec& aut_states, index_type n_ra)
{
  if (g->g_class == goal_always) {
    SimpleSequenceGoal* g1 = (SimpleSequenceGoal*)g;
    CPG f;
    bool ok = g1->constraint->makeCPG(f);
    if (!ok) {
      if (write_warnings || !best_effort) {
 std::cerr << "warning: can't compile goal ";
 g->print(std::cerr);
 std::cerr << std::endl;
 if (!best_effort) exit(1);
      }
      return g;
    }
    return make_automaton_type_a(f, i, n, aut_states, n_ra);
  }
  else if (g->g_class == goal_sometime) {
    SimpleSequenceGoal* g1 = (SimpleSequenceGoal*)g;
    CPG f;
    bool ok = g1->constraint->makeCPG(f);
    if (!ok) {
      if (write_warnings || !best_effort) {
 std::cerr << "warning: can't compile goal ";
 g->print(std::cerr);
 std::cerr << std::endl;
 if (!best_effort) exit(1);
      }
      return g;
    }
    return make_automaton_type_e(f, i, n, aut_states, n_ra);
  }
  else if (g->g_class == goal_at_most_once) {
    SimpleSequenceGoal* g1 = (SimpleSequenceGoal*)g;
    CPG f;
    bool ok = g1->constraint->makeCPG(f);
    if (!ok) {
      if (write_warnings || !best_effort) {
 std::cerr << "warning: can't compile goal ";
 g->print(std::cerr);
 std::cerr << std::endl;
 if (!best_effort) exit(1);
      }
      return g;
    }
    return make_automaton_type_o(f, i, n, aut_states, n_ra);
  }
  else if (g->g_class == goal_sometime_before) {
    TriggeredSequenceGoal* g1 = (TriggeredSequenceGoal*)g;
    CPG f1;
    bool ok = g1->trigger->makeCPG(f1);
    CPG f2;
    ok = (ok && g1->constraint->makeCPG(f2));
    if (!ok) {
      if (write_warnings || !best_effort) {
 std::cerr << "warning: can't compile goal ";
 g->print(std::cerr);
 std::cerr << std::endl;
 if (!best_effort) exit(1);
      }
      return g;
    }
    return make_automaton_type_sb(f1, f2, i, n, aut_states, n_ra);
  }
  else if (g->g_class == goal_sometime_after) {
    TriggeredSequenceGoal* g1 = (TriggeredSequenceGoal*)g;
    CPG f1;
    bool ok = g1->trigger->makeCPG(f1);
    CPG f2;
    ok = (ok && g1->constraint->makeCPG(f2));
    if (!ok) {
      if (write_warnings || !best_effort) {
 std::cerr << "warning: can't compile goal ";
 g->print(std::cerr);
 std::cerr << std::endl;
 if (!best_effort) exit(1);
      }
      return g;
    }
    return make_automaton_type_sa(f1, f2, i, n, aut_states, n_ra);
  }
  else if (!g->is_state()) {
    if (write_warnings || !best_effort) {
      std::cerr << "warning: can't compile goal ";
      g->print(std::cerr);
      std::cerr << std::endl;
      if (!best_effort) exit(1);
    }
  }
  return g;
}
void PDDL_Base::compile_constraints_1()
{
  index_type n_regular_actions = dom_actions.length();
  symbol_vec aut_states;
  aut_states.append(gensym(sym_object, "aut-state-s0", 0));
  aut_states.append(gensym(sym_object, "aut-state-s1", 0));
  aut_states.append(gensym(sym_object, "aut-state-s2", 0));
  aut_states.append(gensym(sym_object, "aut-state-s3", 0));
  aut_states.append(gensym(sym_object, "aut-state-s4", 0));
  index_type n_goals = dom_goals.length();
  for (index_type k = 0; k < n_goals; k++) {
    dom_goals[k] =
      compile_constraint_1(dom_goals[k], k, 0, aut_states, n_regular_actions);
  }
  for (index_type k = 0; k < dom_preferences.length(); k++) {
    dom_preferences[k]->goal =
      compile_constraint_1(dom_preferences[k]->goal,
      dom_goals.length() + k,
      dom_preferences[k]->name,
      aut_states, n_regular_actions);
  }
  dom_constants.append(aut_states);
  for (index_type k = 0; k < dom_constants.length(); k++)
    dom_constants[k]->defined_in_problem = false;
}
PDDL_Base::Goal* PDDL_Base::compile_always_constraint
(SimpleSequenceGoal* g, const Symbol* n)
{
  current_eq_predicate = dom_eq_pred;
  if (write_info) {
    std::cerr << "info: compiling constraint ";
    g->print(std::cerr);
    std::cerr << std::endl;
  }
  CPG f;
  if (!g->constraint->makeCPG(f)) {
    if (write_warnings || !best_effort) {
      std::cerr << "warning: can't compile goal ";
      g->print(std::cerr);
      std::cerr << std::endl;
      if (!best_effort) exit(1);
    }
    return g;
  }
  PredicateSymbol* p_ok =
    (PredicateSymbol*)gensym_s(sym_predicate, "ok-", n, 0);
  make_parameters(f.arg_types, "?arg", p_ok->param);
  p_ok->pos_pre = true;
  dom_predicates.append(p_ok);
  if (write_info) {
    std::cerr << "info: created predicate ";
    p_ok->print(std::cerr);
    std::cerr << std::endl;
  }
  Atom* a_ok = new Atom(p_ok);
  a_ok->param = f.args;
  a_ok->insert(p_ok->pos_goal);
  if (f.initial_value()) {
    Atom* a_init = new Atom(p_ok);
    a_init->param = f.args;
    a_init->insert(p_ok->init);
    dom_init.append(a_init);
    p_ok->deleted = true;
    p_ok->modded = true;
    for (index_type k = 0; k < dom_actions.length(); k++) {
      f.add_destroying_effects(dom_actions[k], p_ok, p_ok, false, 0, 0, 0, false);
    }
  }
  return new AtomicGoal(a_ok, false);
}
PDDL_Base::Goal* PDDL_Base::compile_sometime_constraint
(SimpleSequenceGoal* g, const Symbol* n)
{
  current_eq_predicate = dom_eq_pred;
  if (write_info) {
    std::cerr << "info: compiling constraint ";
    g->print(std::cerr);
    std::cerr << std::endl;
  }
  CPG f;
  if (!g->constraint->makeCPG(f)) {
    if (write_warnings || !best_effort) {
      std::cerr << "warning: can't compile goal ";
      g->print(std::cerr);
      std::cerr << std::endl;
      if (!best_effort) exit(1);
    }
    return g;
  }
  PredicateSymbol* p_ok =
    (PredicateSymbol*)gensym_s(sym_predicate, "ok-", n, 0);
  make_parameters(f.arg_types, "?arg", p_ok->param);
  p_ok->pos_pre = true;
  dom_predicates.append(p_ok);
  if (write_info) {
    std::cerr << "info: created predicate ";
    p_ok->print(std::cerr);
    std::cerr << std::endl;
  }
  Atom* a_ok = new Atom(p_ok);
  a_ok->param = f.args;
  a_ok->insert(p_ok->pos_goal);
  if (f.initial_value()) {
    Atom* a_init = new Atom(p_ok);
    a_init->param = f.args;
    a_init->insert(p_ok->init);
    dom_init.append(a_init);
  }
  else {
    p_ok->added = true;
    p_ok->modded = true;
    for (index_type k = 0; k < dom_actions.length(); k++) {
      f.add_asserting_effects(dom_actions[k], p_ok, true, 0, 0, 0, false);
    }
  }
  return new AtomicGoal(a_ok, false);
}
PDDL_Base::Goal* PDDL_Base::compile_at_most_once_constraint
(SimpleSequenceGoal* g, const Symbol* n)
{
  current_eq_predicate = dom_eq_pred;
  if (write_info) {
    std::cerr << "info: compiling constraint ";
    g->print(std::cerr);
    std::cerr << std::endl;
  }
  CPG f;
  if (!g->constraint->makeCPG(f)) {
    if (write_warnings || !best_effort) {
      std::cerr << "warning: can't compile goal ";
      g->print(std::cerr);
      std::cerr << std::endl;
      if (!best_effort) exit(1);
    }
    return g;
  }
  PredicateSymbol* p_once =
    (PredicateSymbol*)gensym_s(sym_predicate, "once-", n, 0);
  make_parameters(f.arg_types, "?arg", p_once->param);
  p_once->pos_pre = true;
  p_once->added = true;
  p_once->modded = true;
  dom_predicates.append(p_once);
  PredicateSymbol* p_ok =
    (PredicateSymbol*)gensym_s(sym_predicate, "ok-", n, 0);
  make_parameters(f.arg_types, "?arg", p_ok->param);
  p_ok->pos_pre = true;
  p_ok->deleted = true;
  p_ok->modded = true;
  dom_predicates.append(p_ok);
  if (write_info) {
    std::cerr << "info: created predicates ";
    p_once->print(std::cerr);
    std::cerr << " and ";
    p_ok->print(std::cerr);
    std::cerr << std::endl;
  }
  Atom* a_ok = new Atom(p_ok);
  a_ok->param = f.args;
  a_ok->insert(p_ok->pos_goal);
  Atom* a_init = new Atom(p_ok);
  a_init->param = f.args;
  a_init->insert(p_ok->init);
  dom_init.append(a_init);
  for (index_type k = 0; k < dom_actions.length(); k++) {
    f.add_destroying_effects(dom_actions[k], p_once, p_once, true, 0, 0, 0, true);
  }
  for (index_type k = 0; k < dom_actions.length(); k++) {
    bool_vec sat(false, f.atoms.length());
    symbol_pair_vec eq;
    symbol_pair_vec neq;
    f.add_asserting_effects(dom_actions[k], p_ok, false, p_once, 0, 0, true);
  }
  return new AtomicGoal(a_ok, false);
}
PDDL_Base::Goal* PDDL_Base::compile_sometime_before_constraint
(TriggeredSequenceGoal* g, const Symbol* n)
{
  current_eq_predicate = dom_eq_pred;
  if (write_info) {
    std::cerr << "info: compiling constraint ";
    g->print(std::cerr);
    std::cerr << std::endl;
  }
  CPG m;
  index_vec s1;
  bool ok = g->trigger->makeCPG(m, s1);
  index_vec s2;
  ok = (ok && g->constraint->makeCPG(m, s2));
  if (!ok) {
    if (write_warnings || !best_effort) {
      std::cerr << "warning: can't compile goal ";
      g->print(std::cerr);
      std::cerr << std::endl;
      if (!best_effort) exit(1);
    }
    return g;
  }
  CPG f_tr(m, s1);
  CPG f_c(m, s2);
  PredicateSymbol* p_not_safe =
    (PredicateSymbol*)gensym_s(sym_predicate, "not-safe-", n, 0);
  make_parameters(f_c.arg_types, "?arg", p_not_safe->param);
  p_not_safe->pos_pre = true;
  p_not_safe->deleted = true;
  p_not_safe->modded = true;
  dom_predicates.append(p_not_safe);
  PredicateSymbol* p_ok =
    (PredicateSymbol*)gensym_s(sym_predicate, "ok-", n, 0);
  make_parameters(f_tr.arg_types, "?arg", p_ok->param);
  p_ok->pos_pre = true;
  p_ok->deleted = true;
  p_ok->modded = true;
  dom_predicates.append(p_ok);
  if (write_info) {
    std::cerr << "info: created predicates ";
    p_not_safe->print(std::cerr);
    std::cerr << " and ";
    p_ok->print(std::cerr);
    std::cerr << std::endl;
  }
  Atom* a_ok = new Atom(p_ok);
  a_ok->param = f_tr.args;
  a_ok->insert(p_ok->pos_goal);
  if (!f_tr.initial_value()) {
    Atom* a_init = new Atom(p_ok);
    a_init->param = f_tr.args;
    a_init->insert(p_ok->init);
    dom_init.append(a_init);
  }
  if (!f_c.initial_value()) {
    Atom* a_init = new Atom(p_not_safe);
    a_init->param = f_c.args;
    a_init->insert(p_not_safe->init);
    dom_init.append(a_init);
  }
  for (index_type k = 0; k < dom_actions.length(); k++) {
    bool_vec sat(false, f_c.atoms.length());
    symbol_pair_vec eq;
    symbol_pair_vec neq;
    f_c.add_asserting_effects(dom_actions[k], p_not_safe, false, 0, 0, 0, false);
  }
  for (index_type k = 0; k < dom_actions.length(); k++) {
    bool_vec sat(false, f_c.atoms.length());
    symbol_pair_vec eq;
    symbol_pair_vec neq;
    f_tr.add_asserting_effects(dom_actions[k], p_ok, false, p_not_safe, 0, 0, false);
  }
  return new AtomicGoal(a_ok, false);
}
PDDL_Base::Goal* PDDL_Base::compile_constraint_2
(PDDL_Base::Goal* g, const Symbol* n)
{
  if (g->g_class == goal_always) {
    return compile_always_constraint((SimpleSequenceGoal*)g, n);
  }
  else if (g->g_class == goal_sometime) {
    return compile_sometime_constraint((SimpleSequenceGoal*)g, n);
  }
  else if (g->g_class == goal_at_most_once) {
    return compile_at_most_once_constraint((SimpleSequenceGoal*)g, n);
  }
  else if (g->g_class == goal_sometime_before) {
    return compile_sometime_before_constraint((TriggeredSequenceGoal*)g, n);
  }
  else if (g->g_class == goal_sometime_after) {
    if (write_warnings || !best_effort) {
      std::cerr << "warning: compilation of goal ";
      g->print(std::cerr);
      std::cerr << " not implemented" << std::endl;
      if (!best_effort) exit(1);
    }
    return g;
  }
  else if (!g->is_state()) {
    if (write_warnings || !best_effort) {
      std::cerr << "warning: can't compile goal ";
      g->print(std::cerr);
      std::cerr << std::endl;
      if (!best_effort) exit(1);
    }
  }
  return g;
}
void PDDL_Base::compile_constraints_2()
{
  for (index_type k = 0; k < dom_goals.length(); k++) {
    Symbol* c_name = gensym_i(sym_misc, "c", k, 0);
    dom_goals[k] = compile_constraint_2(dom_goals[k], c_name);
  }
  for (index_type k = 0; k < dom_preferences.length(); k++) {
    Symbol* c_name = (dom_preferences[k]->name ?
        dom_preferences[k]->name :
        gensym_i(sym_misc, "p", k, 0));
    dom_preferences[k]->goal =
      compile_constraint_2(dom_preferences[k]->goal, c_name);
  }
}
void PDDL_Base::metric_to_goal(hsps::rational bound)
{
  if ((metric_type == metric_minimize) ||
      (metric_type == metric_maximize)) {
    Relation* r = new Relation((metric_type == metric_minimize ?
    rel_less : rel_greater),
          metric,
          new ConstantExpression(bound));
    dom_goals.append(new NumericGoal(r));
    metric_type = metric_none;
    metric = 0;
  }
  else if (write_warnings || !best_effort) {
    std::cerr << "warning: metric type " << metric_type
       << " can not be converted to bounded goal"
       << std::endl;
    if (!best_effort) exit(1);
  }
}
void PDDL_Base::select_preferences(const bool_vec& sel)
{
  for (index_type k = 0; k < dom_preferences.length(); k++) {
    if (sel[k]) {
      dom_goals.append(dom_preferences[k]->goal);
    }
    if (dom_preferences[k]->name && metric) {
      Expression* e = new ConstantExpression(sel[k] ? 0 : 1);
      metric = metric->substitute_for_preference(dom_preferences[k]->name, e);
    }
  }
  dom_preferences.assign_value(0, 0);
}
void PDDL_Base::compile_set_conditions_and_effects
(ActionSymbol* act, variable_vec& i_param, variable_vec& d_param, index_type p)
{
  if (p < d_param.length()) {
    for (index_type k = 0; k < d_param[p]->sym_types.n_elements(); k++) {
      d_param[p]->value = d_param[p]->sym_types.get_element(k);
      bool pass = true;
      for (index_type k = 0; (k < act->pos_pre.length()) && pass; k++)
 if (act->pos_pre[k]->is_static()) {
   partial_value v = act->pos_pre[k]->partial_eval();
   if (v == p_false) pass = false;
 }
      for (index_type k = 0; (k < act->neg_pre.length()) && pass; k++)
 if (act->neg_pre[k]->is_static()) {
   partial_value v = act->neg_pre[k]->partial_eval();
   if (v == p_true) pass = false;
 }
      for (index_type k = 0; (k < act->num_pre.length()) && pass; k++) {
 partial_value v = act->num_pre[k]->partial_eval();
 if (v == p_false) pass = false;
      }
      if (pass)
 compile_set_conditions_and_effects(act, i_param, d_param, p + 1);
    }
    d_param[p]->value = 0;
  }
  else {
    if (d_param.length() == 0) {
      for (index_type k = 0; k < act->pos_pre.length(); k++)
 if (act->pos_pre[k]->is_static()) {
   partial_value v = act->pos_pre[k]->partial_eval();
   if (v == p_false) return;
 }
      for (index_type k = 0; k < act->neg_pre.length(); k++)
 if (act->neg_pre[k]->is_static()) {
   partial_value v = act->neg_pre[k]->partial_eval();
   if (v == p_true) return;
 }
    }
    ActionSymbol* new_act =
      (ActionSymbol*)gensym(sym_action, act->print_name, 0);
    new_act->param = i_param;
    for (index_type k = 0; k < act->pos_pre.length(); k++)
      new_act->pos_pre.append(act->pos_pre[k]->instantiate_partially());
    for (index_type k = 0; k < act->neg_pre.length(); k++)
      new_act->neg_pre.append(act->neg_pre[k]->instantiate_partially());
    for (index_type k = 0; k < act->dis_pre.length(); k++)
      new_act->dis_pre.append(act->dis_pre[k]->instantiate_partially());
    for (index_type k = 0; k < act->set_pre.length(); k++) {
      if (act->set_pre[k]->context_is_static()) {
 act->set_pre[k]->compile(new_act->pos_pre, new_act->neg_pre, 0);
      }
      else {
 act->set_pre[k]->compile_non_static(new_act->dis_pre, 0);
      }
    }
    for (index_type k = 0; k < act->adds.length(); k++)
      new_act->adds.append(act->adds[k]->instantiate_partially());
    for (index_type k = 0; k < act->dels.length(); k++)
      new_act->dels.append(act->dels[k]->instantiate_partially());
    for (index_type k = 0; k < act->set_eff.length(); k++) {
      assert(act->set_eff[k]->context_is_static());
      act->set_pre[k]->compile(new_act->pos_pre, new_act->neg_pre, 0);
    }
    for (index_type k = 0; k < act->cond_eff.length(); k++)
      new_act->cond_eff.append(act->cond_eff[k]->instantiate_partially());
    for (index_type k = 0; k < act->locks.length(); k++)
      new_act->locks.append(act->locks[k]->instantiate_partially());
    for (index_type k = 0; k < act->enables.length(); k++)
      new_act->enables.append(act->enables[k]->instantiate_partially());
    new_act->dmin = act->dmin;
    new_act->dmax = act->dmax;
    for (index_type k = 0; k < act->irr_ins.length(); k++)
      new_act->irr_ins.append(act->irr_ins[k]->instantiate_partially());
    for (index_type k = 0; k < act->refs.length(); k++)
      new_act->refs.append(act->refs[k]->instantiate_partially());
    if (act->part)
      new_act->part = act->part->instantiate_partially();
    new_act->assoc = act->assoc;
    new_act->post_process();
    dom_actions.append(new_act);
  }
}
void PDDL_Base::compile_set_conditions_and_effects(ActionSymbol* act)
{
  variable_vec dp(0, 0);
  variable_vec ip(0, 0);
  for (index_type k = 0; k < act->param.length(); k++) {
    bool found = false;
    for (index_type i = 0; (i < act->set_pre.length()) && !found; i++)
      if (act->set_pre[i]->occurs_in_context(act->param[k])) {
 dp.append(act->param[k]);
 found = true;
      }
    for (index_type i = 0; (i < act->set_eff.length()) && !found; i++)
      if (act->set_eff[i]->occurs_in_context(act->param[k])) {
 dp.append(act->param[k]);
 found = true;
      }
    if (!found)
      ip.append(act->param[k]);
  }
  act->clear_arguments();
  compile_set_conditions_and_effects(act, ip, dp, 0);
}
void PDDL_Base::compile_set_conditions_and_effects()
{
  lvector<ActionSymbol*> acts(dom_actions);
  dom_actions.clear();
  for (index_type k = 0; k < acts.length(); k++) {
    if ((acts[k]->set_pre.length() > 0) ||
 (acts[k]->set_eff.length() > 0))
      compile_set_conditions_and_effects(acts[k]);
    else
      dom_actions.append(acts[k]);
  }
}
PDDL_Base::Atom* PDDL_Base::make_binding_atom(VariableSymbol* v)
{
  FTerm* bt = v->binding;
  assert(bt != 0);
  hsps::StringTable::Cell* c =
    (hsps::StringTable::Cell*)tab.find(bt->fun->print_name);
  assert(c != 0);
  PredicateSymbol* p = (PredicateSymbol*)c->val;
  assert(p->sym_class == sym_predicate);
  assert(p->param.length() == (bt->fun->param.length() + 1));
  assert(bt->param.length() == bt->fun->param.length());
  Atom* a = new Atom(p);
  for (index_type i = 0; i < bt->param.length(); i++)
    a->param.append(bt->param[i]);
  a->param.append(v);
  return a;
}
void PDDL_Base::compile_object_functions
(ActionSymbol* act, Symbol* undefined_value)
{
  variable_vec pre_omsk_vars(0, 0);
  for (index_type k = 0; k < act->pos_pre.length(); k++)
    act->pos_pre[k]->collect_bound_variables(pre_omsk_vars);
  for (index_type k = 0; k < act->neg_pre.length(); k++)
    act->neg_pre[k]->collect_bound_variables(pre_omsk_vars);
  for (index_type k = 0; k < act->adds.length(); k++) {
    if (act->adds[k]->pred == dom_assign_pred) {
      assert(act->adds[k]->param[0]->sym_class == sym_variable);
      assert(((VariableSymbol*)(act->adds[k]->param[0]))->binding != 0);
      ((VariableSymbol*)(act->adds[k]->param[0]))->binding->collect_bound_variables(pre_omsk_vars);
      if (act->adds[k]->param[1]->sym_class == sym_variable) {
 if (((VariableSymbol*)(act->adds[k]->param[1]))->binding != 0) {
   pre_omsk_vars.append((VariableSymbol*)act->adds[k]->param[1]);
   ((VariableSymbol*)(act->adds[k]->param[1]))->binding->collect_bound_variables(pre_omsk_vars);
 }
      }
    }
    else {
      act->adds[k]->collect_bound_variables(pre_omsk_vars);
    }
  }
  for (index_type k = 0; k < act->dels.length(); k++)
    act->dels[k]->collect_bound_variables(pre_omsk_vars);
  for (index_type k = 0; k < pre_omsk_vars.length(); k++) {
    act->pos_pre.append(make_binding_atom(pre_omsk_vars[k]));
  }
  index_set assigns;
  index_type n_adds = act->adds.length();
  for (index_type k = 0; k < n_adds; k++)
    if (act->adds[k]->pred == dom_assign_pred) {
      assigns.insert(k);
      assert(act->adds[k]->param[0]->sym_class == sym_variable);
      assert(((VariableSymbol*)(act->adds[k]->param[0]))->binding != 0);
      FTerm* bt = ((VariableSymbol*)(act->adds[k]->param[0]))->binding;
      hsps::StringTable::Cell* c =
 (hsps::StringTable::Cell*)tab.find(bt->fun->print_name);
      assert(c != 0);
      PredicateSymbol* p = (PredicateSymbol*)c->val;
      assert(p->sym_class == sym_predicate);
      assert(p->param.length() == (bt->fun->param.length() + 1));
      assert(bt->param.length() == bt->fun->param.length());
      VariableSymbol* m = 0;
      for (index_type i = 0; (i < pre_omsk_vars.length()) && (m == 0); i++)
 if (pre_omsk_vars[i]->binding->equals(*bt))
   m = pre_omsk_vars[i];
      if (m != 0) {
 Atom* a_out = new Atom(p);
 for (index_type i = 0; i < bt->param.length(); i++)
   a_out->param.append(bt->param[i]);
 a_out->param.append(m);
 act->dels.append(a_out);
      }
      else {
 VariableSymbol* v_pre =
   (VariableSymbol*)gensym(sym_variable, "?fval",
      p->param[p->param.length() - 1]->sym_types);
 v_pre->visible = false;
 Atom* a_pre = new Atom(p);
 for (index_type i = 0; i < bt->param.length(); i++)
   a_pre->param.append(bt->param[i]);
 a_pre->param.append(v_pre);
 act->param.append(v_pre);
 act->pos_pre.append(a_pre);
 act->dels.append(a_pre);
      }
      Atom* a_in = new Atom(p);
      for (index_type i = 0; i < bt->param.length(); i++)
 a_in->param.append(bt->param[i]);
      if (act->adds[k]->param[1] == dom_undefined_obj)
 a_in->param.append(undefined_value);
      else
 a_in->param.append(act->adds[k]->param[1]);
      act->adds.append(a_in);
    }
  act->adds.remove(assigns);
  for (index_type k = 0; k < pre_omsk_vars.length(); k++) {
    act->param.append(pre_omsk_vars[k]);
    pre_omsk_vars[k]->visible = false;
    pre_omsk_vars[k]->binding = 0;
  }
}
void PDDL_Base::compile_object_functions_for_validator(ActionSymbol* act)
{
  index_set rm_pos_pre;
  for (index_type k = 0; k < act->pos_pre.length(); k++) {
    variable_vec pre_omsk_vars(0, 0);
    act->pos_pre[k]->collect_bound_variables(pre_omsk_vars);
    if (pre_omsk_vars.length() > 0) {
      SetOf* q = new SetOf();
      for (index_type i = 0; i < pre_omsk_vars.length(); i++) {
 q->param.append(pre_omsk_vars[i]);
 q->pos_con.append(make_binding_atom(pre_omsk_vars[i]));
 pre_omsk_vars[i]->binding = 0;
      }
      q->pos_atoms.append(act->pos_pre[k]);
      act->dis_pre.append(q);
      rm_pos_pre.insert(k);
    }
  }
  act->pos_pre.remove(rm_pos_pre);
  index_set rm_neg_pre;
  for (index_type k = 0; k < act->neg_pre.length(); k++) {
    variable_vec pre_omsk_vars(0, 0);
    act->neg_pre[k]->collect_bound_variables(pre_omsk_vars);
    if (pre_omsk_vars.length() > 0) {
      SetOf* q = new SetOf();
      for (index_type i = 0; i < pre_omsk_vars.length(); i++) {
 q->param.append(pre_omsk_vars[i]);
 q->pos_con.append(make_binding_atom(pre_omsk_vars[i]));
 pre_omsk_vars[i]->binding = 0;
      }
      q->neg_atoms.append(act->neg_pre[k]);
      act->dis_pre.append(q);
      rm_neg_pre.insert(k);
    }
  }
  act->neg_pre.remove(rm_neg_pre);
  index_set rm_adds;
  for (index_type k = 0; k < act->adds.length(); k++) {
    if (act->adds[k]->pred == dom_assign_pred) {
      variable_vec omsk_vars(0, 0);
      assert(act->adds[k]->param[0]->sym_class == sym_variable);
      assert(((VariableSymbol*)(act->adds[k]->param[0]))->binding != 0);
      ((VariableSymbol*)(act->adds[k]->param[0]))->binding->collect_bound_variables(omsk_vars);
      if (act->adds[k]->param[1]->sym_class == sym_variable) {
 if (((VariableSymbol*)(act->adds[k]->param[1]))->binding != 0) {
   omsk_vars.append((VariableSymbol*)act->adds[k]->param[1]);
   ((VariableSymbol*)(act->adds[k]->param[1]))->binding->collect_bound_variables(omsk_vars);
 }
      }
      FTerm* bt = ((VariableSymbol*)(act->adds[k]->param[0]))->binding;
      hsps::StringTable::Cell* c =
 (hsps::StringTable::Cell*)tab.find(bt->fun->print_name);
      assert(c != 0);
      PredicateSymbol* p = (PredicateSymbol*)c->val;
      assert(p->sym_class == sym_predicate);
      assert(p->param.length() == (bt->fun->param.length() + 1));
      assert(bt->param.length() == bt->fun->param.length());
      SetOf* s_out = new SetOf();
      VariableSymbol* v_nb =
 new VariableSymbol(act->adds[k]->param[0]->print_name);
      v_nb->sym_types.assign_copy(act->adds[k]->param[0]->sym_types);
      s_out->param.append(v_nb);
      if (act->adds[k]->param[1] != dom_undefined_obj) {
 Atom* a_neq = new Atom(dom_eq_pred);
 a_neq->param.append(v_nb);
 a_neq->param.append(act->adds[k]->param[1]);
 s_out->neg_con.append(a_neq);
      }
      for (index_type i = 0; i < omsk_vars.length(); i++) {
 s_out->param.append(omsk_vars[i]);
 s_out->pos_con.append(make_binding_atom(omsk_vars[i]));
      }
      Atom* a_out = new Atom(p);
      for (index_type i = 0; i < bt->param.length(); i++)
 a_out->param.append(bt->param[i]);
      a_out->param.append(v_nb);
      s_out->neg_atoms.append(a_out);
      act->cond_eff.append(s_out);
      if (act->adds[k]->param[1] != dom_undefined_obj) {
 if (omsk_vars.length() > 0) {
   SetOf* s_in = new SetOf();
   for (index_type i = 0; i < omsk_vars.length(); i++) {
     s_in->param.append(omsk_vars[i]);
     s_in->pos_con.append(make_binding_atom(omsk_vars[i]));
   }
   Atom* a_in = new Atom(p);
   for (index_type i = 0; i < bt->param.length(); i++)
     a_in->param.append(bt->param[i]);
   a_in->param.append(act->adds[k]->param[1]);
   s_in->pos_atoms.append(a_in);
   act->cond_eff.append(s_in);
 }
 else {
   Atom* a_in = new Atom(p);
   for (index_type i = 0; i < bt->param.length(); i++)
     a_in->param.append(bt->param[i]);
   a_in->param.append(act->adds[k]->param[1]);
   act->adds.append(a_in);
 }
      }
      for (index_type i = 0; i < omsk_vars.length(); i++)
 omsk_vars[i]->binding = 0;
      rm_adds.insert(k);
    }
    else {
      variable_vec omsk_vars(0, 0);
      act->adds[k]->collect_bound_variables(omsk_vars);
      if (omsk_vars.length() > 0) {
 SetOf* q = new SetOf();
 for (index_type i = 0; i < omsk_vars.length(); i++) {
   q->param.append(omsk_vars[i]);
   q->pos_con.append(make_binding_atom(omsk_vars[i]));
   omsk_vars[i]->binding = 0;
 }
 q->pos_atoms.append(act->adds[k]);
 act->cond_eff.append(q);
 rm_adds.insert(k);
      }
    }
  }
  act->adds.remove(rm_adds);
  index_set rm_dels;
  for (index_type k = 0; k < act->dels.length(); k++) {
    variable_vec omsk_vars(0, 0);
    act->dels[k]->collect_bound_variables(omsk_vars);
    if (omsk_vars.length() > 0) {
      SetOf* q = new SetOf();
      for (index_type i = 0; i < omsk_vars.length(); i++) {
 q->param.append(omsk_vars[i]);
 q->pos_con.append(make_binding_atom(omsk_vars[i]));
 omsk_vars[i]->binding = 0;
      }
      q->neg_atoms.append(act->dels[k]);
      act->cond_eff.append(q);
      rm_dels.insert(k);
    }
  }
  act->dels.remove(rm_dels);
}
PDDL_Base::Goal* PDDL_Base::compile_object_functions(Goal* g)
{
  if ((g->g_class == goal_pos_atom) ||
      (g->g_class == goal_neg_atom)) {
    AtomicGoal* ag = (AtomicGoal*)g;
    if (ag->atom->pred == dom_eq_pred) {
      assert(ag->atom->param.length() == 2);
      if ((ag->atom->param[0]->sym_class == sym_variable) &&
   (ag->atom->param[1]->sym_class == sym_object)) {
 if (((VariableSymbol*)ag->atom->param[0])->binding != 0) {
   VariableSymbol* v = (VariableSymbol*)ag->atom->param[0];
   Symbol* co = ag->atom->param[1];
   FTerm* bt = v->binding;
   assert(bt != 0);
   hsps::StringTable::Cell* c =
     (hsps::StringTable::Cell*)tab.find(bt->fun->print_name);
   assert(c != 0);
   PredicateSymbol* p = (PredicateSymbol*)c->val;
   assert(p->sym_class == sym_predicate);
   assert(p->param.length() == (bt->fun->param.length() + 1));
   assert(bt->param.length() == bt->fun->param.length());
   Atom* a = new Atom(p);
   for (index_type i = 0; i < bt->param.length(); i++)
     a->param.append(bt->param[i]);
   a->param.append(co);
   ag->atom = a;
   return g;
 }
      }
      if ((ag->atom->param[1]->sym_class == sym_variable) &&
   (ag->atom->param[0]->sym_class == sym_object)) {
 if (((VariableSymbol*)ag->atom->param[1])->binding != 0) {
   VariableSymbol* v = (VariableSymbol*)ag->atom->param[1];
   Symbol* co = ag->atom->param[0];
   FTerm* bt = v->binding;
   assert(bt != 0);
   hsps::StringTable::Cell* c =
     (hsps::StringTable::Cell*)tab.find(bt->fun->print_name);
   assert(c != 0);
   PredicateSymbol* p = (PredicateSymbol*)c->val;
   assert(p->sym_class == sym_predicate);
   assert(p->param.length() == (bt->fun->param.length() + 1));
   assert(bt->param.length() == bt->fun->param.length());
   Atom* a = new Atom(p);
   for (index_type i = 0; i < bt->param.length(); i++)
     a->param.append(bt->param[i]);
   a->param.append(co);
   ag->atom = a;
   return g;
 }
      }
    }
    variable_vec omsk_vars(0, 0);
    ag->atom->collect_bound_variables(omsk_vars);
    if (omsk_vars.length() > 0) {
      QuantifiedGoal* qg = new QuantifiedGoal(goal_exists);
      for (index_type k = 0; k < omsk_vars.length(); k++) {
 qg->param.append(omsk_vars[k]);
 FTerm* bt = omsk_vars[k]->binding;
 omsk_vars[k]->binding = 0;
 assert(bt != 0);
 hsps::StringTable::Cell* c =
   (hsps::StringTable::Cell*)tab.find(bt->fun->print_name);
 assert(c != 0);
 PredicateSymbol* p = (PredicateSymbol*)c->val;
 assert(p->sym_class == sym_predicate);
 assert(p->param.length() == (bt->fun->param.length() + 1));
 assert(bt->param.length() == bt->fun->param.length());
 Atom* a = new Atom(p);
 for (index_type i = 0; i < bt->param.length(); i++)
   a->param.append(bt->param[i]);
 a->param.append(omsk_vars[k]);
 qg->pos_con.append(a);
      }
      qg->goal = g;
      return qg;
    }
    else {
      return g;
    }
  }
  else if ((g->g_class == goal_conjunction) ||
    (g->g_class == goal_disjunction)) {
    ConjunctiveGoal* cg = (ConjunctiveGoal*)this;
    for (index_type k = 0; k < cg->goals.length(); k++)
      cg->goals[k] = compile_object_functions(cg->goals[k]);
    return g;
  }
  else {
    if (write_warnings || !best_effort) {
      std::cerr << "warning: compilation of object functions in goal ";
      print(std::cerr);
      std::cerr << " not implemented" << std::endl;
      if (!best_effort) exit(1);
    }
    return g;
  }
}
void PDDL_Base::compile_object_functions()
{
  Symbol* undefined_value = 0;
  TypeSymbol* undefined_type = 0;
  if (!compile_for_validator) {
    undefined_type =
      (TypeSymbol*)gensym(sym_typename, "undefined-type", dom_top_type);
    dom_types.append(undefined_type);
    undefined_value =
      gensym(sym_object, "undefined-value", undefined_type);
    undefined_type->add_element(undefined_value);
    dom_constants.append(undefined_value);
  }
  lvector<PredicateSymbol*> fpred(0, 0);
  for (index_type k = 0; k < dom_object_functions.length(); k++) {
    ObjectFunctionSymbol* f = dom_object_functions[k];
    PredicateSymbol* p = new PredicateSymbol(f->print_name);
    p->param = f->param;
    VariableSymbol* vf =
      (VariableSymbol*)gensym(sym_variable, "?fval", f->sym_types);
    if (!compile_for_validator)
      vf->sym_types.append(undefined_type);
    p->param.append(vf);
    if (f->modded) {
      p->added = true;
      p->deleted = true;
      p->modded = true;
    }
    p->pos_pre = true;
    hsps::StringTable::Cell* c =
      (hsps::StringTable::Cell*)tab.find(f->print_name);
    if (c == 0) {
      std::cerr << "very bad error: object function " << f->print_name
  << " declared but not found in string table!"
  << std::endl;
      exit(255);
    }
    c->val = p;
    dom_predicates.append(p);
    fpred.append(p);
    if (!p->is_static()) {
      SetConstraint* f_inv = new SetConstraint();
      if (!compile_for_validator)
 f_inv->sc_type = sc_exactly;
      else
 f_inv->sc_type = sc_at_most;
      f_inv->sc_count = 1;
      f_inv->param = f->param;
      SetOf* s_inv = new SetOf();
      s_inv->param.append(vf);
      Atom* a_inv = new Atom(p);
      for (index_type i = 0; i < f_inv->param.length(); i++)
 a_inv->param.append(f_inv->param[i]);
      a_inv->param.append(vf);
      s_inv->pos_atoms.append(a_inv);
      f_inv->atom_sets.append(s_inv);
      dom_sc_invariants.append(f_inv);
    }
  }
  for (index_type k = 0; k < dom_obj_init.length(); k++) {
    ObjectFunctionSymbol* f = dom_obj_init[k]->fun;
    hsps::StringTable::Cell* c =
      (hsps::StringTable::Cell*)tab.find(f->print_name);
    assert(c != 0);
    PredicateSymbol* p = (PredicateSymbol*)c->val;
    assert(p->sym_class == sym_predicate);
    assert(p->param.length() == (f->param.length() + 1));
    Atom* a = new Atom(p);
    for (index_type i = 0; i < dom_obj_init[k]->param.length(); i++)
      a->param.append(dom_obj_init[k]->param[i]);
    a->param.append(dom_obj_init[k]->val);
    a->at_time = dom_obj_init[k]->at_time;
    a->insert(p->init);
    dom_init.append(a);
  }
  if (!compile_for_validator)
    for (index_type k = 0; k < fpred.length(); k++) {
      symbol_vec pattern(0, fpred[k]->param.length());
      pattern[pattern.length() - 1] = undefined_value;
      fpred[k]->initialise_missing(pattern, &dom_init);
    }
  dom_object_functions.clear();
  dom_obj_init.clear();
  for (index_type k = 0; k < dom_actions.length(); k++) {
    if (compile_for_validator)
      compile_object_functions_for_validator(dom_actions[k]);
    else
      compile_object_functions(dom_actions[k], undefined_value);
  }
  for (index_type k = 0;k < dom_goals.length(); k++) {
    dom_goals[k] = compile_object_functions(dom_goals[k]);
  }
  for (index_type k = 0;k < dom_preferences.length(); k++) {
    dom_preferences[k]->goal =
      compile_object_functions(dom_preferences[k]->goal);
  }
}
void PDDL_Base::Atom::build(Instance& ins, bool neg, index_type p)
{
  if (p < param.length()) {
    if (param[p]->sym_class == sym_variable) {
      for (index_type k = 0; k < param[p]->sym_types.n_elements(); k++) {
 ((VariableSymbol*)param[p])->value =
   param[p]->sym_types.get_element(k);
 build(ins, neg, p + 1);
      }
      ((VariableSymbol*)param[p])->value = 0;
    }
    else {
      build(ins, neg, p + 1);
    }
  }
  else {
    find_prop(ins, neg, true);
  }
}
void PDDL_Base::PredicateSymbol::instantiate(Instance& ins)
{
  Atom* a = new Atom(this, param, false);
  a->build(ins, false, 0);
  a->build(ins, true, 0);
  delete a;
}
void PDDL_Base::PredicateSymbol::initialise_missing
(const symbol_vec& p, atom_vec* created, index_type i)
{
  assert(p.length() == param.length());
  if (i < param.length()) {
    if (p[i] == 0) {
      for (index_type k = 0; k < param[i]->sym_types.n_elements(); k++) {
 param[i]->value = param[i]->sym_types.get_element(k);
 initialise_missing(p, created, i + 1);
      }
      param[i]->value = 0;
    }
    else {
      param[i]->value = 0;
      initialise_missing(p, created, i + 1);
    }
  }
  else {
    Atom a(this, param, false);
    partial_value v = a.partial_eval(&init, 0);
    if (v == p_false) {
      Atom* b = new Atom(this);
      for (index_type k = 0; k < param.length(); k++) {
 if (param[k]->value == 0) {
   assert(p[k] != 0);
   b->param.append(p[k]);
 }
 else {
   b->param.append(param[k]->value);
 }
      }
      b->insert(init);
      if (created) {
 created->append(b);
      }
    }
  }
}
void* PDDL_Base::ActionSymbol::find_instance()
{
  ptr_table* r = &instances;
  for (index_type k = 0; (k < param.length()) && r; k++) {
    r = r->find_next(param[k]->value);
  }
  if (r) {
    if (r->val) return r->val;
  }
  return 0;
}
void PDDL_Base::ActionSymbol::build
(Instance& ins, index_type p, Expression* cost_exp)
{
  if (p < param.length()) {
    for (index_type k = 0; k < param[p]->sym_types.n_elements(); k++) {
      param[p]->value = param[p]->sym_types.get_element(k);
      bool pass = true;
      if (!create_all_actions) {
 for (index_type k = 0; (k < pos_pre.length()) && pass; k++)
   if (pos_pre[k]->is_static()) {
     partial_value v = pos_pre[k]->partial_eval();
     if (v == p_false) pass = false;
   }
 for (index_type k = 0; (k < neg_pre.length()) && pass; k++)
   if (neg_pre[k]->is_static()) {
     partial_value v = neg_pre[k]->partial_eval();
     if (v == p_true) pass = false;
   }
 for (index_type k = 0; (k < num_pre.length()) && pass; k++) {
   partial_value v = num_pre[k]->partial_eval();
   if (v == p_false) pass = false;
 }
 for (index_type k = 0; (k < set_pre.length()) && pass; k++)
   if (set_pre[k]->is_static()) {
     partial_value v = set_pre[k]->partial_eval();
     if (v == p_false) pass = false;
   }
  for (index_type k = 0; (k < dis_pre.length()) && pass; k++)
    if (dis_pre[k]->is_static()) {
      partial_value v = dis_pre[k]->partial_eval(true);
      if (v == p_false) pass = false;
   }
      }
      if (pass) build(ins, p + 1, cost_exp);
    }
    param[p]->value = 0;
  }
  else {
    if ((param.length() == 0) && !create_all_actions) {
      for (index_type k = 0; k < pos_pre.length(); k++)
 if (pos_pre[k]->is_static()) {
   partial_value v = pos_pre[k]->partial_eval();
   if (v == p_false) return;
 }
      for (index_type k = 0; k < neg_pre.length(); k++)
 if (neg_pre[k]->is_static()) {
   partial_value v = neg_pre[k]->partial_eval();
   if (v == p_true) return;
 }
      for (index_type k = 0; k < set_pre.length(); k++)
 if (set_pre[k]->is_static()) {
   partial_value v = set_pre[k]->partial_eval();
   if (v == p_false) return;
 }
      for (index_type k = 0; k < dis_pre.length(); k++)
 if (dis_pre[k]->is_static()) {
   partial_value v = dis_pre[k]->partial_eval(true);
   if (v == p_false) return;
 }
    }
    for (index_type k = 0; k < irr_ins.length(); k++)
      if (irr_ins[k]->included) {
 if (irr_ins[k]->context_is_static()) {
   if (irr_ins[k]->match(param)) {
     if (write_info) {
       std::cerr << "DKEL: action instance " << print_name;
       for (index_type i = 0; i < param.length(); i++)
  std::cerr << " " << param[i]->print_name << "\\"
     << param[i]->value->print_name;
       std::cerr << " excluded by" << std::endl;
       irr_ins[k]->print(std::cerr);
       std::cerr << std::endl;
     }
     return;
   }
 }
 else if (write_warnings) {
   std::cerr << "warning: ignoring :irrelevant ";
   irr_ins[k]->entity->print(std::cerr);
   std::cerr << " with non-static context" << std::endl;
 }
      }
    PDDL_Name* name = new PDDL_Name(this, param, false);
    index_type count_name = 0;
    index_set ac_pre;
    index_set ac_add;
    index_set_vec ac_dc(EMPTYSET, 0);
    index_set ac_del;
    index_set ac_lck;
    index_cost_vec ac_use(index_cost_pair(0, 0), 0);
    index_cost_vec ac_cons(index_cost_pair(0, 0), 0);
    hsps::rational ac_dmin = 1;
    hsps::rational ac_dmax = 1;
    hsps::rational ac_dur = 1;
    hsps::rational ac_cost = 1;
    for (index_type k = 0; k < pos_pre.length(); k++)
      if (!pos_pre[k]->is_static() ||
   (create_all_actions && !pos_pre[k]->pred->is_equality())) {
 Instance::Atom* pp = pos_pre[k]->find_prop(ins, false, true);
 ac_pre.insert(pp->index);
      }
    for (index_type k = 0; k < neg_pre.length(); k++)
      if (!neg_pre[k]->is_static() ||
   (create_all_actions && !neg_pre[k]->pred->is_equality())) {
 Instance::Atom* np = neg_pre[k]->find_prop(ins, true, true);
 ac_pre.insert(np->index);
      }
    for (index_type k = 0; k < set_pre.length(); k++) {
      if (!set_pre[k]->is_static() || create_all_actions) {
 index_set s;
 set_pre[k]->instantiate_as_set(ins, s);
 ac_pre.insert(s);
      }
    }
    for (index_type k = 0; k < adds.length(); k++) {
      Instance::Atom* pp = adds[k]->find_prop(ins, false, true);
      ac_add.insert(pp->index);
      if (adds[k]->pred->neg_pre) {
 Instance::Atom* np = adds[k]->find_prop(ins, true, true);
 ac_del.insert(np->index);
      }
    }
    for (index_type k = 0; k < dels.length(); k++) {
      Instance::Atom* pp = dels[k]->find_prop(ins, false, true);
      ac_del.insert(pp->index);
      if (dels[k]->pred->neg_pre) {
 Instance::Atom* np = dels[k]->find_prop(ins, true, true);
 ac_add.insert(np->index);
      }
    }
    for (index_type k = 0; k < set_eff.length(); k++) {
      index_set s_add;
      index_set s_del;
      set_eff[k]->instantiate_as_effect(ins, s_add, s_del);
      ac_add.insert(s_add);
      ac_del.insert(s_del);
    }
    for (index_type k = 0; k < locks.length(); k++) {
      Instance::Atom* lp = locks[k]->find_prop(ins, false, true);
      ac_lck.insert(lp->index);
    }
    if ((!enables.empty() || !incs.empty() || !fass.empty() ||
  !qc_incs.empty() || !qc_decs.empty() || !qc_fass.empty()) &&
 (write_warnings || !best_effort)) {
      bool is_ok = true;
      std::cerr << "warning: effects of action " << print_name
  << " ignored in instantiation:" << std::endl;
      for (index_type k = 0; k < enables.length(); k++) {
 std::cerr << " - temporary add atom ";
 enables[k]->print(std::cerr);
 std::cerr << std::endl;
      }
      for (index_type k = 0; k < incs.length(); k++) {
 std::cerr << " - fluent increase ";
 incs[k]->print(std::cerr);
 if (!incs[k]->fun->conditioned)
   std::cerr << " (but no condition on this function, so ok)";
 else
   is_ok = false;
 std::cerr << std::endl;
      }
      for (index_type k = 0; k < fass.length(); k++) {
 std::cerr << " - fluent assignment ";
 fass[k]->print(std::cerr);
 std::cerr << std::endl;
      }
      for (index_type k = 0; k < qc_incs.length(); k++) {
 std::cerr << " - quantified/conditional fluent increase ";
 qc_incs[k]->print(std::cerr);
 std::cerr << std::endl;
      }
      for (index_type k = 0; k < qc_decs.length(); k++) {
 std::cerr << " - quantified/conditional fluent decrease ";
 qc_decs[k]->print(std::cerr);
 std::cerr << std::endl;
      }
      for (index_type k = 0; k < qc_fass.length(); k++) {
 std::cerr << " - quantified/conditional fluent assignment ";
 qc_fass[k]->print(std::cerr);
 std::cerr << std::endl;
      }
      if (!best_effort && !is_ok) exit(1);
    }
    for (index_type k = 0; k < reqs.length(); k++) {
      Instance::Resource* rc = reqs[k]->find_resource(ins);
      ac_use.append(index_cost_pair(rc->index, reqs[k]->val->eval_static()));
    }
    for (index_type k = 0; k < decs.length(); k++) {
      Instance::Resource* rc = decs[k]->find_resource(ins);
      ac_cons.append(index_cost_pair(rc->index, decs[k]->val->eval_static()));
    }
    if (dmin) {
      ac_dmin = dmin->eval_static();
      if ((ac_dmin <= 0) && PDDL_Base::write_warnings) {
 std::cerr << "warning: action instance " << name
    << " has (min) duration " << ac_dmin << " <= 0"
    << std::endl;
      }
    }
    if (dmax) {
      ac_dmax = dmax->eval_static();
      if ((ac_dmax <= 0) && PDDL_Base::write_warnings) {
 std::cerr << "warning: action instance " << name
    << " has (max) duration " << ac_dmax << " <= 0"
    << std::endl;
      }
    }
    if (dmax) {
      ac_dur = ac_dmax;
    }
    else if (dmin) {
      ac_dur = ac_dmin;
    }
    if (cost_exp) {
      ac_cost = cost_exp->eval_delta(incs, decs);
      if ((ac_cost <= 0) && PDDL_Base::write_warnings) {
 std::cerr << "warning: action instance " << name
    << " has cost " << ac_cost << " <= 0" << std::endl;
      }
    }
    atom_set_vec ns_dis_pre(0, 0);
    for (index_type k = 0; k < dis_pre.length(); k++)
      if (!dis_pre[k]->is_static())
 ns_dis_pre.append(dis_pre[k]);
    if ((cond_eff.length() > 0) &&
 compile_away_conditional_effects) {
      if ((ns_dis_pre.length() > 0) &&
   compile_away_disjunctive_preconditions) {
 ac_dc.set_length(ns_dis_pre.length());
 for (index_type k = 0; k < ns_dis_pre.length(); k++)
   ns_dis_pre[k]->instantiate_as_set(ins, ac_dc[k]);
      }
      rule_set pce;
      rule_set nce;
      for (index_type k = 0; k < cond_eff.length(); k++) {
 cond_eff[k]->instantiate_conditional(ins, pce, nce);
      }
      SubsetEnumerator se(pce.length() + nce.length());
      bool more = se.first();
      if (write_info) {
 std::cerr << "info: compiling " << pce.length() + nce.length()
    << " conditional effects in action "
    << print_name << "..." << std::endl;
 if (write_trace) {
   std::cerr << "debug: instantiated conditional effects of action "
      << print_name << " are:" << std::endl;
   for (index_type k = 0; k < pce.length(); k++)
     std::cerr << "add: " << pce[k] << std::endl;
   for (index_type k = 0; k < nce.length(); k++)
     std::cerr << "del: " << nce[k] << std::endl;
 }
      }
      while (more) {
 build_actions_with_dc_and_ce(ins, name, count_name, ac_pre, ac_add,
         ac_del, ac_lck, ac_use, ac_cons, ac_dmin,
         ac_dmax, ac_dur, ac_cost, ac_dc, pce, nce,
         se.current_set());
 more = se.next();
      }
    }
    else if ((ns_dis_pre.length() > 0) &&
      compile_away_disjunctive_preconditions) {
      if ((cond_eff.length() > 0) && (write_warnings || !best_effort)) {
 std::cerr << "warning: conditional effects of action " << print_name
    << " ignored in instantiation" << std::endl;
 if (!best_effort) exit(1);
      }
      ac_dc.set_length(dis_pre.length());
      for (index_type k = 0; k < ns_dis_pre.length(); k++)
 ns_dis_pre[k]->instantiate_as_set(ins, ac_dc[k]);
      build_actions_with_dc(ins, name, count_name, ac_pre, ac_add, ac_del,
       ac_lck, ac_use, ac_cons, ac_dmin, ac_dmax, ac_dur,
       ac_cost, ac_dc);
    }
    else {
      if ((cond_eff.length() > 0) && (write_warnings || !best_effort)) {
 std::cerr << "warning: conditional effects of action " << print_name
    << " ignored in instantiation" << std::endl;
 if (!best_effort) exit(1);
      }
      if ((ns_dis_pre.length() > 0) && (write_warnings || !best_effort)) {
 std::cerr << "warning: disjunctive preconditions of action "
    << print_name << " ignored in instantiation" << std::endl;
 if (!best_effort) exit(1);
      }
      build_action(ins, name, count_name, ac_pre, ac_add, ac_del, ac_lck,
     ac_use, ac_cons, ac_dmin, ac_dmax, ac_dur, ac_cost);
    }
  }
}
Instance::Action& PDDL_Base::ActionSymbol::build_action
(Instance& ins, PDDL_Name* name, index_type& count,
 const index_set& pre, const index_set& add, const index_set& del,
 const index_set& lck, const index_cost_vec& r_use,
 const index_cost_vec& r_cons, hsps::rational dmin, hsps::rational dmax, hsps::rational d, hsps::rational c)
{
  ptr_table* r = &instances;
  for (index_type k = 0; k < name->argc(); k++) {
    r = r->insert_next(name->args()[k]);
  }
  if (r->val) {
    if (write_warnings && (count >= 1)) {
      std::cerr << "warning: multiple instances of (" << print_name;
      for (index_type i = 0; i < param.length(); i++)
 std::cerr << " " << param[i]->print_name << "\\"
    << param[i]->value->print_name;
      std::cerr << ")" << std::endl;
    }
    if (number_multiple_action_instances) {
      if (count == 1) {
 ((Instance::Action*)r->val)->name = new Numbered_PDDL_Name(name, 0);
      }
      name = new Numbered_PDDL_Name(name, count++);
    }
  }
  Instance::Action& act = ins.new_action(name);
  act.src = new ptr_pair(this, r);
  if (r->val == 0) {
    r->val = new Instance::action_ref(ins.actions, act.index);
    count = 1;
  }
  for (index_type k = 0; k < refs.length(); k++) {
    if (refs[k]->match(param)) {
      if (write_info) {
 std::cerr << "info: action reference ";
 refs[k]->print(std::cerr);
 std::cerr << " matched to "
    << act.index << "." << act.name
    << std::endl;
      }
      if (write_warnings && !refs[k]->index.empty()) {
 std::cerr << "warning: action reference ";
 refs[k]->print(std::cerr);
 std::cerr << " has multiple matches" << std::endl;
      }
      refs[k]->index.insert(act.index);
    }
  }
  if (part) {
    index_set* s = part->find();
    s->insert(act.index);
  }
  act.pre = pre;
  act.add = add;
  act.del = del;
  act.lck = lck;
  if (del_before_add_semantics) {
    index_set x(del);
    x.intersect(add);
    if (!x.empty()) {
      act.del.subtract(x);
      act.lck.insert(x);
    }
  }
  for (index_type k = 0; k < r_use.length(); k++) {
    act.use.inc_length_to(r_use[k].first + 1, 0);
    act.use[r_use[k].first] += r_use[k].second;
  }
  for (index_type k = 0; k < r_cons.length(); k++) {
    act.cons.inc_length_to(r_cons[k].first + 1, 0);
    act.cons[r_cons[k].first] += r_cons[k].second;
  }
  act.dmin = dmin;
  act.dmax = dmax;
  act.dur = d;
  act.cost = c;
  act.assoc = assoc;
  return act;
}
void PDDL_Base::ActionSymbol::build_actions_with_dc
(Instance& ins, PDDL_Name* name, index_type& count,
 const index_set& pre, const index_set& add, const index_set& del,
 const index_set& lck, const index_cost_vec& r_use,
 const index_cost_vec& r_cons, hsps::rational dmin, hsps::rational dmax, hsps::rational d, hsps::rational c,
 const index_set_vec& dc, index_vec& s, index_type p)
{
  if (p < dc.length()) {
    if ((dc[p].first_common_element(s) != no_such_index) ||
 (dc[p].first_common_element(pre) != no_such_index)) {
      build_actions_with_dc(ins, name, count, pre, add, del, lck, r_use,
       r_cons, dmin, dmax, d, c, dc, s, p + 1);
    }
    else {
      for (index_type k = 0; k < dc[p].length(); k++) {
 bool consistent = true;
 if (check_precondition_consistency) {
   index_type not_dk = ins.atoms[dc[p][k]].neg;
   if (not_dk != no_such_index) {
     if (s.first(not_dk) != no_such_index) consistent = false;
     if (pre.contains(not_dk)) consistent = false;
   }
 }
 if (consistent) {
   s.append(dc[p][k]);
   build_actions_with_dc(ins, name, count, pre, add, del, lck, r_use,
    r_cons, dmin, dmax, d, c, dc, s, p + 1);
   s.dec_length();
 }
      }
    }
  }
  else {
    Instance::Action& act =
      build_action(ins, name, count, pre, add, del, lck, r_use, r_cons,
     dmin, dmax, d, c);
    for (index_type k = 0; k < s.length(); k++)
      act.pre.insert(s[k]);
  }
}
void PDDL_Base::ActionSymbol::build_actions_with_dc
(Instance& ins, PDDL_Name* name, index_type& count,
 const index_set& pre, const index_set& add, const index_set& del,
 const index_set& lck, const index_cost_vec& r_use,
 const index_cost_vec& r_cons, hsps::rational dmin, hsps::rational dmax, hsps::rational d, hsps::rational c,
 const index_set_vec& dc)
{
  index_vec s(no_such_index, 0);
  build_actions_with_dc(ins, name, count, pre, add, del, lck, r_use, r_cons,
   dmin, dmax, d, c, dc, s, 0);
}
void PDDL_Base::ActionSymbol::build_actions_with_dc_and_ce
(Instance& ins, PDDL_Name* name, index_type& count,
 const index_set& pre, const index_set& add, const index_set& del,
 const index_set& lck, const index_cost_vec& r_use,
 const index_cost_vec& r_cons, hsps::rational dmin, hsps::rational dmax, hsps::rational d, hsps::rational c,
 const index_set_vec& dc, const rule_set& pce, const rule_set& nce,
 const bool_vec& ece)
{
  index_set x_pre(pre);
  index_set x_add(add);
  index_set x_del(del);
  index_set_vec x_dc(dc);
  for (index_type k = 0; k < pce.length(); k++) {
    if (ece[k]) {
      x_pre.insert(pce[k].antecedent);
      x_add.insert(pce[k].consequent);
      index_type not_c = ins.atoms[pce[k].consequent].neg;
      if (not_c != no_such_index)
 x_del.insert(not_c);
    }
    else {
      if (pce[k].antecedent.length() == 1) {
 index_type not_a = ins.atoms[pce[k].antecedent[0]].neg;
 if (not_a == no_such_index) {
   std::cerr << "error (compiling conditional effects): negation of "
      << ins.atoms[pce[k].antecedent[0]].name
      << " not defined" << std::endl;
   exit(255);
 }
 x_pre.insert(not_a);
      }
      else {
 index_set all_not_a;
 for (index_type i = 0; i < pce[k].antecedent.length(); i++) {
   index_type not_a = ins.atoms[pce[k].antecedent[i]].neg;
   if (not_a == no_such_index) {
     std::cerr << "error (compiling conditional effects): negation of "
        << ins.atoms[pce[k].antecedent[i]].name
        << " not defined" << std::endl;
     exit(255);
   }
   all_not_a.insert(not_a);
 }
 x_dc.append(all_not_a);
      }
    }
  }
  for (index_type k = 0; k < nce.length(); k++) {
    if (ece[pce.length() + k]) {
      x_pre.insert(nce[k].antecedent);
      x_del.insert(nce[k].consequent);
      index_type not_c = ins.atoms[nce[k].consequent].neg;
      if (not_c != no_such_index)
 x_add.insert(not_c);
    }
    else {
      if (nce[k].antecedent.length() == 1) {
 index_type not_a = ins.atoms[nce[k].antecedent[0]].neg;
 if (not_a == no_such_index) {
   std::cerr << "error (compiling conditional effects): negation of "
      << ins.atoms[nce[k].antecedent[0]].name
      << " not defined" << std::endl;
   exit(255);
 }
 x_pre.insert(not_a);
      }
      else {
 index_set all_not_a;
 for (index_type i = 0; i < nce[k].antecedent.length(); i++) {
   index_type not_a = ins.atoms[nce[k].antecedent[i]].neg;
   if (not_a == no_such_index) {
     std::cerr << "error (compiling conditional effects): negation of "
        << ins.atoms[nce[k].antecedent[i]].name
        << " not defined" << std::endl;
     exit(255);
   }
   all_not_a.insert(not_a);
 }
 x_dc.append(all_not_a);
      }
    }
  }
  index_vec s(no_such_index, 0);
  build_actions_with_dc(ins, name, count, x_pre, x_add, x_del, lck, r_use,
   r_cons, dmin, dmax, d, c, x_dc, s, 0);
}
index_type PDDL_Base::ActionSymbol::param_index(VariableSymbol* p)
{
  return param.first(p);
}
void PDDL_Base::ActionSymbol::get_param_inequalities(symbol_pair_vec& neq)
{
  neq.clear();
  for (index_type k = 0; k < neg_pre.length(); k++)
    if (neg_pre[k]->pred->is_equality()) {
      assert(neg_pre[k]->param.length() == 2);
      neq.append(symbol_pair(neg_pre[k]->param[0], neg_pre[k]->param[1]));
    }
}
void PDDL_Base::ActionSymbol::set_arguments(const symbol_vec& args)
{
  if (args.length() != param.length()) {
    std::cerr << "error: can't set arguments of (" << print_name;
    for (index_type i = 0; i < param.length(); i++)
      std::cerr << " " << param[i]->print_name;
    std::cerr << ") with ";
    for (index_type i = 0; i < args.length(); i++) {
      std::cerr << args[i]->print_name;
      if (i + 1 < args.length()) std::cerr << ";";
    }
    std::cerr << " -- wrong number!" << std::endl;
    exit(255);
  }
  for (index_type k = 0; k < param.length(); k++) param[k]->value = args[k];
}
void PDDL_Base::ActionSymbol::set_arguments(const ptr_table::key_vec& args)
{
  if (args.length() != param.length()) {
    std::cerr << "error: can't set arguments of (" << print_name;
    for (index_type i = 0; i < param.length(); i++)
      std::cerr << " " << param[i]->print_name;
    std::cerr << ") with " << args << " -- wrong number!"
       << std::endl;
    exit(255);
  }
  for (index_type k = 0; k < param.length(); k++) {
    param[k]->value = (PDDL_Base::Symbol*)args[k];
  }
}
void PDDL_Base::ActionSymbol::clear_arguments()
{
  for (index_type k = 0; k < param.length(); k++)
    param[k]->value = 0;
  for (index_type k = 0; k < set_pre.length(); k++)
    set_pre[k]->clear_arguments();
  for (index_type k = 0; k < set_eff.length(); k++)
    set_eff[k]->clear_arguments();
}
bool PDDL_Base::ActionSymbol::is_abstract()
{
  return (exps.length() > 0);
}
void PDDL_Base::ActionSymbol::instantiate(Instance& ins, Expression* cost_exp)
{
  assert(!is_abstract());
  for (index_type k = 0; k < param.length(); k++) param[k]->value = 0;
  build(ins, 0, cost_exp);
}
index_set* PDDL_Base::SetName::find()
{
  ptr_table* r = &(sym->set_table);
  for (index_type k = 0; k < param.length(); k++) {
    if (param[k]->sym_class == sym_variable) {
      if (((VariableSymbol*)param[k])->value == 0) {
 std::cerr << "error: unbound variable "
    << param[k]->print_name << " in ";
 print(std::cerr);
 std::cerr << " - uncompiled object function?"
    << std::endl;
 exit(255);
      }
      r = r->insert_next(((VariableSymbol*)param[k])->value);
    }
    else {
      r = r->insert_next(param[k]);
    }
  }
  if (!r->val) {
    PDDL_Name* s_name = new PDDL_Name(sym);
    for (index_type k = 0; k < param.length(); k++) {
      if (param[k]->sym_class == sym_variable) {
 s_name->add(((VariableSymbol*)param[k])->value);
      }
      else {
 s_name->add(param[k]);
      }
    }
    index_set* s = new index_set;
    r->val = s;
    sym->sets.append(s);
    sym->names.append(s_name);
  }
  return (index_set*)(r->val);
}
PDDL_Base::SetName* PDDL_Base::SetName::instantiate_partially()
{
  SetName* n = new SetName(sym);
  fill_in_args(n);
  return n;
}
bool PDDL_Base::Reference::match(symbol_vec& args)
{
  if (args.length() != param.length()) {
    std::cerr << "error: wrong number of arguments (" << args.length()
       << ", should be " << param.length() << ") in match"
       << std::endl;
    return false;
  }
  for (index_type k = 0; k < param.length(); k++) {
    if (param[k]->sym_class == sym_variable) {
      if (((VariableSymbol*)param[k])->value) {
 if (args[k]->sym_class == sym_variable) {
   if (((VariableSymbol*)args[k])->value !=
       ((VariableSymbol*)param[k])->value)
     return false;
 }
 else {
   if (args[k] != ((VariableSymbol*)param[k])->value) return false;
 }
      }
      else {
 if (args[k]->sym_class == sym_variable) {
   ((VariableSymbol*)param[k])->value =
     ((VariableSymbol*)args[k])->value;
 }
 else {
   ((VariableSymbol*)param[k])->value = args[k];
 }
      }
    }
    else if (param[k]->sym_class == sym_object) {
      if (args[k]->sym_class == sym_variable) {
 if (((VariableSymbol*)args[k])->value != param[k]) return false;
      }
      else {
 if (args[k] != param[k]) return false;
      }
    }
    else {
      std::cerr << "program error: arg " << k + 1
  << " has bad sym_class in match ";
      print(std::cerr);
      std::cerr << std::endl;
      exit(255);
    }
  }
  return true;
}
bool PDDL_Base::Reference::match(variable_vec& args)
{
  if (args.length() != param.length()) {
    std::cerr << "error: wrong number of arguments (" << args.length()
       << ", should be " << param.length() << ") in match"
       << std::endl;
    return false;
  }
  for (index_type k = 0; k < param.length(); k++) {
    if (param[k]->sym_class == sym_variable) {
      if (((VariableSymbol*)param[k])->value) {
 if (args[k]->value != ((VariableSymbol*)param[k])->value) return false;
      }
      else {
 ((VariableSymbol*)param[k])->value = args[k]->value;
      }
    }
    else if (param[k]->sym_class == sym_object) {
      if (args[k]->value != param[k]) return false;
    }
    else {
      std::cerr << "program error: arg " << k + 1
  << " has bad sym_class in match ";
      print(std::cerr);
      std::cerr << std::endl;
      exit(255);
    }
  }
  return true;
}
void* PDDL_Base::Reference::find_action()
{
  if (name->sym_class != sym_action) {
    std::cerr << "error: ";
    name->print(std::cerr);
    std::cerr << " of ";
    print(std::cerr);
    std::cerr << " is not an action symbol" << std::endl;
    exit(255);
  }
  ActionSymbol* act = (ActionSymbol*)name;
  ptr_table* r = &(act->instances);
  for (index_type k = 0; (k < param.length()) && r; k++) {
    if (param[k]->sym_class == sym_variable)
      r = r->find_next(((VariableSymbol*)param[k])->value);
    else
      r = r->find_next(param[k]);
  }
  if (r) {
    return r->val;
  }
  else {
    return 0;
  }
}
void PDDL_Base::Reference::find(const name_vec& names, index_set& ind)
{
  ind.clear();
  Name* n = 0;
  if (has_args) {
    PDDL_Name* pn = new PDDL_Name(name, neg);
    for (index_type k = 0; k < param.length(); k++) {
      if (param[k]->sym_class == sym_variable) {
 VariableSymbol* v = (VariableSymbol*)param[k];
 if (v->value == 0) {
   if (write_warnings) {
     std::cerr << "warning: ";
     v->print(std::cerr);
     std::cerr << " in ";
     print(std::cerr);
     std::cerr << " has no value" << std::endl;
   }
   delete pn;
   return;
 }
 else {
   pn->add(v->value);
 }
      }
      else {
 pn->add(param[k]);
      }
    }
    n = pn;
  }
  else {
    n = new StringName(name->print_name);
  }
  for (index_type k = 0; k < names.length(); k++) {
    if (n->equals(names[k])) {
      if (write_warnings && !ind.empty()) {
 std::cerr << "warning: multiple matches for " << n
    << " in " << names << std::endl;
      }
      ind.insert(k);
    }
  }
  if (write_warnings && ind.empty()) {
    std::cerr << "warning: no match for " << n
       << " in " << names << std::endl;
  }
  delete n;
}
PDDL_Base::Reference* PDDL_Base::Reference::instantiate_partially()
{
  Reference* r = new Reference(name, neg, has_args);
  if (has_args) fill_in_args(r);
  return r;
}
PDDL_Base::IrrelevantItem* PDDL_Base::IrrelevantItem::instantiate_partially()
{
  IrrelevantItem* item = new IrrelevantItem();
  item->param = param;
  for (index_type k = 0; k < pos_con.length(); k++)
    item->pos_con.append(pos_con[k]->instantiate_partially());
  for (index_type k = 0; k < neg_con.length(); k++)
    item->neg_con.append(neg_con[k]->instantiate_partially());
  for (index_type k = 0; k < type_con.length(); k++)
    if (type_con[k]->var->value == 0)
      item->type_con.append(type_con[k]);
  item->entity = entity->instantiate_partially();
  return item;
}
bool PDDL_Base::IrrelevantItem::match(symbol_vec& args)
{
  for (index_type k = 0; k < param.length(); k++) param[k]->value = 0;
  bool schema_match = entity->match(args);
  if (schema_match) {
    partial_value v = Context::partial_eval();
    if (v == p_true) {
      return true;
    }
    else if (v == p_false) {
      return false;
    }
    else {
      if (write_warnings) {
 std::cerr << "warning: undecided context condition in :irrelevant ";
 entity->print(std::cerr);
 std::cerr << " treated as false" << std::endl;
      }
      return false;
    }
  }
  else {
    return false;
  }
}
bool PDDL_Base::IrrelevantItem::match(variable_vec& args)
{
  for (index_type k = 0; k < param.length(); k++) param[k]->value = 0;
  bool schema_match = entity->match(args);
  if (schema_match) {
    partial_value v = Context::partial_eval();
    if (v == p_true) {
      return true;
    }
    else if (v == p_false) {
      return false;
    }
    else {
      if (write_warnings) {
 std::cerr << "warning: undecided context condition in :irrelevant ";
 entity->print(std::cerr);
 std::cerr << " treated as false" << std::endl;
      }
      return false;
    }
  }
  else {
    return false;
  }
}
bool PDDL_Base::TypeConstraint::is_true()
{
  if (var->value) {
    for (index_type k = 0; k < typ->elements.length(); k++) {
      if (typ->elements[k] == var->value) return true;
    }
    return false;
  }
  else {
    return true;
  }
}
PDDL_Base::partial_value PDDL_Base::TypeConstraint::partial_eval()
{
  if (var->value) {
    if (is_true()) {
      return p_true;
    }
    else {
      return p_false;
    }
  }
  else {
    return p_unknown;
  }
}
bool PDDL_Base::Context::context_is_static() const
{
  for (index_type k = 0; k < pos_con.length(); k++)
    if (!pos_con[k]->is_static()) return false;
  for (index_type k = 0; k < neg_con.length(); k++)
    if (!neg_con[k]->is_static()) return false;
  return true;
}
bool PDDL_Base::Context::occurs_in_context(Symbol* s)
{
  for (index_type k = 0; k < pos_con.length(); k++)
    if (pos_con[k]->occurs(s)) return true;
  for (index_type k = 0; k < neg_con.length(); k++)
    if (neg_con[k]->occurs(s)) return true;
  return false;
}
bool PDDL_Base::Context::is_true()
{
  for (index_type k = 0; k < type_con.length(); k++) {
    if (!type_con[k]->is_true()) return false;
  }
  for (index_type k = 0; k < pos_con.length(); k++) {
    if (pos_con[k]->is_static()) {
      partial_value v = pos_con[k]->partial_eval();
      if (v == p_true) return true;
      else if (v == p_false) return false;
      else {
 std::cerr << "error: context ";
 AtomBase::print_bindings = true;
 print(std::cerr);
 AtomBase::print_bindings = false;
 std::cerr << " undecided with complete assignment"
    << std::endl;
 exit(255);
      }
    }
  }
  for (index_type k = 0; k < neg_con.length(); k++) {
    if (neg_con[k]->is_static()) {
      partial_value v = neg_con[k]->partial_eval();
      if (v == p_false) return true;
      else if (v == p_true) return false;
      else {
 std::cerr << "error: context ";
 AtomBase::print_bindings = true;
 print(std::cerr);
 AtomBase::print_bindings = false;
 std::cerr << " undecided with complete assignment"
    << std::endl;
 exit(255);
      }
    }
  }
  return true;
}
void PDDL_Base::Context::clear_arguments()
{
  for (index_type k = 0; k < param.length(); k++)
    param[k]->value = 0;
}
void PDDL_Base::Context::set_mode(mode_keyword m)
{
  for (index_type k = 0; k < pos_con.length(); k++)
    if (pos_con[k]->at == md_none)
      pos_con[k]->at = m;
  for (index_type k = 0; k < neg_con.length(); k++)
    if (neg_con[k]->at == md_none)
      neg_con[k]->at = m;
}
PDDL_Base::partial_value PDDL_Base::Context::partial_eval()
{
  bool is_undecided = false;
  for (index_type k = 0; k < type_con.length(); k++) {
    partial_value v = type_con[k]->partial_eval();
    if (v == p_false) return p_false;
    if (v != p_true) is_undecided = true;
  }
  for (index_type k = 0; k < pos_con.length(); k++) {
    if (pos_con[k]->is_static()) {
      partial_value v = pos_con[k]->partial_eval();
      if (v == p_false) return p_false;
      if (v != p_true) is_undecided = true;
    }
  }
  for (index_type k = 0; k < neg_con.length(); k++) {
    if (neg_con[k]->is_static()) {
      partial_value v = neg_con[k]->partial_eval();
      if (v == p_true) return p_false;
      if (v != p_false) is_undecided = true;
    }
  }
  if (is_undecided)
    return p_unknown;
  return p_true;
}
bool PDDL_Base::SetOf::is_static() const {
  for (index_type k = 0; k < pos_atoms.length(); k++)
    if (!pos_atoms[k]->is_static()) return false;
  for (index_type k = 0; k < neg_atoms.length(); k++)
    if (!neg_atoms[k]->is_static()) return false;
  return true;
}
void PDDL_Base::SetOf::set_mode(mode_keyword m)
{
  Context::set_mode(m);
  for (index_type k = 0; k < pos_atoms.length(); k++)
    if (pos_atoms[k]->at == md_none)
      pos_atoms[k]->at = m;
  for (index_type k = 0; k < neg_atoms.length(); k++)
    if (neg_atoms[k]->at == md_none)
      neg_atoms[k]->at = m;
}
PDDL_Base::partial_value PDDL_Base::SetOf::partial_eval
(index_type p, bool as_disjunction)
{
  partial_value v_c = Context::partial_eval();
  if ((v_c == p_false) && !as_disjunction) return p_true;
  if ((v_c == p_false) && as_disjunction) return p_false;
  bool all_sat = true;
  bool some_sat = false;
  for (index_type k = 0; k < pos_atoms.length(); k++) {
    partial_value v_a = pos_atoms[k]->partial_eval();
    if ((v_c == p_true) && (v_a == p_false) && !as_disjunction) {
      if (PDDL_Base::write_info) {
 AtomBase::print_bindings = true;
 std::cerr << "info: set condition ";
 print(std::cerr);
 std::cerr << " evaluated to false"
    << std::endl;
 AtomBase::print_bindings = true;
      }
      return p_false;
    }
    if ((v_c == p_true) && (v_a == p_true) && as_disjunction) {
      return p_true;
    }
    if (v_a != p_true) all_sat = false;
    if (v_a == p_true) some_sat = true;
  }
  for (index_type k = 0; k < neg_atoms.length(); k++) {
    partial_value v_a = neg_atoms[k]->partial_eval();
    if ((v_c == p_true) && (v_a == p_true) && !as_disjunction) {
      if (PDDL_Base::write_info) {
 AtomBase::print_bindings = true;
 std::cerr << "info: set condition ";
 print(std::cerr);
 std::cerr << " evaluated to false"
    << std::endl;
 AtomBase::print_bindings = true;
      }
      return p_false;
    }
    if ((v_c == p_true) && (v_a == p_false) && as_disjunction) {
      return p_true;
    }
    if (v_a != p_false) all_sat = false;
    if (v_a == p_false) some_sat = true;
  }
  if (!as_disjunction && all_sat) return p_true;
  if (as_disjunction && !some_sat) return p_false;
  if (p < param.length()) {
    partial_value v = p_true;
    for (index_type k = 0; k < param[p]->sym_types.n_elements(); k++) {
      param[p]->value = param[p]->sym_types.get_element(k);
      partial_value v_i = partial_eval(p+1);
      if (v_i == p_false) {
 param[p]->value = 0;
 return p_false;
      }
      else if (v_i == p_unknown) {
 v = p_unknown;
      }
    }
    param[p]->value = 0;
    return v;
  }
  return p_unknown;
}
PDDL_Base::partial_value PDDL_Base::SetOf::partial_eval(bool as_disjunction)
{
  if (!context_is_static()) {
    std::cerr << "error: expression ";
    print(std::cerr);
    std::cerr << " has non-static context" << std::endl;
    exit(255);
  }
  if (!is_static()) {
    std::cerr << "error: expression ";
    print(std::cerr);
    std::cerr << " has non-static atoms" << std::endl;
    exit(255);
  }
  for (index_type k = 0; k < param.length(); k++) param[k]->value = 0;
  return partial_eval(0, as_disjunction);
}
void PDDL_Base::SetOf::build_set
(Instance& ins, index_set& s, index_type p)
{
  if (p < param.length()) {
    for (index_type k = 0; k < param[p]->sym_types.n_elements(); k++) {
      param[p]->value = param[p]->sym_types.get_element(k);
      if (Context::partial_eval() != p_false) {
 build_set(ins, s, p+1);
      }
    }
    param[p]->value = 0;
  }
  else if (Context::is_true()) {
    for (index_type k = 0; k < pos_atoms.length(); k++)
      if (!pos_atoms[k]->pred->is_equality()) {
 Instance::Atom* p = pos_atoms[k]->find_prop(ins, false, true);
 s.insert(p->index);
      }
    for (index_type k = 0; k < neg_atoms.length(); k++)
      if (!pos_atoms[k]->pred->is_equality()) {
 Instance::Atom* p = neg_atoms[k]->find_prop(ins, true, true);
 s.insert(p->index);
      }
  }
}
void PDDL_Base::SetOf::instantiate_as_set(Instance& ins, index_set& s)
{
  if (!context_is_static()) {
    std::cerr << "error: expression ";
    print(std::cerr);
    std::cerr << " has non-static context" << std::endl;
    exit(255);
  }
  for (index_type k = 0; k < param.length(); k++) param[k]->value = 0;
  build_set(ins, s, 0);
}
void PDDL_Base::SetOf::build_effect
(Instance& ins, index_set& s_add, index_set& s_del, index_type p)
{
  if (p < param.length()) {
    for (index_type k = 0; k < param[p]->sym_types.n_elements(); k++) {
      param[p]->value = param[p]->sym_types.get_element(k);
      if (Context::partial_eval() != p_false) {
 build_effect(ins, s_add, s_del, p+1);
      }
    }
    param[p]->value = 0;
  }
  else if (Context::is_true()) {
    for (index_type k = 0; k < pos_atoms.length(); k++) {
      Instance::Atom* p = pos_atoms[k]->find_prop(ins, false, true);
      s_add.insert(p->index);
      if (pos_atoms[k]->pred->neg_pre) {
 Instance::Atom* np = pos_atoms[k]->find_prop(ins, true, true);
 s_del.insert(np->index);
      }
    }
    for (index_type k = 0; k < neg_atoms.length(); k++) {
      Instance::Atom* p = neg_atoms[k]->find_prop(ins, false, true);
      s_del.insert(p->index);
      if (neg_atoms[k]->pred->neg_pre) {
 Instance::Atom* np = neg_atoms[k]->find_prop(ins, true, true);
 s_add.insert(np->index);
      }
    }
  }
}
void PDDL_Base::SetOf::instantiate_as_effect
(Instance& ins, index_set& s_add, index_set& s_del)
{
  if (!context_is_static()) {
    std::cerr << "error: expression ";
    print(std::cerr);
    std::cerr << " has non-static context" << std::endl;
    exit(255);
  }
  for (index_type k = 0; k < param.length(); k++) param[k]->value = 0;
  build_effect(ins, s_add, s_del, 0);
}
void PDDL_Base::SetOf::build_conditional
(Instance& ins, rule_set& s_pos, rule_set& s_neg, index_type p)
{
  if (p < param.length()) {
    for (index_type k = 0; k < param[p]->sym_types.n_elements(); k++) {
      param[p]->value = param[p]->sym_types.get_element(k);
      if (Context::partial_eval() != p_false) {
 build_conditional(ins, s_pos, s_neg, p + 1);
      }
    }
    param[p]->value = 0;
  }
  else {
    if (param.length() == 0) {
      if (!is_true()) return;
    }
    index_set ant;
    for (index_type k = 0; k < pos_con.length(); k++)
      if (!pos_con[k]->is_static()) {
 Instance::Atom* p = pos_con[k]->find_prop(ins, false, true);
 Instance::Atom* neg_p = pos_con[k]->find_prop(ins, true, true);
 ant.insert(p->index);
      }
    for (index_type k = 0; k < neg_con.length(); k++)
      if (!neg_con[k]->is_static()) {
 Instance::Atom* p = neg_con[k]->find_prop(ins, false, true);
 Instance::Atom* neg_p = neg_con[k]->find_prop(ins, true, true);
 ant.insert(neg_p->index);
      }
    for (index_type k = 0; k < pos_atoms.length(); k++) {
      Instance::Atom* q = pos_atoms[k]->find_prop(ins, false, true);
      if (pos_atoms[k]->pred->neg_pre) {
 Instance::Atom* not_q = pos_atoms[k]->find_prop(ins, true, true);
      }
      rule& r = s_pos.append();
      r.antecedent = ant;
      r.consequent = q->index;
    }
    for (index_type k = 0; k < neg_atoms.length(); k++) {
      Instance::Atom* q = neg_atoms[k]->find_prop(ins, false, true);
      if (pos_atoms[k]->pred->neg_pre) {
 Instance::Atom* not_q = neg_atoms[k]->find_prop(ins, true, true);
      }
      rule& r = s_neg.append();
      r.antecedent = ant;
      r.consequent = q->index;
    }
  }
}
void PDDL_Base::SetOf::instantiate_conditional
(Instance& ins, rule_set& s_pos, rule_set& s_neg)
{
  for (index_type k = 0; k < param.length(); k++) param[k]->value = 0;
  build_conditional(ins, s_pos, s_neg, 0);
}
PDDL_Base::SetOf* PDDL_Base::SetOf::instantiate_partially()
{
  SetOf* s = new SetOf();
  s->param = param;
  for (index_type k = 0; k < pos_con.length(); k++)
    s->pos_con.append(pos_con[k]->instantiate_partially());
  for (index_type k = 0; k < neg_con.length(); k++)
    s->neg_con.append(neg_con[k]->instantiate_partially());
  for (index_type k = 0; k < type_con.length(); k++)
    if (type_con[k]->var->value == 0)
      s->type_con.append(type_con[k]);
  for (index_type k = 0; k < pos_atoms.length(); k++)
    s->pos_atoms.append(pos_atoms[k]->instantiate_partially());
  for (index_type k = 0; k < neg_atoms.length(); k++)
    s->neg_atoms.append(neg_atoms[k]->instantiate_partially());
  return s;
}
void PDDL_Base::SetOf::compile
(atom_vec& pos_ins, atom_vec& neg_ins, index_type p)
{
  if (p < param.length()) {
    for (index_type k = 0; k < param[p]->sym_types.n_elements(); k++) {
      param[p]->value = param[p]->sym_types.get_element(k);
      if (Context::partial_eval() != p_false) {
 compile(pos_ins, neg_ins, p + 1);
      }
    }
    param[p]->value = 0;
  }
  else {
    assert(context_is_static());
    if (is_true()) {
      for (index_type k = 0; k < pos_atoms.length(); k++)
 pos_ins.append(pos_atoms[k]->instantiate_partially());
      for (index_type k = 0; k < neg_atoms.length(); k++)
 neg_ins.append(neg_atoms[k]->instantiate_partially());
    }
  }
}
void PDDL_Base::SetOf::compile_non_static
(atom_set_vec& ins, index_type p)
{
  if (p < param.length()) {
    for (index_type k = 0; k < param[p]->sym_types.n_elements(); k++) {
      param[p]->value = param[p]->sym_types.get_element(k);
      if (Context::partial_eval() != p_false) {
 compile_non_static(ins, p + 1);
      }
    }
    param[p]->value = 0;
  }
  else if (is_true()) {
    SetOf* d = new SetOf();
    for (index_type k = 0; k < pos_con.length(); k++)
      d->neg_atoms.append(pos_con[k]->instantiate_partially());
    for (index_type k = 0; k < neg_con.length(); k++)
      d->pos_atoms.append(neg_con[k]->instantiate_partially());
    for (index_type k = 0; k < pos_atoms.length(); k++)
      d->pos_atoms.append(pos_atoms[k]->instantiate_partially());
    for (index_type k = 0; k < neg_atoms.length(); k++)
      d->neg_atoms.append(neg_atoms[k]->instantiate_partially());
    ins.append(d);
  }
}
void PDDL_Base::SetConstraint::build(Instance& ins, index_type p)
{
  if (p < param.length()) {
    for (index_type k = 0; k < param[p]->sym_types.n_elements(); k++) {
      param[p]->value = param[p]->sym_types.get_element(k);
      if (Context::partial_eval() != p_false) build(ins, p+1);
    }
    param[p]->value = 0;
  }
  else {
    index_set c_set;
    for (index_type k = 0; k < atom_sets.length(); k++) {
      atom_sets[k]->instantiate_as_set(ins, c_set);
    }
    for (index_type k = 0; k < pos_atoms.length(); k++) {
      Instance::Atom* p = pos_atoms[k]->find_prop(ins, false, true);
      c_set.insert(p->index);
    }
    for (index_type k = 0; k < neg_atoms.length(); k++) {
      Instance::Atom* p = neg_atoms[k]->find_prop(ins, true, true);
      c_set.insert(p->index);
    }
    if (c_set.empty()) {
      if (write_warnings) {
 std::cerr << "warning: ignoring" << std::endl;
 AtomBase::print_bindings = true;
 print(std::cerr);
 AtomBase::print_bindings = false;
 std::cerr << "because atom set is empty" << std::endl;
      }
      return;
    }
    Instance::Constraint& c =
      ins.new_invariant(c_set, sc_count, (sc_type == sc_exactly));
    if (!c.src) {
      c.src = this;
    }
    if (name && !c.name) {
      c.name = new PDDL_Name(name, param, false);
    }
  }
}
void PDDL_Base::SetConstraint::instantiate(Instance& ins)
{
  if (sc_type == sc_at_least) {
    if (write_warnings)
      std::cerr << "warning: skipping :at-least-n invariant" << std::endl;
    return;
  }
  if (!included) return;
  if (!context_is_static()) {
    if (write_warnings)
      std::cerr << "warning: skipping invariant with non-static context"
  << std::endl;
    return;
  }
  bool any_static = false;
  for (index_type k = 0; k < pos_atoms.length(); k++)
    if (pos_atoms[k]->is_static()) any_static = true;
  for (index_type k = 0; k < neg_atoms.length(); k++)
    if (neg_atoms[k]->is_static()) any_static = true;
  for (index_type k = 0; k < atom_sets.length(); k++)
    if (atom_sets[k]->is_static()) any_static = true;
  if (any_static) {
    if (write_warnings)
      std::cerr << "warning: skipping invariant with static atoms"
  << std::endl;
    return;
  }
  for (index_type k = 0; k < param.length(); k++) param[k]->value = 0;
  build(ins, 0);
}
void PDDL_Base::instantiate(Instance& ins)
{
  if (!ready_to_instantiate) post_process();
  for (index_type k = 0; k < dom_constants.length(); k++) {
    Atom* a = new Atom(dom_eq_pred);
    a->param.append(dom_constants[k]);
    a->param.append(dom_constants[k]);
    a->insert(dom_eq_pred->init);
  }
  if (name_instance_by_problem_file) {
    char* s = problem_file_basename();
    if (s) {
      ins.name = new StringName(s);
    }
    else {
      ins.name = new StringName("NONAME");
    }
  }
  else {
    ins.name = new InstanceName
      (domain_name ? tab.table_char_map().strdup(domain_name) :
       tab.table_char_map().strdup("??"),
       problem_name ? tab.table_char_map().strdup(problem_name) :
       tab.table_char_map().strdup("??"));
  }
  if (instance_name_prefix != 0) {
    ins.name = new ConcatenatedName(new StringName(instance_name_prefix),
        ins.name, '-');
  }
  for (index_type k = 0; k < dom_sc_invariants.length(); k++) {
    dom_sc_invariants[k]->included =
      dom_sc_invariants[k]->item_is_included(excluded_dkel_tags,
          required_dkel_tags);
    if (!dom_sc_invariants[k]->included) {
      if (PDDL_Base::write_info) {
 std::cerr << "DKEL: excluding DKEL item" << std::endl;
 dom_sc_invariants[k]->print(std::cerr);
      }
    }
  }
  for (index_type k = 0; k < dom_irrelevant.length(); k++) {
    dom_irrelevant[k]->included =
      dom_irrelevant[k]->item_is_included(excluded_dkel_tags,
       required_dkel_tags);
    if (!dom_irrelevant[k]->included) {
      if (PDDL_Base::write_info) {
 std::cerr << "DKEL: excluding DKEL item" << std::endl;
 dom_irrelevant[k]->print(std::cerr);
      }
    }
  }
  if (create_all_atoms) {
    for (index_type k = 0; k < dom_predicates.length(); k++)
      dom_predicates[k]->instantiate(ins);
  }
  for (index_type k = 0; k < dom_actions.length(); k++)
    if (!dom_actions[k]->is_abstract()) {
      if (metric) {
 Expression* c_exp = metric->copy();
 if (c_exp) {
   if (metric_type == metric_maximize) {
     c_exp = new BinaryExpression(exp_mul, c_exp,
      new ConstantExpression(-1));
   }
   if (dom_actions[k]->dmax) {
     c_exp->substitute_for_time(dom_actions[k]->dmax);
   }
   else if (dom_actions[k]->dmin) {
     c_exp->substitute_for_time(dom_actions[k]->dmin);
   }
   else {
     c_exp->substitute_for_time(new ConstantExpression(1));
   }
 }
 dom_actions[k]->instantiate(ins, c_exp);
      }
      else {
 dom_actions[k]->instantiate(ins, 0);
      }
    }
  for (index_type k = 0; k < ins.n_actions(); k++) {
    ins.actions[k].use.inc_length_to(ins.n_resources(), 0);
    ins.actions[k].cons.inc_length_to(ins.n_resources(), 0);
  }
  for (index_type k = 0; k < dom_goals.length(); k++) {
    if (dom_goals[k]->is_propositional()) {
      dom_goals[k]->instantiate(ins, POS_INF);
    }
    else if (write_warnings || !best_effort) {
      std::cerr << "warning: goal ";
      print(std::cerr);
      std::cerr << " ignored in instantiation" << std::endl;
      if (!best_effort) exit(1);
    }
  }
  for (index_type k = 0; k < dom_sc_invariants.length(); k++)
    dom_sc_invariants[k]->instantiate(ins);
}
void PDDL_Base::instantiate_atom_set
(Instance& ins, atom_vec& a, index_set& s)
{
  for (index_type k = 0; k < a.length(); k++) {
    Instance::Atom* p = a[k]->find_prop(ins, false, true);
    s.insert(p->index);
  }
}
void PDDL_Base::Goal::instantiate(Instance& ins, hsps::rational deadline)
{
  if (g_class == goal_pos_atom) {
    Instance::Atom* p = ((AtomicGoal*)this)->atom->find_prop(ins, false, true);
    p->goal = true;
    p->goal_t = deadline;
  }
  else if (g_class == goal_neg_atom) {
    Instance::Atom* p = ((AtomicGoal*)this)->atom->find_prop(ins, true, true);
    p->goal = true;
    p->goal_t = deadline;
  }
  else if (g_class == goal_conjunction) {
    ConjunctiveGoal* g = (ConjunctiveGoal*)this;
    for (index_type k = 0; k < g->goals.length(); k++)
      g->goals[k]->instantiate(ins, deadline);
  }
  else if (g_class == goal_within) {
    DeadlineGoal* g = (DeadlineGoal*)this;
    g->goal->instantiate(ins, g->at);
  }
  else if ((g_class == goal_always) && compile_away_plan_constraints) {
    index_set a;
    ((SimpleSequenceGoal*)this)->constraint->instantiate(ins, a, 0, 0);
    ins.compile_pc_always(a, 0);
  }
  else if ((g_class == goal_sometime) && compile_away_plan_constraints) {
    index_set a;
    ((SimpleSequenceGoal*)this)->constraint->instantiate(ins, a, 0, 0);
    ins.compile_pc_sometime(a, 0);
  }
  else if ((g_class == goal_at_most_once) && compile_away_plan_constraints) {
    index_set a;
    ((SimpleSequenceGoal*)this)->constraint->instantiate(ins, a, 0, 0);
    ins.compile_pc_at_most_once(a, 0);
  }
  else if ((g_class == goal_sometime_before) && compile_away_plan_constraints) {
    index_set a;
    ((TriggeredSequenceGoal*)this)->trigger->instantiate(ins, a, 0, 0);
    index_set b;
    ((TriggeredSequenceGoal*)this)->constraint->instantiate(ins, b, 0, 0);
    ins.compile_pc_sometime_before(a, b, 0);
  }
  else if (write_warnings || !best_effort) {
    std::cerr << "warning: goal ";
    print(std::cerr);
    std::cerr << " ignored in instantiation (1)" << std::endl;
    if (!best_effort) exit(1);
  }
}
void PDDL_Base::Goal::instantiate
(Instance& ins, index_set& set, Symbol* p, index_type i)
{
  if (g_class == goal_pos_atom) {
    Instance::Atom* p = ((AtomicGoal*)this)->atom->find_prop(ins, false, true);
    set.insert(p->index);
  }
  else if (g_class == goal_neg_atom) {
    Instance::Atom* p = ((AtomicGoal*)this)->atom->find_prop(ins, true, true);
    set.insert(p->index);
  }
  else if (g_class == goal_conjunction) {
    ConjunctiveGoal* g = (ConjunctiveGoal*)this;
    for (index_type k = 0; k < g->goals.length(); k++)
      g->goals[k]->instantiate(ins, set, p, k);
  }
  else if ((g_class == goal_always) && compile_away_plan_constraints) {
    index_set a;
    ((SimpleSequenceGoal*)this)->constraint->instantiate(ins, a, p, i);
    Name* n = (p ? (i != no_such_index ?
      (Name*)new EnumName(p->print_name, i) :
      (Name*)new StringName(p->print_name)) :
        (Name*)0);
    set.insert(ins.compile_pc_always(a, n));
  }
  else if ((g_class == goal_sometime) && compile_away_plan_constraints) {
    index_set a;
    ((SimpleSequenceGoal*)this)->constraint->instantiate(ins, a, p, i);
    Name* n = (p ? (i != no_such_index ?
      (Name*)new EnumName(p->print_name, i) :
      (Name*)new StringName(p->print_name)) :
        (Name*)0);
    set.insert(ins.compile_pc_sometime(a, n));
  }
  else if ((g_class == goal_at_most_once) && compile_away_plan_constraints) {
    index_set a;
    ((SimpleSequenceGoal*)this)->constraint->instantiate(ins, a, p, i);
    Name* n = (p ? (i != no_such_index ?
      (Name*)new EnumName(p->print_name, i) :
      (Name*)new StringName(p->print_name)) :
        (Name*)0);
    set.insert(ins.compile_pc_at_most_once(a, n));
  }
  else if ((g_class == goal_sometime_before) && compile_away_plan_constraints) {
    index_set a;
    ((TriggeredSequenceGoal*)this)->trigger->instantiate(ins, a, p, i);
    index_set b;
    ((TriggeredSequenceGoal*)this)->constraint->instantiate(ins, b, p, i);
    Name* n = (p ? (i != no_such_index ?
      (Name*)new EnumName(p->print_name, i) :
      (Name*)new StringName(p->print_name)) :
        (Name*)0);
    set.insert(ins.compile_pc_sometime_before(a, b, n));
  }
  else if (write_warnings || !best_effort) {
    std::cerr << "warning: goal ";
    print(std::cerr);
    std::cerr << " ignored in instantiation (2)" << std::endl;
    if (!best_effort) exit(1);
  }
}
hsps::rational PDDL_Base::Preference::value(metric_class metric_type, Expression* m)
{
  assert(m);
  hsps::rational b = m->eval_delta(0, 0, 1);
  hsps::rational d = m->eval_delta(name, 0, 1);
  return (metric_type == metric_minimize ? -1 : 1) * (d - b);
}
void PDDL_Base::Preference::instantiate
(SoftInstance& ins, metric_class metric_type, Expression* m)
{
  SoftInstance::SoftGoal& g = ins.new_soft_goal();
  g.name = new StringName(name->print_name, true);
  g.src = this;
  goal->instantiate(ins, g.atoms, name, no_such_index);
  for (index_type k = 0; k < g.atoms.length(); k++)
    ins.atoms[g.atoms[k]].goal = true;
  g.weight = (m ? value(metric_type, m) : 1);
}
void PDDL_Base::instantiate_soft(SoftInstance& ins)
{
  for (index_type k = 0; k < ins.n_atoms(); k++)
    if (ins.atoms[k].goal) ins.hard.insert(k);
  for (index_type k = 0; k < dom_preferences.length(); k++) {
    if (dom_preferences[k]->is_propositional()) {
      dom_preferences[k]->instantiate(ins, metric_type, metric);
    }
    else if (write_warnings || !best_effort) {
      std::cerr << "warning: non-propositional soft goal ";
      dom_preferences[k]->print(std::cerr);
      std::cerr << " ignored" << std::endl;
      if (!best_effort) exit(1);
    }
  }
  if (metric) {
    ins.null_value =
      (metric_type == metric_minimize ? -1 : 1) * metric->eval_delta(0, 0, 1);
  }
}
bool PDDL_Base::InputPlan::export_to_instance
(Instance& ins, const index_vec& map, Plan& p)
{
  if (steps.length() == 0) {
    p.end();
    return true;
  }
  InputPlanStep* sorted[steps.length() + 1];
  for (index_type k = 0; k < steps.length(); k++) {
    if (steps[k]->act->index.empty()) {
      std::cerr << "error (export plan): action ";
      steps[k]->act->print(std::cerr);
      std::cerr << " does not exist in instance!" << std::endl;
      exit(255);
    }
    index_type i = 0;
    bool found = false;
    while ((i < k) && !found) {
      if (sorted[i]->start_time > steps[k]->start_time) {
 for (index_type j = k - 1; j >= i; j--) sorted[j+1] = sorted[j];
 sorted[i] = steps[k];
 found = true;
      }
      else {
 i += 1;
      }
    }
    if (!found) {
      sorted[k] = steps[k];
    }
  }
  for (index_type k = 0; k < steps.length(); k++) {
    if (sorted[k]->act->index.empty()) {
      std::cerr << "warning (export plan): no action ";
      sorted[k]->act->print(std::cerr);
      std::cerr << " in instance" << std::endl;
      return false;
    }
    if (sorted[k]->act->index.length() > 1) {
      std::cerr << "warning (export plan): reference to action ";
      sorted[k]->act->print(std::cerr);
      std::cerr << " is ambiguous" << std::endl;
      return false;
    }
    index_type i0 = sorted[k]->act->index[0];
    if (i0 > map.length()) {
      std::cerr << "error (export plan): action ";
      sorted[k]->act->print(std::cerr);
      std::cerr << " has invalid index " << sorted[k]->act->index
  << std::endl;
      exit(255);
    }
    index_type new_index = map[i0];
    if (new_index == no_such_index) {
      std::cerr << "warning (export plan): action ";
      sorted[k]->act->print(std::cerr);
      std::cerr << " has been removed" << std::endl;
      return false;
    }
    p.insert(new_index);
    if (k < steps.length() - 1) {
      p.advance(sorted[k + 1]->start_time - sorted[k]->start_time);
    }
    else {
      p.end();
    }
  }
  return true;
}
bool PDDL_Base::export_plan
(index_type i, Instance& ins, const index_vec& map, Plan& p)
{
  if (input_plans.length() <= i) {
    std::cerr << "error: can't export plan " << i << " since there are only "
       << input_plans.length() << " plans in input" << std::endl;
    exit(255);
  }
  bool ok = input_plans[i]->export_to_instance(ins, map, p);
  if (!ok) return false;
  if (input_plans[i]->name)
    p.set_name(new StringName(input_plans[i]->name->print_name, true));
  p.set_optimal(input_plans[i]->is_opt);
  return true;
}
bool PDDL_Base::export_plan
(index_type i, Instance& ins, Plan& p)
{
  if (input_plans.length() <= i) {
    std::cerr << "error: can't export plan " << i << " since there are only "
       << input_plans.length() << " plans in input" << std::endl;
    exit(255);
  }
  index_vec map(no_such_index, ins.n_actions());
  for (index_type k = 0; k < ins.n_actions(); k++) map[k] = k;
  bool ok = input_plans[i]->export_to_instance(ins, map, p);
  if (!ok) return false;
  if (input_plans[i]->name)
    p.set_name(new StringName(input_plans[i]->name->print_name, true));
  p.set_optimal(input_plans[i]->is_opt);
  return true;
}
void PDDL_Base::export_heuristic
(Instance& ins, const index_vec& atom_map, bool opt_maximize, Heuristic& h)
{
  for (index_type k = 0; k < h_table.length(); k++) {
    index_set s;
    for (index_type i = 0; i < h_table[k]->atoms.length(); i++) {
      Instance::Atom* a =
 h_table[k]->atoms[i]->find_prop(ins, h_table[k]->neg[i], false);
      if (!a) {
 std::cerr << "error (export heuristic): atom ";
 h_table[k]->atoms[i]->print(std::cerr);
 std::cerr << " does not exist in instance" << std::endl;
 exit(255);
      }
      s.insert(a->index);
    }
    index_type l = s.length();
    ins.remap_set(s, atom_map);
    if (s.length() != l) {
      std::cerr << "warning: set ";
      ins.write_atom_set(std::cerr, s);
      std::cerr << " shrunk in remap, ignoring it" << std::endl;
    }
    else {
      if (opt_maximize) {
 hsps::rational v = h.eval(s);
 if (v < h_table[k]->cost) {
   if (write_info) {
     std::cerr << "info: storing ";
     ins.write_atom_set(std::cerr, s);
     std::cerr << " = " << v << std::endl;
   }
   h.store(s, h_table[k]->cost, h_table[k]->opt);
 }
      }
      else {
 h.store(s, h_table[k]->cost, h_table[k]->opt);
      }
    }
  }
}
bool PDDL_Base::SimpleReferenceSet::build
(const name_vec& names, index_set& set, index_type p)
{
  if (p < param.length()) {
    for (index_type k = 0; k < param[p]->sym_types.n_elements(); k++) {
      param[p]->value = param[p]->sym_types.get_element(k);
      if (Context::partial_eval() != p_false) {
 bool ok = build(names, set, p + 1);
 if (!ok && PDDL_Base::strict_set_export) return false;
      }
    }
    param[p]->value = 0;
    return true;
  }
  else if (is_true()) {
    index_set m;
    ref->find(names, m);
    if (m.empty() && PDDL_Base::strict_set_export) {
      return false;
    }
    if ((m.length() > 1) && !PDDL_Base::strict_set_export) {
      return false;
    }
    if (write_info) {
      std::cerr << "info: reference ";
      print(std::cerr);
      std::cerr << " with binding ";
      print_assignment(std::cerr);
      std::cerr << " matched to {";
      for (index_type k = 0; k < m.length(); k++) {
 if (k > 0) std::cerr << ", ";
 std::cerr << m[k] << "." << names[m[k]];
      }
      std::cerr << "}" << std::endl;
    }
    set.insert(m);
    return true;
  }
}
void PDDL_Base::ReferenceSet::build
(const name_vec& names, index_set_vec& sets, index_type p)
{
  if (p < param.length()) {
    for (index_type k = 0; k < param[p]->sym_types.n_elements(); k++) {
      param[p]->value = param[p]->sym_types.get_element(k);
      if (Context::partial_eval() != p_false) {
 build(names, sets, p + 1);
      }
    }
    param[p]->value = 0;
  }
  else if (is_true()) {
    index_set s;
    bool all_ok = true;
    for (index_type k = 0; (k < refs.length()) && all_ok; k++) {
      bool ok = refs[k]->build(names, s, 0);
      if (!ok && write_warnings) {
 std::cerr << "warning: failed to build instance ";
 print_assignment(std::cerr);
 std::cerr << " of ";
 print(std::cerr);
 std::cerr << std::endl;
      }
      all_ok = (all_ok && ok);
    }
    if (all_ok) sets.append(s);
  }
}
void PDDL_Base::export_sets(const name_vec& names, index_set_vec& sets)
{
  for (index_type k = 0; k < input_sets.length(); k++) {
    input_sets[k]->build(names, sets, 0);
  }
}
void PDDL_Base::export_action_partitions(name_vec& names, index_set_vec& sets)
{
  names.clear();
  sets.clear();
  for (index_type k = 0; k < partitions.length(); k++) {
    SetSymbol* s = partitions[k];
    assert(s->sets.length() == s->names.length());
    for (index_type i = 0; i < s->sets.length(); i++) {
      names.append(s->names[i]);
      sets.append(*(s->sets[i]));
    }
  }
}
bool PDDL_Base::DKEL_Item::item_is_included
(string_set& ex_tags, string_set& req_tags)
{
  if (exclude_all_dkel_items) return false;
  for (index_type k = 0; k < item_tags.length(); k++) {
    if (ex_tags.contains(item_tags[k])) {
      return false;
    }
  }
  for (index_type k = 0; k < req_tags.length(); k++) {
    if (!item_tags.contains(req_tags[k])) {
      return false;
    }
  }
  return true;
}
void PDDL_Base::lift_DKEL_Items(const Instance& ins)
{
  for (index_type k = 0; k < ins.n_invariants(); k++)
    if (ins.invariants[k].src == 0) {
      SetConstraint* c = new SetConstraint();
      for (index_type i = 0; i < ins.invariants[k].set.length(); i++) {
 ptr_pair* p = (ptr_pair*)ins.atoms[ins.invariants[k].set[i]].src;
 assert(p);
 bool n;
 Atom* a = make_atom_from_prop(*p, n);
 if (!n) {
   c->pos_atoms.append(a);
 }
 else {
   c->neg_atoms.append(a);
 }
      }
      if (ins.invariants[k].exact) {
 c->sc_type = sc_exactly;
      }
      else {
 c->sc_type = sc_at_most;
      }
      c->sc_count = ins.invariants[k].lim;
      if (ins.invariants[k].verified) {
 c->item_tags.append((char*)"verified");
      }
      c->defined_in_problem = true;
      dom_sc_invariants.append(c);
    }
}
PDDL_Base::PredicateSymbol*
PDDL_Base::find_type_predicate(Symbol* type_sym)
{
  for (index_type k = 0; k < dom_predicates.length(); k++)
    if (dom_predicates[k]->print_name == type_sym->print_name)
      return dom_predicates[k];
  std::cerr << "error: no type predicate found for type "
     << type_sym->print_name << std::endl;
  exit(255);
}
void PDDL_Base::Formula::untype(PDDL_Base* base)
{
  switch (fc) {
  case fc_false:
  case fc_true:
  case fc_atom:
  case fc_equality:
    return;
  case fc_negation:
    ((NFormula*)this)->f->untype(base);
    return;
  case fc_conjunction:
  case fc_disjunction:
    for (index_type k = 0; k < ((CFormula*)this)->parts.length(); k++) {
      ((CFormula*)this)->parts[k]->untype(base);
    }
    return;
  case fc_implication:
  case fc_equivalence:
    ((BFormula*)this)->f1->untype(base);
    ((BFormula*)this)->f2->untype(base);
    return;
  case fc_universal:
    {
      QFormula* qf = (QFormula*)this;
      CFormula* df = new CFormula(fc_disjunction);
      for (index_type k = 0; k < qf->vars.length(); k++) {
 if (qf->vars[k]->sym_types.length() == 1) {
   if (qf->vars[k]->sym_types[0] != base->dom_top_type) {
     PredicateSymbol* type_pred =
       base->find_type_predicate(qf->vars[k]->sym_types[0]);
     AFormula* type_atom = new AFormula(type_pred);
     type_atom->param.append(qf->vars[k]);
     df->add(new NFormula(type_atom));
   }
   qf->vars[k]->sym_types.clear();
 }
 else if (qf->vars[k]->sym_types.length() > 1) {
   CFormula* ddf = new CFormula(fc_disjunction);
   for (index_type i = 0; i < qf->vars[k]->sym_types.length(); i++) {
     if (qf->vars[k]->sym_types[i] != base->dom_top_type) {
       PredicateSymbol* type_pred =
  base->find_type_predicate(qf->vars[k]->sym_types[i]);
       AFormula* type_atom = new AFormula(type_pred);
       type_atom->param.append(qf->vars[k]);
       ddf->add(type_atom);
     }
   }
   df->add(new NFormula(ddf));
   qf->vars[k]->sym_types.clear();
 }
      }
      qf->f->untype(base);
      df->add(qf->f);
      qf->f = df;
      return;
    }
  case fc_existential:
    {
      QFormula* qf = (QFormula*)this;
      CFormula* cf = new CFormula(fc_conjunction);
      for (index_type k = 0; k < qf->vars.length(); k++) {
 if (qf->vars[k]->sym_types.length() == 1) {
   if (qf->vars[k]->sym_types[0] != base->dom_top_type) {
     PredicateSymbol* type_pred =
       base->find_type_predicate(qf->vars[k]->sym_types[0]);
     AFormula* type_atom = new AFormula(type_pred);
     type_atom->param.append(qf->vars[k]);
     cf->add(type_atom);
   }
   qf->vars[k]->sym_types.clear();
 }
 else if (qf->vars[k]->sym_types.length() > 1) {
   CFormula* ddf = new CFormula(fc_disjunction);
   for (index_type i = 0; i < qf->vars[k]->sym_types.length(); i++) {
     if (qf->vars[k]->sym_types[i] != base->dom_top_type) {
       PredicateSymbol* type_pred =
  base->find_type_predicate(qf->vars[k]->sym_types[i]);
       AFormula* type_atom = new AFormula(type_pred);
       type_atom->param.append(qf->vars[k]);
       ddf->add(type_atom);
     }
   }
   cf->add(ddf);
   qf->vars[k]->sym_types.clear();
 }
      }
      qf->f->untype(base);
      cf->add(qf->f);
      qf->f = cf;
      return;
    }
  }
}
void PDDL_Base::Context::untype(PDDL_Base* base)
{
  for (index_type k = 0; k < param.length(); k++) {
    if (param[k]->sym_types.length() == 1) {
      if (param[k]->sym_types[0] != base->dom_top_type) {
 PredicateSymbol* type_pred =
   base->find_type_predicate(param[k]->sym_types[0]);
 Atom* type_atom = new Atom(type_pred);
 type_atom->param.append(param[k]);
 pos_con.append(type_atom);
      }
      param[k]->sym_types.clear();
    }
    else if (param[k]->sym_types.length() > 1) {
      std::cerr << "error: can't untype ";
      param[k]->print(std::cerr);
      std::cerr << " in ";
      print(std::cerr);
      std::cerr << std::endl;
      exit(255);
    }
  }
}
void PDDL_Base::SetConstraint::untype(PDDL_Base* base)
{
  PDDL_Base::Context::untype(base);
  for (index_type k = 0; k < atom_sets.length(); k++)
    atom_sets[k]->untype(base);
}
void PDDL_Base::InvariantFormula::untype(PDDL_Base* base)
{
  PDDL_Base::Context::untype(base);
  f->untype(base);
}
void PDDL_Base::ActionSymbol::untype(PDDL_Base* base)
{
  for (index_type k = 0; k < param.length(); k++) {
    if (param[k]->sym_types.length() == 1) {
      if (param[k]->sym_types[0] != base->dom_top_type) {
 PredicateSymbol* type_pred =
   base->find_type_predicate(param[k]->sym_types[0]);
 Atom* type_atom = new Atom(type_pred);
 type_atom->param.append(param[k]);
 pos_pre.append(type_atom);
      }
      param[k]->sym_types.clear();
    }
    else if (param[k]->sym_types.length() > 1) {
      SetOf* d = new SetOf();
      for (index_type i = 0; i < param[k]->sym_types.length(); i++)
 if (param[k]->sym_types[i] != base->dom_top_type) {
   PredicateSymbol* type_pred =
     base->find_type_predicate(param[k]->sym_types[i]);
   Atom* type_atom = new Atom(type_pred);
   type_atom->param.append(param[k]);
   d->pos_atoms.append(type_atom);
 }
      dis_pre.append(d);
      param[k]->sym_types.clear();
    }
  }
  for (index_type k = 0; k < set_pre.length(); k++) set_pre[k]->untype(base);
  for (index_type k = 0; k < set_eff.length(); k++) set_eff[k]->untype(base);
  for (index_type k = 0; k < cond_eff.length(); k++) cond_eff[k]->untype(base);
}
void PDDL_Base::untype()
{
  StringTable::Cell* var_x = tab.inserta("?X");
  for (index_type k = 0; k < dom_types.length(); k++) {
    PredicateSymbol* type_pred =
      new PredicateSymbol(dom_types[k]->print_name);
    type_pred->param.append(new VariableSymbol(var_x->text));
    type_pred->pos_pre = true;
    dom_predicates.append(type_pred);
    for (index_type i = 0; i < dom_types[k]->elements.length(); i++) {
      Atom* a = new Atom(type_pred);
      a->param.append(dom_types[k]->elements[i]);
      a->insert(type_pred->init);
      dom_init.append(a);
    }
  }
  for (index_type k = 0; k < dom_predicates.length(); k++) {
    PredicateSymbol* pred = dom_predicates[k];
    for (index_type i = 0; i < pred->param.length(); i++)
      pred->param[i]->sym_types.clear();
  }
  for (index_type k = 0; k < dom_functions.length(); k++) {
    FunctionSymbol* fun = dom_functions[k];
    for (index_type i = 0; i < fun->param.length(); i++)
      fun->param[i]->sym_types.clear();
  }
  for (index_type k = 0; k < dom_constants.length(); k++) {
    dom_constants[k]->sym_types.clear();
  }
  for (index_type k = 0; k < dom_actions.length(); k++)
    dom_actions[k]->untype(this);
  for (index_type k = 0; k < dom_sc_invariants.length(); k++)
    dom_sc_invariants[k]->untype(this);
  for (index_type k = 0; k < dom_f_invariants.length(); k++)
    dom_f_invariants[k]->untype(this);
  for (index_type k = 0; k < dom_irrelevant.length(); k++)
    dom_irrelevant[k]->untype(this);
  dom_types.clear();
}
bool PDDL_Base::Goal::is_state()
{
  switch (g_class) {
  case goal_pos_atom:
  case goal_neg_atom:
  case goal_relation:
    return true;
  case goal_conjunction:
  case goal_disjunction:
    {
      ConjunctiveGoal* cg = (ConjunctiveGoal*)this;
      for (index_type k = 0; k < cg->goals.length(); k++)
 if (!cg->goals[k]->is_state()) return false;
      return true;
    }
  case goal_forall:
  case goal_exists:
    {
      QuantifiedGoal* qg = (QuantifiedGoal*)this;
      return qg->goal->is_state();
    }
  case goal_task:
  case goal_always:
  case goal_sometime:
  case goal_at_most_once:
  case goal_within:
  case goal_always_within:
  case goal_sometime_before:
  case goal_sometime_after:
    return false;
  default:
    std::cerr << "error: invalid goal class (" << g_class << ")" << std::endl;
    exit(255);
  }
}
bool PDDL_Base::Goal::is_propositional()
{
  switch (g_class) {
  case goal_pos_atom:
  case goal_neg_atom:
    return true;
  case goal_conjunction:
  case goal_disjunction:
    {
      ConjunctiveGoal* cg = (ConjunctiveGoal*)this;
      for (index_type k = 0; k < cg->goals.length(); k++)
 if (!cg->goals[k]->is_propositional()) return false;
      return true;
    }
  case goal_forall:
  case goal_exists:
    {
      QuantifiedGoal* qg = (QuantifiedGoal*)this;
      return qg->goal->is_state();
    }
  case goal_relation:
  case goal_task:
    return false;
  case goal_always:
  case goal_sometime:
  case goal_at_most_once:
    return ((SimpleSequenceGoal*)this)->constraint->is_propositional();
  case goal_within:
  case goal_always_within:
    return false;
  case goal_sometime_before:
  case goal_sometime_after:
    return (((TriggeredSequenceGoal*)this)->trigger->is_propositional() &&
     ((TriggeredSequenceGoal*)this)->constraint->is_propositional());
  default:
    std::cerr << "error: invalid goal class (" << g_class << ")" << std::endl;
    exit(255);
  }
}
bool PDDL_Base::Goal::is_singular()
{
  switch (g_class) {
  case goal_pos_atom:
  case goal_neg_atom:
  case goal_relation:
    return true;
  case goal_conjunction:
  case goal_disjunction:
  case goal_forall:
  case goal_exists:
  case goal_task:
  case goal_always:
  case goal_sometime:
  case goal_at_most_once:
  case goal_within:
  case goal_always_within:
  case goal_sometime_before:
  case goal_sometime_after:
    return false;
  default:
    std::cerr << "error: invalid goal class (" << g_class << ")" << std::endl;
    exit(255);
  }
}
void PDDL_Base::Goal::print(std::ostream& s)
{
  switch (g_class) {
  case goal_pos_atom:
  case goal_neg_atom:
    ((AtomicGoal*)this)->print(s);
    break;
  case goal_relation:
    ((NumericGoal*)this)->print(s);
    break;
  case goal_conjunction:
    ((ConjunctiveGoal*)this)->print(s);
    break;
  case goal_disjunction:
    ((DisjunctiveGoal*)this)->print(s);
    break;
  case goal_forall:
  case goal_exists:
    ((QuantifiedGoal*)this)->print(s);
    break;
  case goal_task:
    ((TaskGoal*)this)->print(s);
    break;
  case goal_always:
  case goal_sometime:
  case goal_at_most_once:
    ((SimpleSequenceGoal*)this)->print(s);
    break;
  case goal_within:
    ((DeadlineGoal*)this)->print(s);
    break;
  case goal_always_within:
    ((TriggeredDeadlineGoal*)this)->print(s);
    break;
  case goal_sometime_before:
  case goal_sometime_after:
    ((TriggeredSequenceGoal*)this)->print(s);
    break;
  default:
    std::cerr << "error: invalid goal class (" << g_class << ")" << std::endl;
    exit(255);
  }
}
void PDDL_Base::AtomicGoal::print(std::ostream& s)
{
  atom->print(s, (g_class == goal_neg_atom));
}
void PDDL_Base::NumericGoal::print(std::ostream& s)
{
  rel->print(s, false);
}
void PDDL_Base::TaskGoal::print(std::ostream& s)
{
  task->print(s);
}
void PDDL_Base::ConjunctiveGoal::print(std::ostream& s)
{
  if (goals.length() > 1) s << "(and";
  for (index_type k = 0; k < goals.length(); k++) {
    s << " ";
    goals[k]->print(s);
  }
  if (goals.length() > 1) s << ")";
}
void PDDL_Base::DisjunctiveGoal::print(std::ostream& s)
{
  if (goals.length() > 1) s << "(or";
  for (index_type k = 0; k < goals.length(); k++) {
    s << " ";
    goals[k]->print(s);
  }
  if (goals.length() > 1) s << ")";
}
void PDDL_Base::QuantifiedGoal::print(std::ostream& s)
{
  if (g_class == goal_forall) {
    s << "(forall (";
  }
  else if (g_class == goal_exists) {
    s << "(exists (";
  }
  else {
    std::cerr << "error: invalid goal class " << g_class
       << " for QuantifiedGoal" << std::endl;
    exit(255);
  }
  bool first = true;
  for (index_type k = 0; k < param.length(); k++) {
    if (!first) s << " ";
    s << param[k]->print_name;
    param[k]->sym_types.write_type(s);
    first = false;
  }
  s << ")";
  if (pos_con.length() + neg_con.length() > 0) {
    if (g_class == goal_forall) {
      s << "(imply";
      if (pos_con.length() + neg_con.length() > 1) s << " (and";
      for (index_type k = 0; k < pos_con.length(); k++) {
 s << " ";
 pos_con[k]->print(s);
      }
      for (index_type k = 0; k < neg_con.length(); k++) {
 s << " (not ";
 neg_con[k]->print(s);
 s << ")";
      }
      if (pos_con.length() + neg_con.length() > 1) s << ")";
      s << " ";
      goal->print(s);
      s << "))";
    }
    else {
      s << "(and";
      for (index_type k = 0; k < pos_con.length(); k++) {
 s << " ";
 pos_con[k]->print(s);
      }
      for (index_type k = 0; k < neg_con.length(); k++) {
 s << " (not ";
 neg_con[k]->print(s);
 s << ")";
      }
      s << " ";
      goal->print(s);
      s << "))";
    }
  }
  else {
    s << " ";
    goal->print(s);
    s << ")";
  }
}
void PDDL_Base::SimpleSequenceGoal::print(std::ostream& s)
{
  switch (g_class) {
  case goal_always:
    s << "(always ";
    break;
  case goal_sometime:
    s << "(sometime ";
    break;
  case goal_at_most_once:
    s << "(at-most-once ";
    break;
  default:
    std::cerr << "error: invalid goal class " << g_class
       << " for SimpleSequenceGoal" << std::endl;
    exit(255);
  }
  constraint->print(s);
  s << ")";
}
void PDDL_Base::TriggeredSequenceGoal::print(std::ostream& s)
{
  switch (g_class) {
  case goal_sometime_before:
    s << "(sometime-before ";
    break;
  case goal_sometime_after:
    s << "(sometime-after ";
    break;
  default:
    std::cerr << "error: invalid goal class " << g_class << " for TriggeredSequenceGoal" << std::endl;
    exit(255);
  }
  trigger->print(s);
  s << " ";
  constraint->print(s);
  s << ")";
}
void PDDL_Base::DeadlineGoal::print(std::ostream& s)
{
  s << "(within " << std::resetiosflags(std::ios::scientific) << ((at).decimal()) << " ";
  goal->print(s);
  s << ")";
}
void PDDL_Base::TriggeredDeadlineGoal::print(std::ostream& s)
{
  s << "(always-within " << std::resetiosflags(std::ios::scientific) << ((delay).decimal()) << " ";
  trigger->print(s);
  s << " ";
  goal->print(s);
  s << ")";
}
void PDDL_Base::Symbol::print(std::ostream& s) const
{
  s << print_name;
}
void PDDL_Base::VariableSymbol::print(std::ostream& s)
{
  s << print_name;
  sym_types.write_type(s);
  if (binding) {
    s << " :binding ";
    binding->print(s);
  }
}
void PDDL_Base::TypeSymbol::print(std::ostream& s) const
{
  s << "(:type " << print_name;
  sym_types.write_type(s);
  s << "):";
  if (is_base_type) s << " basetype";
  s << " {";
  for (index_type k = 0; k < elements.length(); k++) {
    elements[k]->print(s);
    if (k < elements.length() - 1) s << ", ";
  }
  s << "}" << std::endl;
}
void PDDL_Base::PredicateSymbol::print(std::ostream& s)
{
  s << "(:predicate " << print_name;
  for (index_type k = 0; k < param.length(); k++) {
    s << " ";
    param[k]->print(s);
  }
  s << "):";
  if (is_static()) s << " static";
  if (pos_pre) s << " pos prec.";
  if (neg_pre) s << " neg prec.";
  if (added) s << " added";
  if (deleted) s << " deleted";
  if (locked) s << " locked";
  index_type c = init.count_values();
  element_vec* its = init.values();
  s << " init (" << c << ") = {";
  for (index_type k = 0; k < its->length(); k++) {
    if (k > 0) s << ' ';
    ((PDDL_Base::Atom*)((*its)[k]))->print(s);
  }
  delete its;
  s << "}" << std::endl;
}
void PDDL_Base::PredicateSymbol::write_prototype(std::ostream& s)
{
  s << "(" << print_name;
  for (index_type k = 0; k < param.length(); k++) {
    s << " ";
    param[k]->print(s);
  }
  s << ")";
}
void PDDL_Base::ObjectFunctionSymbol::print(std::ostream& s)
{
  s << "(:function " << print_name;
  for (index_type k = 0; k < param.length(); k++) {
    s << " ";
    param[k]->print(s);
  }
  s << ")";
  sym_types.write_type(s);
  s << ": ";
  if (is_static()) s << " static";
  index_type c = init.count_values();
  element_vec* its = init.values();
  s << " init (" << c << ") = {";
  for (index_type k = 0; k < its->length(); k++) {
    if (k > 0) s << ' ';
    ((PDDL_Base::FInitAtom*)((*its)[k]))->print(s);
  }
  delete its;
  s << "}" << std::endl;
}
void PDDL_Base::FunctionSymbol::print(std::ostream& s)
{
  s << "(:function " << print_name;
  for (index_type k = 0; k < param.length(); k++) {
    s << " ";
    param[k]->print(s);
  }
  s << "):";
  if (is_static()) s << " static";
  if (increased) s << " increased";
  if (decreased) s << " decreased";
  if (assigned) s << " assigned";
  if (borrowed) s << " borrowed";
  if (linear) s << " linear";
  if (integral) s << " integral";
  index_type c = init.count_values();
  element_vec* its = init.values();
  s << " init (" << c << ") = {";
  for (index_type k = 0; k < its->length(); k++) {
    if (k > 0) s << ' ';
    ((PDDL_Base::FInitAtom*)((*its)[k]))->print(s);
  }
  delete its;
  s << "}" << std::endl;
}
void PDDL_Base::Expression::print_sum(std::ostream& s, bool grnd)
{
  if (exp_class == exp_add) {
    BinaryExpression* bexp = (BinaryExpression*)this;
    bexp->first->print_sum(s, grnd);
    s << ' ';
    bexp->second->print_sum(s, grnd);
  }
  else {
    print(s, grnd);
  }
}
void PDDL_Base::Expression::print_product(std::ostream& s, bool grnd)
{
  if (exp_class == exp_mul) {
    BinaryExpression* bexp = (BinaryExpression*)this;
    bexp->first->print_product(s, grnd);
    s << ' ';
    bexp->second->print_product(s, grnd);
  }
  else {
    print(s, grnd);
  }
}
void PDDL_Base::Expression::print(std::ostream& s, bool grnd)
{
  switch (exp_class) {
  case exp_fun:
    {
      if (Instance::write_PDDL2) {
 FunctionExpression* fexp = (FunctionExpression*)this;
 s << '(' << fexp->fun->print_name;
 if (fexp->args) fexp->args->print(s, grnd);
 s << ')';
      }
      else {
 s << "0";
      }
    }
    return;
  case exp_list:
    {
      ListExpression* lexp = (ListExpression*)this;
      if ((lexp->sym->sym_class == sym_variable) &&
   (((VariableSymbol*)lexp->sym)->value != 0) &&
   grnd) {
 s << ' ' << ((VariableSymbol*)lexp->sym)->value->print_name;
      }
      else {
 s << ' ' << lexp->sym->print_name;
      }
      if (lexp->rest) lexp->rest->print(s, grnd);
    }
    return;
  case exp_time:
    {
      TimeExpression* texp = (TimeExpression*)this;
      if (texp->time_exp == 0) {
 s << "(total-time)";
      }
      else {
 texp->time_exp->print(s, grnd);
      }
    }
    return;
  case exp_const:
    {
      ConstantExpression* cexp = (ConstantExpression*)this;
      s << std::resetiosflags(std::ios::scientific) << ((cexp->val).decimal());
    }
    return;
  case exp_add:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      s << "(+ ";
      if (print_nary) {
 bexp->first->print_sum(s, grnd);
      }
      else {
 bexp->first->print(s, grnd);
      }
      s << ' ';
      if (print_nary) {
 bexp->second->print_sum(s, grnd);
      }
      else {
 bexp->second->print(s, grnd);
      }
      s << ')';
    }
    return;
  case exp_sub:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      s << "(- ";
      bexp->first->print(s, grnd);
      s << ' ';
      bexp->second->print(s, grnd);
      s << ')';
    }
    return;
  case exp_mul:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      s << "(* ";
      if (print_nary) {
 bexp->first->print_product(s, grnd);
      }
      else {
 bexp->first->print(s, grnd);
      }
      s << ' ';
      if (print_nary) {
 bexp->second->print_product(s, grnd);
      }
      else {
 bexp->second->print(s, grnd);
      }
      s << ')';
    }
    return;
  case exp_div:
    {
      BinaryExpression* bexp = (BinaryExpression*)this;
      s << "(/ ";
      bexp->first->print(s, grnd);
      s << ' ';
      bexp->second->print(s, grnd);
      s << ')';
    }
    return;
  case exp_preference:
    {
      if (Instance::write_PDDL3) {
 PreferenceExpression* pexp = (PreferenceExpression*)this;
 s << "(is-violated ";
 pexp->name->print(s);
 s << ")";
      }
      else {
 s << "0";
      }
    }
    return;
  }
}
void PDDL_Base::Relation::print(std::ostream& s, bool grnd)
{
  switch (at) {
  case md_start:
    s << "(at start ";
    break;
  case md_end:
    s << "(at end ";
    break;
  case md_all:
    s << "(over all ";
    break;
  case md_init:
    s << "(:init ";
    break;
  case md_pos_goal:
    s << "(:goal ";
    break;
  case md_neg_goal:
    s << "(:goal (not ";
    break;
  }
  s << "(";
  switch (rel) {
  case rel_equal:
    s << "= ";
    break;
  case rel_greater:
    s << "> ";
    break;
  case rel_greater_equal:
    s << ">= ";
    break;
  case rel_less:
    s << "< ";
    break;
  case rel_less_equal:
    s << "<= ";
    break;
  }
  first->print(s, grnd);
  s << " ";
  second->print(s, grnd);
  s << ")";
  switch (at) {
  case md_start:
  case md_end:
  case md_all:
  case md_init:
  case md_pos_goal:
    s << ")";
    break;
  case md_neg_goal:
    s << "))";
    break;
  }
}
void PDDL_Base::ActionSymbol::print(std::ostream& s)
{
  s << "(:action " << print_name << std::endl;
  s << "  :parameters (";
  for (index_type k = 0; k < param.length(); k++) {
    if (k > 0) s << ' ';
    param[k]->print(s);
  }
  s << ")" << std::endl;
  if (part) {
    s << "  :set ";
    part->print(s);
    s << std::endl;
  }
  if (assoc) {
    s << "  :assoc \"" << assoc << "\"" << std::endl;
  }
  s << "  :pos_prec (";
  for (index_type k = 0; k < pos_pre.length(); k++) {
    pos_pre[k]->print(s);
    if (k + 1 < pos_pre.length()) s << " ";
  }
  s << ")" << std::endl;
  s << "  :neg_prec (";
  for (index_type k = 0; k < neg_pre.length(); k++) {
    neg_pre[k]->print(s);
    if (k + 1 < neg_pre.length()) s << " ";
  }
  s << ")" << std::endl;
  s << "  :set_prec (";
  for (index_type k = 0; k < set_pre.length(); k++) {
    set_pre[k]->print(s);
    if (k + 1 < set_pre.length()) s << " ";
  }
  s << ")" << std::endl;
  s << "  :dis_prec (";
  for (index_type k = 0; k < dis_pre.length(); k++) {
    dis_pre[k]->print_as_disjunction(s);
    if (k + 1 < dis_pre.length()) s << " ";
  }
  s << ")" << std::endl;
  s << "  :num_prec (";
  for (index_type k = 0; k < num_pre.length(); k++) {
    num_pre[k]->print(s, false);
    if (k + 1 < num_pre.length()) s << " ";
  }
  s << ")" << std::endl;
  s << "  :add (";
  for (index_type k = 0; k < adds.length(); k++) {
    adds[k]->print(s);
    if (k + 1 < adds.length()) s << " ";
  }
  s << ")" << std::endl;
  s << "  :del (";
  for (index_type k = 0; k < dels.length(); k++) {
    dels[k]->print(s);
    if (k + 1 < dels.length()) s << " ";
  }
  s << ")" << std::endl;
  s << "  :lock (";
  for (index_type k = 0; k < locks.length(); k++) {
    locks[k]->print(s);
    if (k + 1 < locks.length()) s << " ";
  }
  s << ")" << std::endl;
  s << "  :enable (";
  for (index_type k = 0; k < enables.length(); k++) {
    enables[k]->print(s);
    if (k + 1 < enables.length()) s << " ";
  }
  s << ")" << std::endl;
  s << "  :cons - " << cons.length() << " - (";
  for (index_type k = 0; k < cons.length(); k++) {
    cons[k]->print(s);
    if (k + 1 < cons.length()) s << " ";
  }
  s << ")" << std::endl;
  s << "  :require (";
  for (index_type k = 0; k < reqs.length(); k++) {
    reqs[k]->print(s);
    if (k + 1 < reqs.length()) s << " ";
  }
  s << ")" << std::endl;
  s << "  :increase (";
  for (index_type k = 0; k < incs.length(); k++) {
    if (k > 0) s << " ";
    incs[k]->print(s);
  }
  for (index_type k = 0; k < qc_incs.length(); k++) {
    if ((k > 0) || (incs.length() > 0)) s << " ";
    qc_incs[k]->print(s);
  }
  s << ")" << std::endl;
  s << "  :decrease (";
  for (index_type k = 0; k < decs.length(); k++) {
    if (k > 0) s << " ";
    decs[k]->print(s);
  }
  for (index_type k = 0; k < qc_decs.length(); k++) {
    if ((k > 0) || (decs.length() > 0)) s << " ";
    qc_decs[k]->print(s);
  }
  s << ")" << std::endl;
  s << "  :assign (";
  for (index_type k = 0; k < fass.length(); k++) {
    if (k > 0) s << " ";
    fass[k]->print(s);
  }
  for (index_type k = 0; k < qc_fass.length(); k++) {
    if ((k > 0) || (fass.length() > 0)) s << " ";
    qc_fass[k]->print(s);
  }
  s << ")" << std::endl;
  s << "  :set_effects (";
  for (index_type k = 0; k < set_eff.length(); k++) {
    set_eff[k]->print(s);
    if (k + 1 < set_eff.length()) s << " ";
  }
  s << ")" << std::endl;
  s << "  :cond_effects (";
  for (index_type k = 0; k < cond_eff.length(); k++) {
    cond_eff[k]->print(s);
    if (k + 1 < cond_eff.length()) s << " ";
  }
  s << ")" << std::endl;
  if (dmin) {
    s << "  :dmin ";
    dmin->print(s, false);
    s << std::endl;
  }
  if (dmax) {
    s << "  :dmax ";
    dmax->print(s, false);
    s << std::endl;
  }
  for (index_type k = 0; k < exps.length(); k++) {
    s << "  (:expansion " << std::endl;
    exps[k]->print(s);
    s << "  )" << std::endl;
  }
  if (irr_ins.length() > 0) {
    s << "%% irrelevant instances" << std::endl;
    for (index_type k = 0; k < irr_ins.length(); k++) {
      irr_ins[k]->print(s);
    }
    s << "%%" << std::endl;
  }
  s << "  :refs";
  for (index_type k = 0; k < refs.length(); k++) {
    s << " ";
    refs[k]->print(s);
  }
  s << ")" << std::endl;
}
void PDDL_Base::ActionSymbol::write_prototype(std::ostream& s)
{
  s << "(" << print_name;
  for (index_type k = 0; k < param.length(); k++) {
    if (k > 0) s << ' ';
    param[k]->print(s);
  }
  s << ")";
}
void PDDL_Base::SetName::print(std::ostream& s)
{
  s << "(" << sym->print_name;
  PDDL_Base::AtomBase::print(s);
  s << ")";
}
void PDDL_Base::AtomBase::print(std::ostream& s) const
{
  for (index_type k = 0; k < param.length(); k++) {
    s << ' ';
    if (param[k]->sym_class == sym_variable) {
      VariableSymbol* v = (VariableSymbol*)param[k];
      if (v->binding != 0) {
 v->binding->print(s);
      }
      else {
 s << v->print_name;
      }
    }
    else {
      s << param[k]->print_name;
    }
    if (print_bindings) {
      if (param[k]->sym_class == sym_variable) {
 VariableSymbol* v = (VariableSymbol*)param[k];
 if (v->value)
   v->value->print(s << " = ");
 else
   s << " = ??";
      }
    }
  }
}
void PDDL_Base::SetName::print_instance(std::ostream& s)
{
  s << "(" << sym->print_name;
  PDDL_Base::AtomBase::print_instance(s);
  s << ")";
}
void PDDL_Base::AtomBase::print_instance(std::ostream& s)
{
  for (index_type k = 0; k < param.length(); k++) {
    s << ' ';
    if (param[k]->sym_class == sym_variable) {
      VariableSymbol* v = (VariableSymbol*)param[k];
      if (v->value)
 v->value->print(s);
      else
 s << "?";
    }
    else {
      param[k]->print(s);
    }
  }
}
void PDDL_Base::Atom::print(std::ostream& s, bool neg) const
{
  if (Instance::write_PDDL2) {
    switch (at) {
    case md_start:
      s << "(at start ";
      break;
    case md_end:
      s << "(at end ";
      break;
    case md_all:
      s << "(over all ";
      break;
    }
  }
  if (neg) s << "(not ";
  if (Instance::write_DKEL) {
    switch (at) {
    case md_init:
      s << "(:init ";
      break;
    case md_pos_goal:
      s << "(:goal ";
      break;
    case md_neg_goal:
      s << "(:goal (not ";
      break;
    }
  }
  s << "(" << pred->print_name;
  PDDL_Base::AtomBase::print(s);
  s << ")";
  if (Instance::write_DKEL) {
    switch (at) {
    case md_init:
    case md_pos_goal:
      s << ")";
      break;
    case md_neg_goal:
      s << "))";
    }
  }
  if (neg) s << ")";
  if (Instance::write_PDDL2) {
    switch (at) {
    case md_start:
    case md_end:
    case md_all:
      s << ")";
    }
  }
}
void PDDL_Base::FTerm::print(std::ostream& s) const
{
  s << "(" << fun->print_name;
  PDDL_Base::AtomBase::print(s);
  s << ")";
}
void PDDL_Base::FInitAtom::print(std::ostream& s)
{
  s << "(= (" << fun->print_name;
  PDDL_Base::AtomBase::print(s);
  s << ") " << val << ")";
}
void PDDL_Base::OInitAtom::print(std::ostream& s)
{
  s << "(= (" << fun->print_name;
  PDDL_Base::AtomBase::print(s);
  s << ") " << val->print_name << ")";
}
void PDDL_Base::FChangeAtom::print(std::ostream& s)
{
  switch (at) {
  case md_start:
    s << "(at start ";
    break;
  case md_end:
    s << "(at end ";
    break;
  case md_all:
    s << "(over all ";
    break;
  }
  s << "((" << fun->print_name;
  PDDL_Base::AtomBase::print(s);
  s << ") . ";
  val->print(s, false);
  s << ")";
  if (at != md_none) s << ")";
}
void PDDL_Base::Reference::print(std::ostream& s)
{
  s << '(' << name->print_name;
  PDDL_Base::AtomBase::print(s);
  s << ')';
}
void PDDL_Base::SimpleReferenceSet::print(std::ostream& s)
{
  if (param.length() > 0) s << "(setof";
  PDDL_Base::Context::print(s);
  ref->print(s);
  if (param.length() > 0) s << ")";
}
void PDDL_Base::ReferenceSet::print(std::ostream& s)
{
  s << "(:set";
  if (name) {
    s << " :name" << name->print_name;
  }
  PDDL_Base::Context::print(s);
  for (index_type k = 0; k < refs.length(); k++) {
    s << " ";
    refs[k]->print(s);
  }
  s << ")";
}
void PDDL_Base::SequentialTaskNet::print(std::ostream& s)
{
  s << "(:expansion" << std::endl;
  PDDL_Base::Context::print(s);
  s << "  :tasks (";
  for (index_type k = 0; k < tasks.length(); k++) {
    tasks[k]->print(s);
    if (k + 1 < tasks.length()) s << std::endl;
  }
  s << "))" << std::endl;
}
void PDDL_Base::TypeConstraint::print(std::ostream& s)
{
  s << "( " << typ->print_name << " ";
  if (var->binding != 0) {
    var->binding->print(s);
  }
  else {
    s << var->print_name;
  }
  s << ")";
}
void PDDL_Base::Context::print(std::ostream& s)
{
  if (param.length() > 0) {
    s << "  :vars (";
    for (index_type k = 0; k < param.length(); k++) {
      if (k > 0) s << ' ';
      param[k]->print(s);
    }
    s << ")" << std::endl;
  }
  if (pos_con.length() > 0) {
    s << "  :pos_context (";
    for (index_type k = 0; k < pos_con.length(); k++) {
      pos_con[k]->print(s);
      if (k + 1 < pos_con.length()) s << " ";
    }
    s << ")" << std::endl;
  }
  if (neg_con.length() > 0) {
    s << "  :neg_context (";
    for (index_type k = 0; k < neg_con.length(); k++) {
      neg_con[k]->print(s);
      if (k + 1 < neg_con.length()) s << " ";
    }
    s << ")" << std::endl;
  }
  if (type_con.length() > 0) {
    s << "  :type_con (";
    for (index_type k = 0; k < type_con.length(); k++) {
      type_con[k]->print(s);
      if (k + 1 < type_con.length()) s << " ";
    }
    s << ")" << std::endl;
  }
}
void PDDL_Base::Context::print_assignment(std::ostream& s)
{
  for (index_type k = 0; k < param.length(); k++) {
    if (k > 0) s << ", ";
    param[k]->print(s);
    s << " = ";
    if (param[k]->value) {
      param[k]->value->print(s);
    }
    else {
      s << "?";
    }
  }
}
void PDDL_Base::DKEL_Item::print_begin(std::ostream& s)
{
  s << '(' << item_name << std::endl;
  if (name) {
    s << "  :name " << name->print_name << std::endl;
  }
  for (index_type k = 0; k < item_tags.length(); k++) {
    s << "  :tag " << item_tags[k] << std::endl;
  }
  Context::print(s);
}
void PDDL_Base::DKEL_Item::write_dkel(std::ostream& s)
{
  s << " (" << item_name << std::endl;
  if (name) {
    s << "  :name " << name->print_name << std::endl;
  }
  for (index_type k = 0; k < item_tags.length(); k++) {
    s << "  :tag " << item_tags[k] << std::endl;
  }
  if (param.length() > 0) {
    s << "  :vars (";
    for (index_type k = 0; k < param.length(); k++) {
      if (k > 0) s << ' ';
      param[k]->print(s);
    }
    s << ")" << std::endl;
  }
  if ((pos_con.length() + neg_con.length()) > 0) {
    s << "  :context (and";
    for (index_type k = 0; k < pos_con.length(); k++) {
      s << " ";
      pos_con[k]->print(s, false);
    }
    for (index_type k = 0; k < neg_con.length(); k++) {
      s << " ";
      neg_con[k]->print(s, true);
    }
    s << ")" << std::endl;
  }
}
void PDDL_Base::DKEL_Item::print_end(std::ostream& s)
{
  s << ")" << std::endl;
}
void PDDL_Base::DKEL_Item::print(std::ostream& s)
{
  print_begin(s);
  print_end(s);
}
void PDDL_Base::SetOf::print(std::ostream& s)
{
  s << "(setof :vars (";
  for (index_type k = 0; k < param.length(); k++) {
    if (k > 0) s << ' ';
    param[k]->print(s);
  }
  s << ")";
  if (pos_con.length() + neg_con.length() > 0) {
    s << ":context";
    if (pos_con.length() + neg_con.length() > 1) s << " (and";
    for (index_type k = 0; k < pos_con.length(); k++) {
      s << " ";
      pos_con[k]->print(s);
    }
    for (index_type k = 0; k < neg_con.length(); k++) {
      s << " (not ";
      neg_con[k]->print(s);
      s << ")";
    }
    if (pos_con.length() + neg_con.length() > 1) s << ")";
  }
  if (pos_atoms.length() + neg_atoms.length() > 1) s << " (and";
  for (index_type k = 0; k < pos_atoms.length(); k++) {
    s << " ";
    pos_atoms[k]->print(s);
  }
  for (index_type k = 0; k < neg_atoms.length(); k++) {
    s << " ";
    neg_atoms[k]->print(s);
  }
  if (pos_atoms.length() + neg_atoms.length() > 1) s << ")";
  s << ")";
}
void PDDL_Base::SetOf::print_as_disjunction(std::ostream& s)
{
  if (param.length() > 0) {
    s << "(exists (";
    for (index_type k = 0; k < param.length(); k++) {
      if (k > 0) s << ' ';
      param[k]->print(s);
    }
    s << ") ";
  }
  if (pos_con.length() + neg_con.length() > 0) {
    s << "(and ";
    for (index_type k = 0; k < pos_con.length(); k++) {
      s << " ";
      pos_con[k]->print(s);
    }
    for (index_type k = 0; k < neg_con.length(); k++) {
      s << " (not ";
      neg_con[k]->print(s);
      s << ")";
    }
    s << " ";
  }
  if (pos_atoms.length() + neg_atoms.length() > 1) s << "(or ";
  for (index_type k = 0; k < pos_atoms.length(); k++) {
    if (k > 0) s << " ";
    pos_atoms[k]->print(s);
  }
  for (index_type k = 0; k < neg_atoms.length(); k++) {
    if ((k > 0) || (pos_atoms.length() > 0)) s << " ";
    neg_atoms[k]->print(s);
  }
  if (pos_atoms.length() + neg_atoms.length() > 1) s << ")";
  if (pos_con.length() + neg_con.length() > 0) s << ")";
  if (param.length() > 0) s << ")";
}
void PDDL_Base::QCNumericEffect::print(std::ostream& s)
{
  s << "(setof :vars (";
  for (index_type k = 0; k < param.length(); k++) {
    if (k > 0) s << ' ';
    param[k]->print(s);
  }
  s << ") ";
  if (pos_con.length() + neg_con.length() > 0) {
    s << ":context";
    if (pos_con.length() + neg_con.length() > 1) s << " (and";
    for (index_type k = 0; k < pos_con.length(); k++) {
      s << " ";
      pos_con[k]->print(s);
    }
    for (index_type k = 0; k < neg_con.length(); k++) {
      s << " (not ";
      neg_con[k]->print(s);
      s << ")";
    }
    if (pos_con.length() + neg_con.length() > 1) s << ")";
    s << " ";
  }
  atom->print(s);
  s << ")";
}
void PDDL_Base::SetConstraint::print(std::ostream& s)
{
  PDDL_Base::DKEL_Item::print_begin(s);
  s << "  :set-constraint (";
  switch (sc_type) {
  case sc_at_most:
    s << "at-most-n";
    break;
  case sc_at_least:
    s << "at-least-n";
    break;
  case sc_exactly:
    s << "exactly-n";
    break;
  }
  s << " " << sc_count;
  for (index_type k = 0; k < pos_atoms.length(); k++) {
    s << " ";
    pos_atoms[k]->print(s);
  }
  for (index_type k = 0; k < neg_atoms.length(); k++) {
    s << " (not ";
    neg_atoms[k]->print(s);
    s << ")";
  }
  for (index_type k = 0; k < atom_sets.length(); k++) {
    s << " ";
    atom_sets[k]->print(s);
  }
  s << ")" << std::endl;
  PDDL_Base::DKEL_Item::print_end(s);
}
void PDDL_Base::SetConstraint::write_dkel(std::ostream& s)
{
  PDDL_Base::DKEL_Item::write_dkel(s);
  s << "  :set-constraint (";
  switch (sc_type) {
  case sc_at_most:
    s << "at-most-n";
    break;
  case sc_at_least:
    s << "at-least-n";
    break;
  case sc_exactly:
    s << "exactly-n";
    break;
  }
  s << " " << sc_count;
  for (index_type k = 0; k < pos_atoms.length(); k++) {
    s << " ";
    pos_atoms[k]->print(s);
  }
  for (index_type k = 0; k < neg_atoms.length(); k++) {
    s << " (not ";
    neg_atoms[k]->print(s);
    s << ")";
  }
  for (index_type k = 0; k < atom_sets.length(); k++) {
    s << " ";
    atom_sets[k]->print(s);
  }
  s << "))" << std::endl;
}
void PDDL_Base::InvariantFormula::write_dkel(std::ostream& s)
{
  PDDL_Base::DKEL_Item::write_dkel(s);
  s << "  :formula ";
  f->print(s);
  s << ")" << std::endl;
}
void PDDL_Base::IrrelevantItem::print(std::ostream& s)
{
  PDDL_Base::DKEL_Item::print_begin(s);
  if (entity->name->sym_class == sym_predicate)
    s << "  :fact ";
  else
    s << "  :action ";
  entity->print(s);
  PDDL_Base::DKEL_Item::print_end(s);
}
void PDDL_Base::IrrelevantItem::write_dkel(std::ostream& s)
{
  PDDL_Base::DKEL_Item::write_dkel(s);
  if (entity->name->sym_class == sym_predicate)
    s << "  :fact ";
  else
    s << "  :action ";
  entity->print(s);
  s << ")" << std::endl;
}
void PDDL_Base::Preference::print(std::ostream& s)
{
  s << "(preference ";
  if (name) {
    name->print(s);
    s << " ";
  }
  goal->print(s);
  s << ")";
}
void PDDL_Base::InputPlan::print(std::ostream& s)
{
  s << "(:plan";
  if (name) {
    s << std::endl << "  :name ";
    name->print(s);
  }
  if (is_opt) {
    s << std::endl << "  :opt";
  }
  for (index_type k = 0; k < steps.length(); k++) {
    s << std::endl << "  " << std::resetiosflags(std::ios::scientific) << ((steps[k]->start_time).decimal()) << " : ";
    steps[k]->act->print(s);
    s << " ; " << steps[k]->act->index;
  }
  s << std::endl << ")" << std::endl;
}
void PDDL_Base::print(std::ostream& s)
{
  s << "domain: " << (domain_name ? domain_name : "<not defined>") << std::endl;
  s << "problem: " << (problem_name ? problem_name : "<not defined>") << std::endl;
  s << "<" << dom_predicates.length() << "," << dom_functions.length() << "," << dom_actions.length()
    << ">" << std::endl;
  dom_top_type->print(s);
  for (index_type k = 0; k < dom_types.length(); k++) dom_types[k]->print(s);
  for (index_type k = 0; k < dom_predicates.length(); k++) dom_predicates[k]->print(s);
  for (index_type k = 0; k < dom_object_functions.length(); k++) dom_object_functions[k]->print(s);
  for (index_type k = 0; k < dom_functions.length(); k++) dom_functions[k]->print(s);
  for (index_type k = 0; k < dom_actions.length(); k++) dom_actions[k]->print(s);
  for (index_type k = 0; k < dom_sc_invariants.length(); k++)
    dom_sc_invariants[k]->print(s);
  for (index_type k = 0; k < dom_f_invariants.length(); k++)
    dom_f_invariants[k]->print(s);
  s << "goals:";
  for (index_type k = 0; k < dom_goals.length(); k++) {
    s << " ";
    dom_goals[k]->print(s);
  }
  s << std::endl << "preferences:";
  for (index_type k = 0; k < dom_preferences.length(); k++) {
    s << " ";
    dom_preferences[k]->print(s);
  }
  s << std::endl;
}
void PDDL_Base::write_declarations(std::ostream& s)
{
  if (dom_types.length() > 0) {
    s << " (:types";
    for (index_type k = 0; k < dom_types.length(); k++) {
      s << " " << dom_types[k]->print_name;
      dom_types[k]->sym_types.write_type(s);
    }
    s << ")" << std::endl;
  }
  if (dom_predicates.length() > 0) {
    s << " (:predicates";
    for (index_type k = 0; k < dom_predicates.length(); k++) {
      s << " (" << dom_predicates[k]->print_name;
      for (index_type i = 0; i < dom_predicates[k]->param.length(); i++) {
 s << " " << dom_predicates[k]->param[i]->print_name;
 if (dom_types.length() > 0) {
   dom_predicates[k]->param[i]->sym_types.write_type(s);
 }
      }
      s << ")";
    }
    s << ")" << std::endl;
  }
  if (Instance::write_PDDL2 && (dom_functions.length() > 0)) {
    s << " (:functions";
    for (index_type k = 0; k < dom_functions.length(); k++) {
      s << " (" << dom_functions[k]->print_name;
      for (index_type i = 0; i < dom_functions[k]->param.length(); i++) {
 s << " " << dom_functions[k]->param[i]->print_name;
 if (dom_types.length() > 0) {
   dom_functions[k]->param[i]->sym_types.write_type(s);
 }
      }
      s << ")";
    }
    s << ")" << std::endl;
  }
}
void PDDL_Base::write_set_precondition(std::ostream& s, SetOf* set)
{
  mode_keyword m = md_none;
  if (set->pos_atoms.length() > 0)
    m = set->pos_atoms[0]->at;
  else if (set->neg_atoms.length() > 0)
    m = set->neg_atoms[0]->at;
  if (Instance::write_PDDL2) {
    switch (m) {
    case md_start:
      s << "(at start ";
      break;
    case md_end:
      s << "(at end ";
      break;
    case md_all:
      s << "(over all ";
      break;
    }
  }
  s << "(forall (";
  for (index_type j = 0; j < set->param.length(); j++) {
    s << " " << set->param[j]->print_name;
    if (dom_types.length() > 0) {
      set->param[j]->sym_types.write_type(s);
    }
  }
  s << ")";
  if (set->pos_con.length() + set->neg_con.length() + set->type_con.length() > 0) {
    s << " (imply (and";
    for (index_type j = 0; j < set->pos_con.length(); j++) {
      s << " ";
      set->pos_con[j]->print(s, false);
    }
    for (index_type j = 0; j < set->neg_con.length(); j++) {
      s << " ";
      set->neg_con[j]->print(s, true);
    }
    for (index_type j = 0; j < set->type_con.length(); j++) {
      s << " ";
      set->type_con[j]->print(s);
    }
    s << ")";
  }
  if (set->pos_atoms.length() + set->neg_atoms.length() > 1) s << " (and";
  for (index_type k = 0; k < set->pos_atoms.length(); k++) {
    s << " (" << set->pos_atoms[k]->pred->print_name;
    ((PDDL_Base::AtomBase*)set->pos_atoms[k])->print(s);
    s << ")";
  }
  for (index_type k = 0; k < set->neg_atoms.length(); k++) {
    s << " (not (" << set->neg_atoms[k]->pred->print_name;
    ((PDDL_Base::AtomBase*)set->neg_atoms[k])->print(s);
    s << "))";
  }
  if (set->pos_atoms.length() + set->neg_atoms.length() > 1) s << ")";
  if (set->pos_con.length() + set->neg_con.length() + set->type_con.length() > 0) s << ")";
  s << ")";
  if (Instance::write_PDDL2) {
    switch (m) {
    case md_start:
    case md_end:
    case md_all:
      s << ")";
    }
  }
}
void PDDL_Base::write_disjunctive_set_precondition(std::ostream& s, SetOf* set)
{
  mode_keyword m = md_none;
  if (set->pos_atoms.length() > 0)
    m = set->pos_atoms[0]->at;
  else if (set->neg_atoms.length() > 0)
    m = set->neg_atoms[0]->at;
  if (Instance::write_PDDL2) {
    switch (m) {
    case md_start:
      s << "(at start ";
      break;
    case md_end:
      s << "(at end ";
      break;
    case md_all:
      s << "(over all ";
      break;
    }
  }
  s << "(exists (";
  for (index_type j = 0; j < set->param.length(); j++) {
    s << " " << set->param[j]->print_name;
    if (dom_types.length() > 0) {
      set->param[j]->sym_types.write_type(s);
    }
  }
  s << ")";
  if (set->pos_con.length() + set->neg_con.length() + set->type_con.length() > 0) {
    s << " (and";
    for (index_type j = 0; j < set->pos_con.length(); j++) {
      s << " ";
      set->pos_con[j]->print(s, false);
    }
    for (index_type j = 0; j < set->neg_con.length(); j++) {
      s << " ";
      set->neg_con[j]->print(s, true);
    }
    for (index_type j = 0; j < set->type_con.length(); j++) {
      s << " ";
      set->type_con[j]->print(s);
    }
  }
  if (set->pos_atoms.length() + set->neg_atoms.length() > 1) s << " (or";
  for (index_type k = 0; k < set->pos_atoms.length(); k++) {
    s << " (" << set->pos_atoms[k]->pred->print_name;
    ((PDDL_Base::AtomBase*)set->pos_atoms[k])->print(s);
    s << ")";
  }
  for (index_type k = 0; k < set->neg_atoms.length(); k++) {
    s << " (not (" << set->neg_atoms[k]->pred->print_name;
    ((PDDL_Base::AtomBase*)set->neg_atoms[k])->print(s);
    s << "))";
  }
  if (set->pos_atoms.length() + set->neg_atoms.length() > 1) s << ")";
  if (set->pos_con.length() + set->neg_con.length() + set->type_con.length() > 0) s << ")";
  s << ")";
  if (Instance::write_PDDL2) {
    switch (m) {
    case md_start:
    case md_end:
    case md_all:
      s << ")";
    }
  }
}
void PDDL_Base::write_set_effect(std::ostream& s, SetOf* set)
{
  mode_keyword m = md_none;
  if (set->pos_atoms.length() > 0)
    m = set->pos_atoms[0]->at;
  else if (set->neg_atoms.length() > 0)
    m = set->neg_atoms[0]->at;
  if (Instance::write_PDDL2) {
    switch (m) {
    case md_start:
      s << "(at start ";
      break;
    case md_end:
      s << "(at end ";
      break;
    case md_all:
      s << "(over all ";
      break;
    }
  }
  if (set->param.length() > 0) {
    s << "(forall (";
    for (index_type j = 0; j < set->param.length(); j++) {
      s << " " << set->param[j]->print_name;
      if (dom_types.length() > 0) {
 set->param[j]->sym_types.write_type(s);
      }
    }
    s << ") ";
  }
  if (set->pos_con.length() + set->neg_con.length() + set->type_con.length() > 0) {
    s << "(when (and";
    for (index_type j = 0; j < set->pos_con.length(); j++) {
      s << " ";
      set->pos_con[j]->print(s, false);
    }
    for (index_type j = 0; j < set->neg_con.length(); j++) {
      s << " ";
      set->neg_con[j]->print(s, true);
    }
    for (index_type j = 0; j < set->type_con.length(); j++) {
      s << " ";
      set->type_con[j]->print(s);
    }
    s << ") ";
  }
  if (set->pos_atoms.length() + set->neg_atoms.length() > 1) s << "(and";
  for (index_type k = 0; k < set->pos_atoms.length(); k++) {
    s << " (" << set->pos_atoms[k]->pred->print_name;
    ((PDDL_Base::AtomBase*)set->pos_atoms[k])->print(s);
    s << ")";
  }
  for (index_type k = 0; k < set->neg_atoms.length(); k++) {
    s << " (not (" << set->neg_atoms[k]->pred->print_name;
    ((PDDL_Base::AtomBase*)set->neg_atoms[k])->print(s);
    s << "))";
  }
  if (set->pos_atoms.length() + set->neg_atoms.length() > 1) s << ")";
  if (set->pos_con.length() + set->neg_con.length() + set->type_con.length() > 0) s << ")";
  if (set->param.length() > 0) s << ")";
  if (Instance::write_PDDL2) {
    switch (m) {
    case md_start:
    case md_end:
    case md_all:
      s << ")";
    }
  }
}
void PDDL_Base::write_QCN_effect(std::ostream& s, const char* effect_type, QCNumericEffect* qcn)
{
  if (Instance::write_PDDL2) {
    switch (qcn->atom->at) {
    case md_start:
      s << "(at start ";
      break;
    case md_end:
      s << "(at end ";
      break;
    }
  }
  if (qcn->param.length() > 0) {
    s << "(forall (";
    for (index_type j = 0; j < qcn->param.length(); j++) {
      if (j > 0) s << " ";
      s << qcn->param[j]->print_name;
      if (dom_types.length() > 0) {
 qcn->param[j]->sym_types.write_type(s);
      }
    }
    s << ") ";
  }
  if (qcn->pos_con.length() + qcn->neg_con.length() + qcn->type_con.length() > 0) {
    s << "(when (and";
    for (index_type j = 0; j < qcn->pos_con.length(); j++) {
      s << " ";
      qcn->pos_con[j]->print(s, false);
    }
    for (index_type j = 0; j < qcn->neg_con.length(); j++) {
      s << " ";
      qcn->neg_con[j]->print(s, true);
    }
    for (index_type j = 0; j < qcn->type_con.length(); j++) {
      s << " ";
      qcn->type_con[j]->print(s);
    }
    s << ") ";
  }
  s << "(" << effect_type << " ";
  s << "(" << qcn->atom->fun->print_name;
  ((PDDL_Base::AtomBase*)qcn->atom)->print(s);
  s << ") ";
  qcn->atom->val->print(s, false);
  s << ")";
  if (qcn->pos_con.length() + qcn->neg_con.length() + qcn->type_con.length() > 0) s << ")";
  if (qcn->param.length() > 0) s << ")";
  if (Instance::write_PDDL2) {
    switch (qcn->atom->at) {
    case md_start:
    case md_end:
    case md_all:
      s << ")";
    }
  }
}
void PDDL_Base::write_action(std::ostream& s, ActionSymbol* act)
{
  bool is_durative = (Instance::write_PDDL2 && (act->dmin || act->dmax));
  index_type n_pre = (act->pos_pre.length() + act->neg_pre.length() +
        act->set_pre.length() + act->dis_pre.length() +
        (Instance::write_PDDL2 ? act->num_pre.length() : 0));
  index_type n_eff = (act->adds.length() + act->dels.length() +
        act->set_eff.length() + act->cond_eff.length() +
        (Instance::write_PDDL2 ? act->locks.length() : 0) +
        (Instance::write_PDDL2 ? act->enables.length() : 0) +
        (Instance::write_PDDL2 ? act->reqs.length() : 0) +
        (Instance::write_PDDL2 ? act->incs.length() : 0) +
        (Instance::write_PDDL2 ? act->decs.length() : 0) +
        (Instance::write_PDDL2 ? act->fass.length() : 0) +
        (Instance::write_PDDL2 ? act->qc_fass.length() : 0));
  if (is_durative)
    s << " (:durative-action " << act->print_name << std::endl;
  else
    s << " (:action " << act->print_name << std::endl;
  if ((act->param.length() > 0) ||
      Instance::always_write_parameters) {
    s << "  :parameters (";
    for (index_type i = 0; i < act->param.length(); i++) {
      s << " " << act->param[i]->print_name;
      if (dom_types.length() > 0) {
 act->param[i]->sym_types.write_type(s);
      }
    }
    s << ")" << std::endl;
  }
  if ((act->part != 0) && Instance::write_extra) {
    s << "  :set ";
    act->part->print(s);
    s << std::endl;
  }
  if (act->assoc && Instance::write_extra) {
    s << "  :assoc \"" << act->assoc << "\"" << std::endl;
  }
  if (Instance::write_PDDL2 && (act->dmin || act->dmax)) {
    if (act->dmin == act->dmax) {
      s << "  :duration (= ?duration ";
      act->dmax->print(s, false);
      s << ")" << std::endl;
    }
    else if (act->dmax) {
      if (act->dmin) {
 s << "  :duration (and (>= ?duration ";
 act->dmin->print(s, false);
 s << ") (<= ?duration ";
 act->dmax->print(s, false);
 s << "))" << std::endl;
      }
      else {
 s << "  :duration (<= ?duration ";
 act->dmax->print(s, false);
 s << ")" << std::endl;
      }
    }
    else if (act->dmin) {
      s << "  :duration (>= ?duration ";
      act->dmin->print(s, false);
      s << ")" << std::endl;
    }
  }
  if (n_pre > 0) {
    if (is_durative)
      s << "  :condition";
    else
      s << "  :precondition";
    if ((n_pre > 1) || Instance::always_write_conjunction) s << " (and";
    for (index_type i = 0; i < act->pos_pre.length(); i++) {
      s << " ";
      act->pos_pre[i]->print(s, false);
    }
    for (index_type i = 0; i < act->neg_pre.length(); i++) {
      s << " ";
      act->neg_pre[i]->print(s, true);
    }
    for (index_type i = 0; i < act->set_pre.length(); i++) {
      s << " ";
      write_set_precondition(s, act->set_pre[i]);
    }
    for (index_type i = 0; i < act->dis_pre.length(); i++) {
      s << " ";
      write_disjunctive_set_precondition(s, act->dis_pre[i]);
    }
    for (index_type i = 0; i < act->num_pre.length(); i++) {
      s << " ";
      act->num_pre[i]->print(s, false);
    }
    if ((n_pre > 1) || Instance::always_write_conjunction) s << ")";
    s << std::endl;
  }
  else if (Instance::always_write_precondition) {
    if (is_durative)
      s << "  :condition (";
    else
      s << "  :precondition (";
    if (Instance::always_write_conjunction)
      s << "and)";
    else
      s << ")";
  }
  if (n_eff > 0) {
    s << "  :effect ";
    if ((n_eff > 1) || Instance::always_write_conjunction) s << "(and";
    for (index_type i = 0; i < act->adds.length(); i++) {
      s << " ";
      act->adds[i]->print(s, false);
    }
    for (index_type i = 0; i < act->dels.length(); i++) {
      s << " ";
      act->dels[i]->print(s, true);
    }
    for (index_type i = 0; i < act->set_eff.length(); i++) {
      s << " ";
      write_set_effect(s, act->set_eff[i]);
    }
    for (index_type i = 0; i < act->cond_eff.length(); i++) {
      s << " ";
      write_set_effect(s, act->cond_eff[i]);
    }
    if (Instance::write_PDDL2) {
      for (index_type i = 0; i < act->locks.length(); i++) {
 s << " (at start (not (" << act->locks[i]->pred->print_name;
 ((PDDL_Base::AtomBase*)act->locks[i])->print(s);
 s << ")))";
 s << " (at end (" << act->locks[i]->pred->print_name;
 ((PDDL_Base::AtomBase*)act->locks[i])->print(s);
 s << "))";
      }
      for (index_type i = 0; i < act->enables.length(); i++) {
 s << " (at start (" << act->enables[i]->pred->print_name;
 ((PDDL_Base::AtomBase*)act->enables[i])->print(s);
 s << "))";
 s << " (at end (not (" << act->enables[i]->pred->print_name;
 ((PDDL_Base::AtomBase*)act->enables[i])->print(s);
 s << ")))";
      }
      for (index_type i = 0; i < act->incs.length(); i++) {
 s << " ";
 switch (act->incs[i]->at) {
 case md_start:
   s << "(at start ";
   break;
 case md_end:
   s << "(at end ";
   break;
 case md_all:
   s << "(over all ";
   break;
 }
 s << "(increase (" << act->incs[i]->fun->print_name;
 ((PDDL_Base::AtomBase*)act->incs[i])->print(s);
 s << ") ";
 act->incs[i]->val->print(s, false);
 s << ")";
 if ((act->incs[i]->at == md_start) ||
     (act->incs[i]->at == md_end) ||
     (act->incs[i]->at == md_all))
   s << ")";
      }
      for (index_type i = 0; i < act->decs.length(); i++) {
 s << " ";
 switch (act->decs[i]->at) {
 case md_start:
   s << "(at start ";
   break;
 case md_end:
   s << "(at end ";
   break;
 case md_all:
   s << "(over all ";
   break;
 }
 s << "(decrease (" << act->decs[i]->fun->print_name;
 ((PDDL_Base::AtomBase*)act->decs[i])->print(s);
 s << ") ";
 act->decs[i]->val->print(s, false);
 s << ")";
 if ((act->decs[i]->at == md_start) ||
     (act->decs[i]->at == md_end) ||
     (act->decs[i]->at == md_all))
   s << ")";
      }
      for (index_type i = 0; i < act->fass.length(); i++) {
 s << " ";
 switch (act->fass[i]->at) {
 case md_start:
   s << "(at start ";
   break;
 case md_end:
   s << "(at end ";
   break;
 case md_all:
   s << "(over all ";
   break;
 }
 s << "(assign (" << act->fass[i]->fun->print_name;
 ((PDDL_Base::AtomBase*)act->fass[i])->print(s);
 s << ") ";
 act->fass[i]->val->print(s, false);
 s << ")";
 if ((act->fass[i]->at == md_start) ||
     (act->fass[i]->at == md_end) ||
     (act->fass[i]->at == md_all))
   s << ")";
      }
      for (index_type i = 0; i < act->qc_fass.length(); i++) {
 s << " ";
 write_QCN_effect(s, "assign", act->qc_fass[i]);
      }
      for (index_type i = 0; i < act->reqs.length(); i++) {
 s << " (at start (decrease (" << act->reqs[i]->fun->print_name;
 ((PDDL_Base::AtomBase*)act->reqs[i])->print(s);
 s << ") ";
 act->reqs[i]->val->print(s, false);
 s << ")) (at end (increase (" << act->reqs[i]->fun->print_name;
 ((PDDL_Base::AtomBase*)act->reqs[i])->print(s);
 s << ") ";
 act->reqs[i]->val->print(s, false);
 s << "))";
      }
    }
    if ((n_eff > 1) || Instance::always_write_conjunction) s << ")";
    s << std::endl;
  }
  else if (Instance::always_write_effect) {
    if (Instance::always_write_conjunction)
      s << "  :effect (and)" << std::endl;
    else
      s << "  :effect ()" << std::endl;
  }
  s << " )" << std::endl;
}
void PDDL_Base::write_objects(std::ostream& s, bool defined_in_problem)
{
  index_type n_obj = 0;
  for (index_type k = 0; k < dom_constants.length(); k++)
    if (dom_constants[k]->defined_in_problem == defined_in_problem) n_obj += 1;
  if (n_obj > 0) {
    if (defined_in_problem) {
      s << " (:objects";
    }
    else {
      s << " (:constants";
    }
    for (index_type k = 0; k < dom_constants.length(); k++)
      if (dom_constants[k]->defined_in_problem == defined_in_problem) {
 s << " " << dom_constants[k]->print_name;
 if (dom_types.length() > 0) {
   dom_constants[k]->sym_types.write_type(s);
 }
      }
    s << ")" << std::endl;
  }
}
void PDDL_Base::write_init(std::ostream& s)
{
  index_type n_init = dom_init.length();
  if (Instance::write_PDDL2) n_init += dom_fun_init.length();
  if (write_PDDL31) n_init += dom_obj_init.length();
  if (n_init > 0) {
    s << " (:init";
    for (index_type k = 0; k < dom_init.length(); k++) {
      s << " (" << dom_init[k]->pred->print_name;
      ((AtomBase*)dom_init[k])->print(s);
      s << ")";
    }
    if (write_PDDL31) {
      for (index_type k = 0; k < dom_obj_init.length(); k++) {
 s << " (= (" << dom_obj_init[k]->fun->print_name;
 ((AtomBase*)dom_obj_init[k])->print(s);
 s << ") " << dom_obj_init[k]->val->print_name << ")";
      }
    }
    if (Instance::write_PDDL2) {
      for (index_type k = 0; k < dom_fun_init.length(); k++) {
 s << " (= (" << dom_fun_init[k]->fun->print_name;
 ((AtomBase*)dom_fun_init[k])->print(s);
 s << ") " << std::resetiosflags(std::ios::scientific) << ((dom_fun_init[k]->val).decimal()) << ")";
      }
    }
    s << ")" << std::endl;
  }
}
void PDDL_Base::write_goal(std::ostream& s)
{
  index_type n_in_goal = 0;
  for (index_type k = 0; k < dom_goals.length(); k++)
    if (dom_goals[k]->is_state())
      if (dom_goals[k]->is_propositional() || Instance::write_PDDL2)
 n_in_goal += 1;
  if (Instance::write_PDDL3)
    for (index_type k = 0; k < dom_preferences.length(); k++)
      if (dom_preferences[k]->is_state())
 if (dom_preferences[k]->is_propositional() || Instance::write_PDDL2)
   n_in_goal += 1;
  if (n_in_goal > 0) {
    s << " (:goal";
    if (n_in_goal > 1) s << " (and";
    for (index_type k = 0; k < dom_goals.length(); k++) {
      if (dom_goals[k]->is_state()) {
 if (dom_goals[k]->is_propositional() || Instance::write_PDDL2) {
   s << " ";
   dom_goals[k]->print(s);
 }
      }
    }
    if (Instance::write_PDDL3) {
      for (index_type k = 0; k < dom_preferences.length(); k++) {
 if (dom_preferences[k]->is_state()) {
   if (dom_preferences[k]->is_propositional() ||
       Instance::write_PDDL2) {
     s << " ";
     dom_preferences[k]->print(s);
   }
 }
      }
    }
    if (n_in_goal > 1) s << ")";
    s << ")" << std::endl;
  }
  if (Instance::write_PDDL3) {
    index_type n_in_cons = 0;
    for (index_type k = 0; k < dom_goals.length(); k++)
      if (!dom_goals[k]->is_state())
 if (dom_goals[k]->is_propositional() || Instance::write_PDDL2)
   n_in_cons += 1;
    for (index_type k = 0; k < dom_preferences.length(); k++)
      if (!dom_preferences[k]->is_state())
 if (dom_preferences[k]->is_propositional() || Instance::write_PDDL2)
   n_in_cons += 1;
    if (n_in_cons > 0) {
      s << " (:constraints";
      if (n_in_cons > 1) s << " (and";
      for (index_type k = 0; k < dom_goals.length(); k++) {
 if (!dom_goals[k]->is_state()) {
   if (dom_goals[k]->is_propositional() || Instance::write_PDDL2) {
     s << " ";
     dom_goals[k]->print(s);
   }
 }
      }
      for (index_type k = 0; k < dom_preferences.length(); k++) {
 if (!dom_preferences[k]->is_state()) {
   if (dom_preferences[k]->is_propositional() ||
       Instance::write_PDDL2) {
     s << " ";
     dom_preferences[k]->print(s);
   }
 }
      }
      if (n_in_cons > 1) s << ")";
      s << ")" << std::endl;
    }
  }
}
void PDDL_Base::write_metric(std::ostream& s)
{
  if (Instance::write_metric &&
      (Instance::write_PDDL2 || Instance::write_PDDL3)) {
    switch (metric_type) {
    case metric_makespan:
      s << " (:metric minimize (total-time))" << std::endl;
      break;
    case metric_minimize:
      s << " (:metric minimize ";
      metric->print(s, false);
      s << ")" << std::endl;
      break;
    case metric_maximize:
      s << " (:metric maximize ";
      metric->print(s, false);
      s << ")" << std::endl;
      break;
    }
  }
}
void PDDL_Base::write_dkel_items(std::ostream& s, bool defined_in_problem)
{
  if (Instance::write_DKEL) {
    for (index_type k = 0; k < dom_irrelevant.length(); k++) {
      if ((dom_irrelevant[k]->
    item_is_included(excluded_dkel_tags, required_dkel_tags)) &&
   (dom_irrelevant[k]->defined_in_problem == defined_in_problem))
 dom_irrelevant[k]->write_dkel(s);
    }
    for (index_type k = 0; k < dom_sc_invariants.length(); k++) {
      if ((dom_sc_invariants[k]->
    item_is_included(excluded_dkel_tags, required_dkel_tags)) &&
   (dom_sc_invariants[k]->defined_in_problem == defined_in_problem))
 dom_sc_invariants[k]->write_dkel(s);
    }
    for (index_type k = 0; k < dom_f_invariants.length(); k++) {
      if ((dom_f_invariants[k]->
    item_is_included(excluded_dkel_tags, required_dkel_tags)) &&
   (dom_f_invariants[k]->defined_in_problem == defined_in_problem))
 dom_f_invariants[k]->write_dkel(s);
    }
  }
}
void PDDL_Base::write_domain_begin(std::ostream& s)
{
  s << "(define (domain " << domain_name << ")" << std::endl;
}
void PDDL_Base::write_problem_begin(std::ostream& s)
{
  s << "(define (problem " << problem_name << ")" << std::endl;
  if (domain_name) {
    s << " (:domain " << domain_name << ")" << std::endl;
  }
}
void PDDL_Base::write_end(std::ostream& s)
{
  s << ")" << std::endl;
}
void PDDL_Base::write_dkel_domain(std::ostream& s, bool leave_open)
{
  write_domain_begin(s);
  write_declarations(s);
  write_objects(s, false);
  for (index_type k = 0; k < dom_actions.length(); k++) {
    write_action(s, dom_actions[k]);
  }
  write_dkel_items(s, false);
  if (!leave_open) write_end(s);
}
void PDDL_Base::write_dkel_problem(std::ostream& s, bool leave_open)
{
  write_problem_begin(s);
  write_objects(s, true);
  write_init(s);
  write_goal(s);
  write_metric(s);
  write_dkel_items(s, true);
  if (!leave_open) write_end(s);
}
void PDDL_Base::write_plans(std::ostream& s)
{
  for (index_type k = 0; k < input_plans.length(); k++) {
    input_plans[k]->print(s);
  }
}
void PDDL_Base::write_heuristic_table(std::ostream& s)
{
  s << "(:heuristic";
  for (index_type k = 0; k < h_table.length(); k++) {
    s << std::endl << "(";
    for (index_type i = 0; i < h_table[k]->atoms.length(); i++)
      h_table[k]->atoms[i]->print(s);
    s << ") ";
    if (h_table[k]->opt) s << ":opt ";
    if ((h_table[k]->cost).infinite()) s << ":inf";
    else s << h_table[k]->cost;
  }
  s << ")" << std::endl;
}
void PDDL_Base::write_sets(std::ostream& s)
{
  for (index_type k = 0; k < input_sets.length(); k++) {
    input_sets[k]->print(s);
    s << std::endl;
  }
}
PDDL_Base::Atom* PDDL_Base::make_atom_from_prop(ptr_pair& src, bool& neg)
{
  index_type i = dom_predicates.first((PredicateSymbol*)src.first);
  if (i == no_such_index) {
    std::cerr << "error in make_atom_from_prop: "
       << src.first << " is not a predicate symbol in the domain"
       << std::endl;
    exit(255);
  }
  ptr_table* ins = (ptr_table*)src.second;
  ptr_table::key_vec* args = ins->key_sequence();
  ptr_table* root = ins->root();
  if (root == &(dom_predicates[i]->pos_prop)) {
    neg = false;
  }
  else if (root == &(dom_predicates[i]->neg_prop)) {
    neg = true;
  }
  else {
    std::cerr << "error: root " << root << " of atom instance "
       << ins << " does not equal pos. or neg. set of predicate "
       << dom_predicates[i]->print_name
       << std::endl;
    exit(255);
  }
  Atom* a = new Atom(dom_predicates[i]);
  for (index_type k = 0; k < dom_predicates[i]->param.length(); k++)
    a->param.append((PDDL_Base::Symbol*)((*args)[k + 1]));
  delete args;
  return a;
}
void InstanceName::write(std::ostream& s, unsigned int c) const
{
  if (context_is_domain(c)) write_string_escaped(s, domain_name, c);
  else if (context_is_problem(c)) write_string_escaped(s, problem_name, c);
  else {
    write_string_escaped(s, domain_name, c);
    write_string_escaped(s, "::", c);
    write_string_escaped(s, problem_name, c);
  }
}
const Name* InstanceName::cast_to(const char* cname) const
{
  if (strcmp(cname, "InstanceName") == 0) return this;
  return 0;
}
char PDDL_Name::catc = '_';
bool PDDL_Name::obscure_symbol_names = false;
PDDL_Name::PDDL_Name
(PDDL_Base::Symbol* s, PDDL_Base::variable_vec a, bool n)
  : neg(n), sym(s), arg(0, a.length()), vis(s->visible), avis(true, a.length())
{
  for (index_type k = 0; k < a.length(); k++) {
    arg[k] = a[k]->value;
    avis[k] = a[k]->visible;
  }
}
void PDDL_Name::add(PDDL_Base::Symbol* s)
{
  arg.append(s);
  avis.append(s->visible);
}
void PDDL_Name::add(PDDL_Base::Symbol* s, bool v)
{
  arg.append(s);
  avis.append(v);
}
void PDDL_Name::write(std::ostream& s, unsigned int c) const
{
  if (context_is_instance(c)) {
    if (neg) {
      s << "not";
      write_char_escaped(s, catc, c);
    }
    if (obscure_symbol_names) {
      s << "S" << ((void*)sym->print_name);
    }
    else {
      write_string_escaped(s, sym->print_name, c);
    }
    for (index_type k = 0; k < arg.length(); k++) {
      write_char_escaped(s, catc, c);
      if (obscure_symbol_names) {
 s << "S" << ((void*)arg[k]->print_name);
      }
      else {
 write_string_escaped(s, arg[k]->print_name, c);
      }
    }
  }
  else {
    if (context_is_plan(c) && conform_to_IPC(c) && !vis) return;
    if (neg) write_string_escaped(s, "(not ", c);
    write_char_escaped(s, '(', c);
    if (obscure_symbol_names) {
      s << "S" << ((void*)sym->print_name);
    }
    else {
      write_string_escaped(s, sym->print_name, c);
    }
    for (index_type k = 0; k < arg.length(); k++) {
      bool do_print = true;
      if (context_is_plan(c) && conform_to_IPC(c)) {
 assert(avis.length() > k);
 if (!avis[k]) do_print = false;
      }
      if (do_print) {
 s << ' ';
 if (obscure_symbol_names) {
   s << "S" << ((void*)arg[k]->print_name);
 }
 else {
   write_string_escaped(s, arg[k]->print_name, c);
 }
      }
    }
    write_char_escaped(s, ')', c);
    if (neg) write_char_escaped(s, ')', c);
  }
}
const Name* PDDL_Name::cast_to(const char* cname) const
{
  if (strcmp(cname, "PDDL_Name") == 0) return this;
  return 0;
}
Numbered_PDDL_Name::Numbered_PDDL_Name(PDDL_Name* n, index_type c)
  : PDDL_Name(n->symbol(), n->args(), n->is_neg()), copy(c)
{
}
void Numbered_PDDL_Name::write(std::ostream& s, unsigned int c) const
{
  if (context_is_instance(c)) {
    if (neg) write_string_escaped(s, "not_", c);
    write_string_escaped(s, sym->print_name, c);
    for (index_type k = 0; k < arg.length(); k++) {
      write_char_escaped(s, '_', c);
      write_string_escaped(s, arg[k]->print_name, c);
    }
    write_char_escaped(s, '_', c);
    s << copy;
  }
  else {
    if (neg) write_string_escaped(s, "(not ", c);
    write_char_escaped(s, '(', c);
    write_string_escaped(s, sym->print_name, c);
    for (index_type k = 0; k < arg.length(); k++) {
      write_char_escaped(s, ' ', c);
      write_string_escaped(s, arg[k]->print_name, c);
    }
    write_char_escaped(s, ' ', c);
    if (!context_is_plan(c)) {
      write_char_escaped(s, '#', c);
      s << copy;
    }
    if (neg) write_char_escaped(s, ')', c);
  }
}
}
