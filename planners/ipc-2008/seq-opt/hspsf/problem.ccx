#include <string.h>
inline char* strndup(char* s, unsigned int n)
{
  char* d = new char[n+1];
  strncpy(s, d, n);
  return d;
}
#include <assert.h>
#include <limits.h>
#include <vector>
#include <utility>
#include <iostream>
namespace hsps {
typedef unsigned int index_type;
const index_type index_type_max = (UINT_MAX - 1);

const index_type LARGE_PRIME = 2147483629U;
const index_type no_such_index = UINT_MAX;

typedef unsigned long count_type;
const count_type count_type_max = ULONG_MAX;

template<class T> class swapable_pair : public std::pair<T, T>
{
 public:
  swapable_pair()
    : std::pair<T, T>() { };
  swapable_pair(const T& v1, const T& v2)
    : std::pair<T, T>(v1, v2) { };
  swapable_pair(const T& v)
    : std::pair<T, T>(v, v) { };
  swapable_pair(const swapable_pair& p)
    : std::pair<T, T>(p) { };

  void swap();
};

template<class T> class comparable_pair : public swapable_pair<T>
{
 public:
  comparable_pair()
    : swapable_pair<T>() { };
  comparable_pair(const T& v1, const T& v2)
    : swapable_pair<T>(v1, v2) { };
  comparable_pair(const T& v)
    : swapable_pair<T>(v) { };
  comparable_pair(const comparable_pair& p)
    : swapable_pair<T>(p) { };

  void sort_ascending();
  void sort_descending();
};

typedef comparable_pair<index_type> index_pair;

template<class T> class zero_init_pair : public comparable_pair<T>
{
 public:
  zero_init_pair()
    : comparable_pair<T>(0) { };
  zero_init_pair(const T& v1, const T& v2)
    : comparable_pair<T>(v1, v2) { };
  zero_init_pair(const T& v)
    : comparable_pair<T>(v) { };
  zero_init_pair(const zero_init_pair& p)
    : comparable_pair<T>(p) { };
};




class index_set;
class bool_vec;

template<class T> class lvector : public std::vector<T>
{
 public:
  lvector() : std::vector<T>() { };
  lvector(const T& v, index_type l) : std::vector<T>(l, v) { };
  lvector(const lvector<T>& vec) : std::vector<T>(vec) { };




  class element_reference {
    lvector* _vec;
    index_type _pos;
  public:
    element_reference() : _vec(0), _pos(no_such_index) { };
    element_reference(lvector& v, index_type p) : _vec(&v), _pos(p) { };
    operator T*() const {
      if (_vec == 0) return 0;
      return &((*_vec)[_pos]);
    };
  };

  class order {
   public:
    virtual bool operator()(const T& v0, const T& v1) const = 0;
  };

  index_type length() const;
  bool contains(const T& v) const;
  index_type first(const T& v) const;
  index_type next(const T& v, index_type i) const;
  index_type find(const T& v, bool_vec& s) const;
  index_type count(const T& v) const;
  index_type arg_max() const;
  index_type arg_min() const;
  index_type arg_first(const order& o) const;
  index_type arg_last(const order& o) const;
  index_pair first_common(const lvector<T>& vec) const;
  index_pair next_common(const lvector<T>& vec, index_pair p) const;
  void difference(const lvector& v1, lvector& d0, lvector& d1);
  bool operator==(const lvector& _vec) const;
  bool operator!=(const lvector& _vec) const;
  bool operator<(const lvector& vec) const;
  bool operator>(const lvector& vec) const;
  bool operator<=(const lvector& vec) const;
  bool operator>=(const lvector& vec) const;
  void assign_copy(const lvector& _vec);
  void assign_copy(const T* _arr, index_type n);
  void assign_value(const T& val);
  void assign_value(const T& val, index_type l);
  void assign_remap(const lvector& vec, const lvector<index_type>& map);
  void remap(const lvector<index_type>& map);
  void assign_select(const lvector& _vec, const index_set& s);
  void assign_select(const lvector& _vec, const bool_vec& s);
  const lvector& operator=(const lvector& _vec);
  void set_length(index_type l);
  void set_length(index_type l, const T& v);
  void inc_length_to(index_type l);
  void inc_length_to(index_type l, const T& v);
  index_type inc_length() { return inc_length(1); };
  index_type inc_length(index_type d);
  index_type inc_length(index_type d, const T& v);
  index_type dec_length() { return dec_length(1); };
  index_type dec_length(index_type d);
  void clear();
  void append(const T& v);
  void append(const lvector& v);
  T& append();
  void insert(const T& v, index_type p);
  index_type insert_ordered(const T& v, const order& o, index_type f = 0);
  index_type insert_ordered(const lvector& vec, const order& o);
  void remove(index_type p);
  void remove(index_type p0, index_type p1);
  void remove(const index_set& s);
  void remove(const index_set& s, lvector<index_type>& map);
  void remove(const bool_vec& s);
  void remove(const bool_vec& s, lvector<index_type>& map);
  void remove_duplicate_elements();
  void swap(index_type i, index_type j);
};
template<class T> class auto_expanding_vector : public lvector<T>
{
  T _default;
 public:
  auto_expanding_vector() : lvector<T>() { };
  auto_expanding_vector(const T& v, index_type l)
    : lvector<T>(v, l), _default(v) { };
  auto_expanding_vector(const lvector<T>& vec)
    : lvector<T>(vec) { };
  auto_expanding_vector(const auto_expanding_vector<T>& vec)
    : lvector<T>(vec), _default(vec._default) { };
  typename std::vector<T>::reference
  operator[](typename std::vector<T>::size_type k)
  {
    inc_length_to(k + 1, _default);
    return lvector<T>::operator[](k);
  };
  typename std::vector<T>::const_reference
  operator[](typename std::vector<T>::size_type k) const
  {
    if (k >= std::vector<T>::size())
      return _default;
    else
      return lvector<T>::operator[](k);
  };
  void assign_value(const T& val)
  {
    _default = val;
    lvector<T>::assign_value(val);
  };
  void assign_value(const T& val, index_type l)
  {
    _default = val;
    lvector<T>::assign_value(val, l);
  };
};
typedef lvector<index_type> index_vec;
typedef lvector<index_pair> pair_vec;
class index_vec_util : public index_vec
{
 public:
  class decreasing_index_order : public index_vec::order {
  public:
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      { return (v0 > v1); };
  };
  class increasing_index_order : public index_vec::order {
  public:
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      { return (v0 < v1); };
  };
  class increasing_value_order : public index_vec::order {
    const index_vec& value;
  public:
    increasing_value_order(const index_vec& v) : value(v) { };
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      {
 assert(v0 < value.length());
 assert(v1 < value.length());
 return (value[v0] < value[v1]);
      };
  };
  static class decreasing_index_order decreasing;
  static class increasing_index_order increasing;
  static void fill(index_vec& vec, index_type max);
  static index_type min(const index_vec& vec, index_type def = no_such_index);
  static index_type max(const index_vec& vec, index_type def = no_such_index);
  static int compare(const index_vec& v0, const index_vec& v1);
  static index_type hash(const index_vec& vec);
  void fill(index_type max);
  int compare(const index_vec& v1) const;
  index_type hash() const;
};
void factors(index_type n, index_vec& f);
template<class T> class svector : public lvector<T>
{
 public:
  svector() : lvector<T>() { };
  svector(const svector<T>& _svec) : lvector<T>(_svec) { };
  svector(const lvector<T>& _lvec) : lvector<T>() {
    for (index_type k = 0; k < _lvec.size(); k++) insert(_lvec[k]);
  };
  bool contains(const T& v) const;
  bool contains(const svector& vec) const;
  bool subset(const svector& vec) const;
  index_pair first_common(const lvector<T>& vec) const;
  index_pair next_common(const lvector<T>& vec, index_pair p) const;
  index_pair first_common(const svector<T>& vec) const;
  index_pair next_common(const svector<T>& vec, index_pair p) const;
  index_type count_common(const svector& vec) const;
  void assign_singleton(const T& _val);
  void assign_values(const lvector<T>& vec);
  void insert(const T& v);
  void insert(const lvector<T>& vec);
  void intersect(const svector& vec);
  void difference(const svector& vec);
  void subtract(const svector& vec);
  void subtract(const T& v);
};
class index_set : public svector<index_type>
{
 public:
  index_set()
    : svector<index_type>() { };
  index_set(const index_set& _svec)
    : svector<index_type>(_svec) { };
  index_set(const lvector<index_type>& _lvec)
    : svector<index_type>(_lvec) { };
  index_set(const bool* _arr, index_type n);
  index_set(const bool_vec& _vec);
  index_set(const index_set& s0, const index_set& s);
  index_set(const index_set& s0, const bool_vec& s);
  index_set(const index_set& s0, const index_vec& map);
  index_type first_common_element(const index_set& set) const;
  index_type first_common_element(const index_vec& vec) const;
  index_type first_common_element(const bool_vec vec) const;
  index_type first_common_element(const bool* vec, index_type n) const;
  index_type count_common(const index_set& set) const;
  index_type count_common(const bool_vec& set) const;
  bool have_common_element(const index_set& set) const;
  bool have_common_element(const bool_vec& set) const;
  void insert(const index_type& v);
  void insert(const index_vec& vec);
  void insert(const bool_vec& set);
  void intersect(const index_set& vec);
  void intersect(const bool_vec& set);
  void subtract(const index_vec& vec);
  void subtract(const bool_vec& set);
  void subtract(const index_type& v);
  bool* copy_to(bool* s, index_type n) const;
  void fill(index_type to);
  void assign_remap(const index_set& set, const index_vec& map);
  void remap(const index_vec& map);
};
extern const index_set EMPTYSET;
typedef svector<index_pair> pair_set;
class bool_vec : public lvector<bool>
{
 public:
  bool_vec() : lvector<bool>() { };
  bool_vec(bool _val, index_type l) : lvector<bool>(_val, l) { };
  bool_vec(const bool_vec& _vec) : lvector<bool>(_vec) { };
  bool_vec(const bool* _arr, index_type n) : lvector<bool>(false, n) {
    for (index_type k = 0; k < n; k++) {
      if (_arr[k])
 (*this)[k] = true;
      else
 (*this)[k] = false;
    }
  };
  bool_vec(const index_set& set, index_type l);
  void complement();
  void insert(const bool_vec& vec);
  void insert(const index_set& set);
  void intersect(const bool_vec& vec);
  void intersect(const index_set& set);
  void subtract(const bool_vec& vec);
  void subtract(const index_set& set);
  bool subset(const bool_vec& vec) const;
  bool strict_subset(const bool_vec& vec) const;
  bool superset(const bool_vec& vec) const;
  bool strict_superset(const bool_vec& vec) const;
  bool contains(const bool& v) const;
  bool contains(const bool_vec& set) const;
  bool contains(const index_set& set) const;
  bool contains_any(const index_set& set) const;
  index_type first_common_element(const index_set& vec) const;
  index_type first_common_element(const bool_vec vec) const;
  index_type count_common(const bool_vec& vec) const;
  index_type count_common(const index_set& set) const;
  index_set& copy_to(index_set& set) const;
  index_set& insert_into(index_set& set) const;
  index_set& subtract_from(index_set& set) const;
  bool* copy_to(bool* s, index_type n) const;
  int compare(const bool_vec& vec) const;
  index_type hash() const;
};
class index_set_vec : public lvector<index_set>
{
 public:
  index_set_vec()
    : lvector<index_set>() { };
  index_set_vec(const index_set& set, index_type l)
    : lvector<index_set>(set, l) { };
  index_set_vec(index_type l)
    : lvector<index_set>(EMPTYSET, l) { };
  index_set_vec(const index_set_vec& vec)
    : lvector<index_set>(vec) { };
  class decreasing_cardinality_order : public index_set_vec::order {
  public:
    virtual bool operator()
      (const index_set& v0, const index_set& v1) const
      { return (v0.size() > v1.size()); };
  };
  decreasing_cardinality_order decreasing_cardinality;
  index_type minimum_cardinality() const;
  index_type maxmimum_cardinality() const;
  index_type selected_minimum_cardinality(const index_set& sel) const;
  index_type selected_maximum_cardinality(const index_set& sel) const;
  index_type first_minimum_cardinality_set() const;
  index_type first_maxmimum_cardinality_set() const;
  index_type first_superset(const index_set& set) const;
  index_type first_strict_superset(const index_set& set) const;
  index_type first_subset(const index_set& set) const;
  index_type first_strict_subset(const index_set& set) const;
  index_set& union_set(index_set& set) const;
  index_set& selected_union_set(const index_set& sel, index_set& set) const;
  index_set& intersection_set(index_set& set) const;
  void insert_maximal(const index_set& set);
  void insert_minimal(const index_set& set);
  void reduce_to_maximal();
  void reduce_to_minimal();
  void append_if_not_subset(const index_set& set);
  void append_if_not_superset(const index_set& set);
  void append_if_new(const index_set& set);
  void remove_sets_size_le(index_type l);
  void remove_empty_sets();
  void insert_in_all(index_type i);
  void insert_in_all(const index_set& set);
  void subtract_from_all(index_type i);
  void subtract_from_all(const index_set& set);
  void combinations_by_union(const index_set_vec& sv);
  void combinations_by_union(const index_set_vec& sv1,
        const index_set_vec& sv2);
};
template<class T> class matrix : public lvector< lvector<T> >
{
 public:
  typedef lvector<T> row_type;
  matrix()
    : lvector<row_type>() { };
  matrix(const T& _val, index_type r, index_type c)
    : lvector<row_type>(row_type(_val, c), r) { };
  matrix(const matrix& _mat)
    : lvector<row_type>(_mat) { };
  index_type rows() const
  {
    return lvector<row_type>::length();
  };
  index_type columns() const
  {
    if (lvector<row_type>::length() == 0) return 0;
    else return (*this)[0].length();
  };
  void set_size(index_type r, index_type c);
  void assign_value(const T& _val);
  void assign_value(const T& _val, index_type r, index_type c);
};
class bool_matrix : public matrix<bool> {
 public:
  bool_matrix()
    : matrix<bool>() { };
  bool_matrix(const bool& v, index_type r, index_type c)
    : matrix<bool>(v, c, r) { };
  bool_matrix(const bool_matrix& m)
    : matrix<bool>(m) { };
  void complement();
  void insert(const bool_matrix& m);
  void intersect(const bool_matrix& m);
  void subtract(const bool_matrix& m);
  void multiply(const bool_matrix& m0, const bool_matrix& m1);
  void transitive_closure();
};
typedef matrix<index_type> index_matrix;
class mapping : public index_vec
{
 public:
  static void identity_map
    (index_type n, index_vec& map)
    { index_vec_util::fill(map, n); };
  static bool invert_map
    (const index_vec& map, index_vec& inv, index_type m = 0);
  static void delete_index_map
    (index_type n, index_type i, index_vec& map);
  static void compose
    (const index_vec& m0, const index_vec& m1, index_vec& cm);
  static void map_image
    (const index_vec& map, const index_vec& vec, index_vec& img);
  static void inverse_map_image
    (const index_vec& map, index_type x, index_set& img);
  static void inverse_map_image
    (const index_vec& map, const index_set& x, index_set& img);
  static index_type range(const index_vec& map, index_type d);
  mapping()
    : index_vec() { };
  mapping(index_type n)
    : index_vec() { identity_map(n, *this); };
  mapping(index_type n, index_type i, bool out) : index_vec() {
    if (out) delete_index_map(n, i, *this); else assign_value(i, n);
  };
  mapping(const mapping& map)
    : index_vec(map) { };
  void assign_identity(index_type n)
    { identity_map(n, *this); };
  index_type operator()(index_type x) const
    { assert(x < size()); return (*this)[x]; };
  index_vec operator()(const index_vec& vec) const
    { index_vec res; map_image(*this, vec, res); return res; };
  index_vec& inverse(index_type x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  index_vec& inverse(const index_set& x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  bool invert(index_vec& rmap) const
    { return invert_map(*this, rmap); };
  bool invert()
    { index_vec tmp(*this); return invert_map(tmp, *this); };
  index_type range() const
    { return range(*this, length()); };
};
class sparse_mapping : public pair_vec
{
 public:
  static void dense_to_sparse(const index_vec& dm, pair_vec sm);
  static void sparse_to_dense(const pair_vec& sm, index_vec dm);
  static index_type map_image
    (const pair_vec& map, index_type x);
  static void map_image
    (const pair_vec& map, const index_vec& vec, index_vec& img);
  static void inverse_map_image
    (const pair_vec& map, index_type x, index_set& img);
  static void inverse_map_image
    (const pair_vec& map, const index_set& x, index_set& img);
  sparse_mapping()
    : pair_vec() { };
  sparse_mapping(const pair_vec& m)
    : pair_vec(m) { };
  sparse_mapping(const index_vec& m)
    : pair_vec() { dense_to_sparse(m, *this); };
  index_type operator()(index_type x) const
    { return map_image(*this, x); };
  index_vec operator()(const index_vec& vec) const
    { index_vec res; map_image(*this, vec, res); return res; };
  index_set& inverse(index_type x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  index_set& inverse(const index_set& x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
};
class equivalence : public index_vec
{
 public:
  equivalence()
    : index_vec() { };
  equivalence(index_type n)
    : index_vec(no_such_index, n) { index_vec_util::fill(*this, n); };
  equivalence(const equivalence& eq)
    : index_vec(eq) { };
  bool operator()(index_type a, index_type b) const;
  index_type canonical(index_type a) const;
  void extend(index_type a);
  void merge(index_type a, index_type b);
  void merge(const equivalence& eq);
  void merge(const index_set& set);
  void merge(const index_set& sa, const index_set& sb);
  void reset();
  void reset(index_type n);
  void canonical_set(index_set& set) const;
  void canonical_elements(index_set& set) const;
  void class_elements(index_type rep, index_set& set) const;
  index_type n_class_elements(index_type rep) const;
  void classes(index_set_vec& sets) const;
  void make_map(index_vec& map) const;
  index_type n_classes() const;
  index_type n_squeezed() const;
};
class set_hash_function : index_vec
{
 public:
  set_hash_function(index_type n)
    : index_vec() { init(n); };
  void init(index_type n);
  index_type operator()(index_type& i, index_type v) const;
  index_type operator()(const index_set& set) const;
  index_type operator()(const bool_vec& set) const;
  index_type operator()(const bool* set, index_type n) const;
};
template<class T, class N> struct weighted
{
  T value;
  N weight;
  weighted() : weight(0) { };
  weighted(const T& v) : value(v), weight(0) { };
  weighted(const T& v, const N& w) : value(v), weight(w) { };
  weighted(const weighted& w) : value(w.value), weight(w.weight) { };
  ~weighted() { };
  weighted& operator=(const T& v)
  {
    value = v;
    weight = 0;
    return *this;
  };
  weighted& operator=(const weighted& w)
  {
    value = w.value;
    weight = w.weight;
    return *this;
  };
  bool operator==(const weighted& w) const
  {
    return (value == w.value);
  };
  bool operator!=(const weighted& w) const
  {
    return (value != w.value);
  };
  bool operator<(const weighted& w) const
  {
    return (value < w.value);
  };
  bool operator<=(const weighted& w) const
  {
    return (value <= w.value);
  };
  bool operator>(const weighted& w) const
  {
    return (value > w.value);
  };
  bool operator>=(const weighted& w) const
  {
    return (value >= w.value);
  };
};
template<class T, class N> class weighted_vec
: public lvector< weighted<T, N> >
{
 public:
  class decreasing_weight_order : public lvector< weighted<T,N> >::order {
  public:
    virtual bool operator()
      (const weighted<T,N>& v0, const weighted<T,N>& v1) const
      { return (v0.weight > v1.weight); };
  };
  class increasing_weight_order : public lvector< weighted<T,N> >::order {
  public:
    virtual bool operator()
      (const weighted<T,N>& v0, const weighted<T,N>& v1) const
      { return (v0.weight < v1.weight); };
  };
  static class decreasing_weight_order decreasing;
  static class increasing_weight_order increasing;
  void insert_increasing(const weighted<T,N>& v);
  void insert_decreasing(const weighted<T,N>& v);
  void insert_increasing(const T& v, const N& w);
  void insert_decreasing(const T& v, const N& w);
};
template<class T, class N> class weighted_set
: public svector< weighted<T,N> >
{
 public:
  void insert(const T& v, const N& w);
  void insert(const T& v);
  index_type arg_max();
  index_type arg_min();
};
template<class T>
bool lvector<T>::operator==(const lvector& _vec) const
{
  if (lvector<T>::size() != _vec.size()) return false;
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if (!((*this)[k] == _vec[k])) return false;
  return true;
}
template<class T>
bool lvector<T>::operator!=(const lvector& _vec) const
{
  if (*this == _vec) return false;
  else return true;
}
template<class T>
bool lvector<T>::operator<(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return true;
  else if (lvector<T>::size() > vec.size()) return false;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return true;
      else if ((*this)[k] > vec[k]) return false;
    }
    return false;
  }
}
template<class T>
bool lvector<T>::operator<=(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return true;
  else if (lvector<T>::size() > vec.size()) return false;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return true;
      else if ((*this)[k] > vec[k]) return false;
    }
    return true;
  }
}
template<class T>
bool lvector<T>::operator>(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return false;
  else if (lvector<T>::size() > vec.size()) return true;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return false;
      else if ((*this)[k] > vec[k]) return true;
    }
    return false;
  }
}
template<class T>
bool lvector<T>::operator>=(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return false;
  else if (lvector<T>::size() > vec.size()) return true;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return false;
      else if ((*this)[k] > vec[k]) return true;
    }
    return true;
  }
}
template<class T>
bool lvector<T>::contains(const T& v) const
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return true;
  return false;
}
template<class T>
index_type lvector<T>::first(const T& v) const
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return k;
  return no_such_index;
}
template<class T>
index_type lvector<T>::next(const T& v, index_type p) const
{
  for (index_type k = p + 1; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return k;
  return no_such_index;
}
template<class T>
index_type lvector<T>::find(const T& v, bool_vec& s) const
{
  index_type n = 0;
  s.assign_value(false, lvector<T>::size());
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) {
      s[k] = true;
      n += 1;
    }
  return n;
}
template<class T>
index_type lvector<T>::count(const T& v) const
{
  index_type c = 0;
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) c += 1;
  return c;
}
template<class T>
index_type lvector<T>::length() const
{
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::arg_max() const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if ((*this)[k] > (*this)[m]) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_min() const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if ((*this)[k] < (*this)[m]) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_first(const order& o) const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if (o((*this)[k], (*this)[m])) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_last(const order& o) const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if (o((*this)[m], (*this)[k])) m = k;
  return m;
}
template<class T>
index_pair lvector<T>::first_common(const lvector<T>& vec) const
{
  for (index_type i = 0; i < lvector<T>::size(); i++) {
    for (index_type j = 0; j < vec.size(); j++)
      if ((*this)[i] == vec[j]) return index_pair(i, j);
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_pair lvector<T>::next_common(const lvector<T>& vec, index_pair p) const
{
  index_type i = p.first;
  index_type j = p.second + 1;
  while (j < vec.size()) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    j += 1;
  }
  i += 1;
  while (i < lvector<T>::size()) {
    j = 0;
    while (j < vec.size()) {
      if ((*this)[i] == vec[j])
 return index_pair(i, j);
      j += 1;
    }
    i += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
void lvector<T>::difference
(const lvector& v1, lvector& d0, lvector& d1)
{
  d0.assign_copy(*this);
  d1.assign_copy(v1);
  index_type i0 = 0;
  while (i0 < d0.size()) {
    index_type i1 = d1.first(d0[i0]);
    if (i1 != no_such_index) {
      d0.remove(i0);
      d1.remove(i1);
    }
    else {
      i0 += 1;
    }
  }
}
template<class T>
void lvector<T>::assign_copy(const lvector& _vec)
{
  std::vector<T>::resize(_vec.size());
  for (index_type k = 0; k < _vec.size(); k++)
    (*this)[k] = _vec[k];
}
template<class T>
void lvector<T>::assign_copy(const T* _arr, index_type n)
{
  std::vector<T>::resize(n);
  for (index_type k = 0; k < n; k++)
    (*this)[k] = _arr[k];
}
template<class T>
void lvector<T>::assign_value(const T& _val)
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    (*this)[k] = _val;
}
template<class T>
void lvector<T>::assign_value(const T& _val, index_type l)
{
  std::vector<T>::resize(l);
  for (index_type k = 0; k < lvector<T>::size(); k++)
    (*this)[k] = _val;
}
template<class T>
void lvector<T>::assign_remap(const lvector<T>& vec, const index_vec& map)
{
  assert(map.length() == vec.length());
  index_type m = 0;
  for (index_type k = 0; k < vec.length(); k++)
    if (map[k] != no_such_index)
      if (map[k] > m) m = map[k];
  set_length(m + 1);
  for (index_type k = 0; k < vec.length(); k++)
    if (map[k] != no_such_index)
      (*this)[map[k]] = vec[k];
}
template<class T>
void lvector<T>::remap(const index_vec& map)
{
  lvector v0(*this);
  assign_remap(v0, map);
}
template<class T>
void lvector<T>::assign_select(const lvector& _vec, const index_set& s)
{
  set_length(s.length());
  for (index_type k = 0; k < s.length(); k++)
    (*this)[k] = _vec[s[k]];
}
template<class T>
void lvector<T>::assign_select(const lvector& _vec, const bool_vec& s)
{
  clear();
  for (index_type k = 0; k < _vec.length(); k++)
    if (s[k]) append(_vec[k]);
}
template<class T>
const lvector<T>& lvector<T>::operator=(const lvector<T>& _vec)
{
  assign_copy(_vec);
  return _vec;
}
template<class T>
void lvector<T>::set_length(index_type l)
{
  std::vector<T>::resize(l);
}
template<class T>
void lvector<T>::set_length(index_type l, const T& v)
{
  std::vector<T>::resize(l, v);
}
template<class T>
void lvector<T>::inc_length_to(index_type l)
{
  if (std::vector<T>::size() < l)
    std::vector<T>::resize(l);
}
template<class T>
void lvector<T>::inc_length_to(index_type l, const T& v)
{
  if (std::vector<T>::size() < l)
    std::vector<T>::resize(l, v);
}
template<class T>
index_type lvector<T>::inc_length(index_type d)
{
  std::vector<T>::resize(std::vector<T>::size() + d);
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::inc_length(index_type d, const T& v)
{
  std::vector<T>::resize(std::vector<T>::size() + d, v);
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::dec_length(index_type d)
{
  assert(std::vector<T>::size() >= d);
  std::vector<T>::resize(std::vector<T>::size() - d);
  return std::vector<T>::size();
}
template<class T>
void lvector<T>::clear()
{
  std::vector<T>::clear();
}
template<class T>
void lvector<T>::append(const T& v)
{
  std::vector<T>::push_back(v);
}
template<class T>
void lvector<T>::append(const lvector<T>& v)
{
  for (index_type k = 0; k < v.size(); k++) append(v[k]);
}
template<class T>
T& lvector<T>::append()
{
  T v;
  std::vector<T>::push_back(v);
  return (*this)[std::vector<T>::size() - 1];
}
template<class T>
void lvector<T>::insert(const T& v, index_type p)
{
  if (p < lvector<T>::size()) {
    std::vector<T>::insert(std::vector<T>::begin() + p, v);
  }
  else {
    std::vector<T>::resize(p + 1);
    (*this)[p] = v;
  }
}
template<class T>
index_type lvector<T>::insert_ordered(const T& v, const order& o, index_type f)
{
  assert(f <= lvector<T>::size());
  for (index_type k = f; k < lvector<T>::size(); k++) {
    if (o(v, (*this)[k])) {
      insert(v, k);
      return k;
    }
  }
  append(v);
  return (lvector<T>::size() - 1);
}
template<class T>
index_type lvector<T>::insert_ordered(const lvector& vec, const order& o)
{
  if (vec.empty()) return no_such_index;
  index_type p0 = insert_ordered(vec[0], o);
  for (index_type k = 1; k < vec.size(); k++) {
    index_type p1 = insert_ordered(vec[k], o);
    if (p1 < p0) p0 = p1;
  }
  return p0;
}
template<class T>
void lvector<T>::remove(index_type p)
{
  if (p < lvector<T>::size())
    std::vector<T>::erase(std::vector<T>::begin() + p);
}
template<class T>
void lvector<T>::remove(index_type p0, index_type p1)
{
  assert(p0 < p1);
  if (p1 < lvector<T>::size())
    std::vector<T>::erase(std::vector<T>::begin() + p0,
     std::vector<T>::begin() + p1);
  else
    std::vector<T>::erase(std::vector<T>::begin() + p0,
     std::vector<T>::end());
}
template<class T>
void lvector<T>::remove(const bool_vec& s, index_vec& map)
{
  assert(s.size() >= lvector<T>::size());
  index_type scan_p = 0;
  index_type put_p = 0;
  index_vec rm_map(no_such_index, lvector<T>::size());
  while (scan_p < lvector<T>::size()) {
    if (!s[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      rm_map[scan_p] = put_p;
      put_p += 1;
    }
    else {
      rm_map[scan_p] = no_such_index;
    }
    scan_p += 1;
  }
  std::vector<T>::resize(put_p);
  for (index_type k = 0; k < map.size(); k++)
    if (map[k] != no_such_index) {
      assert(map[k] < rm_map.size());
      map[k] = rm_map[map[k]];
    }
}
template<class T>
void lvector<T>::remove(const bool_vec& s)
{
  assert(s.size() >= lvector<T>::size());
  index_type scan_p = 0;
  index_type put_p = 0;
  while (scan_p < lvector<T>::size()) {
    if (!s[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      put_p += 1;
    }
    scan_p += 1;
  }
  std::vector<T>::resize(put_p);
}
template<class T>
void lvector<T>::remove(const index_set& s)
{
  bool_vec s1(s, lvector<T>::size());
  remove(s1);
}
template<class T>
void lvector<T>::remove(const index_set& s, index_vec& map)
{
  bool_vec s1(s, std::vector<T>::size());
  lvector<T>::remove(s1, map);
}
template<class T>
void lvector<T>::remove_duplicate_elements()
{
  equivalence eq(lvector<T>::size());
  for (index_type i = 0; i < lvector<T>::size(); i++)
    for (index_type j = i+1; j < lvector<T>::size(); j++)
      if ((*this)[i] == (*this)[j])
 eq.merge(i, j);
  bool_vec s(false, lvector<T>::size());
  for (index_type i = 0; i < lvector<T>::size(); i++)
    if (eq.canonical(i) != i)
      s[i] = true;
  remove(s);
}
template<class T>
void lvector<T>::swap(index_type i, index_type j)
{
  T tmp = (*this)[i];
  (*this)[i] = (*this)[j];
  (*this)[j] = tmp;
}
template<class T>
void svector<T>::assign_singleton(const T& _val)
{
  lvector<T>::set_length(1);
  (*this)[0] = _val;
}
template<class T>
void svector<T>::assign_values(const lvector<T>& vec)
{
  lvector<T>::clear();
  for (index_type k = 0; k < vec.size(); k++)
    insert(vec[k]);
}
template<class T>
void svector<T>::insert(const T& v) {
  index_type i = 0;
  bool seeking = (i < std::vector<T>::size());
  while (seeking) {
    if ((*this)[i] < v) {
      i += 1;
      if (i >= std::vector<T>::size())
 seeking = false;
    }
    else {
      seeking = false;
    }
  }
  if (i < lvector<T>::size()) {
    if ((*this)[i] == v)
      return;
    else
      lvector<T>::insert(v, i);
  }
  else {
    lvector<T>::append(v);
  }
}
template<class T>
void svector<T>::insert(const lvector<T>& vec)
{
  for (index_type k = 0; k < vec.size(); k++) insert(vec[k]);
}
template<class T>
bool svector<T>::contains(const T& v) const
{
  index_type i = 0;
  while ((i < lvector<T>::size()) &&
  ((*this)[i] < v)) i += 1;
  if (i < lvector<T>::size())
    if ((*this)[i] == v) return true;
  return false;
}
template<class T>
bool svector<T>::contains(const svector& vec) const
{
  index_type v_i = 0;
  index_type i = 0;
  while (v_i < vec.size()) {
    if (i >= lvector<T>::size()) return false;
    if ((*this)[i] == vec[v_i]) {
      v_i += 1;
      i += 1;
    }
    else if ((*this)[i] > vec[v_i]) {
      return false;
    }
    else {
      while ((i < lvector<T>::size()) && ((*this)[i] < vec[v_i]))
 i += 1;
    }
  }
  return true;
}
template<class T>
bool svector<T>::subset(const svector& vec) const
{
  return vec.contains(*this);
}
template<class T>
void svector<T>::intersect(const svector& vec)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if (!vec.contains((*this)[i]))
      lvector<T>::remove(i);
    else
      i += 1;
  }
}
template<class T>
void svector<T>::difference(const svector& vec)
{
  svector d(vec);
  d.subtract(*this);
  subtract(vec);
  insert(d);
}
template<class T>
index_pair svector<T>::first_common(const lvector<T>& vec) const
{
  return lvector<T>::first_common(vec);
}
template<class T>
index_pair svector<T>::next_common(const lvector<T>& vec, index_pair p) const
{
  return lvector<T>::next_common(vec, p);
}
template<class T>
index_pair svector<T>::first_common(const svector<T>& vec) const
{
  index_type i = 0;
  index_type j = 0;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    else if
      ((*this)[i] < vec[j]) i += 1;
    else
      j += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_pair svector<T>::next_common(const svector<T>& vec, index_pair p) const
{
  index_type i = p.first + 1;
  index_type j = p.second + 1;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    else if ((*this)[i] < vec[j])
      i += 1;
    else
      j += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_type svector<T>::count_common(const svector& vec) const
{
  index_type i = 0;
  index_type j = 0;
  index_type c = 0;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j]) {
      c += 1;
      i += 1;
      j += 1;
    }
    else if ((*this)[i] < vec[j])
      i += 1;
    else
      j += 1;
  }
  return c;
}
template<class T>
void svector<T>::subtract(const svector& vec)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if (vec.contains((*this)[i]))
      lvector<T>::remove(i);
    else
      i += 1;
  }
}
template<class T>
void svector<T>::subtract(const T& v)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if ((*this)[i] == v) {
      lvector<T>::remove(i);
      return;
    }
    else {
      i += 1;
    }
  }
}
template<class T>
void matrix<T>::set_size(index_type r, index_type c)
{
  lvector<row_type>::set_length(r);
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].set_length(c);
}
template<class T>
void matrix<T>::assign_value(const T& _val)
{
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].assign_value(_val);
}
template<class T>
void matrix<T>::assign_value(const T& _val, index_type r, index_type c)
{
  lvector<row_type>::set_length(r);
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].assign_value(_val, c);
}
template<class T>
void swapable_pair<T>::swap()
{
  T tmp = this->first;
  this->first = this->second;
  this->second = tmp;
}
template<class T>
void comparable_pair<T>::sort_ascending()
{
  if (this->first > this->second) swapable_pair<T>::swap();
}
template<class T>
void comparable_pair<T>::sort_descending()
{
  if (this->first < this->second) swapable_pair<T>::swap();
}
template<class T, class N>
class weighted_vec<T,N>::decreasing_weight_order
  weighted_vec<T,N>::decreasing;
template<class T, class N>
class weighted_vec<T,N>::increasing_weight_order
  weighted_vec<T,N>::increasing;
template<class T, class N>
void weighted_vec<T,N>::insert_increasing(const weighted<T,N>& v)
{
  insert_ordered(v, increasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_decreasing(const weighted<T,N>& v)
{
  insert_ordered(v, decreasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_increasing(const T& v, const N& w)
{
  insert_ordered(weighted<T,N>(v, w), increasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_decreasing(const T& v, const N& w)
{
  insert_ordered(weighted<T,N>(v, w), decreasing);
}
template<class T, class N>
void weighted_set<T,N>::insert(const T& v, const N& w)
{
  index_type p = svector< weighted<T,N> >::first(v);
  if (p == no_such_index) {
    svector< weighted<T,N> >::insert(weighted<T,N>(v, w));
  }
  else {
    (*this)[p].weight += w;
  }
}
template<class T, class N>
void weighted_set<T,N>::insert(const T& v)
{
  index_type p = svector< weighted<T,N> >::first(v);
  if (p == no_such_index) {
    svector< weighted<T,N> >::insert(weighted<T,N>(v, 1));
  }
  else {
    (*this)[p].weight += 1;
  }
}
template<class T, class N>
index_type weighted_set<T,N>::arg_max()
{
  if (weighted_set<T,N>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < weighted_set<T,N>::size(); k++)
    if ((*this)[k].weight > (*this)[m].weight) m = k;
  return m;
}
template<class T, class N>
index_type weighted_set<T,N>::arg_min()
{
  if (weighted_set<T,N>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < weighted_set<T,N>::size(); k++)
    if ((*this)[k].weight < (*this)[m].weight) m = k;
  return m;
}
template<class T>
inline std::ostream& operator<<(std::ostream& s, const swapable_pair<T>& p)
{
  return s << '(' << p.first << ',' << p.second << ')';
}
template<class T>
::std::ostream& operator<<(::std::ostream& s, const lvector<T>& _vec)
{
  s << '[';
  for (index_type k = 0; k < _vec.size(); k++) {
    if (k > 0) s << ',';
    s << _vec[k];
  }
  s << ']';
  return s;
}
inline std::ostream& operator<<(std::ostream& s, const mapping& m)
{
  s << '{';
  for (index_type k = 0; k < m.length(); k++) {
    if (k > 0) s << ',';
    s << k << '-' << '>';
    if (m[k] == no_such_index)
      s << '_';
    else
      s << m[k];
  }
  return s << '}';
}
inline std::ostream& operator<<(std::ostream& s, const equivalence& eq)
{
  s << '{';
  bool first = true;
  for (index_type k = 0; k < eq.length(); k++) {
    index_type c = eq.canonical(k);
    if (!first) {
      s << ',';
    }
    else {
      first = false;
    }
    s << k << '=' << c;
  }
  return s << '}';
}
template<class T, class N>
std::ostream& operator<<(::std::ostream& s, const weighted<T,N>& w)
{
  s << '<' << w.value << ':' << w.weight << '>';
}
}
#include <iostream>
#include <limits.h>
namespace hsps {
long euclid(long n, long k, long& a, long& b);
long gcd(long n, long k);
long lcm(long n, long k);
unsigned long ilog(unsigned long n);
long imag(long n);
class rational {
  long nm;
  long dv;
 public:
  rational();
  rational(long n);
  rational(long n, long d);
  rational(const rational& r);
  struct XR {
    long x_nm;
    long x_dv;
    XR& operator=(const rational r);
  };
  rational(const XR& x);
  long numerator() const;
  long divisor() const;
  long sign() const;
  bool zero() const;
  bool finite() const;
  bool infinite() const;
  bool integral() const;
  static rational reduce(rational r);
  static rational invert(const rational r);
  static rational infinity(const rational r);
  static rational infinity(const long s);
  static rational floor(const rational r);
  static rational floor_to(const rational r, long div);
  static rational ceil(const rational r);
  static rational ceil_to(const rational r, long div);
  static rational frac(const rational r);
  static rational round(const rational r, long div_max);
  static rational min(const rational r0, const rational r1);
  static rational max(const rational r0, const rational r1);
  static rational rgcd(const rational r0, const rational r1);
  static rational dtor(double v);
  static rational ator(const char* s);
  rational reduce() const;
  rational invert() const;
  rational floor() const;
  rational floor_to(long d) const;
  rational ceil() const;
  rational frac() const;
  rational round(long div_max) const;
  rational round() const;
  rational operator=(const rational r);
  rational operator=(long n);
  rational operator+=(const rational r);
  rational operator-=(const rational r);
  rational operator*=(const rational r);
  rational operator/=(const rational r);
  rational operator+=(long n);
  rational operator-=(long n);
  rational operator*=(long n);
  rational operator/=(long n);
  double decimal() const;
};
bool operator==(const rational r0, const rational r1);
bool operator==(const rational r0, long n1);
bool operator==(long n0, const rational r1);
bool operator!=(const rational r0, const rational r1);
bool operator!=(const rational r0, long n1);
bool operator!=(long n0, const rational r1);
bool operator<(const rational r0, const rational r1);
bool operator<=(const rational r0, const rational r1);
bool operator>(const rational r0, const rational r1);
bool operator>=(const rational r0, const rational r1);
rational operator+(const rational r0, const rational r1);
rational operator-(const rational r0, const rational r1);
rational operator*(const rational r0, const rational r1);
rational operator/(const rational r0, const rational r1);
rational operator+(const rational r0, long n1);
rational operator-(const rational r0, long n1);
rational operator*(const rational r0, long n1);
rational operator/(const rational r0, long n1);
rational operator+(long n0, const rational r1);
rational operator-(long n0, const rational r1);
rational operator*(long n0, const rational r1);
rational operator/(long n0, const rational r1);
rational safeadd(const rational r0, const rational r1);
rational safemul(const rational r0, const rational r1);
::std::ostream& operator<<(::std::ostream& s, const rational r);
inline rational::XR& rational::XR::operator=(const rational r)
{
  x_nm = r.numerator();
  x_dv = r.divisor();
  return *this;
}
inline rational::rational()
  : nm(0), dv(1) { }
inline rational::rational(long n)
  : nm(n), dv(1) { }
inline rational::rational(long n, long d)
  : nm(d < 0 ? -1*n : n), dv(d < 0 ? -1*d : d) { }
inline rational::rational(const rational& r)
  : nm(r.nm), dv(r.dv) { }
inline rational::rational(const rational::XR& x)
  : nm(x.x_nm), dv(x.x_dv) { };
inline long rational::numerator() const { return nm; }
inline long rational::divisor() const { return dv; }
inline long rational::sign() const
{
  return (nm < 0 ? -1 : (nm > 0 ? 1 : 0));
}
inline bool rational::zero() const
{
  return nm == 0;
}
inline bool rational::finite() const
{
  return dv != 0;
}
inline bool rational::infinite() const
{
  return dv == 0;
}
inline bool rational::integral() const
{
  return dv == 1;
}
inline rational rational::reduce(rational r)
{
  if (r.infinite()) return infinity(r.sign());
  if (r.sign() == 0) return rational(0,1);
  long c = gcd(r.nm, r.dv);
  return rational(r.nm / c, r.dv / c);
}
inline rational rational::invert(const rational r)
{
  return rational(r.dv, r.nm);
}
inline rational rational::infinity(const long s)
{
  return rational((s < 0 ? -1 : (s > 0 ? 1 : 0)), 0);
}
inline rational rational::infinity(const rational r)
{
  return rational(r.sign(),0);
}
inline rational rational::floor(const rational r)
{
  if (r.infinite()) return r;
  return rational(r.nm / r.dv);
}
inline rational rational::floor_to(const rational r, long d)
{
  if (r.infinite()) return r;
  return rational((r.nm * d) / r.dv, d);
}
inline rational rational::ceil(const rational r)
{
  if (r.infinite()) return r;
  if (r.dv == 1) return r;
  return rational((r.nm / r.dv) + 1, 1);
}
inline rational rational::ceil_to(const rational r, long d)
{
  if (r.infinite()) return r;
  long x = (r.nm * d);
  long y = x / r.dv;
  if ((y * r.dv) == x)
    return rational(y, d);
  else
    return rational(y + 1, d);
}
inline rational rational::frac(const rational r) {
  if (r.infinite()) return r;
  return reduce(rational(r.nm % r.dv, r.dv));
}
inline rational rational::round(const rational r, long d_max)
{
  if (r.infinite()) return r;
  rational s(r);
  while (s.dv > d_max) {
    s.dv = (s.dv / 2);
    s.nm = (s.nm / 2);
    s.reduce();
  }
  return s;
}
inline rational rational::rgcd(const rational r0, const rational r1)
{
  long c = gcd(r0.divisor(), r1.divisor());
  long a0 = r0.numerator() * (r1.divisor() / c);
  long a1 = r1.numerator() * (r0.divisor() / c);
  long d = gcd(a0, a1);
  return rational(d, (r0.divisor() / c) * (r1.divisor() / c) * c).reduce();
}
inline rational rational::min(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    if (r0.sign() < 0) return r0;
    else return r1;
  }
  else if (r1.infinite()) {
    if (r1.sign() < 0) return r1;
    else return r0;
  }
  else if (r0 < r1) return r0;
  else return r1;
}
inline rational rational::max(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    if (r0.sign() > 0) return r0;
    else return r1;
  }
  else if (r1.infinite()) {
    if (r1.sign() > 0) return r1;
    else return r0;
  }
  else if (r0 < r1) return r1;
  else return r0;
}
inline rational rational::reduce() const
{
  return reduce(*this);
}
inline rational rational::invert() const
{
  return invert(*this);
}
inline rational rational::floor() const
{
  return floor(*this);
}
inline rational rational::floor_to(long d) const
{
  return floor_to(*this, d);
}
inline rational rational::ceil() const
{
  return ceil(*this);
}
inline rational rational::frac() const
{
  return frac(*this);
}
inline rational rational::round(long d_max) const
{
  return round(*this, d_max);
}
inline rational rational::round() const
{
  return round(*this, (LONG_MAX/16));
}
inline rational rational::operator=(const rational r)
{
  nm = r.nm;
  dv = r.dv;
  return *this;
}
inline rational rational::operator=(long n)
{
  nm = n;
  dv = 1;
  return *this;
}
inline rational rational::operator+=(const rational r)
{
  return *this = (*this + r);
}
inline rational rational::operator-=(const rational r)
{
  return *this = (*this - r);
}
inline rational rational::operator*=(const rational r)
{
  return *this = (*this * r);
}
inline rational rational::operator/=(const rational r)
{
  return *this = (*this / r);
}
inline rational rational::operator+=(long n)
{
  return *this = (*this + n);
}
inline rational rational::operator-=(long n)
{
  return *this = (*this - n);
}
inline rational rational::operator*=(long n)
{
  return *this = (*this * n);
}
inline rational rational::operator/=(long n)
{
  return *this = (*this / n);
}
inline double rational::decimal() const { return nm/(double)dv; };
inline bool operator==(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite()) return r0.sign() == r1.sign();
  else return ((r0.numerator() == r1.numerator()) &&
        (r0.divisor() == r1.divisor()));
}
inline bool operator==(const rational r0, long n1)
{
  return ((r0.numerator() == n1) && (r0.divisor() == 1));
}
inline bool operator==(long n0, const rational r1)
{
  return ((r1.numerator() == n0) && (r1.divisor() == 1));
}
inline bool operator!=(const rational r0, const rational r1)
{
  return !(r0 == r1);
}
inline bool operator!=(const rational r0, long n1)
{
  return !(r0 == n1);
}
inline bool operator!=(long n0, const rational r1)
{
  return !(n0 == r1);
}
inline bool operator<(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return false;
  else return (r0 - r1).sign() < 0;
}
inline bool operator<=(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return true;
  else return (r0 - r1).sign() <= 0;
}
inline bool operator>(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return false;
  else return (r0 - r1).sign() > 0;
}
inline bool operator>=(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return true;
  else return (r0 - r1).sign() >= 0;
}
inline rational operator+(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() == r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " + " << r1 << " not defined"
           << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() + r1.numerator(), 1);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n = (r0.numerator() * (r1.divisor() / c) +
       r1.numerator() * (r0.divisor() / c));
    long d = ((r0.divisor() / c) * r1.divisor());
    return rational(n, d).reduce();
  }
}
inline rational operator-(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() != r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " - " << r1 << " not defined"
      << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1.sign() * -1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() - r1.numerator(), 1);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n = (r0.numerator() * (r1.divisor() / c) -
       r1.numerator() * (r0.divisor() / c));
    long d = ((r0.divisor() / c) * r1.divisor());
    return rational(n, d).reduce();
  }
}
inline rational operator*(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else if (r1.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() * r1.numerator(), 1);
  }
  else {
    long c0 = gcd(r0.numerator(), r1.divisor());
    long c1 = gcd(r1.numerator(), r0.divisor());
    return rational((r0.numerator() / c0) * (r1.numerator() / c1),
      (r0.divisor() / c1) * (r1.divisor() / c0)).reduce();
  }
}
inline rational operator/(const rational r0, const rational r1)
{
  return (r0 * r1.invert());
}
inline rational operator+(const rational r0, long n1)
{
  return rational(r0.numerator() + (n1 * r0.divisor()), r0.divisor()).reduce();
}
inline rational operator-(const rational r0, long n1)
{
  return rational(r0.numerator() - (n1 * r0.divisor()), r0.divisor()).reduce();
}
inline rational operator*(const rational r0, long n1)
{
  return rational(r0.numerator() * n1, r0.divisor()).reduce();
}
inline rational operator/(const rational r0, long n1)
{
  return rational((n1 < 0 ? r0.numerator() * -1 : r0.numerator()),
    r0.divisor() * (n1 < 0 ? n1 * -1 : n1)).reduce();
}
inline rational operator+(long n0, const rational r1)
{
  return rational(r1.numerator() + (n0 * r1.divisor()), r1.divisor()).reduce();
}
inline rational operator-(long n0, const rational r1)
{
  return rational((n0 * r1.divisor()) - r1.numerator(), r1.divisor()).reduce();
}
inline rational operator*(long n0, const rational r1)
{
  return rational(r1.numerator() * n0, r1.divisor()).reduce();
}
inline rational operator/(long n0, const rational r1)
{
  return (n0 * r1.invert());
}
inline rational safeadd(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() == r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " + " << r1 << " not defined"
      << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n0 = r0.numerator();
    long d0 = r0.divisor() / c;
    long n1 = r1.numerator();
    long d1 = r1.divisor() / c;
    assert(d0 > 0);
    assert(d1 > 0);
    while (((LONG_MAX / (2*d1)) < (imag(n0) + 1)) ||
    ((LONG_MAX / (2*d0)) < (imag(n1) + 1)) ||
    ((LONG_MAX / (d0 * c)) < (d1 + 1))) {
      if ((d1 < 2) && (d0 < 2)) {
 std::cerr << "error: overflow in safeadd(" << r0 << ", " << r1 << ")"
    << std::endl;
 abort();
      }
      if (d0 < 2) {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
      else if (d1 < 2) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else if ((imag(n0) - d0) > (imag(n1) - d1)) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
    }
    long f0 = n0 * d1;
    long f1 = n1 * d0;
    long n = f0 + f1;
    long d = d0 * d1 * c;
    return rational(n, d).reduce();
  }
}
inline rational safemul(const rational r0, const rational r1)
{
  if (r0.infinite() || r1.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else {
    long c0 = gcd(r0.numerator(), r1.divisor());
    long c1 = gcd(r1.numerator(), r0.divisor());
    long n0 = r0.numerator() / c0;
    long n1 = r1.numerator() / c1;
    long d0 = r0.divisor() / c1;
    long d1 = r1.divisor() / c0;
    while (((LONG_MAX / imag(n0)) < (imag(n1) + 1)) ||
    ((LONG_MAX / d0) < (d1 + 1))) {
      if ((d1 < 2) && (d0 < 2)) {
 std::cerr << "error: overflow in safeadd(" << r0 << ", " << r1 << ")"
    << std::endl;
 abort();
      }
      if (d0 < 2) {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
      else if (d1 < 2) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else if ((imag(n0) - d0) > (imag(n1) - d1)) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
    }
    return rational(n0 * n1, d0 * d1).reduce();
  }
}
inline ::std::ostream& operator<<(::std::ostream& s, const rational r)
{
  if (r.infinite()) {
    if (r.sign() < 0) return s << "-INF";
    else return s << "INF";
  }
  else if (r.integral()) {
    return s << r.numerator();
  }
  else {
    return s << r.numerator() << '/' << r.divisor();
  }
}
}
namespace hsps {
class RNG {
 public:
  virtual ~RNG() { };
  virtual void seed(unsigned long s) = 0;
  virtual unsigned long seed_value() = 0;
  virtual unsigned long random() = 0;
  void seed_with_pid();
  void seed_with_time();
  unsigned long random_in_range(unsigned long range);
  unsigned long random_in_range(unsigned long range, unsigned long except);
  double random_double(unsigned long div);
  double normal_sample(double mean, double var);
  unsigned long binomial_sample(unsigned long n, double p);
  index_type select_one_of(const bool_vec& sel);
  index_type select_one_of(const index_vec& sel);
  void select_fixed_set(index_set& s, index_type m, index_type n);
  void select_variable_set(index_set& s, index_type m, index_type n);
  void select_non_empty_variable_set(index_set& s, index_type m, index_type n);
  virtual unsigned long max() = 0;
};
class LC_RNG : public RNG {
  unsigned long a;
  unsigned long b;
  unsigned long mod;
  unsigned long x;
 public:
  LC_RNG()
    : a(23), b(0), mod(100000001), x(100000001 - 1) { };
  LC_RNG(unsigned long _a, unsigned long _b, unsigned long m)
    : a(_a), b(_b), mod(m), x(m - 1) { };
  LC_RNG(unsigned long s)
    : a(23), b(0), mod(100000001), x(s) { };
  LC_RNG(unsigned long _a, unsigned long _b, unsigned long m, unsigned long s)
    : a(_a), b(_b), mod(m), x(s) { };
  virtual ~LC_RNG() { };
  virtual void seed(unsigned long s);
  virtual unsigned long seed_value();
  virtual unsigned long random();
  virtual unsigned long max();
};
}
#include <iostream>
#include <iomanip>
const hsps::rational POS_INF(1,0);
const hsps::rational NEG_INF(-1,0);
const hsps::rational ZERO(0,1);
namespace hsps {
inline hsps::rational random_numeric
(hsps::rational min, hsps::rational max, unsigned long prec, RNG& rng)
{
  hsps::rational d = (max - min);
  hsps::rational s = (d / prec);
  unsigned long r = rng.random_in_range(prec + 1);
  return ((r*s) + min);
}
class amt_vec : public auto_expanding_vector<hsps::rational> {
 public:
  amt_vec()
    : auto_expanding_vector<hsps::rational>() { };
  amt_vec(const hsps::rational& v, index_type l)
    : auto_expanding_vector<hsps::rational>(v, l) { };
  amt_vec(const amt_vec& vec)
    : auto_expanding_vector<hsps::rational>(vec) { };
  int compare(const amt_vec& vec, index_type n);
  int dcompare(const amt_vec& vec, index_type n);
  index_type hash(index_type n);
  void write(std::ostream& s, index_type n);
};
inline int amt_vec::compare(const amt_vec& vec, index_type n)
{
  for (index_type k = 0; k < n; k++) {
    if ((*this)[k] < vec[k]) return -1;
    else if ((*this)[k] > vec[k]) return 1;
  }
  return 0;
}
inline int amt_vec::dcompare(const amt_vec& vec, index_type n)
{
  bool this_less_than_vec = false;
  bool vec_less_than_this = false;
  for (index_type k = 0; k < n; k++) {
    if ((*this)[k] < vec[k]) this_less_than_vec = true;
    else if ((*this)[k] > vec[k]) vec_less_than_this = true;
  }
  if (this_less_than_vec && !vec_less_than_this) return -1;
  else if (!this_less_than_vec && vec_less_than_this) return 1;
  else return 0;
}
inline index_type amt_vec::hash(index_type n)
{
  if (n == 0) return 0;
  if (n == 1) return ((index_type)(((*this)[0]).numerator() - ((*this)[0]).divisor()));
  index_type h = 0;
  for (index_type k = 0; k < n - 1; k++) {
    h += ((index_type)(((((*this)[k]) + 1) * (((*this)[k + 1]) + 1)).numerator() - ((((*this)[k]) + 1) * (((*this)[k + 1]) + 1)).divisor()));
  }
  return h;
}
inline void amt_vec::write(std::ostream& s, index_type n)
{
  s << '[';
  for (index_type k = 0; k < n; k++) {
    if (k > 0) s << ',';
    s << std::resetiosflags(std::ios::scientific) << (((*this)[k]).decimal());
  }
  s << ']';
}
typedef lvector<hsps::rational> cost_vec;
typedef svector<hsps::rational> cost_set;
typedef matrix<hsps::rational> cost_matrix;
class cost_vec_util : public cost_vec
{
 public:
  class decreasing_cost_order : public cost_vec::order {
  public:
    virtual bool operator()
      (const hsps::rational& v0, const hsps::rational& v1) const
      { return (v0 > v1); };
  };
  class increasing_cost_order : public cost_vec::order {
  public:
    virtual bool operator()
      (const hsps::rational& v0, const hsps::rational& v1) const
      { return (v0 < v1); };
  };
  static class decreasing_cost_order decreasing;
  static class increasing_cost_order increasing;
  static hsps::rational max(const cost_vec& v);
  static hsps::rational min(const cost_vec& v);
  hsps::rational max() const { return max(*this); };
  hsps::rational min() const { return min(*this); };
};
struct interval : public comparable_pair<hsps::rational> {
  interval(const hsps::rational& v1, const hsps::rational& v2) :
    comparable_pair<hsps::rational>(v1, v2) { };
  interval(const hsps::rational& v) :
    comparable_pair<hsps::rational>(v) { };
  interval(const interval& p) :
    comparable_pair<hsps::rational>(p) { };
  interval() :
    comparable_pair<hsps::rational>(NEG_INF, POS_INF) { };
};
typedef std::pair<index_type, hsps::rational> index_cost_pair;
typedef lvector<index_cost_pair> index_cost_vec;
inline std::ostream& operator<<(std::ostream& s, const index_cost_pair& p)
{
  s << '(' << p.first << ',' << p.second << ')';
}
inline std::ostream& operator<<(std::ostream& s, const interval& i)
{
  s << '[' << i.first << ',' << i.second << ']';
}
}
#include <string>
#include <iostream>
namespace hsps {
class Name {
 public:
  static const unsigned int NC_DEFAULT = 0;
  static const unsigned int NC_INSTANCE = 1;
  static const unsigned int NC_DOMAIN = 2;
  static const unsigned int NC_PROBLEM = 4;
  static const unsigned int NC_PLAN = 8;
  static const unsigned int NC_ESCAPE = 16 + 32;
  static const unsigned int NC_PDDL = 16;
  static const unsigned int NC_XML = 32;
  static const unsigned int NC_LATEX = 16 + 32;
  static const unsigned int NC_IPC = 64;
  static bool context_is_instance(unsigned int c)
    { return ((c & NC_INSTANCE) == NC_INSTANCE); };
  static bool context_is_domain(unsigned int c)
    { return ((c & NC_DOMAIN) == NC_DOMAIN); };
  static bool context_is_problem(unsigned int c)
    { return ((c & NC_PROBLEM) == NC_PROBLEM); };
  static bool context_is_plan(unsigned int c)
    { return ((c & NC_PLAN) == NC_PLAN); };
  static bool escape_for_pddl(unsigned int c)
    { return ((c & NC_ESCAPE) == NC_PDDL); };
  static bool escape_for_xml(unsigned int c)
    { return ((c & NC_ESCAPE) == NC_XML); };
  static bool escape_for_latex(unsigned int c)
    { return ((c & NC_ESCAPE) == NC_LATEX); };
  static bool conform_to_IPC(unsigned int c)
    { return ((c & NC_IPC) == NC_IPC); };
  virtual ~Name();
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const = 0;
  virtual const Name* cast_to(const char* cname) const;
  ::std::string to_string(unsigned int c = NC_DEFAULT) const;
  char* to_cstring(unsigned int c = NC_DEFAULT) const;
  bool equals(const Name* name) const;
  void write_char_escaped(::std::ostream& s,
     char ch,
     unsigned int c) const;
  void write_string_escaped(::std::ostream& s,
       ::std::string& str,
       unsigned int c) const;
  void write_string_escaped(::std::ostream& s,
       const char* str,
       unsigned int c) const;
};
typedef lvector<const Name*> name_vec;
inline ::std::ostream& operator<<(::std::ostream& s, const Name& n) {
  n.write(s, false);
  return s;
}
inline ::std::ostream& operator<<(::std::ostream& s, const Name* n) {
  n->write(s, false);
  return s;
}
inline void Name::write_char_escaped
(::std::ostream& s, char ch, unsigned int c) const
{
  if (escape_for_latex(c)) {
    if (ch == '_') s << '\\' << '_';
    else if (ch == '%') s << '\\' << '%';
    else if (ch == '#') s << '\\' << '#';
    else s << ch;
  }
  else if (escape_for_xml(c)) {
    if (ch == '<') s << "&lt;";
    else if (ch == '>') s << "&gt;";
    else if (ch == '&') s << "&amp;";
    else if (ch == '"') s << "&quot;";
    else s << ch;
  }
  else if (escape_for_pddl(c)) {
    if (ch == ' ') s << '_';
    else s << ch;
  }
  else {
    s << ch;
  }
}
inline void Name::write_string_escaped
(::std::ostream& s, const char* str, unsigned int c) const
{
  while (*str) {
    write_char_escaped(s, *str, c);
    str++;
  }
}
inline void Name::write_string_escaped
(::std::ostream& s, ::std::string& str, unsigned int c) const
{
  for (index_type i = 0; i < str.length(); i++)
    write_char_escaped(s, str[i], c);
}
class NameWithContext : public Name {
  const Name* name;
  unsigned int c_on;
  unsigned int c_off;
 public:
  NameWithContext(const Name* n, unsigned int on, unsigned int off)
    : name(n), c_on(on), c_off(off) { };
  virtual ~NameWithContext() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class StringName : public Name {
  const char* _string;
  bool _own;
 public:
  StringName(const char* s, bool c = false)
    : _string(c ? strdup(s) : s), _own(c) { };
  virtual ~StringName() { if (_own) delete (char*)_string; };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class ConcatenatedName : public Name {
  name_vec elements;
  char catc;
 public:
  ConcatenatedName() : elements((Name*)0, 0), catc('+') { };
  ConcatenatedName(const Name* n) : elements(n, 1), catc('+') { };
  ConcatenatedName(char c) : elements((Name*)0, 0), catc(c) { };
  ConcatenatedName(const Name* n1, const Name* n2, char c)
    : elements((Name*)0, 0), catc(c)
  {
    elements.append(n1);
    elements.append(n2);
  };
  virtual ~ConcatenatedName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
  void append(const Name* n) { elements.append(n); };
};
class ModName : public Name {
  const char* _mod;
  const Name* _name;
 public:
  ModName(const Name* n, const char* m) : _mod(m), _name(n) { };
  virtual ~ModName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class CopyName : public Name {
  const Name* _name;
  index_type _num;
 public:
  CopyName(const Name* n) : _name(n), _num(no_such_index) { };
  CopyName(const Name* n, index_type m) : _name(n), _num(m) { };
  virtual ~CopyName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class NameAtIndex : public Name {
  const Name* _name;
  index_type _index;
 public:
  NameAtIndex(const Name* n, index_type i) : _name(n), _index(i) { };
  virtual ~NameAtIndex() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class EnumName : public Name {
  const char* prefix;
  index_type index;
 public:
  EnumName(const char* p, index_type i) : prefix(p), index(i) { };
  virtual ~EnumName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
}
#include <map>
#include <iostream>
namespace hsps {
class graph {
 private:
  index_type _size;
  bool_matrix adj;
  index_set_vec in;
  index_set_vec out;
  index_set_vec bi;
  index_vec comp;
  index_type n_comp;
 public:
  graph();
  graph(index_type s);
  graph(const graph& g);
  graph(const graph& g, const index_set& n);
  graph(const graph& g, const equivalence& eq);
  ~graph();
  index_type size() const { return _size; };
  bool adjacent(index_type i, index_type j) const { return adj[i][j]; };
  bool adjacent(index_type i, const index_set& n) const;
  bool adjacent(const index_set& n, index_type i) const;
  bool adjacent(const index_set& n0, const index_set& n1) const;
  bool bi_adjacent(index_type i, index_type j) const
    { return (adj[i][j] && adj[j][i]); };
  bool bi_adjacent(index_type i, const index_set& n) const;
  index_type n_edges() const;
  index_type n_edges(const index_set& from, const index_set& to) const;
  pair_set& edges(pair_set& s) const;
  index_type n_induced_undirected_edges() const;
  index_type n_induced_undirected_edges(const index_set& n0,
     const index_set& n1) const;
  index_type n_bidirectional_edges() const;
  index_type n_bidirectional_edges(const index_set& n0,
       const index_set& n1) const;
  const index_set& successors(index_type i) const { return out[i]; };
  index_type out_degree(index_type i) const { return out[i].length(); };
  const index_set& predecessors(index_type i) const { return in[i]; };
  index_type in_degree(index_type i) const { return in[i].length(); };
  const index_set& bidirectional(index_type i) const { return bi[i]; };
  index_type bi_degree(index_type i) const { return bi[i].length(); };
  pair_set& bidirectional_edges(pair_set& s) const;
  void descendants(index_type n0, bool_vec& s) const;
  void descendants(const index_set& s0, bool_vec& s) const;
  void descendants(index_type n0, index_set& s) const;
  void descendants(const index_set& s0, index_set& s) const;
  void ancestors(index_type n0, bool_vec& s) const;
  void ancestors(const index_set& s0, bool_vec& s) const;
  void ancestors(index_type n0, index_set& s) const;
  void ancestors(const index_set& s0, index_set& s) const;
  index_type max_out_degree() const;
  index_type max_in_degree() const;
  index_type max_bi_degree() const;
  index_type min_out_degree() const;
  index_type min_in_degree() const;
  index_type min_bi_degree() const;
  bool empty() const;
  bool connected() const;
  bool strongly_connected() const;
  bool reachable(index_type n0, index_type n1) const;
  void reachable(bool_vec& v) const;
  index_type count_reachable(index_type n0) const;
  bool acyclic() const;
  bool top_sort(index_vec& s) const;
  index_type first_root() const;
  index_type first_leaf() const;
  void fringe(const index_set& n, index_set& fn) const;
  void bi_fringe(const index_set& n, index_set& fn) const;
  void distance(index_type s0, index_vec& d) const;
  void distance(const index_set& s0, index_vec& d) const;
  index_type distance(index_type s0, index_type s1) const;
  void strongly_connected_components();
  index_type component(index_type i) const { return comp[i]; };
  index_type n_components() const { return n_comp; };
  index_type component_node(index_type i) const;
  index_type component_size(index_type i) const;
  void component_node_set(index_type i, index_set& set) const;
  graph& component_tree(graph& cg) const;
  equivalence& component_partitioning(equivalence& eq) const;
  index_type maximal_non_unit_component() const;
  graph& subgraph(graph& g, const index_set& n) const;
  graph& edge_subgraph(graph& g, const index_set& nodes) const;
  equivalence& induced_partitioning(equivalence& eq) const;
  graph& induced_undirected_graph(graph& g) const;
  graph& minimal_equivalent_digraph(graph& g) const;
  graph& minimal_distance_graph(graph& g, const index_set& s0) const;
  graph& quotient(graph& g, const equivalence& eq) const;
  bool equals(const graph& g) const;
  bool equals(const graph& g, const index_vec& c) const;
  void difference(const graph& g,
    const index_vec& c,
    pair_set& d0,
    pair_set& d1) const;
  void difference(const graph& g,
    pair_set& d0,
    pair_set& d1) const;
  index_type cardinality_of_difference(const graph& g) const;
  void init(index_type s);
  void copy(const graph& g);
  void copy(const graph& g, const index_vec& map);
  void copy_and_rename(const graph& g, const index_vec& map);
  index_type add_node();
  void remove_node(index_type n);
  void add_graph(const graph& g, mapping& m);
  void add_edge(index_type src, index_type dst);
  void add_edge(const index_set& srcs, index_type dst);
  void add_edge(index_type src, const index_set& dsts);
  void add_edge_to_transitive_closure(index_type src,
          index_type dst,
          pair_set& e);
  void remove_edge(index_type src, index_type dst);
  void remove_edges_from(index_type src);
  void remove_edges_to(index_type dst);
  void remove_edges_incident_on(index_type n);
  void remove_edges(const pair_set& e);
  void add_undirected_edge(index_type n0, index_type n1);
  void remove_undirected_edge(index_type n0, index_type n1);
  void remove_undirected_edges(const pair_set& e);
  void clear_edges();
  void recalculate();
  void complement();
  void complement_with_loops();
  void remove_loops();
  void reverse();
  void transitive_closure();
  void missing_transitive_edges(pair_set& e) const;
  void transitive_reduction();
  void intersect(const graph& g);
  void randomize(count_type n, RNG& rnd);
  void randomize_connected(count_type n, RNG& rnd);
  void randomize_strongly_connected(count_type n, RNG& rnd);
  void random_digraph(count_type n, RNG& rnd);
  void random_connected_digraph(count_type n, RNG& rnd);
  void random_strongly_connected_digraph(count_type n, RNG& rnd);
  void random_digraph_with_density(rational density, RNG& rnd);
  void random_tree(RNG& rnd);
  void random_tree(index_type b, index_type d, RNG& rnd);
  bool is_clique(const index_set& nodes) const;
  bool is_independent(const index_set& nodes) const;
  bool is_independent_range(index_type l, index_type u) const;
  void maximal_clique(index_set& clique) const;
  void maximal_clique_including(index_type node, index_set& clique) const;
  void maximal_clique_cover(index_set_vec& sets) const;
  void all_maximal_cliques(index_set_vec& cliques) const;
  void all_maximal_cliques_including(index_type node, index_set_vec& cliques)
    const;
  void apx_independent_set(index_set& set) const;
  void apx_independent_set_including(index_type node, index_set& set) const;
  void apx_independent_set_cover(index_set_vec& sets) const;
  void apx_independent_set_disjoint_cover(index_set_vec& sets) const;
  void all_nondominated_cliques(index_set_vec &cliques) const;
  void all_cliques_geq(index_type k, index_set_vec& cliques) const;
  void write_node_set(::std::ostream& s) const;
  void write_edge_set(::std::ostream& s) const;
  void write_compact(::std::ostream& s) const;
  void write_undirected_edge_set(::std::ostream& s) const;
  void write_adjacency_lists(::std::ostream& s) const;
  void write_digraph(::std::ostream& s,
       bool with_node_indices,
       const char* name) const;
  void write_component_labeled_digraph(::std::ostream& s,
           const char* name) const;
  void write_graph_correspondance(::std::ostream& s,
      const graph& g,
      const index_vec& c,
      const char* name) const;
 public:
  void max_clique(index_set& sel,
    index_type next,
    index_set& clique) const;
  void all_max_cliques(index_set& sel,
         index_type next,
         index_set_vec& cliques) const;
  void all_nondominated_cliques_aux(index_set_vec &cliques,
                                    index_set &current_clique,
                                    const index_set &candidates,
        index_type min) const;
  void ramsey(const index_set& nodes, index_set& I, index_set& C) const;
  void apx_independent_set(const index_set& nodes, index_set& set) const;
  void undirected_dfs(index_type n, bool_vec& visited) const;
  void reachable(index_type n, bool_vec& v) const;
  void reverse_reachable(index_type n, bool_vec& v) const;
 private:
  void scc_first_dfs(index_type n, bool_vec& visited, index_vec& num) const;
  void scc_second_dfs(index_type n, bool_vec& visited, index_type c_id);
};
template<class LS>
void write_labeled_digraph
(std::ostream& s,
 const graph& g,
 const LS& ls,
 bool with_node_indices = false,
 const char* name = 0,
 index_type c_id = no_such_index)
{
  if (c_id != no_such_index) {
    s << "subgraph cluster" << c_id << "{" << std::endl;
  }
  else if (name) {
    s << "digraph \"" << name << "\" {" << ::std::endl;
  }
  s << "node [width=0,height=0];" << ::std::endl;
  for (index_type k = 0; k < g.size(); k++) {
    if (with_node_indices) {
      s << "\t" << k + (c_id == no_such_index ? 0 : c_id)
 << " [label=\"(" << k << ") " << ls[k] << "\"];"
 << ::std::endl;
    }
    else {
      s << "\t" << k + (c_id == no_such_index ? 0 : c_id)
 << " [label=\"" << ls[k] << "\"];"
 << ::std::endl;
    }
  }
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j))
 s << "\t" << i + (c_id == no_such_index ? 0 : c_id)
   << " -> " << j + (c_id == no_such_index ? 0 : c_id)
   << ";" << ::std::endl;
  if ((c_id != no_such_index) || (name != 0)) {
    s << "}" << ::std::endl;
  }
}
typedef lvector<graph> graph_vec;
template<class N, class E> class labeled_graph : public graph {
 public:
  typedef std::map<index_type, N> node_label_map;
  typedef std::map<index_pair, E> edge_label_map;
  typedef lvector<N> node_label_vec;
  typedef lvector<E> edge_label_vec;
 protected:
  node_label_map _node_label;
  edge_label_map _edge_label;
 public:
  labeled_graph();
  labeled_graph(index_type size);
  labeled_graph(const graph& g);
  labeled_graph(const labeled_graph& g);
  labeled_graph(const graph& g, const index_set& nodes);
  labeled_graph(const labeled_graph& g, const index_set& nodes);
  labeled_graph(const graph& g, const equivalence& eq);
  ~labeled_graph();
  N& node_label(index_type n);
  E& edge_label(index_type i, index_type j);
  const N& node_label(index_type n) const;
  const E& edge_label(index_type i, index_type j) const;
  bool node_has_label(index_type n) const;
  bool edge_has_label(index_type i, index_type j) const;
  labeled_graph& subgraph(labeled_graph& g, const index_set& n) const;
  index_type node_with_label(const N& l) const;
  index_pair edge_with_label(const E& l) const;
  void init(index_type size);
  void init(index_type size, const N& n, const E& e);
  void copy(const graph& g);
  void copy(const labeled_graph& g);
  void add_graph(const graph& g, mapping& m);
  void add_graph(const labeled_graph& g, mapping& m);
  void add_edge(index_type src, index_type dst);
  void add_edge(index_type src, index_type dst, const E& lbl);
  void add_edge(const index_set& srcs, index_type dst);
  void add_edge(const index_set& srcs, index_type dst, const E& lbl);
  void add_edge(index_type src, const index_set& dsts);
  void add_edge(index_type src, const index_set& dsts, const E& lbl);
  index_type add_node();
  index_type add_node(const N& l);
  void remove_node(index_type n);
  void remove_edge(index_type src, index_type dst);
  void remove_edges_from(index_type src);
  void remove_edges_to(index_type dst);
  void remove_edges_incident_on(index_type n);
  void remove_undirected_edge(index_type n0, index_type n1);
  void remove_edges(const pair_set& e);
  void remove_undirected_edges(const pair_set& e);
  void clear_edges();
  void clear_node_labels();
  void clear_edge_labels();
  void remove_edges_with_label(const E& l);
  void write_digraph(::std::ostream& s,
       bool with_node_indices,
       bool with_node_labels,
       bool with_edge_labels,
       bool compact_edges,
       const char* name) const;
  void write_matrix(::std::ostream& s,
      const char* unlabeled_edge,
      const char* missing_edge) const;
};
template<class N, class E>
labeled_graph<N,E>::labeled_graph()
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(index_type s)
  : graph(s)
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(const graph& g)
  : graph(g)
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(const labeled_graph& g)
  : graph(g), _node_label(g._node_label), _edge_label(g._edge_label)
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(const graph& g, const index_set& n)
{
  g.subgraph(*this, n);
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph
(const labeled_graph& g, const index_set& n)
{
  g.subgraph(*this, n);
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph
(const graph& g, const equivalence& eq)
{
  g.quotient(*this, eq);
}
template<class N, class E>
labeled_graph<N,E>::~labeled_graph()
{
}
template<class N, class E>
N& labeled_graph<N,E>::node_label(index_type n)
{
  assert(n < size());
  return _node_label[n];
}
template<class N, class E>
E& labeled_graph<N,E>::edge_label(index_type i, index_type j)
{
  assert((i < size()) && (j < size()));
  return _edge_label[index_pair(i, j)];
}
template<class N, class E>
const N& labeled_graph<N,E>::node_label(index_type n) const
{
  assert(node_has_label(n));
  return (_node_label.find(n)->second);
}
template<class N, class E>
const E& labeled_graph<N,E>::edge_label(index_type i, index_type j) const
{
  assert(edge_has_label(i, j));
  return (_edge_label.find(index_pair(i, j))->second);
}
template<class N, class E>
bool labeled_graph<N,E>::node_has_label(index_type n) const
{
  assert(n < size());
  return (_node_label.find(n) != _node_label.end());
}
template<class N, class E>
bool labeled_graph<N,E>::edge_has_label(index_type i, index_type j) const
{
  assert((i < size()) && (j < size()));
  return (_edge_label.find(index_pair(i, j)) != _edge_label.end());
}
template<class N, class E>
void labeled_graph<N,E>::init(index_type s)
{
  graph::init(s);
  _node_label.clear();
  _edge_label.clear();
}
template<class N, class E>
void labeled_graph<N,E>::copy(const labeled_graph& g)
{
  graph::copy(g);
  _node_label = g._node_label;
  _edge_label = g._edge_label;
}
template<class N, class E>
labeled_graph<N,E>& labeled_graph<N,E>::subgraph
(labeled_graph& g, const index_set& n) const
{
  g.init(n.length());
  for (index_type k = 0; k < n.length(); k++) {
    assert(n[k] < size());
    if (node_has_label(n[k])) {
      g.node_label(k) = node_label(n[k]);
    }
  }
  for (index_type i = 0; i < n.length(); i++)
    for (index_type j = 0; j < n.length(); j++)
      if (adjacent(n[i], n[j])) {
 g.add_edge(i, j);
 if (edge_has_label(n[i], n[j])) {
   g.edge_label(i, j) = edge_label(n[i], n[j]);
 }
      }
}
template<class N, class E>
index_type labeled_graph<N,E>::node_with_label(const N& l) const
{
  for (index_type k = 0; k < size(); k++)
    if (node_has_label(k))
      if (node_label(k) == l)
 return k;
  return no_such_index;
}
template<class N, class E>
index_pair labeled_graph<N,E>::edge_with_label(const E& l) const
{
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) && edge_has_label(i, j))
 if (edge_label(i, j) == l)
   return index_pair(i, j);
  return no_such_index;
}
template<class N, class E>
void labeled_graph<N,E>::add_graph
(const graph& g, mapping& m)
{
  graph::add_graph(g, m);
}
template<class N, class E>
void labeled_graph<N,E>::add_graph
(const labeled_graph& g, mapping& m)
{
  graph::add_graph(g, m);
  for (index_type i = 0; i < g.size(); i++) {
    if (g.node_has_label(i))
      node_label(m[i]) = g.node_label(i);
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j) && g.edge_has_label(i, j))
 edge_label(m[i], m[j]) = g.edge_label(i, j);
  }
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, index_type dst)
{
  graph::add_edge(src, dst);
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, index_type dst, const E& lbl)
{
  graph::add_edge(src, dst);
  edge_label(src, dst) = lbl;
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(const index_set& srcs, index_type dst)
{
  graph::add_edge(srcs, dst);
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(const index_set& srcs, index_type dst, const E& lbl)
{
  graph::add_edge(srcs, dst);
  for (index_type k = 0; k < srcs.length(); k++)
    edge_label(srcs[k], dst) = lbl;
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, const index_set& dsts)
{
  graph::add_edge(src, dsts);
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, const index_set& dsts, const E& lbl)
{
  graph::add_edge(src, dsts);
  for (index_type k = 0; k < dsts.length(); k++)
    edge_label(src, dsts[k]) = lbl;
}
template<class N, class E>
index_type labeled_graph<N,E>::add_node()
{
  return graph::add_node();
}
template<class N, class E>
index_type labeled_graph<N,E>::add_node(const N& l)
{
  index_type n = graph::add_node();
  node_label(n) = l;
  return n;
}
template<class N, class E>
void labeled_graph<N,E>::remove_node(index_type n)
{
  assert(n < size());
  labeled_graph g(*this);
  index_set ns;
  ns.fill(size());
  ns.subtract(n);
  g.subgraph(*this, ns);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edge(index_type src, index_type dst)
{
  _edge_label.erase(index_pair(src, dst));
  graph::remove_edge(src, dst);
}
template<class N, class E>
void labeled_graph<N,E>::remove_undirected_edge(index_type n0, index_type n1)
{
  _edge_label.erase(index_pair(n0, n1));
  _edge_label.erase(index_pair(n1, n0));
  graph::remove_undirected_edge(n0, n1);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_from(index_type src)
{
  index_set ns(successors(src));
  for (index_type k = 0; k < ns.length(); k++)
    remove_edge(src, ns[k]);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_to(index_type dst)
{
  index_set ns(predecessors(dst));
  for (index_type k = 0; k < ns.length(); k++)
    remove_edge(ns[k], dst);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_incident_on(index_type n)
{
  remove_edges_from(n);
  remove_edges_to(n);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges(const pair_set& e)
{
  for (index_type k = 0; k < e.length(); k++) {
    remove_edge(e[k].first, e[k].second);
  }
}
template<class N, class E>
void labeled_graph<N,E>::remove_undirected_edges(const pair_set& e)
{
  for (index_type k = 0; k < e.length(); k++) {
    remove_undirected_edge(e[k].first, e[k].second);
  }
}
template<class N, class E>
void labeled_graph<N,E>::clear_edges()
{
  _edge_label.clear();
  graph::clear_edges();
}
template<class N, class E>
void labeled_graph<N,E>::clear_node_labels()
{
  _node_label.clear();
}
template<class N, class E>
void labeled_graph<N,E>::clear_edge_labels()
{
  _edge_label.clear();
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_with_label(const E& l)
{
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) && (edge_label(i, j) == l))
 remove_edge(i, j);
}
template<class N, class E>
void labeled_graph<N,E>::write_digraph
(::std::ostream& s,
 bool with_node_indices,
 bool with_node_labels,
 bool with_edge_labels,
 bool compact_edges,
 const char* name) const
{
  if (strncmp(name, "cluster", 7) == 0)
    s << "subgraph";
  else
    s << "digraph";
  s << " \"" << name << "\"" << ::std::endl << "{" << ::std::endl;
  if (with_node_indices || with_node_labels) {
    s << "\tnode [shape=ellipse];" << ::std::endl;
  }
  else {
    s << "\tnode [shape=point];" << ::std::endl;
  }
  for (index_type i = 0; i < size(); i++) {
    s << "\t" << i;
    if (with_node_indices || with_node_labels) {
      s << " [label=\"";
      if (with_node_indices) {
 if (with_node_labels) {
   s << i << ": ";
   if (node_has_label(i)) {
     s << node_label(i);
   }
 }
 else {
   s << i;
 }
      }
      else {
 if (node_has_label(i)) {
   s << node_label(i);
 }
      }
      s << "\"]";
    }
    s << ";" << std::endl;
  }
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j)) {
 if (adjacent(j, i) && compact_edges) {
   if (i < j) {
     s << "\t" << i << " -> " << j;
     s << " [dir=both";
     if (with_edge_labels &&
  (edge_has_label(i, j) || edge_has_label(j, i))) {
       if (!edge_has_label(i, j)) {
  s << ",label=\"" << edge_label(j, i) << "\"";
       }
       else if (!edge_has_label(j, i)) {
  s << ",label=\"" << edge_label(i, j) << "\"";
       }
       else if (edge_label(i, j) == edge_label(j, i)) {
  s << ",label=\"" << edge_label(i, j) << "\"";
       }
       else {
  s << ",label=\"" << edge_label(i, j) << ", "
    << edge_label(j, i) << "\"";
       }
     }
     s << "]" << ::std::endl;
   }
 }
 else {
   s << "\t" << i << " -> " << j;
   if (with_edge_labels && edge_has_label(i, j)) {
     s << " [label=\"" << edge_label(i, j) << "\"]";
   }
   s << ";" << ::std::endl;
 }
      }
  s << "}" << ::std::endl;
}
template<class N, class E>
void labeled_graph<N,E>::write_matrix
(::std::ostream& s, const char* unlabeled_edge, const char* missing_edge) const
{
  s << '[';
  for (index_type i = 0; i < size(); i++) {
    if (i > 0) s << ' ';
    s << '[';
    for (index_type j = 0; j < size(); j++) {
      if (j > 0) s << ',';
      if (adjacent(i, j)) {
 if (edge_has_label(i, j)) {
   s << edge_label(i, j);
 }
 else {
   s << unlabeled_edge;
 }
      }
      else {
 s << missing_edge;
      }
    }
    s << ']';
    if (i + 1 < size()) {
      s << ',' << '\n';
    }
    else {
      s << ']' << '\n';
    }
  }
}
class index_graph : public labeled_graph<index_type,index_type> {
  static const index_type NODE_SHAPE = 2 + 4 + 8 + 16;
  static const index_type NODE_STYLE = 64 + 128 + 256;
  static const index_type EDGE_STYLE = 64 + 128;
  static const index_type EDGE_DIR = 512 + 1024;
 public:
  static const index_type NS_CIRCLE = 0;
  static const index_type NS_ELLIPSE = 2;
  static const index_type NS_BOX = 4;
  static const index_type NS_POINT = 6;
  static const index_type NS_DIAMOND = 8;
  static const index_type NS_HEXAGON = 10;
  static const index_type NS_OCTAGON = 12;
  static const index_type NS_PLAINTEXT = 14;
  static const index_type NS_NORMAL = 0;
  static const index_type NS_DOUBLE = 32;
  static const index_type NS_BOLD = 64;
  static const index_type NS_DASHED = 128;
  static const index_type NS_DOTTED = 192;
  static const index_type NS_FILLED = 256;
  static const index_type ED_NONE = 0;
  static const index_type ED_FORWARD = 512;
  static const index_type ED_BACK = 1024;
  static const index_type ED_BOTH = ED_FORWARD + ED_BACK;
  static const index_type ES_NORMAL = NS_NORMAL;
  static const index_type ES_BOLD = NS_BOLD;
  static const index_type ES_DASHED = NS_DASHED;
  static const index_type ES_DOTTED = NS_DOTTED;
  static const index_type STYLE_MAX = 2048;
  index_graph()
    : labeled_graph<index_type, index_type>() { };
  index_graph(index_type size)
    : labeled_graph<index_type, index_type>(size) { };
  index_graph(const graph& g)
    : labeled_graph<index_type, index_type>(g) { };
  index_graph(const index_graph& g)
    : labeled_graph<index_type, index_type>(g) { };
  index_graph(const graph& g, const index_set& nodes)
    : labeled_graph<index_type, index_type>(g, nodes) { };
  index_graph(const index_graph& g, const index_set& nodes)
    : labeled_graph<index_type, index_type>(g, nodes) { };
  index_graph(const graph& g, const equivalence& eq)
    : labeled_graph<index_type, index_type>(g, eq) { };
  ~index_graph() { };
  void reverse();
  void reflect();
  static void write_node_style(std::ostream& s, index_type l);
  static void write_edge_style(std::ostream& s, index_type l);
  void write_styled_digraph(std::ostream& s,
       bool with_node_indices = false,
       const char* name = 0,
       index_type c_id = no_such_index) const;
  void write_matrix(std::ostream& s) const;
  void write_MATLAB(std::ostream& s,
      const char* n,
      const char* t) const;
};
template<class LS>
void write_styled_digraph
(std::ostream& s,
 const index_graph& g,
 const LS& ls,
 bool with_node_indices = false,
 const char* name = 0,
 index_type c_id = no_such_index)
{
  if (c_id != no_such_index) {
    s << "subgraph cluster" << c_id << " {" << std::endl;
    s << "node [width=0.5,height=0.5];" << ::std::endl;
  }
  else if (name) {
    s << "digraph \"" << name << "\" {" << std::endl;
    s << "node [width=0.5,height=0.5];" << ::std::endl;
  }
  for (index_type k = 0; k < g.size(); k++) {
    s << "\t" << k + (c_id != no_such_index ? c_id : 0) << " [";
    index_graph::write_node_style(s, g.node_has_label(k) ? g.node_label(k) : 0);
    if (with_node_indices)
      s << ",label=\"(" << k << ") " << ls[k] << "\"];" << std::endl;
    else
      s << ",label=\"" << ls[k] << "\"];" << std::endl;
  }
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j)) {
 s << "\t" << i + (c_id != no_such_index ? c_id : 0)
   << " -> " << j + (c_id != no_such_index ? c_id : 0) << " [";
 index_graph::write_edge_style(s, g.edge_has_label(i, j) ? g.edge_label(i, j) : 0);
 s << "];" << std::endl;
      }
  if ((c_id != no_such_index) || (name != 0)) {
    s << "}" << ::std::endl;
  }
}
class weighted_graph : public labeled_graph<hsps::rational,hsps::rational> {
 public:
  weighted_graph() { };
  weighted_graph(index_type s)
    : labeled_graph<hsps::rational,hsps::rational>(s) { };
  weighted_graph(const graph& g)
    : labeled_graph<hsps::rational,hsps::rational>(g) { };
  weighted_graph(const weighted_graph& g)
    : labeled_graph<hsps::rational,hsps::rational>(g) { };
  weighted_graph(const graph& g, const index_set& n)
    : labeled_graph<hsps::rational,hsps::rational>(g, n) { };
  weighted_graph(const weighted_graph& g, const index_set& n)
    : labeled_graph<hsps::rational,hsps::rational>(g, n) { };
  weighted_graph(const graph& g, const equivalence& eq)
    : labeled_graph<hsps::rational,hsps::rational>(g, eq) { };
  weighted_graph(const weighted_graph& g, const equivalence& eq);
  ~weighted_graph() { };
  weighted_graph& quotient(weighted_graph& g, const equivalence& eq) const;
  hsps::rational apx_weighted_independent_set_1(index_set& set) const;
  hsps::rational apx_weighted_independent_set_2(index_set& set) const;
  hsps::rational apx_weighted_independent_set(index_set& set) const;
  void add_edge(index_type src, index_type dst);
  void add_edge(index_type src, index_type dst, hsps::rational w);
  void add_undirected_edge(index_type n0, index_type n1);
  void add_undirected_edge(index_type n0, index_type n1, hsps::rational w);
  hsps::rational weight(index_type n) const;
  hsps::rational weight(index_type n0, index_type n1) const;
  hsps::rational weight(const index_set& ns) const;
  void set_weight(index_type n, hsps::rational w);
  void set_weight(index_type n0, index_type n1, hsps::rational w);
  void increment_edge_weight(index_type src, index_type dst, hsps::rational w);
  hsps::rational max_node_weight() const;
  void transitive_closure();
  hsps::rational critical_path(cost_vec& s);
  hsps::rational max_flow(index_type s, index_type t);
  hsps::rational max_flow(index_type s, index_type t, weighted_graph& rg);
  hsps::rational max_flow(index_type s, index_type t, cost_matrix& f);
  hsps::rational min_cut(index_type s, index_type t, bool_vec& s_set);
  hsps::rational min_cut(index_type s, index_type t, pair_set& e_set);
  index_pair max_weight_edge() const;
  void min_and_max_edges(const index_set& nodes,
    pair_set& e_min, hsps::rational& w_min,
    pair_set& e_max, hsps::rational& w_max) const;
  hsps::rational maximal_matching(weighted_graph& matching);
  hsps::rational apx_matching(bool_vec& nodes);
  void write_node_set(::std::ostream& s) const;
  void write_edge_set(::std::ostream& s) const;
  void write_compact(::std::ostream& s) const;
  void write_matrix(::std::ostream& s) const;
 private:
  hsps::rational augmenting_path(index_type s, index_type t, const cost_matrix& f,
   pair_vec& p);
};
class index_set_graph : public labeled_graph<index_set,index_set> {
 public:
  index_set_graph() { };
  index_set_graph(index_type s)
    : labeled_graph<index_set,index_set>(s) { };
  index_set_graph(const graph& g)
    : labeled_graph<index_set,index_set>(g) { };
  index_set_graph(const index_set_graph& g)
    : labeled_graph<index_set,index_set>(g) { };
  index_set_graph(const graph& g, const index_set& n)
    : labeled_graph<index_set,index_set>(g, n) { };
  index_set_graph(const index_set_graph& g, const index_set& n)
    : labeled_graph<index_set,index_set>(g, n) { };
  index_set_graph(const graph& g, const equivalence& eq);
  index_set_graph(const index_set_graph& g, const equivalence& eq);
  ~index_set_graph() { };
  void union_reachable();
  void merge_labels(const index_set& ns);
  void merge_labels_upwards();
  void merge_labels_downwards();
  index_set_graph& quotient(index_set_graph& g, const equivalence& eq) const;
  index_set_graph& union_reachable(index_set_graph& g) const;
  index_set_graph& subgraph_set_size_gt(index_set_graph& g, index_type l);
  void write_edge_set(::std::ostream& s) const;
  void write_digraph(::std::ostream& s, const char* name) const;
};
inline ::std::ostream& operator<<(::std::ostream& s, const graph& g)
{
  g.write_compact(s);
  return s;
};
inline ::std::ostream& operator<<(::std::ostream& s, const weighted_graph& g)
{
  g.write_compact(s);
  return s;
};
inline ::std::ostream& operator<<(::std::ostream& s, const index_set_graph& g)
{
  g.write_edge_set(s);
  return s;
};
}
namespace hsps {
class Heuristic;
struct rule {
  index_set antecedent;
  index_type consequent;
  rule() : antecedent(EMPTYSET), consequent(no_such_index) { };
  rule(index_type c) : antecedent(EMPTYSET), consequent(c) { };
  rule(const index_set& a, index_type c) : antecedent(a), consequent(c) { };
  rule(const rule& r) : antecedent(r.antecedent), consequent(r.consequent) { };
  rule& operator=(const rule& r) {
    antecedent = r.antecedent;
    consequent = r.consequent;
    return *this;
  };
  bool operator==(const rule& r) const {
    return ((antecedent == r.antecedent) && (consequent == r.consequent));
  };
  bool operator!=(const rule& r) const {
    return (!(*this == r));
  };
  bool operator<(const rule& r) const {
    return ((consequent < r.consequent) ||
     ((consequent == r.consequent) && (antecedent < r.antecedent)));
  };
  bool operator>(const rule& r) const {
    return ((consequent > r.consequent) ||
     ((consequent == r.consequent) && (antecedent > r.antecedent)));
  };
};
class rule_set : public svector<rule> {
 public:
  index_type find_rule(index_type c) const;
  void compute_dependency_graph(index_type n, index_graph& g) const;
  void remove(const bool_vec& set, index_vec& map);
  void remove(const bool_vec& set, index_graph& g);
  void remove(const bool_vec& set);
  void make_acyclic(index_graph& g);
  void make_post_unique(index_graph& g);
};
typedef svector<const char*> string_set;
class Instance {
  bool xrf;
 public:
  static bool write_negation;
  static bool write_DKEL;
  static bool write_PDDL2;
  static bool write_time;
  static bool write_PDDL3;
  static bool write_metric;
  static bool write_extra;
  static bool write_resource_constraints_at_start;
  static bool always_write_parameters;
  static bool always_write_requirements;
  static bool always_write_precondition;
  static bool always_write_effect;
  static bool always_write_conjunction;
  static bool write_atom_set_with_symbolic_names;
  static bool write_action_set_with_symbolic_names;
  static const char* goal_atom_name;
  static const char* goal_action_name;
  static hsps::rational goal_action_cost;
  static const char* pc_name;
  static index_type pc_count;
  struct Atom {
    const Name* name;
    index_type index;
    index_type neg;
    bool init;
    hsps::rational init_t;
    bool goal;
    hsps::rational goal_t;
    bool irrelevant;
    void* src;
    index_vec req_by;
    index_vec add_by;
    index_vec del_by;
    Atom() : name(0), index(no_such_index), neg(no_such_index),
  init(false), init_t(0), goal(false), goal_t(POS_INF),
  irrelevant(false), src(0), req_by(no_such_index, 0),
  add_by(no_such_index, 0), del_by(no_such_index, 0) { };
    Atom(const Name* n) : name(n), index(0), neg(no_such_index),
  init(false), init_t(0), goal(false), goal_t(POS_INF),
  irrelevant(false), src(0), req_by(no_such_index, 0),
  add_by(no_such_index, 0), del_by(no_such_index, 0) { };
    Atom(const Name* n, index_type i) : name(n), index(i),
  neg(no_such_index), init(false), init_t(0), goal(false),
  goal_t(POS_INF),
  irrelevant(false), req_by(no_such_index, 0),
  add_by(no_such_index, 0), del_by(no_such_index, 0) { };
    Atom& operator=(const Atom& a) {
      name = a.name;
      index = a.index;
      neg = a.neg;
      init = a.init;
      init_t = a.init_t;
      goal = a.goal;
      goal_t = a.goal_t;
      irrelevant = a.irrelevant;
      src = a.src;
      req_by = a.req_by;
      add_by = a.add_by;
      del_by = a.del_by;
      return *this;
    };
    bool operator==(const Atom& a) {
      return (index == a.index);
    };
  };
  struct Resource {
    const Name* name;
    index_type index;
    hsps::rational init;
    void* src;
    bool consumed;
    bool used;
    Resource() : name(0), index(no_such_index), init(0), src(0),
  consumed(false), used(false) { };
    Resource(const Name* n) : name(n), index(no_such_index), init(0), src(0),
  consumed(false), used(false) { };
    Resource(const Name* n, index_type i) : name(n), index(i), init(0),
  src(0), consumed(false), used(false) { };
    Resource& operator=(const Resource& r) {
      name = r.name;
      index = r.index;
      init = r.init;
      src = r.src;
      consumed = r.consumed;
      used = r.used;
      return *this;
    };
    bool operator==(const Resource& r) {
      return (index == r.index);
    };
    bool reusable() const { return (used && !consumed); };
    bool consumable() const { return (consumed); };
  };
  struct Action {
    const Name* name;
    index_type index;
    bool sel;
    index_set pre;
    index_set add;
    index_set del;
    index_set lck;
    amt_vec use;
    amt_vec cons;
    hsps::rational dur;
    hsps::rational dmin;
    hsps::rational dmax;
    hsps::rational cost;
    const char* assoc;
    void* src;
    index_set ncw_atms;
    Action()
      : name(0), index(no_such_index), sel(true), pre(), add(), del(),
        lck(), use(ZERO, 0), cons(ZERO, 0), dur(1), dmin(1), dmax(1), cost(1),
  assoc(0), src(0), ncw_atms() { };
    Action(const Name* n)
      : name(n), index(no_such_index), sel(true), pre(), add(), del(),
        lck(), use(ZERO, 0), cons(ZERO, 0), dur(1), dmin(1), dmax(1), cost(1),
 assoc(0), src(0), ncw_atms() { };
    Action& operator=(const Action& a) {
      name = a.name;
      index = a.index;
      sel = a.sel;
      pre = a.pre;
      add = a.add;
      del = a.del;
      lck = a.lck;
      use = a.use;
      cons = a.cons;
      dur = a.dur;
      dmin = a.dmin;
      dmax = a.dmax;
      cost = a.cost;
      assoc = a.assoc;
      src = a.src;
      ncw_atms = a.ncw_atms;
      return *this;
    };
    bool operator==(const Action& a) {
      return (index == a.index);
    };
    hsps::rational req(index_type r) const { return use[r] + cons[r]; };
    bool e_deletes(index_type p, Heuristic* inc) const;
    bool e_deletes(const index_set& s, Heuristic* inc) const;
  };
  struct Constraint {
    const Name* name;
    index_type index;
    index_set set;
    index_type lim;
    bool exact;
    void* src;
    bool verified;
    Constraint() : name(0), index(no_such_index), set(), lim(0),
  exact(false), src(0), verified(false) { };
    Constraint(const Name* n) : name(n), index(no_such_index),
  set(), lim(0), exact(false), src(0), verified(false) { };
    Constraint(index_set s, index_type n, bool e) : name(0),
  index(no_such_index), set(s), lim(n), exact(e), src(0),
  verified(false) { };
    Constraint& operator=(const Constraint& c) {
      name = c.name;
      index = c.index;
      set = c.set;
      lim = c.lim;
      exact = c.exact;
      src = c.src;
      verified = c.verified;
      return *this;
    };
    bool operator==(const Constraint& c) {
      return ((set == c.set) && (lim == c.lim) && (exact == c.exact));
    };
  };
  typedef lvector<Atom> atom_vec;
  typedef lvector<Resource> resource_vec;
  typedef lvector<Action> action_vec;
  typedef lvector<Constraint> constraint_vec;
  typedef atom_vec::element_reference atom_ref;
  typedef resource_vec::element_reference resource_ref;
  typedef action_vec::element_reference action_ref;
  typedef constraint_vec::element_reference constraint_ref;
  const Name* name;
  atom_vec atoms;
  action_vec actions;
  resource_vec resources;
  constraint_vec invariants;
  index_set init_atoms;
  index_set goal_atoms;
  index_type max_pre, max_add, max_del, max_lck,
               max_add_by, max_del_by, max_req_by;
  hsps::rational min_dur, max_dur, min_cost, max_cost;
  set_hash_function atom_set_hash;
  set_hash_function action_set_hash;
  static int default_trace_level;
  int trace_level;
  Instance();
  Instance(const Name* n);
  Instance(const Instance& ins);
  ~Instance() { };
  Atom& new_atom(const Name* name);
  Resource& new_resource(const Name* name);
  Action& new_action(const Name* name);
  Action& copy_action(index_type a);
  Constraint& new_invariant();
  Constraint& new_invariant(const Name* name);
  Constraint& new_invariant(const index_set& s, index_type l, bool e);
  void copy(const Instance& ins);
  Instance* copy() const;
  void clear();
  void restricted_copy(const Instance& ins, const index_set& atms,
         const index_set& rc, index_set& acts, index_vec& map);
  void restricted_copy(const Instance& ins, const index_set& acts,
         index_vec& map);
  void abstracted_copy(const Instance& ins, const index_set& atms,
         index_vec& atm_map, index_vec& act_map);
  void reverse_copy(const Instance& ins);
  void delete_relax(const index_set& x_atms);
  void delete_relax_less(const index_set& x_atms);
  void assign_unique_action_names();
  void remove_actions(const bool_vec& set, index_vec& map);
  void remove_atoms(const bool_vec& set, index_vec& map);
  void remove_invariants(const bool_vec& set, index_vec& map);
  void remap_set(index_set& set, const index_vec& map);
  void remap_sets(index_set_vec& sets, const index_vec& map);
  void set_initial(const index_set& init);
  void set_goal(const index_set& goal);
  void set_DNF_goal(const index_set_vec& goal);
  void replace_atom_by_conjunction(index_type p, const index_set& c);
  void set_cost_bound(hsps::rational b);
  void create_composite_resource(const index_set& set);
  void create_total_resource();
  void extract_atom_negations_from_invariants();
  index_type complete_atom_negation(index_type a);
  void complete_atom_negations(const index_set& s);
  void complete_atom_negations();
  index_type create_history_atom(index_type a);
  void add_all_negation_invariants();
  void add_missing_negation_invariants();
  index_type compile_pc_always(const index_set& f, const Name* n);
  index_type compile_pc_sometime(const index_set& f, const Name* n);
  index_type compile_pc_at_most_once(const index_set& f, const Name* n);
  index_type compile_pc_sometime_before(const index_set& f_t,
     const index_set& f_c,
     const Name* n);
  void enforce_pc_always(const index_set& f, const Name* n);
  void enforce_pc_sometime(const index_set& f, const Name* n);
  void enforce_pc_at_most_once(const index_set& f, const Name* n);
  void enforce_pc_sometime_before(const index_set& f_t,
      const index_set& f_c,
      const Name* n);
  void compute_iff_axioms(rule_set& ax);
  void cross_reference();
  void clear_cross_reference();
  bool cross_referenced() const;
  bool verify_invariant(Constraint& inv);
  void verify_invariants();
  void save_durations(cost_vec& out) const;
  void set_durations(const cost_vec& in);
  void set_durations(const cost_vec& in, cost_vec& out);
  void assign_unit_durations(hsps::rational unit = hsps::rational(1));
  void discretize_durations(hsps::rational interval_width);
  void quantize_durations(index_type n_intervals);
  void round_durations_up();
  void round_durations_down();
  void round_durations();
  void assign_unit_costs(cost_vec& save);
  void restore_costs(const cost_vec& saved);
  void assign_unlimited_resources(cost_vec& save);
  void restore_resources(const cost_vec& saved);
  index_type n_atoms() const { return atoms.length(); };
  index_type n_resources() const { return resources.length(); };
  index_type n_reusable_resources() const;
  index_type n_consumable_resources() const;
  index_type n_actions() const { return actions.length(); };
  index_type n_invariants() const { return invariants.length(); };
  index_type n_verified_invariants() const;
  void atom_names(name_vec& names) const;
  void action_names(name_vec& names) const;
  void coadd_graph(graph& g) const;
  void cochange_graph(graph& g) const;
  void causal_graph(graph& g) const;
  void partitioning_graph(const index_set& goal,
     index_set_graph& g,
     index_set& n_goal) const;
  void make_graph_representation(index_graph& g, name_vec& nn);
  bool non_interfering(index_type a0, index_type a1) const;
  bool lock_compatible(index_type a0, index_type a1) const;
  bool resource_compatible(index_type a0, index_type a1) const;
  bool commutative(const Action& a0, const Action& a1) const;
  bool commutative(index_type a0, index_type a1) const;
  bool additive(index_type p0, index_type p1) const;
  bool cochanged(index_type p0, index_type p1) const;
  bool eval_invariant_in_partial_state(const index_set& s,
           const Constraint& inv);
  bool eval_invariant_in_partial_state(const bool_vec& s,
           const Constraint& inv);
  bool eval_invariant_in_complete_state(const index_set& s,
     const Constraint& inv);
  bool eval_invariant_in_complete_state(const bool_vec& s,
     const Constraint& inv);
  void negation_atom_set(const index_set& pset, index_set& nset) const;
  void write_atom_set(::std::ostream& s,
        const index_vec& set,
        unsigned int c = Name::NC_DEFAULT) const;
  void write_atom_set(::std::ostream& s,
        const bool_vec& set,
        unsigned int c = Name::NC_DEFAULT) const;
  void write_atom_sets(::std::ostream& s,
         const index_set_vec& sets,
         unsigned int c = Name::NC_DEFAULT) const;
  void write_action_set(::std::ostream& s,
   const index_vec& set,
   unsigned int c = Name::NC_DEFAULT) const;
  void write_action_set(::std::ostream& s,
   const bool_vec& set,
   unsigned int c = Name::NC_DEFAULT) const;
  void write_iff_axiom(::std::ostream& s, const rule& r) const;
  void write_iff_axiom_set(::std::ostream& s, const rule_set& rset) const;
  void write_atom_digraph(::std::ostream& s,
     const graph& g,
     const index_set& atomset,
     const bool_vec& mark_shaded,
     const bool_vec& mark_dashed,
     const char* label) const;
  void write_atom_digraph(::std::ostream& s,
     const graph& g,
     const char* label) const;
  void write_atom_action_digraph(::std::ostream& s,
     const graph& g,
     const index_set& atomset,
     const index_set& actionset,
     const bool_vec& mark_shaded,
     const bool_vec& mark_bold,
     const bool_vec& mark_dashed,
     const char* label) const;
  void write_atom_set_digraph(::std::ostream& s,
         const index_set_graph& g,
         const char* label) const;
  void write_atom_set_graph(::std::ostream& s,
       const index_set_graph& g,
       const char* label) const;
  void write_axiom_dependency_graph(::std::ostream& s,
        const index_graph& g,
        const char* label) const;
  virtual void write_PDDL_action
    (::std::ostream& s, const Action& act) const;
  virtual void write_DKEL_invariant_item
    (::std::ostream& s, const Constraint& inv, string_set& tags) const;
  virtual void write_DKEL_irrelevant_atom_item
    (::std::ostream& s, const Atom& atm, string_set& tags) const;
  virtual void write_DKEL_irrelevant_action_item
    (::std::ostream& s, const Action& act, string_set& tags) const;
  virtual void write_domain_atom_set
    (::std::ostream& s, const index_set& set) const;
  virtual void write_domain_action_set
    (::std::ostream& s, const index_set& set) const;
  virtual void write_domain_action_set
    (::std::ostream& s, const index_set& set, const Name* name) const;
  virtual void write_domain(::std::ostream& s) const;
  virtual void write_domain_init(::std::ostream& s) const;
  virtual void write_domain_declarations(::std::ostream& s) const;
  virtual void write_domain_actions(::std::ostream& s) const;
  virtual void write_domain_DKEL_items(::std::ostream& s) const;
  virtual void write_problem(::std::ostream& s) const;
  virtual void write_problem_init(::std::ostream& s) const;
  virtual void write_problem_goal(::std::ostream& s) const;
  virtual void write_problem_metric(::std::ostream& s) const;
  void print_atom(::std::ostream& s, const Atom& a) const;
  void print_resource(::std::ostream& s, const Resource& r) const;
  void print_action(::std::ostream& s, const Action& a) const;
  void print_invariant(::std::ostream& s, const Constraint& c) const;
  virtual void print(::std::ostream& s) const;
 private:
  void create_atom_negation(index_type a);
};
typedef lvector<Instance*> instance_vec;
class PreconditionEvaluator {
  enum eval_node_type { positive_leaf,
   undecided_leaf,
   no_test,
   test_invariant,
   test_atom };
  Instance& instance;
  eval_node_type node_type;
  index_type i_test;
  lvector<PreconditionEvaluator*> next;
  PreconditionEvaluator* prev;
  index_type n_positive;
  index_set acts;
  static void construct(Instance& ins,
   PreconditionEvaluator* p,
   bool_vec& s,
   bool_vec& ua,
   index_type n_ua,
   index_type n_pos,
   bool_vec& rem_invs,
   bool_vec& rem_atoms,
   hsps::rational T);
 public:
  PreconditionEvaluator(Instance& ins);
  ~PreconditionEvaluator();
  static PreconditionEvaluator* construct(Instance& ins, hsps::rational T);
  PreconditionEvaluator* node(const bool_vec& s);
  index_type eval(const bool_vec& s,
    const bool_vec& a,
    index_type* app,
    index_type c);
  void write_graph(std::ostream& s, bool root = true);
};
inline ::std::ostream& operator<<(::std::ostream& s, const rule& r)
{
  return s << r.antecedent << "->" << r.consequent;
};
inline ::std::ostream& operator<<(::std::ostream& s, const rule_set& r)
{
  s << '{';
  for (index_type k = 0; k < r.length(); k++) {
    if (k > 0) s << ',';
    s << r[k];
  }
  s << '}';
  return s;
};
}
namespace hsps {
class Search;
class Plan;
class State {
 protected:
  State* pre;
 public:
  State() : pre(0) { };
  State(const State& s) : pre(s.pre) { };
  virtual ~State();
  virtual const State* predecessor() const;
  virtual State* predecessor();
  virtual void set_predecessor(State* p);
  virtual bool is_encapsulated();
  virtual hsps::rational delta_cost() = 0;
  virtual hsps::rational acc_cost();
  virtual index_type depth() const;
  virtual hsps::rational est_cost() = 0;
  virtual bool is_final() = 0;
  virtual bool is_max() = 0;
  virtual hsps::rational expand(Search& s, hsps::rational bound) = 0;
  virtual void store(hsps::rational cost, bool opt) = 0;
  virtual void reevaluate() = 0;
  virtual int compare(const State& s) = 0;
  virtual index_type hash() = 0;
  virtual State* copy() = 0;
  virtual void insert(Plan& p) = 0;
  virtual void insert_path(Plan& p) = 0;
  virtual void write(::std::ostream& s) = 0;
  virtual void write_plan(::std::ostream& s) = 0;
  virtual void write_eval(::std::ostream& s, char* p = 0, bool e = true);
  State* copy_path();
  void delete_path();
  int compare_path(const State* s);
  void write_path(::std::ostream& s);
  virtual void write_path_as_graph(::std::ostream& s);
};
inline bool operator==(State& s0, State& s1) {
  return (s0.compare(s1) == 0);
}
inline bool operator<(State& s0, State& s1) {
  return (s0.compare(s1) < 0);
}
inline bool operator<=(State& s0, State& s1) {
  return (s0.compare(s1) <= 0);
}
inline bool operator>(State& s0, State& s1) {
  return (s0.compare(s1) > 0);
}
inline bool operator>=(State& s0, State& s1) {
  return (s0.compare(s1) >= 0);
}
inline ::std::ostream& operator<<(::std::ostream& s, State& state) {
  state.write(s);
  return s;
}
class ProgressionState : public State {
 public:
  ProgressionState() { };
  ProgressionState(const ProgressionState& s) : State(s) { };
  virtual ~ProgressionState() { };
  virtual void insert_path(Plan& p);
};
class RegressionState : public State {
 public:
  RegressionState() { };
  RegressionState(const RegressionState& s) : State(s) { };
  virtual ~RegressionState() { };
  virtual void insert_path(Plan& p);
};
typedef lvector<State*> state_vec;
class PlanTrait {
 public:
  PlanTrait() { };
  virtual ~PlanTrait();
  virtual const PlanTrait* cast_to(const char* class_name) const;
};
typedef lvector<PlanTrait*> plan_trait_vec;
class Plan {
 public:
  virtual ~Plan();
  virtual void protect(index_type atom) = 0;
  virtual void insert(index_type act) = 0;
  virtual void advance(hsps::rational delta) = 0;
  virtual void end() = 0;
  virtual void output(Plan& to);
  virtual void set_name(const Name* n);
  virtual void set_optimal(bool o);
  virtual void add_trait(PlanTrait* t);
};
class Search {
 public:
  virtual ~Search();
  virtual hsps::rational new_state(State& s, hsps::rational bound) = 0;
  virtual bool solved() const = 0;
  virtual bool optimal() const = 0;
  virtual bool done() const = 0;
};
class NoSearch : public Search {
  bool _solved;
 public:
  NoSearch() : _solved(false) { };
  virtual ~NoSearch();
  void reset();
  virtual hsps::rational new_state(State& s, hsps::rational bound);
  virtual bool solved() const;
  virtual bool optimal() const;
  virtual bool done() const;
};
class Transitions : public state_vec, public Search {
  State* target_state;
  hsps::rational delta_bound;
  bool bound_is_exact;
 public:
  Transitions();
  Transitions(State* from, State* to, hsps::rational db);
  virtual ~Transitions();
  void clear();
  bool find(State* from, State* to, hsps::rational d, bool x);
  virtual hsps::rational new_state(State& s, hsps::rational bound);
  virtual bool solved() const;
  virtual bool optimal() const;
  virtual bool done() const;
};
class StateFactory {
 public:
  virtual ~StateFactory();
  virtual State* new_state(const index_set& s, State* pre) = 0;
  virtual State* new_state(const bool_vec& s, State* pre) = 0;
};
class PlanSet {
 public:
  virtual ~PlanSet();
  virtual Plan* new_plan() = 0;
  virtual void output(PlanSet& to);
  virtual void output(PlanSet& to, const bool_vec& s);
};
}
namespace hsps {
extern const double D_INF;
class Stopwatch {
  double start_t;
  double current_t;
  double total_t;
  static const double TIME_OUT_TOLERANCE = 1.1;
  static bool interrupt_signal_trapped;
  static volatile bool interrupt_signal_raised;
  static bool alarm_signal_trapped;
  static volatile bool alarm_signal_raised;
  bool interrupt_enabled;
  bool time_out_enabled;
  double time_out_t;
  bool memory_limit_enabled;
  unsigned long memory_limit;
  bool stack_limit_enabled;
  unsigned long stack_limit;
  static void alarm_handler(int sig);
  static void interrupt_handler(int sig);
  static void check_stack();
  void set_interrupt();
  void clear_interrupt();
  void set_alarm(double t);
  void clear_alarm();
  void check_signals();
  static unsigned long peak_mem;
  static unsigned long peak_size;
  static unsigned long peak_stack;
  static unsigned long init_stack;
 protected:
  bool interrupt_flag;
  bool time_out_flag;
  bool out_of_memory_flag;
  bool out_of_stack_flag;
  bool error_flag;
  count_type running;
  bool terminate_on_interrupt;
  bool terminate_on_time_out;
  bool terminate_on_out_of_memory;
  bool terminate_on_out_of_stack;
  bool terminate_on_error;
 public:
  static const long FLAG_INTERRUPTED = 1;
  static const long FLAG_TIME_OUT = 2;
  static const long FLAG_OUT_OF_MEMORY = 4;
  static const long FLAG_OUT_OF_STACK = 8;
  static const long FLAG_ERROR = 16;
  Stopwatch();
  ~Stopwatch();
  static double seconds();
  void enable_interrupt(bool terminate);
  void disable_interrupt();
  void enable_time_out(double t, bool terminate);
  void disable_time_out();
  void enable_memory_limit(unsigned long l, bool terminate);
  void disable_memory_limit();
  void enable_stack_limit(unsigned long l, bool terminate);
  void disable_stack_limit();
  void set_terminate_flags(bool on_interrupt,
      bool on_time_out,
      bool on_out_of_memory,
      bool on_out_of_stack,
      bool on_error);
  bool interrupt_raised();
  bool time_out_raised();
  bool out_of_memory_raised();
  bool out_of_stack_raised();
  bool error_raised();
  double remaining();
  bool break_signal_raised();
  virtual void interrupt();
  virtual void time_out();
  virtual void out_of_memory();
  virtual void out_of_stack();
  virtual void error();
  virtual void start();
  virtual void stop();
  virtual void reset();
  count_type run_level() { return running; };
  void add(Stopwatch& s);
  void add_total(Stopwatch& s);
  double time();
  double total_time();
  unsigned long peak_memory() const;
  unsigned long peak_total_size() const;
  unsigned long peak_stack_size() const;
  unsigned long flags();
  void print(::std::ostream& s);
};
class Statistics : public Stopwatch {
  count_type min_nodes_created;
  count_type max_nodes_created;
  count_type min_nodes_expanded;
  count_type max_nodes_expanded;
  count_type iterations_started;
  count_type iterations_finished;
  count_type total_min_nodes_created;
  count_type total_max_nodes_created;
  count_type total_min_nodes_expanded;
  count_type total_max_nodes_expanded;
  count_type total_iterations_started;
  count_type total_iterations_finished;
  index_type max_depth;
  hsps::rational max_lb;
  count_type nodes_to_prove_lb;
 public:
  static bool long_print_format;
  static bool running_print_max;
  Statistics()
    : min_nodes_created(0), max_nodes_created(0),
    min_nodes_expanded(0), max_nodes_expanded(0),
    iterations_started(0), iterations_finished(0),
    total_min_nodes_created(0), total_max_nodes_created(0),
    total_min_nodes_expanded(0), total_max_nodes_expanded(0),
    total_iterations_started(0), total_iterations_finished(0),
    max_depth(0), max_lb(0), nodes_to_prove_lb(0)
    { };
  void create_node(State& s);
  void expand_node(State& s);
  void current_lower_bound(hsps::rational b);
  void begin_iteration();
  void end_iteration();
  virtual void start();
  virtual void stop();
  virtual void reset();
  virtual void time_out();
  virtual void interrupt();
  virtual void out_of_memory();
  virtual void out_of_stack();
  void add(Statistics& s);
  void add_nodes(Statistics& s);
  void add_total(Statistics& s);
  void add_nodes_total(Statistics& s);
  double branching_factor() const {
    return ((min_nodes_created + max_nodes_created)/
     ((double)(min_nodes_expanded + max_nodes_expanded)));
  };
  count_type nodes() const {
    return (min_nodes_expanded + max_nodes_expanded);
  };
  count_type total_nodes() const {
    if (running)
      return (total_min_nodes_expanded + total_max_nodes_expanded +
       min_nodes_expanded + max_nodes_expanded);
    else
      return (total_min_nodes_expanded + total_max_nodes_expanded);
  };
  count_type total_min_nodes() const {
    if (running) return (total_min_nodes_expanded + min_nodes_expanded);
    else return total_min_nodes_expanded;
  };
  count_type total_max_nodes() const {
    if (running) return (total_max_nodes_expanded + max_nodes_expanded);
    else return total_max_nodes_expanded;
  };
  hsps::rational max_lower_bound() const {
    return max_lb;
  };
  count_type nodes_at_max_lower_bound() const {
    return nodes_to_prove_lb;
  };
  count_type iterations() {
    return iterations_started;
  };
  count_type complete_iterations() {
    return iterations_finished;
  };
  count_type total_iterations() {
    if (running) return iterations_started + total_iterations_started;
    else return total_iterations_started;
  };
  count_type total_complete_iterations() {
    if (running) return iterations_finished + total_iterations_finished;
    else return total_iterations_finished;
  };
  void print_brief(::std::ostream& s, const char* p = 0);
  void print(::std::ostream& s, const char* p = 0);
  void print_total(::std::ostream& s, const char* p = 0);
};
inline ::std::ostream& operator<<(::std::ostream& s, Stopwatch& t) {
  return s << t.total_time();
}
inline ::std::ostream& operator<<(::std::ostream& s, Statistics& t) {
  if (Statistics::long_print_format) {
    t.print_total(s);
    return s;
  }
  else {
    return s << t.total_nodes() << " nodes, "
      << t.total_time() << " seconds, "
      << t.peak_memory() << "k heap, "
      << t.peak_stack_size() << "k stack";
  }
}
}
namespace hsps {
class ACF {
 public:
  virtual ~ACF() { };
  virtual hsps::rational operator()(index_type a) const = 0;
  virtual hsps::rational min_cost(index_type n) const;
  virtual hsps::rational max_cost(index_type n) const;
  virtual hsps::rational avg_cost(index_type n) const;
  virtual hsps::rational cost_gcd(index_type n) const;
};
class Heuristic {
 protected:
  Instance& instance;
  int trace_level;
 public:
  static count_type eval_count;
  static int default_trace_level;
  Heuristic(Instance& ins)
    : instance(ins), trace_level(default_trace_level) { };
  virtual ~Heuristic();
  virtual void set_trace_level(int level);
  virtual hsps::rational eval(const index_set& s) = 0;
  virtual hsps::rational eval(const bool_vec& s) = 0;
  virtual void write_eval(const index_set& s,
     ::std::ostream& st,
     char* p = 0,
     bool e = true);
  virtual void write_eval(const bool_vec& s,
     ::std::ostream& st,
     char* p = 0,
     bool e = true);
  virtual hsps::rational eval_precondition(const Instance::Action& a);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
  virtual void store(const index_set& s, hsps::rational v, bool opt);
  virtual void store(const bool_vec& s, hsps::rational v, bool opt);
  hsps::rational eval(index_type atom);
  void compute_heuristic_graph(const ACF& cost, graph& g);
};
class ZeroHeuristic : public Heuristic {
 public:
  ZeroHeuristic(Instance& ins) : Heuristic(ins) { };
  virtual ~ZeroHeuristic() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
};
class EvalActionCache : public Heuristic {
  Heuristic& base_h;
  cost_vec cache;
 public:
  EvalActionCache(Instance& ins, Heuristic& h);
  virtual ~EvalActionCache() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational eval_precondition(const Instance::Action& a);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class RegressionInvariantCheck : public Heuristic {
  Heuristic& base_h;
  bool verified_invariants_only;
 public:
  RegressionInvariantCheck(Instance& ins, Heuristic& h, bool v)
    : Heuristic(ins), base_h(h), verified_invariants_only(v) { };
  virtual ~RegressionInvariantCheck() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class ForwardReachabilityCheck : public Heuristic {
  index_set goals;
  bool_vec r;
  bool_vec f;
  bool_vec d;
  hsps::rational compute();
 public:
  ForwardReachabilityCheck(Instance& i, const index_set& g);
  virtual ~ForwardReachabilityCheck();
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
};
class Combine2ByMax : public Heuristic {
  Heuristic& h0;
  Heuristic& h1;
 public:
  Combine2ByMax(Instance& ins, Heuristic& _h0, Heuristic& _h1)
    : Heuristic(ins), h0(_h0), h1(_h1) { };
  virtual ~Combine2ByMax() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class CombineNByMax : public Heuristic {
  lvector<Heuristic*> h_vec;
 public:
  CombineNByMax(Instance& ins)
    : Heuristic(ins), h_vec((Heuristic*)0, 0) { };
  virtual ~CombineNByMax() { };
  void add(Heuristic* h) { h_vec.append(h); };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class CombineNBySum : public Heuristic {
  lvector<Heuristic*> h_vec;
 public:
  CombineNBySum(Instance& ins)
    : Heuristic(ins), h_vec((Heuristic*)0, 0) { };
  virtual ~CombineNBySum() { };
  void add(Heuristic* h) { h_vec.append(h); };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class RoundUp : public Heuristic {
  Heuristic& h;
  long d;
 public:
  RoundUp(Instance& ins, Heuristic& h0)
    : Heuristic(ins), h(h0), d(1) { };
  RoundUp(Instance& ins, Heuristic& h0, long d0)
    : Heuristic(ins), h(h0), d(d0) { };
  virtual ~RoundUp() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual hsps::rational eval_to_bound(const index_set& s, hsps::rational bound);
  virtual hsps::rational eval_to_bound(const bool_vec& s, hsps::rational bound);
};
class HX : public Heuristic {
  Heuristic& h0;
  index_set X;
 public:
  HX(Instance& ins, Heuristic& h, const index_set& x)
    : Heuristic(ins), h0(h), X(x) { };
  HX(Instance& ins, Heuristic& h)
    : Heuristic(ins), h0(h) { };
  virtual ~HX() { };
  void setX(const index_set& x) { X = x; };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
  virtual void write_eval(const index_set& s,
     ::std::ostream& st,
     char* p = 0,
     bool e = true);
  virtual void write_eval(const bool_vec& s,
     ::std::ostream& st,
     char* p = 0,
     bool e = true);
};
class AtomMapAdapter : public Heuristic {
  index_vec map;
  Heuristic& base_h;
 public:
  AtomMapAdapter(Instance& i, const index_vec& m, Heuristic& h)
    : Heuristic(i), map(m), base_h(h)
  { assert(map.length() == instance.n_atoms()); };
  virtual ~AtomMapAdapter() { };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
  virtual hsps::rational incremental_eval(const index_set& s, index_type i_new);
  virtual hsps::rational incremental_eval(const bool_vec& s, index_type i_new);
};
class CompleteNegationAdapter : public Heuristic {
  Heuristic& h_base;
  pair_vec pn_map;
  bool_vec sc;
 public:
  CompleteNegationAdapter(Instance& ins, const pair_vec& p, Heuristic& h);
  virtual ~CompleteNegationAdapter();
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
};
class CompareEval : public Heuristic {
  Heuristic& base_h;
  Heuristic& alt_h;
  bool max_h_val;
 public:
  static count_type lower;
  static count_type equal;
  static count_type higher;
  CompareEval(Instance& i, Heuristic& h0, Heuristic& h1)
    : Heuristic(i), base_h(h0), alt_h(h1) { }
  virtual ~CompareEval() { };
  void set_maximal_heuristic_value(bool on) { max_h_val = on; };
  virtual hsps::rational eval(const index_set& s);
  virtual hsps::rational eval(const bool_vec& s);
};
class UnitACF : public ACF {
 public:
  UnitACF() { };
  virtual ~UnitACF() { };
  virtual hsps::rational operator()(index_type a) const;
  virtual hsps::rational min_cost(index_type n) const;
  virtual hsps::rational max_cost(index_type n) const;
  virtual hsps::rational avg_cost(index_type n) const;
};
class ZeroACF : public ACF {
 public:
  ZeroACF() { };
  virtual ~ZeroACF() { };
  virtual hsps::rational operator()(index_type a) const;
  virtual hsps::rational min_cost(index_type n) const;
  virtual hsps::rational max_cost(index_type n) const;
  virtual hsps::rational avg_cost(index_type n) const;
};
class CostACF : public ACF {
  Instance& instance;
 public:
  CostACF(Instance& i) : instance(i) { };
  virtual ~CostACF() { };
  virtual hsps::rational operator()(index_type a) const;
};
class FracACF : public ACF {
  const ACF& baseACF;
  cost_vec df;
 public:
  FracACF(const ACF& b, index_type l);
  FracACF(const ACF& b, index_type l, hsps::rational f);
  virtual ~FracACF();
  void set(index_type a, hsps::rational f);
  void set(const index_set& d, hsps::rational f);
  virtual hsps::rational operator()(index_type a) const;
};
class DiscountACF : public ACF {
  const ACF& baseACF;
  bool_vec discounted;
 public:
  DiscountACF(const ACF& b, index_type l)
    : baseACF(b), discounted(false, l) { };
  DiscountACF(const ACF& b, const index_set& d, index_type l)
    : baseACF(b), discounted(d, l) { };
  DiscountACF(const ACF& b, const bool_vec& d)
    : baseACF(b), discounted(d) { };
  virtual ~DiscountACF() { };
  void discount(index_type a) { discounted[a] = true; };
  void discount(const index_set& d) { discounted.insert(d); };
  void discount(const bool_vec& d) { discounted.insert(d); };
  void count(index_type a) { discounted[a] = false; };
  void count(const index_set& d) { discounted.subtract(d); };
  void count(const bool_vec& d) { discounted.subtract(d); };
  void count_only(const bool_vec& d);
  const bool_vec& discounted_actions() { return discounted; };
  virtual hsps::rational operator()(index_type a) const;
};
class MakespanACF : public ACF {
  Instance& instance;
 public:
  MakespanACF(Instance& i) : instance(i) { };
  virtual ~MakespanACF() { };
  virtual hsps::rational operator()(index_type a) const;
};
class ResourceConsACF : public ACF {
  Instance& instance;
  index_type resource_id;
 public:
  ResourceConsACF(Instance& i, index_type r);
  virtual ~ResourceConsACF() { };
  virtual hsps::rational operator()(index_type a) const;
};
class ResourceReqACF : public ACF {
  Instance& instance;
  index_type resource_id;
 public:
  ResourceReqACF(Instance& i, index_type r);
  virtual ~ResourceReqACF() { };
  virtual hsps::rational operator()(index_type a) const;
};
}
namespace hsps {
bool Instance::write_negation = true;
bool Instance::write_DKEL = true;
bool Instance::write_PDDL2 = true;
bool Instance::write_time = true;
bool Instance::write_PDDL3 = true;
bool Instance::write_metric = true;
bool Instance::write_extra = true;
bool Instance::write_resource_constraints_at_start = false;
bool Instance::always_write_parameters = false;
bool Instance::always_write_requirements = false;
bool Instance::always_write_precondition = false;
bool Instance::always_write_effect = false;
bool Instance::always_write_conjunction = false;
bool Instance::write_atom_set_with_symbolic_names = true;
bool Instance::write_action_set_with_symbolic_names = true;
int Instance::default_trace_level = 0;
const char* Instance::goal_atom_name = "GoalReached";
const char* Instance::goal_action_name = "GoalAction";
hsps::rational Instance::goal_action_cost = 0;
const char* Instance::pc_name = "constraint";
index_type Instance::pc_count = 0;
index_type rule_set::find_rule(index_type c) const
{
  for (index_type k = 0; k < length(); k++) {
    if ((*this)[k].consequent == c) return k;
    if ((*this)[k].consequent > c) return no_such_index;
  }
  return no_such_index;
}
void rule_set::compute_dependency_graph
(index_type n, index_graph& g) const
{
  g.init(n);
  for (index_type k = 0; k < length(); k++) {
    g.node_label((*this)[k].consequent) = (*this)[k].consequent;
    for (index_type i = 0; i < (*this)[k].antecedent.length(); i++) {
      g.add_edge((*this)[k].consequent, (*this)[k].antecedent[i]);
      g.edge_label((*this)[k].consequent, (*this)[k].antecedent[i]) = k;
      g.node_label((*this)[k].antecedent[i]) = (*this)[k].antecedent[i];
    }
  }
}
void rule_set::remove(const bool_vec& set, index_vec& map)
{
  index_type scan_p = 0;
  index_type put_p = 0;
  map.assign_value(no_such_index, length());
  while (scan_p < length()) {
    if (!set[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      map[scan_p] = put_p;
      put_p += 1;
    }
    scan_p += 1;
  }
  set_length(put_p);
}
void rule_set::remove(const bool_vec& set, index_graph& g)
{
  index_vec map;
  remove(set, map);
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j)) {
 if (map[g.edge_label(i, j)] == no_such_index) {
   g.remove_edge(i, j);
   g.edge_label(i, j) = no_such_index;
 }
 else {
   g.edge_label(i, j) = map[g.edge_label(i, j)];
 }
      }
}
void rule_set::remove(const bool_vec& set)
{
  index_vec map;
  remove(set, map);
}
void rule_set::make_acyclic(index_graph& dg)
{
  if (empty()) return;
  bool_vec keep(true, length());
  dg.strongly_connected_components();
  index_type c = dg.maximal_non_unit_component();
  while (c != no_such_index) {
    index_set rc;
    for (index_type k = 0; k < length(); k++) {
      const rule& r = (*this)[k];
      if (dg.component(r.consequent) == c) {
 bool f = false;
 for (index_type i = 0; (i < r.antecedent.length()) && !f; i++) {
   if (dg.component(r.antecedent[i]) == c) {
     f = true;
     rc.insert(k);
   }
 }
      }
    }
    assert(!rc.empty());
    index_type p = no_such_index;
    for (index_type k = 0; (k < rc.length()) && (p == no_such_index); k++) {
      const rule& r = (*this)[rc[k]];
      for (index_type i = 0; (i < length()) && (p == no_such_index); i++)
 if (!rc.contains(i) && ((*this)[i].consequent == r.consequent))
   p = rc[k];
    }
    for (index_type k = 0; (k < rc.length()) && (p == no_such_index); k++) {
      const rule& r = (*this)[rc[k]];
      for (index_type i = 0; (i < rc.length()) && (p == no_such_index); i++)
 if ((*this)[rc[i]].consequent == r.consequent) {
   if ((*this)[rc[i]].antecedent.length() < r.antecedent.length())
     p = rc[i];
   else
     p = rc[k];
 }
    }
    if (p == no_such_index) {
      p = rc[0];
      for (index_type k = 1; k < rc.length(); k++) {
 const rule& r = (*this)[rc[k]];
 if (r.antecedent.length() > (*this)[p].antecedent.length())
   p = rc[k];
      }
    }
    assert((p < length()) && keep[p]);
    dg.remove_edges_with_label(p);
    keep[p] = false;
    dg.strongly_connected_components();
    c = dg.maximal_non_unit_component();
  }
  if (keep.count(true) < length()) {
    keep.complement();
    remove(keep, dg);
  }
}
void rule_set::make_post_unique(index_graph& dg)
{
  if (empty()) return;
  bool_vec keep(true, length());
  for (index_type k = 0; k < length(); k++) if (keep[k]) {
    const rule& r = (*this)[k];
    index_set rsc;
    for (index_type i = k + 1; i < length(); i++)
      if ((*this)[i].consequent == r.consequent)
 rsc.insert(i);
    if (!rsc.empty()) {
      rsc.insert(k);
      index_type p = rsc[0];
      index_type s = dg.count_reachable((*this)[p].consequent);
      for (index_type i = 1; i < rsc.length(); i++) {
 index_type si = dg.count_reachable((*this)[rsc[i]].consequent);
 if (si < s) {
   p = rsc[i];
   s = si;
 }
      }
      assert(p < rsc.length());
      for (index_type i = 0; i < rsc.length(); i++)
 if (rsc[i] != p) keep[rsc[i]] = false;
    }
  }
  if (keep.count(true) < length()) {
    keep.complement();
    remove(keep, dg);
  }
}
bool Instance::Action::e_deletes(index_type p, Heuristic* inc) const
{
  if (del.contains(p)) return true;
  if (inc) {
    if ((inc->incremental_eval(pre, p)).infinite()) return true;
  }
  return false;
}
bool Instance::Action::e_deletes(const index_set& s, Heuristic* inc) const
{
  if (add.first_common_element(s) != no_such_index)
    return false;
  for (index_type k = 0; k < s.length(); k++)
    if (!e_deletes(s[k], inc)) return false;
  return true;
}
Instance::Instance()
  : xrf(false),
    name(0),
    atoms(Atom(), 0),
    actions(Action(), 0),
    resources(Resource(), 0),
    invariants(Constraint(), 0),
    init_atoms(),
    goal_atoms(),
    max_pre(0), max_add(0), max_del(0), max_lck(0),
    max_add_by(0), max_del_by(0), max_req_by(0),
    min_dur(POS_INF), max_dur(NEG_INF),
    min_cost(POS_INF), max_cost(NEG_INF),
    atom_set_hash(0), action_set_hash(0),
    trace_level(default_trace_level)
{
}
Instance::Instance(const Name* n)
  : xrf(false),
    name(n),
    atoms(Atom(), 0),
    actions(Action(), 0),
    resources(Resource(), 0),
    invariants(Constraint(), 0),
    init_atoms(),
    goal_atoms(),
    max_pre(0), max_add(0), max_del(0), max_lck(0),
    max_add_by(0), max_del_by(0), max_req_by(0),
    min_dur(POS_INF), max_dur(NEG_INF),
    min_cost(POS_INF), max_cost(NEG_INF),
    atom_set_hash(0), action_set_hash(0),
    trace_level(default_trace_level)
{
}
Instance::Instance(const Instance& ins)
  : xrf(false),
    name(ins.name),
    atoms(ins.atoms),
    actions(ins.actions),
    resources(ins.resources),
    invariants(ins.invariants),
    init_atoms(ins.init_atoms),
    goal_atoms(ins.goal_atoms),
    max_pre(0), max_add(0), max_del(0), max_lck(0),
    max_add_by(0), max_del_by(0), max_req_by(0),
    min_dur(POS_INF), max_dur(NEG_INF),
    min_cost(POS_INF), max_cost(NEG_INF),
    atom_set_hash(ins.n_atoms()),
    action_set_hash(ins.n_atoms()),
    trace_level(ins.trace_level)
{
}
Instance::Atom& Instance::new_atom(const Name* name)
{
  Atom& p = atoms.append();
  p.index = atoms.length() - 1;
  p.name = name;
  p.neg = no_such_index;
  p.init = false;
  p.init_t = 0;
  p.goal = false;
  p.goal_t = POS_INF;
  p.irrelevant = false;
  p.req_by.clear();
  p.add_by.clear();
  p.del_by.clear();
  if (trace_level > 2) {
    std::cerr << "atom " << p.index << "." << p.name
       << " created" << ::std::endl;
  }
  return p;
}
Instance::Resource& Instance::new_resource(const Name* name)
{
  Resource& r = resources.append();
  r.index = resources.length() - 1;
  r.name = name;
  r.init = 0;
  if (trace_level > 2) {
    std::cerr << "resouce " << r.index << "." << r.name
       << " created" << ::std::endl;
  }
  return r;
}
Instance::Action& Instance::new_action(const Name* name)
{
  Action& a = actions.append();
  a.index = actions.length() - 1;
  a.name = name;
  a.pre.clear();
  a.add.clear();
  a.del.clear();
  a.lck.clear();
  a.use.assign_value(0);
  a.cons.assign_value(0);
  a.dur = 1;
  a.cost = 1;
  a.ncw_atms.clear();
  if (trace_level > 2) {
    ::std::cerr << "action " << a.index << "." << a.name
       << " created" << ::std::endl;
  }
  return a;
}
Instance::Action& Instance::copy_action(index_type a1)
{
  Action& a = actions.append();
  a.index = actions.length() - 1;
  a.name = actions[a1].name;
  a.pre = actions[a1].pre;
  a.add = actions[a1].add;
  a.del = actions[a1].del;
  a.lck = actions[a1].lck;
  a.use = actions[a1].use;
  a.cons = actions[a1].cons;
  a.dur = actions[a1].dur;
  a.cost = actions[a1].cost;
  a.ncw_atms.clear();
  if (trace_level > 2) {
    ::std::cerr << "action " << a.index << "." << a.name
  << " created as copy of " << a1
  << ::std::endl;
  }
  return a;
}
Instance::Constraint& Instance::new_invariant()
{
  Constraint& c = invariants.append();
  c.index = invariants.length() - 1;
  c.name = 0;
  c.set.clear();
  c.lim = 0;
  c.exact = false;
  c.verified = false;
  if (trace_level > 2) {
    std::cerr << "invariant " << invariants.length() - 1
       << " created" << ::std::endl;
  }
  return c;
}
Instance::Constraint& Instance::new_invariant(const Name* name)
{
  Constraint& c = invariants.append();
  c.index = invariants.length() - 1;
  c.name = name;
  c.set.clear();
  c.lim = 0;
  c.exact = false;
  c.verified = false;
  if (trace_level > 2) {
    std::cerr << "invariant " << name << " (" << invariants.length() - 1
       << ") created" << ::std::endl;
  }
  return c;
}
Instance::Constraint& Instance::new_invariant
(const index_set& s, index_type l, bool e)
{
  for (index_type k = 0; k < invariants.length(); k++) {
    if ((invariants[k].lim == l) && (invariants[k].exact == e)) {
      if (invariants[k].set.contains(s)) {
 return invariants[k];
      }
      else if (s.contains(invariants[k].set)) {
 invariants[k].set = s;
 return invariants[k];
      }
    }
  }
  Constraint& c = new_invariant();
  c.set = s;
  c.lim = l;
  c.exact = e;
  c.verified = false;
  return c;
}
void Instance::atom_names(name_vec& names) const
{
  names.clear();
  for (index_type k = 0; k < n_atoms(); k++)
    names.append(atoms[k].name);
}
void Instance::action_names(name_vec& names) const
{
  names.clear();
  for (index_type k = 0; k < n_actions(); k++)
    names.append(actions[k].name);
}
void Instance::assign_unique_action_names()
{
  bool_vec cov(false, n_actions());
  for (index_type k = 0; k < n_actions(); k++) if (!cov[k]) {
    index_set s;
    for (index_type i = k; i < n_actions(); i++)
      if (actions[i].name->equals(actions[k].name)) {
 s.insert(i);
 cov[i] = true;
      }
    if (s.length() > 0) {
      const Name* b = actions[k].name;
      for (index_type i = 0; i < s.length(); i++)
 actions[s[i]].name = new CopyName(b, i);
    }
  }
}
void Instance::coadd_graph(graph& g) const
{
  g.init(n_atoms());
  for (index_type k = 0; k < n_actions(); k++) {
    for (index_type i = 0; i < actions[k].add.length(); i++)
      for (index_type j = i + 1; j < actions[k].add.length(); j++)
 g.add_undirected_edge(actions[k].add[i], actions[k].add[j]);
  }
}
void Instance::cochange_graph(graph& g) const
{
  g.init(n_atoms());
  for (index_type k = 0; k < n_actions(); k++) {
    for (index_type i = 0; i < actions[k].add.length(); i++)
      for (index_type j = i + 1; j < actions[k].add.length(); j++)
 g.add_undirected_edge(actions[k].add[i], actions[k].add[j]);
    for (index_type i = 0; i < actions[k].del.length(); i++)
      for (index_type j = i + 1; j < actions[k].del.length(); j++)
 g.add_undirected_edge(actions[k].del[i], actions[k].del[j]);
    for (index_type i = 0; i < actions[k].add.length(); i++)
      for (index_type j = 0; j < actions[k].del.length(); j++)
 g.add_undirected_edge(actions[k].add[i], actions[k].del[j]);
  }
}
void Instance::causal_graph(graph& g) const
{
  cochange_graph(g);
  for (index_type k = 0; k < n_actions(); k++) {
    for (index_type i = 0; i < actions[k].add.length(); i++)
      for (index_type j = 0; j < actions[k].pre.length(); j++)
 g.add_edge(actions[k].add[i], actions[k].pre[j]);
  }
}
void Instance::partitioning_graph
(const index_set& goal, index_set_graph& g, index_set& n_goal) const
{
  graph ccg;
  cochange_graph(ccg);
  equivalence eq(n_atoms());
  for (index_type i = 0; i < goal.length(); i++) {
    for (index_type j = i + 1; j < goal.length(); j++)
      if (ccg.adjacent(goal[i], goal[j]))
 eq.merge(goal[i], goal[j]);
    for (index_type k = 0; k < n_invariants(); k++)
      if ((invariants[k].lim == 1) &&
   invariants[k].set.contains(goal[i]) &&
   (invariants[k].exact)) {
 eq.merge(invariants[k].set);
      }
  }
  index_set_graph g_tmp(ccg, eq);
  g.copy(g_tmp);
  index_vec m;
  eq.make_map(m);
  n_goal.assign_remap(goal, m);
  bool done = false;
  index_type d = 1;
  while (!done) {
    done = true;
    eq.reset(g.size());
    for (index_type k = 0; k < n_goal.length(); k++) {
      for (index_type i = 0; i < g.bidirectional(n_goal[k]).length(); i++) {
 bool in_cfl = false;
 for (index_type j = 0; j < n_goal.length(); j++)
   if ((j != k) &&
       (g.bi_adjacent(g.bidirectional(n_goal[k])[i], n_goal[j]) ||
        g.bi_adjacent(g.bidirectional(n_goal[k])[i],
        g.bidirectional(n_goal[j]))))
     in_cfl = true;
 if (!in_cfl) {
   eq.merge(n_goal[k], g.bidirectional(n_goal[k])[i]);
   done = false;
 }
      }
    }
    g.quotient(g_tmp, eq);
    g.copy(g_tmp);
    eq.make_map(m);
    n_goal.remap(m);
  }
}
void Instance::make_graph_representation(index_graph& g, name_vec& nn)
{
  g.init(n_atoms() + n_actions());
  nn.assign_value(0, n_atoms() + n_actions());
  index_type o = n_atoms();
  for (index_type k = 0; k < n_atoms(); k++) {
    g.node_label(k) = (index_graph::NS_ELLIPSE +
         (atoms[k].init ? index_graph::NS_FILLED : 0) +
         (atoms[k].goal ? index_graph::NS_DOUBLE : 0));
    nn[k] = atoms[k].name;
  }
  for (index_type k = 0; k < n_actions(); k++) {
    g.node_label(o + k) = index_graph::NS_BOX;
    nn[o + k] = actions[k].name;
    for (index_type i = 0; i < actions[k].add.length(); i++) {
      g.add_edge(o + k, actions[k].add[i]);
      g.edge_label(o + k, actions[k].add[i]) =
 index_graph::ES_NORMAL + index_graph::ED_FORWARD;
    }
    for (index_type i = 0; i < actions[k].pre.length(); i++) {
      g.add_edge(actions[k].pre[i], o + k);
      if (actions[k].del.contains(actions[k].pre[i]))
 g.edge_label(actions[k].pre[i], o + k) =
   index_graph::ES_NORMAL + index_graph::ED_FORWARD;
      else
 g.edge_label(actions[k].pre[i], o + k) =
   index_graph::ES_DASHED + index_graph::ED_FORWARD;
    }
    for (index_type i = 0; i < actions[k].del.length(); i++)
      if (!actions[k].pre.contains(actions[k].del[i])) {
 g.add_edge(o + k, actions[k].del[i]);
 g.edge_label(o + k, actions[k].del[i]) =
   index_graph::ES_BOLD + index_graph::ED_NONE;
      }
  }
}
void Instance::copy(const Instance& ins)
{
  name = ins.name;
  atoms = ins.atoms;
  resources = ins.resources;
  actions = ins.actions;
  invariants = ins.invariants;
  xrf = false;
}
Instance* Instance::copy() const
{
  Instance* new_ins = new Instance();
  new_ins->copy(*this);
  return new_ins;
}
void Instance::clear()
{
  atoms.clear();
  actions.clear();
  resources.clear();
  invariants.clear();
  clear_cross_reference();
}
void Instance::restricted_copy
(const Instance& ins, const index_set& atms, const index_set& rc,
 index_set& acts, index_vec& map)
{
  clear();
  map.assign_value(no_such_index, ins.n_atoms());
  for (index_type k = 0; k < atms.length(); k++) {
    assert(atms[k] < ins.n_atoms());
    Atom& a = new_atom(ins.atoms[atms[k]].name);
    a.init = ins.atoms[atms[k]].init;
    a.goal = ins.atoms[atms[k]].goal;
    map[atms[k]] = a.index;
  }
  for (index_type k = 0; k < rc.length(); k++) {
    assert(rc[k] < ins.n_resources());
    Resource& r = new_resource(ins.resources[rc[k]].name);
    r.init = ins.resources[rc[k]].init;
  }
  acts.clear();
  for (index_type k = 0; k < ins.actions.length(); k++)
    if (ins.actions[k].add.count_common(atms) > 0) {
      Action& a = new_action(ins.actions[k].name);
      for (index_type i = 0; i < ins.actions[k].pre.length(); i++)
 if (map[ins.actions[k].pre[i]] != no_such_index)
   a.pre.insert(map[ins.actions[k].pre[i]]);
      for (index_type i = 0; i < ins.actions[k].add.length(); i++)
 if (map[ins.actions[k].add[i]] != no_such_index)
   a.add.insert(map[ins.actions[k].add[i]]);
      for (index_type i = 0; i < ins.actions[k].del.length(); i++)
 if (map[ins.actions[k].del[i]] != no_such_index)
   a.del.insert(map[ins.actions[k].del[i]]);
      for (index_type i = 0; i < ins.actions[k].lck.length(); i++)
 if (map[ins.actions[k].lck[i]] != no_such_index)
   a.lck.insert(map[ins.actions[k].lck[i]]);
      for (index_type i = 0; i < n_resources(); i++)
 a.use[i] = ins.actions[k].use[rc[i]];
      for (index_type i = 0; i < n_resources(); i++)
 a.cons[i] = ins.actions[k].cons[rc[i]];
      a.dur = ins.actions[k].dur;
      a.cost = ins.actions[k].cost;
      acts.insert(k);
    }
  for (index_type k = 0; k < ins.invariants.length(); k++)
    if (ins.invariants[k].set.count_common(atms) > ins.invariants[k].lim) {
      Constraint& c = new_invariant(ins.invariants[k].name);
      for (index_type i = 0; i < ins.invariants[k].set.length(); i++)
 if (map[ins.invariants[k].set[i]] != no_such_index)
   c.set.insert(map[ins.invariants[k].set[i]]);
      c.lim = ins.invariants[k].lim;
      c.exact = false;
      c.verified = false;
    }
}
void Instance::restricted_copy
(const Instance& ins, const index_set& acts, index_vec& map)
{
  clear();
  index_set atms;
  for (index_type k = 0; k < acts.length(); k++) {
    atms.insert(ins.actions[acts[k]].pre);
    atms.insert(ins.actions[acts[k]].add);
    atms.insert(ins.actions[acts[k]].del);
    atms.insert(ins.actions[acts[k]].lck);
  }
  map.assign_value(no_such_index, ins.n_atoms());
  for (index_type k = 0; k < atms.length(); k++) {
    Atom& a = new_atom(ins.atoms[atms[k]].name);
    a.init = ins.atoms[atms[k]].init;
    a.goal = ins.atoms[atms[k]].goal;
    map[atms[k]] = a.index;
  }
  for (index_type k = 0; k < acts.length(); k++) {
    Action& a = new_action(ins.actions[acts[k]].name);
    for (index_type i = 0; i < ins.actions[acts[k]].pre.length(); i++)
      a.pre.insert(map[ins.actions[acts[k]].pre[i]]);
    for (index_type i = 0; i < ins.actions[acts[k]].add.length(); i++)
      a.add.insert(map[ins.actions[acts[k]].add[i]]);
    for (index_type i = 0; i < ins.actions[acts[k]].del.length(); i++)
      a.del.insert(map[ins.actions[acts[k]].del[i]]);
    for (index_type i = 0; i < ins.actions[acts[k]].lck.length(); i++)
      a.lck.insert(map[ins.actions[acts[k]].lck[i]]);
    a.dur = ins.actions[acts[k]].dur;
    a.cost = ins.actions[acts[k]].cost;
  }
  for (index_type k = 0; k < ins.invariants.length(); k++)
    if (ins.invariants[k].set.count_common(atms) > ins.invariants[k].lim) {
      Constraint& c = new_invariant(ins.invariants[k].name);
      for (index_type i = 0; i < ins.invariants[k].set.length(); i++)
 if (map[ins.invariants[k].set[i]] != no_such_index)
   c.set.insert(map[ins.invariants[k].set[i]]);
      c.lim = ins.invariants[k].lim;
      c.exact = false;
      c.verified = false;
    }
}
void Instance::abstracted_copy
(const Instance& ins, const index_set& atms, index_vec& atm_map,
 index_vec& act_map)
{
  clear();
  atm_map.assign_value(no_such_index, ins.n_atoms());
  for (index_type k = 0; k < atms.length(); k++) {
    assert(atms[k] < ins.n_atoms());
    Atom& a = new_atom(ins.atoms[atms[k]].name);
    a.init = ins.atoms[atms[k]].init;
    a.goal = ins.atoms[atms[k]].goal;
    atm_map[atms[k]] = a.index;
  }
  act_map.assign_value(no_such_index, ins.n_actions());
  for (index_type k = 0; k < ins.actions.length(); k++) {
    if (ins.actions[k].add.count_common(atms) > 0) {
      index_set pre;
      index_set add;
      index_set del;
      index_set lck;
      for (index_type i = 0; i < ins.actions[k].pre.length(); i++)
 if (atm_map[ins.actions[k].pre[i]] != no_such_index)
   pre.insert(atm_map[ins.actions[k].pre[i]]);
      for (index_type i = 0; i < ins.actions[k].add.length(); i++)
 if (atm_map[ins.actions[k].add[i]] != no_such_index)
   add.insert(atm_map[ins.actions[k].add[i]]);
      for (index_type i = 0; i < ins.actions[k].del.length(); i++)
 if (atm_map[ins.actions[k].del[i]] != no_such_index)
   del.insert(atm_map[ins.actions[k].del[i]]);
      for (index_type i = 0; i < ins.actions[k].lck.length(); i++)
 if (atm_map[ins.actions[k].lck[i]] != no_such_index)
   lck.insert(atm_map[ins.actions[k].lck[i]]);
      bool found = false;
      for (index_type i = 0; (i < n_actions()) && !found; i++) {
 if ((actions[i].pre == pre) && (actions[i].add == add) &&
     (actions[i].del == del) && (actions[i].lck == lck)) {
   actions[i].dur = hsps::rational::min(actions[i].dur,ins.actions[k].dur);
   actions[i].cost = hsps::rational::min(actions[i].cost,ins.actions[k].cost);
   act_map[k] = i;
   found = true;
 }
      }
      if (!found) {
 Action& a = new_action(ins.actions[k].name);
 a.pre = pre;
 a.add = add;
 a.del = del;
 a.lck = lck;
 a.dur = ins.actions[k].dur;
 a.cost = ins.actions[k].cost;
 act_map[k] = a.index;
      }
    }
    else {
      act_map[k] = no_such_index;
    }
  }
  for (index_type k = 0; k < ins.invariants.length(); k++) {
    index_set s;
    for (index_type i = 0; i < ins.invariants[k].set.length(); i++)
      if (atm_map[ins.invariants[k].set[i]] != no_such_index)
 s.insert(atm_map[ins.invariants[k].set[i]]);
    if (s.length() > ins.invariants[k].lim) {
      Constraint& c = new_invariant(s, ins.invariants[k].lim, false);
      if (!c.name && ins.invariants[k].name)
 c.name = ins.invariants[k].name;
      c.verified = false;
    }
  }
}
void Instance::reverse_copy(const Instance& ins)
{
  clear();
  for (index_type k = 0; k < ins.n_atoms(); k++) {
    assert(ins.atoms[k].neg != no_such_index);
    Atom& a = new_atom(ins.atoms[k].name);
    if (ins.atoms[ins.atoms[k].neg].goal)
      a.init = false;
    else
      a.init = true;
    a.goal = ins.atoms[k].init;
  }
  for (index_type k = 0; k < ins.n_actions(); k++) {
    index_set per_pre(ins.actions[k].pre);
    per_pre.subtract(ins.actions[k].del);
    index_set del_pre(ins.actions[k].pre);
    del_pre.intersect(ins.actions[k].del);
    Action& a = new_action(ins.actions[k].name);
    a.pre = ins.actions[k].add;
    a.pre.insert(per_pre);
    ins.negation_atom_set(ins.actions[k].del, a.pre);
    a.add = del_pre;
    ins.negation_atom_set(ins.actions[k].pre, a.del);
    for (index_type i = 0; i < ins.actions[k].add.length(); i++)
      if (!ins.actions[k].pre.contains(ins.actions[k].add[i]) &&
   !ins.actions[k].pre.contains(ins.atoms[ins.actions[k].add[i]].neg)) {
 a.add.insert(ins.actions[k].add[i]);
 a.add.insert(ins.atoms[ins.actions[k].add[i]].neg);
      }
    for (index_type i = 0; i < ins.actions[k].del.length(); i++)
      if (!ins.actions[k].pre.contains(ins.actions[k].del[i]) &&
   !ins.actions[k].pre.contains(ins.atoms[ins.actions[k].del[i]].neg)) {
 a.add.insert(ins.actions[k].del[i]);
 a.add.insert(ins.atoms[ins.actions[k].del[i]].neg);
      }
    a.lck = ins.actions[k].lck;
    a.cost = ins.actions[k].cost;
    a.dmin = ins.actions[k].dmin;
    a.dmax = ins.actions[k].dmax;
    a.dur = ins.actions[k].dur;
    a.assoc = ins.actions[k].assoc;
    a.src = ins.actions[k].src;
  }
}
void Instance::delete_relax(const index_set& x_atms)
{
  for (index_type k = 0; k < n_actions(); k++)
    actions[k].del.intersect(x_atms);
}
void Instance::delete_relax_less(const index_set& x_atms)
{
  for (index_type k = 0; k < n_actions(); k++)
    if (actions[k].del.first_common_element(x_atms) == no_such_index)
      actions[k].del.clear();
}
bool Instance::non_interfering(index_type a0, index_type a1) const
{
  for (index_type k = 0; k < actions[a0].del.length(); k++) {
    if (actions[a1].pre.contains(actions[a0].del[k])) {
      if (trace_level > 3) {
 ::std::cerr << actions[a0].name << " deletes "
    << atoms[actions[a0].del[k]].name
    << " precondition of "
    << actions[a1].name << ::std::endl;
      }
      return false;
    }
    if (actions[a1].add.contains(actions[a0].del[k])) {
      if (trace_level > 3) {
 ::std::cerr << actions[a0].name << " deletes "
    << atoms[actions[a0].del[k]].name
    << " added by "
    << actions[a1].name << ::std::endl;
      }
      return false;
    }
  }
  for (index_type k = 0; k < actions[a1].del.length(); k++) {
    if (actions[a0].pre.contains(actions[a1].del[k])) {
      if (trace_level > 3) {
 ::std::cerr << actions[a1].name << " deletes "
    << atoms[actions[a1].del[k]].name
    << " precondition of "
    << actions[a0].name << ::std::endl;
      }
      return false;
    }
    if (actions[a0].add.contains(actions[a1].del[k])) {
      if (trace_level > 3) {
 ::std::cerr << actions[a1].name << " deletes "
    << atoms[actions[a1].del[k]].name
    << " added by "
    << actions[a0].name << ::std::endl;
      }
      return false;
    }
  }
  return true;
}
bool Instance::lock_compatible(index_type a0, index_type a1) const
{
  for (index_type k = 0; k < actions[a0].lck.length(); k++) {
    if (actions[a1].lck.contains(actions[a0].lck[k])) {
      if (trace_level > 3) {
 ::std::cerr << actions[a0].name << " and "
    << actions[a1].name << " both require "
    << atoms[actions[a0].lck[k]].name << ::std::endl;
      }
      return false;
    }
    else if (actions[a1].del.contains(actions[a0].lck[k])) {
      if (trace_level > 3) {
 ::std::cerr << actions[a1].name << " deletes "
    << atoms[actions[a0].lck[k]].name << " locked by "
    << actions[a0].name << ::std::endl;
      }
      return false;
    }
    else if (actions[a1].pre.contains(actions[a0].lck[k])) {
      if (trace_level > 3) {
 ::std::cerr << actions[a0].name << " locks "
    << atoms[actions[a0].lck[k]].name
    << " persistent precondition of "
    << actions[a1].name << ::std::endl;
      }
      return false;
    }
  }
  for (index_type k = 0; k < actions[a1].lck.length(); k++) {
    if (actions[a0].del.contains(actions[a1].lck[k])) {
      if (trace_level > 3) {
 ::std::cerr << actions[a0].name << " deletes "
    << atoms[actions[a1].lck[k]].name << " locked by "
    << actions[a1].name << ::std::endl;
      }
      return false;
    }
    else if (actions[a0].pre.contains(actions[a1].lck[k])) {
      if (trace_level > 3) {
 ::std::cerr << actions[a1].name << " locks "
    << atoms[actions[a1].lck[k]].name
    << " persistent precondition of "
    << actions[a0].name << ::std::endl;
      }
      return false;
    }
  }
  return true;
}
bool Instance::resource_compatible(index_type a0, index_type a1) const
{
  for (index_type k = 0; k < n_resources(); k++) {
    hsps::rational sum = actions[a0].use[k] + actions[a1].use[k];
    if (sum > resources[k].init) return false;
  }
  return true;
}
bool Instance::commutative
(const Instance::Action& a0, const Instance::Action& a1) const
{
  for (index_type k = 0; k < a0.del.length(); k++) {
    if (a1.pre.contains(a0.del[k])) {
      if (trace_level > 3) {
 ::std::cerr << a0.name << " deletes "
    << atoms[a0.del[k]].name
    << " precondition of "
    << a1.name << ::std::endl;
      }
      return false;
    }
    if (a1.add.contains(a0.del[k])) {
      if (trace_level > 3) {
 ::std::cerr << a0.name << " deletes "
    << atoms[a0.del[k]].name
    << " added by "
    << a1.name << ::std::endl;
      }
      return false;
    }
  }
  for (index_type k = 0; k < a0.add.length(); k++) {
    if (a1.pre.contains(a0.add[k])) {
      if (trace_level > 3) {
 ::std::cerr << a0.name << " adds "
    << atoms[a0.add[k]].name
    << " precondition of "
    << a1.name << ::std::endl;
      }
      return false;
    }
  }
  for (index_type k = 0; k < a1.del.length(); k++) {
    if (a0.pre.contains(a1.del[k])) {
      if (trace_level > 3) {
 ::std::cerr << a1.name << " deletes "
    << atoms[a1.del[k]].name
    << " precondition of "
    << a0.name << ::std::endl;
      }
      return false;
    }
    if (a0.add.contains(a1.del[k])) {
      if (trace_level > 3) {
 ::std::cerr << a1.name << " deletes "
    << atoms[a1.del[k]].name
    << " added by "
    << a0.name << ::std::endl;
      }
      return false;
    }
  }
  for (index_type k = 0; k < a1.add.length(); k++) {
    if (a0.pre.contains(a1.add[k])) {
      if (trace_level > 3) {
 ::std::cerr << a1.name << " adds "
    << atoms[a1.add[k]].name
    << " precondition of "
    << a0.name << ::std::endl;
      }
      return false;
    }
  }
  return true;
}
bool Instance::commutative(index_type a0, index_type a1) const
{
  return commutative(actions[a0], actions[a1]);
}
bool Instance::additive(index_type p0, index_type p1) const
{
  for (index_type k = 0; k < n_actions(); k++) {
    if (actions[k].add.contains(p0) &&
 actions[k].add.contains(p1))
      return false;
  }
  return true;
}
bool Instance::cochanged(index_type p0, index_type p1) const
{
  for (index_type k = 0; k < n_actions(); k++) {
    if (actions[k].add.contains(p0)) {
      if (actions[k].add.contains(p1))
 return true;
      if (actions[k].del.contains(p1))
 return true;
    }
    else if (actions[k].del.contains(p0)) {
      if (actions[k].add.contains(p1))
 return true;
      if (actions[k].del.contains(p1))
 return true;
    }
  }
  return false;
}
bool Instance::eval_invariant_in_partial_state
(const index_set& s, const Instance::Constraint& inv)
{
  index_type n = 0;
  for (index_type i = 0; (i < inv.set.length()) && (n <= inv.lim); i++)
    if (s.contains(inv.set[i])) n += 1;
  if (n > inv.lim) {
    if (trace_level > 2) {
      ::std::cerr << "state ";
      write_atom_set(::std::cerr, s);
      ::std::cerr << " violates invariant " << '|';
      write_atom_set(::std::cerr, inv.set);
      ::std::cerr << "| <= " << inv.lim << ::std::endl;
    }
    return false;
  }
  else {
    return true;
  }
}
bool Instance::eval_invariant_in_partial_state
(const bool_vec& s, const Instance::Constraint& inv)
{
  index_type n = 0;
  for (index_type i = 0; (i < inv.set.length()) && (n <= inv.lim); i++)
    if (s[inv.set[i]]) n += 1;
  if (n > inv.lim) {
    if (trace_level > 2) {
      ::std::cerr << "state ";
      write_atom_set(::std::cerr, s);
      ::std::cerr << " violates invariant " << '|';
      write_atom_set(::std::cerr, inv.set);
      ::std::cerr << "| <= " << inv.lim << ::std::endl;
    }
    return false;
  }
  else {
    return true;
  }
}
bool Instance::eval_invariant_in_complete_state
(const index_set& s, const Instance::Constraint& inv)
{
  index_type n = 0;
  for (index_type i = 0; (i < inv.set.length()) && (n <= inv.lim); i++)
    if (s.contains(inv.set[i])) n += 1;
  if (n > inv.lim) {
    if (trace_level > 2) {
      ::std::cerr << "state ";
      write_atom_set(::std::cerr, s);
      ::std::cerr << " violates invariant " << '|';
      write_atom_set(::std::cerr, inv.set);
      ::std::cerr << "| <= " << inv.lim << ::std::endl;
    }
    return false;
  }
  else if ((n < inv.lim) && inv.exact) {
    if (trace_level > 2) {
      ::std::cerr << "state ";
      write_atom_set(::std::cerr, s);
      ::std::cerr << " violates invariant " << '|';
      write_atom_set(::std::cerr, inv.set);
      ::std::cerr << "| == " << inv.lim << ::std::endl;
    }
    return false;
  }
  else {
    return true;
  }
}
bool Instance::eval_invariant_in_complete_state
(const bool_vec& s, const Instance::Constraint& inv)
{
  index_type n = 0;
  for (index_type i = 0; (i < inv.set.length()) && (n <= inv.lim); i++)
    if (s[inv.set[i]]) n += 1;
  if (n > inv.lim) {
    if (trace_level > 2) {
      ::std::cerr << "state ";
      write_atom_set(::std::cerr, s);
      ::std::cerr << " violates invariant " << '|';
      write_atom_set(::std::cerr, inv.set);
      ::std::cerr << "| <= " << inv.lim << ::std::endl;
    }
    return false;
  }
  else if ((n < inv.lim) && inv.exact) {
    if (trace_level > 2) {
      ::std::cerr << "state ";
      write_atom_set(::std::cerr, s);
      ::std::cerr << " violates invariant " << '|';
      write_atom_set(::std::cerr, inv.set);
      ::std::cerr << "| == " << inv.lim << ::std::endl;
    }
    return false;
  }
  else {
    return true;
  }
}
void Instance::negation_atom_set(const index_set& pset, index_set& nset) const
{
  for (index_type k = 0; k < pset.length(); k++)
    if (atoms[pset[k]].neg != no_such_index)
      nset.insert(atoms[pset[k]].neg);
}
bool Instance::verify_invariant(Instance::Constraint& inv)
{
  if (!cross_referenced()) cross_reference();
  if (trace_level > 1) {
    ::std::cerr << "verifying invariant |";
    write_atom_set(::std::cerr, inv.set);
    ::std::cerr << "| " << (inv.exact ? "==" : "<=") << " " << inv.lim
       << "..." << ::std::endl;
  }
  index_type init_n = init_atoms.count_common(inv.set);
  if (init_n > inv.lim) {
    if (trace_level > 2) {
      ::std::cerr << " - violated by initial state" << ::std::endl;
    }
    return false;
  }
  else if (init_n < inv.lim) {
    if (trace_level > 2) {
      ::std::cerr << " - not exact in initial state" << ::std::endl;
    }
    return false;
  }
  for (index_type k = 0; k < n_actions(); k++) {
    index_type n_pre = actions[k].pre.count_common(inv.set);
    if (n_pre <= inv.lim) {
      index_type n_add = actions[k].add.count_common(inv.set);
      index_type n_del = actions[k].del.count_common(inv.set);
      if (n_add > n_del) {
 if (trace_level > 2) {
   ::std::cerr << " - violated by action "
      << actions[k].name << ::std::endl;
 }
 return false;
      }
      if (n_add < n_del) {
 if (trace_level > 2) {
   ::std::cerr << " - not exact by action "
      << actions[k].name << ::std::endl;
 }
 return false;
      }
    }
  }
  if (!inv.exact) {
    if (trace_level > 2) {
      ::std::cerr << " - is in fact exact: strengthening" << ::std::endl;
    }
    inv.exact = true;
  }
  else if (trace_level > 2) {
    ::std::cerr << " - ok" << ::std::endl;
  }
  return true;
}
void Instance::verify_invariants()
{
  if (trace_level > 0) {
    ::std::cerr << "verifying invariants (instance only)..." << ::std::endl;
  }
  for (index_type k = 0; k < n_invariants(); k++)
    invariants[k].verified = verify_invariant(invariants[k]);
}
index_type Instance::n_verified_invariants() const
{
  index_type n = 0;
  for (index_type k = 0; k < n_invariants(); k++)
    if (invariants[k].verified) n += 1;
  return n;
}
void Instance::cross_reference()
{
  if (xrf) return;
  for (index_type k = 0; k < actions.length(); k++) {
    Action& act = actions[k];
    for (index_type i = 0; i < act.pre.length(); i++)
      atoms[act.pre[i]].req_by.append(k);
    for (index_type i = 0; i < act.add.length(); i++)
      atoms[act.add[i]].add_by.append(k);
    for (index_type i = 0; i < act.del.length(); i++)
      atoms[act.del[i]].del_by.append(k);
    for (index_type i = 0; i < n_resources(); i++) {
      if (act.use[i] > 0) resources[i].used = true;
      if (act.cons[i] > 0) resources[i].consumed = true;
    }
    if (act.pre.length() > max_pre) max_pre = act.pre.length();
    if (act.add.length() > max_add) max_add = act.add.length();
    if (act.del.length() > max_del) max_del = act.del.length();
    if (act.lck.length() > max_lck) max_lck = act.lck.length();
    if (act.dur < min_dur) min_dur = act.dur;
    if (act.dur > max_dur) max_dur = act.dur;
    if (act.cost < min_cost) min_cost = act.cost;
    if (act.cost > max_cost) max_cost = act.cost;
  }
  init_atoms.clear();
  goal_atoms.clear();
  for (index_type k = 0; k < atoms.length(); k++) {
    Atom& prop = atoms[k];
    if (prop.req_by.length() > max_req_by)
      max_req_by = prop.req_by.length();
    if (prop.add_by.length() > max_add_by)
      max_add_by = prop.add_by.length();
    if (prop.del_by.length() > max_del_by)
      max_del_by = prop.del_by.length();
    if (prop.init) init_atoms.insert(k);
    if (prop.goal) goal_atoms.insert(k);
  }
  xrf = true;
  atom_set_hash.init(n_atoms());
  action_set_hash.init(n_actions());
}
void Instance::remap_set(index_set& set, const index_vec& map)
{
  index_type scan_p = 0;
  index_type put_p = 0;
  while (scan_p < set.length()) {
    if (map[set[scan_p]] != no_such_index) {
      set[put_p] = map[set[scan_p]];
      put_p += 1;
    }
    scan_p += 1;
  }
  set.set_length(put_p);
}
void Instance::remap_sets(index_set_vec& sets, const index_vec& map)
{
  for (index_type k = 0; k < sets.length(); k++)
    remap_set(sets[k], map);
}
void Instance::remove_actions(const bool_vec& set, index_vec& map)
{
  assert(set.length() >= actions.length());
  index_type scan_p = 0;
  index_type put_p = 0;
  index_vec rm_map(no_such_index, actions.length());
  while (scan_p < actions.length()) {
    if (!set[scan_p]) {
      if (put_p < scan_p) {
 actions[put_p] = actions[scan_p];
 actions[put_p].index = put_p;
      }
      rm_map[scan_p] = put_p;
      put_p += 1;
    }
    else {
      rm_map[scan_p] = no_such_index;
    }
    scan_p += 1;
  }
  actions.set_length(put_p);
  for (index_type k = 0; k < map.length(); k++)
    if (map[k] != no_such_index) {
      assert(map[k] < rm_map.length());
      map[k] = rm_map[map[k]];
    }
}
void Instance::remove_atoms(const bool_vec& set, index_vec& map)
{
  index_type scan_p = 0;
  index_type put_p = 0;
  index_vec rm_map(no_such_index, atoms.length());
  while (scan_p < atoms.length()) {
    if (!set[scan_p]) {
      if (put_p < scan_p) {
 atoms[put_p] = atoms[scan_p];
 atoms[put_p].index = put_p;
      }
      rm_map[scan_p] = put_p;
      put_p += 1;
    }
    else {
      rm_map[scan_p] = no_such_index;
    }
    scan_p += 1;
  }
  atoms.set_length(put_p);
  for (index_type k = 0; k < atoms.length(); k++) {
    if (atoms[k].neg != no_such_index)
      atoms[k].neg = rm_map[atoms[k].neg];
  }
  for (index_type k = 0; k < actions.length(); k++) {
    remap_set(actions[k].pre, rm_map);
    remap_set(actions[k].add, rm_map);
    remap_set(actions[k].del, rm_map);
    remap_set(actions[k].lck, rm_map);
  }
  for (index_type k = 0; k < invariants.length(); k++) {
    remap_set(invariants[k].set, rm_map);
  }
  for (index_type k = 0; k < map.length(); k++)
    if (map[k] != no_such_index) {
      assert(map[k] < rm_map.length());
      map[k] = rm_map[map[k]];
    }
}
void Instance::remove_invariants(const bool_vec& set, index_vec& map)
{
  index_type scan_p = 0;
  index_type put_p = 0;
  index_vec rm_map(no_such_index, invariants.length());
  while (scan_p < invariants.length()) {
    if (!set[scan_p]) {
      if (put_p < scan_p) {
 invariants[put_p] = invariants[scan_p];
 invariants[put_p].index = put_p;
      }
      rm_map[scan_p] = put_p;
      put_p += 1;
    }
    else {
      rm_map[scan_p] = no_such_index;
    }
    scan_p += 1;
  }
  invariants.set_length(put_p);
  for (index_type k = 0; k < map.length(); k++)
    if (map[k] != no_such_index) {
      assert(map[k] < rm_map.length());
      map[k] = rm_map[map[k]];
    }
}
void Instance::set_initial(const index_set& init)
{
  for (index_type k = 0; k < n_atoms(); k++) atoms[k].init = false;
  for (index_type k = 0; k < init.length(); k++) atoms[init[k]].init = true;
  init_atoms = init;
}
void Instance::set_goal(const index_set& goal)
{
  for (index_type k = 0; k < n_atoms(); k++) {
    atoms[k].goal = false;
    atoms[k].irrelevant = false;
  }
  for (index_type k = 0; k < goal.length(); k++) atoms[goal[k]].goal = true;
  goal_atoms = goal;
}
void Instance::set_DNF_goal(const index_set_vec& goal)
{
  for (index_type k = 0; k < n_atoms(); k++) {
    atoms[k].goal = false;
    atoms[k].irrelevant = false;
  }
  Atom& g_atom = new_atom(new StringName(goal_atom_name));
  g_atom.goal = true;
  for (index_type k = 0; k < goal.length(); k++) {
    Action& g_act = new_action(new EnumName(goal_action_name, k));
    g_act.pre = goal[k];
    g_act.add.assign_singleton(g_atom.index);
    g_act.cost = goal_action_cost;
    g_act.dmin = goal_action_cost;
    g_act.dmax = goal_action_cost;
    g_act.dur = goal_action_cost;
  }
  clear_cross_reference();
}
void Instance::replace_atom_by_conjunction(index_type p, const index_set& c)
{
  assert(p < n_atoms());
  for (index_type k = 0; k < n_actions(); k++) {
    if (actions[k].pre.contains(p))
      actions[k].pre.insert(c);
  }
  if (atoms[p].goal) {
    for (index_type k = 0; k < c.length(); k++)
      atoms[c[k]].goal = true;
  }
}
void Instance::set_cost_bound(hsps::rational b)
{
  Resource& r = new_resource(new StringName("_bcost"));
  for (index_type k = 0; k < n_actions(); k++)
    actions[k].cons[r.index] = actions[k].cost;
  r.init = b;
}
void Instance::create_composite_resource(const index_set& set)
{
  ConcatenatedName* cn = new ConcatenatedName();
  for (index_type r = 0; r < set.length(); r++) {
    assert(set[r] < n_resources());
    cn->append(resources[set[r]].name);
  }
  Resource& cr = new_resource(cn);
  for (index_type r = 0; r < set.length(); r++) {
    cr.init += resources[set[r]].init;
  }
  for (index_type k = 0; k < n_actions(); k++) {
    hsps::rational cu = 0;
    hsps::rational cc = 0;
    for (index_type r = 0; r < set.length(); r++) {
      cu += actions[k].use[set[r]];
      cc += actions[k].cons[set[r]];
    }
    actions[k].use[cr.index] = cu;
    actions[k].cons[cr.index] = cc;
    if (cu > 0) resources[cr.index].used = true;
    if (cc > 0) resources[cr.index].consumed = true;
  }
}
void Instance::create_total_resource()
{
  index_set s;
  s.fill(n_resources());
  create_composite_resource(s);
}
void Instance::add_all_negation_invariants()
{
  index_type n_new = 0;
  for (index_type k = 0; k < n_atoms(); k++) {
    if (atoms[k].neg != no_such_index) {
      Constraint& c = new_invariant();
      c.set.insert(k);
      c.set.insert(atoms[k].neg);
      c.lim = 1;
      c.exact = true;
      n_new += 1;
    }
  }
  if (trace_level > 0) {
    ::std::cerr << n_new << " negation invariants added" << ::std::endl;
  }
}
void Instance::add_missing_negation_invariants()
{
  bool_vec a(false, n_atoms());
  for (index_type k = 0; k < n_invariants(); k++)
    for (index_type i = 0; i < invariants[k].set.length(); i++)
      a[invariants[k].set[i]] = true;
  if (trace_level > 0) {
    ::std::cerr << a.count(true) << " of " << n_atoms()
       << " atoms part of some invariant..." << ::std::endl;
  }
  index_type n_new = 0;
  for (index_type k = 0; k < n_atoms(); k++) if (!a[k]) {
    if (atoms[k].neg != no_such_index) {
      Constraint& c = new_invariant();
      c.set.insert(k);
      c.set.insert(atoms[k].neg);
      c.lim = 1;
      c.exact = true;
      a[k] = true;
      a[atoms[k].neg] = true;
      n_new += 1;
    }
  }
  if (trace_level > 0) {
    ::std::cerr << n_new << " negation invariants added" << ::std::endl;
  }
}
void Instance::create_atom_negation(index_type a)
{
  Atom& not_a = new_atom(new ModName(atoms[a].name, "neg-of"));
  not_a.init = !atoms[a].init;
  not_a.neg = atoms[a].index;
  atoms[a].neg = not_a.index;
  for (index_type k = 0; k < n_actions(); k++) {
    if (actions[k].add.contains(a)) actions[k].del.insert(not_a.index);
    if (actions[k].del.contains(a)) actions[k].add.insert(not_a.index);
  }
}
index_type Instance::complete_atom_negation(index_type a)
{
  assert(a < atoms.length());
  if (atoms[a].neg == no_such_index) {
    create_atom_negation(a);
    clear_cross_reference();
  }
  assert(atoms[a].neg != no_such_index);
  return atoms[a].neg;
}
void Instance::complete_atom_negations(const index_set& s)
{
  index_type n = n_atoms();
  for (index_type k = 0; k < s.length(); k++)
    if (atoms[s[k]].neg == no_such_index)
      create_atom_negation(s[k]);
  if (n_atoms() > n)
    clear_cross_reference();
}
void Instance::complete_atom_negations()
{
  index_type n = n_atoms();
  for (index_type k = 0; k < n; k++)
    if (atoms[k].neg == no_such_index)
      create_atom_negation(k);
  if (n_atoms() > n)
    clear_cross_reference();
}
void Instance::extract_atom_negations_from_invariants()
{
  for (index_type k = 0; k < n_invariants(); k++)
    if ((invariants[k].set.length() == 2) &&
 (invariants[k].lim == 1) &&
 invariants[k].exact) {
      index_type p = invariants[k].set[0];
      index_type q = invariants[k].set[1];
      assert(p < n_atoms());
      assert(q < n_atoms());
      if ((atoms[p].neg == no_such_index) &&
   (atoms[q].neg == no_such_index)) {
 atoms[p].neg = q;
 atoms[q].neg = p;
      }
    }
}
void Instance::compute_iff_axioms(rule_set& ax)
{
  extract_atom_negations_from_invariants();
  for (index_type k = 0; k < n_invariants(); k++)
    if ((invariants[k].lim == 1) && invariants[k].exact) {
      index_set n_set;
      index_type p0 = no_such_index;
      bool ok = true;
      for (index_type i = 0; (i < invariants[k].set.length()) && ok; i++) {
 index_type p = invariants[k].set[i];
 if ((atoms[p].neg != no_such_index) &&
     !invariants[k].set.contains(atoms[p].neg)) {
   n_set.insert(atoms[p].neg);
 }
 else if (p0 == no_such_index) {
   p0 = p;
 }
 else {
   ok = false;
 }
      }
      if (ok && (n_set.length() == invariants[k].set.length())) {
 for (index_type i = 0; i < invariants[k].set.length(); i++) {
   rule r(n_set, invariants[k].set[i]);
   assert(r.antecedent.contains(atoms[r.consequent].neg));
   r.antecedent.subtract(atoms[r.consequent].neg);
   ax.insert(r);
 }
      }
      if (ok && (n_set.length() == (invariants[k].set.length() - 1))) {
 assert(p0 < n_atoms());
 rule r(n_set, p0);
 ax.insert(r);
      }
    }
}
index_type Instance::create_history_atom(index_type a)
{
  Atom& ha = new_atom(new ModName(atoms[a].name, "reached"));
  ha.init = atoms[a].init;
  for (index_type k = 0; k < n_actions(); k++)
    if (actions[k].add.contains(a)) actions[k].add.insert(ha.index);
  return ha.index;
}
index_type Instance::compile_pc_always(const index_set& f, const Name* n)
{
  if (!n) n = new EnumName(pc_name, pc_count++);
  if (trace_level > 2) {
    ::std::cerr << "compiling " << n << ": always ";
    write_atom_set(std::cerr, f);
    std::cerr << "..." << ::std::endl;
  }
  Atom& a_ok = new_atom(new ModName(n, "ok"));
  a_ok.init = true;
  a_ok.goal = true;
  for (index_type k = 0; (k < f.length()) && a_ok.init; k++)
    if (!atoms[f[k]].init) a_ok.init = false;
  if (a_ok.init) {
    for (index_type k = 0; k < n_actions(); k++)
      if (actions[k].del.first_common_element(f) != no_such_index)
 actions[k].del.insert(a_ok.index);
  }
  clear_cross_reference();
  return a_ok.index;
}
index_type Instance::compile_pc_sometime(const index_set& f, const Name* n)
{
  if (!n) n = new EnumName(pc_name, pc_count++);
  if (trace_level > 2) {
    ::std::cerr << "compiling " << n << ": sometime ";
    write_atom_set(std::cerr, f);
    std::cerr << "..." << ::std::endl;
  }
  Atom& a_ok = new_atom(new ModName(n, "ok"));
  a_ok.init = true;
  a_ok.goal = true;
  for (index_type k = 0; (k < f.length()) && a_ok.init; k++)
    if (!atoms[f[k]].init) a_ok.init = false;
  if (!a_ok.init) {
    index_type n_act = n_actions();
    for (index_type k = 0; k < n_act; k++)
      if ((actions[k].add.first_common_element(f) != no_such_index) &&
   (actions[k].del.first_common_element(f) == no_such_index)) {
 index_set c(f);
 c.subtract(actions[k].add);
 if (c.empty()) {
   actions[k].add.insert(a_ok.index);
 }
 else {
   Action& a2 = copy_action(k);
   a2.pre.insert(c);
   a2.add.insert(a_ok.index);
 }
      }
  }
  clear_cross_reference();
  return a_ok.index;
}
index_type Instance::compile_pc_at_most_once(const index_set& f, const Name* n)
{
  if (!n) n = new EnumName(pc_name, pc_count++);
  if (trace_level > 2) {
    ::std::cerr << "compiling " << n << ": at-most-once ";
    write_atom_set(std::cerr, f);
    std::cerr << "..." << ::std::endl;
  }
  Atom& a_ok = new_atom(new ModName(n, "ok"));
  a_ok.init = true;
  a_ok.goal = true;
  Atom& a_once = new_atom(new ModName(n, "once"));
  a_once.init = false;
  a_once.goal = false;
  index_set m;
  for (index_type k = 0; k < n_actions(); k++) {
    if (actions[k].del.first_common_element(f) != no_such_index) {
      index_set c(f);
      c.subtract(actions[k].pre);
      m.insert(c);
    }
    if ((actions[k].add.first_common_element(f) != no_such_index) &&
 (actions[k].del.first_common_element(f) == no_such_index)) {
      index_set c(f);
      c.subtract(actions[k].add);
      m.insert(c);
    }
  }
  complete_atom_negations(m);
  index_type n_act = n_actions();
  for (index_type k = 0; k < n_act; k++)
    if (actions[k].del.first_common_element(f) != no_such_index) {
      index_set c(f);
      c.subtract(actions[k].pre);
      if (c.empty()) {
 actions[k].add.insert(a_once.index);
      }
      else {
 for (index_type i = 0; i < c.length(); i++) {
   assert(atoms[c[i]].neg != no_such_index);
   Action& a2 = copy_action(k);
   a2.pre.insert(atoms[c[i]].neg);
 }
 actions[k].pre.insert(c);
 actions[k].add.insert(a_once.index);
      }
    }
  index_type a_not_once = complete_atom_negation(a_once.index);
  n_act = n_actions();
  for (index_type k = 0; k < n_act; k++)
    if ((actions[k].add.first_common_element(f) != no_such_index) &&
 (actions[k].del.first_common_element(f) == no_such_index)) {
      index_set c(f);
      c.subtract(actions[k].add);
      if (c.empty()) {
 Action& a2 = copy_action(k);
 actions[k].pre.insert(a_not_once);
 a2.pre.insert(a_once.index);
 a2.del.insert(a_ok.index);
      }
      else {
 for (index_type i = 0; i < c.length(); i++) {
   assert(atoms[c[i]].neg != no_such_index);
   Action& a2 = copy_action(k);
   a2.pre.insert(atoms[c[i]].neg);
 }
 Action& a3 = copy_action(k);
 a3.pre.insert(c);
 a3.pre.insert(a_once.index);
 a3.del.insert(a_ok.index);
 actions[k].pre.insert(c);
 actions[k].pre.insert(a_not_once);
      }
    }
  clear_cross_reference();
  return a_ok.index;
}
index_type Instance::compile_pc_sometime_before
(const index_set& f_t, const index_set& f_c, const Name* n)
{
  if (!n) n = new EnumName(pc_name, pc_count++);
  if (trace_level > 2) {
    ::std::cerr << "compiling " << n << ": sometime-before ";
    write_atom_set(std::cerr, f_t);
    ::std::cerr << " ";
    write_atom_set(std::cerr, f_c);
    std::cerr << "..." << ::std::endl;
  }
  Atom& a_safe = new_atom(new ModName(n, "safe"));
  a_safe.init = true;
  for (index_type k = 0; k < f_c.length(); k++)
    if (!atoms[f_c[k]].init) a_safe.init = false;
  a_safe.goal = false;
  Atom& a_ok = new_atom(new ModName(n, "ok"));
  a_ok.init = false;
  for (index_type k = 0; k < f_t.length(); k++)
    if (!atoms[f_t[k]].init) a_ok.init = true;
  a_ok.goal = true;
  if (a_ok.init && !a_safe.init) {
    index_set m;
    for (index_type k = 0; k < n_actions(); k++) {
      if ((actions[k].add.first_common_element(f_t) != no_such_index) &&
   (actions[k].del.first_common_element(f_t) == no_such_index)) {
 index_set c(f_t);
 c.subtract(actions[k].add);
 m.insert(c);
      }
    }
    if (trace_level > 2) {
      ::std::cerr << "completing negations of ";
      write_atom_set(std::cerr, m);
      std::cerr << "..." << ::std::endl;
    }
    complete_atom_negations(m);
    index_type n_act = n_actions();
    for (index_type k = 0; k < n_act; k++)
      if ((actions[k].add.first_common_element(f_c) != no_such_index) &&
   (actions[k].del.first_common_element(f_c) == no_such_index)) {
 index_set c(f_c);
 c.subtract(actions[k].add);
 if (c.empty()) {
   actions[k].add.insert(a_safe.index);
   if (trace_level > 2) {
     std::cerr << "case 1: atom " << a_safe.index << "." << a_safe.name
        << " add by " << k << "." << actions[k].name
        << std::endl;
   }
 }
 else {
   Action& a2 = copy_action(k);
   a2.pre.insert(c);
   a2.add.insert(a_safe.index);
   if (trace_level > 2) {
     std::cerr << "case 2: atoms " << c << " pre of "
        << a2.index << "." << a2.name
        << std::endl;
     std::cerr << "case 2: atom " << a_safe.index << "." << a_safe.name
        << " add by " << a2.index << "." << a2.name
        << std::endl;
   }
 }
      }
    n_act = n_actions();
    for (index_type k = 0; k < n_act; k++)
      if ((actions[k].add.first_common_element(f_t) != no_such_index) &&
   (actions[k].del.first_common_element(f_t) == no_such_index)) {
 index_set c(f_t);
 c.subtract(actions[k].add);
 if (c.empty()) {
   Action& a2 = copy_action(k);
   a2.del.insert(a_ok.index);
   if (trace_level > 2) {
     std::cerr << "case 3: atom " << a_ok.index << "." << a_ok.name
        << " del by " << a2.index << "." << a2.name
        << std::endl;
   }
   actions[k].pre.insert(a_safe.index);
   if (trace_level > 2) {
     std::cerr << "case 4: atom " << a_safe.index << "." << a_safe.name
        << " pre of " << k << "." << actions[k].name
        << std::endl;
   }
 }
 else {
   for (index_type i = 0; i < c.length(); i++) {
     assert(atoms[c[i]].neg != no_such_index);
     Action& a2 = copy_action(k);
     a2.pre.insert(atoms[c[i]].neg);
     if (trace_level > 2) {
       std::cerr << "case 5: atom " << atoms[c[i]].neg
   << " pre of " << a2.index << "." << a2.name
   << std::endl;
     }
   }
   Action& a3 = copy_action(k);
   a3.del.insert(a_ok.index);
   if (trace_level > 2) {
     std::cerr << "case 6: atom " << a_ok.index << "." << a_ok.name
        << " del by " << a3.index << "." << a3.name
        << std::endl;
   }
   actions[k].pre.insert(a_safe.index);
   if (trace_level > 2) {
     std::cerr << "case 7: atom " << a_safe.index << "." << a_safe.name
        << " pre of " << k << "." << actions[k].name
        << std::endl;
   }
 }
      }
  }
  clear_cross_reference();
  return a_ok.index;
}
void Instance::enforce_pc_always(const index_set& f, const Name* n)
{
  if (trace_level > 2) {
    ::std::cerr << "enforcing ";
    if (n) std::cerr << n << ": ";
    std::cerr << "always ";
    write_atom_set(std::cerr, f);
    std::cerr << "..." << ::std::endl;
  }
  bool_vec d(false, n_actions());
  for (index_type k = 0; k < n_actions(); k++)
    if (actions[k].del.first_common_element(f) != no_such_index)
      d[k] = true;
  actions.remove(d);
  clear_cross_reference();
}
void Instance::enforce_pc_sometime(const index_set& f, const Name* n)
{
  if (trace_level > 2) {
    ::std::cerr << "enforcing ";
    if (n) std::cerr << n << ": ";
    std::cerr << "sometime ";
    write_atom_set(std::cerr, f);
    std::cerr << "..." << ::std::endl;
  }
  index_type g = compile_pc_sometime(f, n);
  atoms[g].goal = true;
  clear_cross_reference();
}
void Instance::enforce_pc_at_most_once(const index_set& f, const Name* n)
{
  if (!n) n = new EnumName(pc_name, pc_count++);
  if (trace_level > 2) {
    ::std::cerr << "enforcing " << n << ": at-most-once ";
    write_atom_set(std::cerr, f);
    std::cerr << "..." << ::std::endl;
  }
  index_type a_first = new_atom(new ModName(n, "first")).index;
  atoms[a_first].init = true;
  atoms[a_first].goal = false;
  index_set m;
  for (index_type k = 0; k < n_actions(); k++) {
    if (actions[k].del.first_common_element(f) != no_such_index) {
      index_set c(f);
      c.subtract(actions[k].pre);
      m.insert(c);
    }
    if ((actions[k].add.first_common_element(f) != no_such_index) &&
 (actions[k].del.first_common_element(f) == no_such_index)) {
      index_set c(f);
      c.subtract(actions[k].add);
      m.insert(c);
    }
  }
  complete_atom_negations(m);
  index_type n_act = n_actions();
  for (index_type k = 0; k < n_act; k++)
    if (actions[k].del.first_common_element(f) != no_such_index) {
      index_set c(f);
      c.subtract(actions[k].pre);
      if (c.empty()) {
 actions[k].del.insert(a_first);
      }
      else {
 for (index_type i = 0; i < c.length(); i++) {
   assert(atoms[c[i]].neg != no_such_index);
   Action& a2 = copy_action(k);
   a2.pre.insert(atoms[c[i]].neg);
 }
 actions[k].pre.insert(c);
 actions[k].del.insert(a_first);
      }
    }
  n_act = n_actions();
  for (index_type k = 0; k < n_act; k++)
    if ((actions[k].add.first_common_element(f) != no_such_index) &&
 (actions[k].del.first_common_element(f) == no_such_index)) {
      index_set c(f);
      c.subtract(actions[k].add);
      if (c.empty()) {
 actions[k].pre.insert(a_first);
      }
      else {
 for (index_type i = 0; i < c.length(); i++) {
   assert(atoms[c[i]].neg != no_such_index);
   Action& a2 = copy_action(k);
   a2.pre.insert(atoms[c[i]].neg);
 }
 actions[k].pre.insert(c);
 actions[k].pre.insert(a_first);
      }
    }
  clear_cross_reference();
}
void Instance::enforce_pc_sometime_before
(const index_set& f_t, const index_set& f_c, const Name* n)
{
  if (!n) n = new EnumName(pc_name, pc_count++);
  if (trace_level > 2) {
    ::std::cerr << "compiling " << n << ": sometime-before ";
    write_atom_set(std::cerr, f_t);
    ::std::cerr << " ";
    write_atom_set(std::cerr, f_c);
    std::cerr << "..." << ::std::endl;
  }
  bool is_safe = true;
  for (index_type k = 0; k < f_c.length(); k++)
    if (!atoms[f_c[k]].init) is_safe = false;
  if (!is_safe) {
    index_type a_safe = new_atom(new ModName(n, "safe")).index;
    atoms[a_safe].init = false;
    atoms[a_safe].goal = false;
    index_set m;
    for (index_type k = 0; k < n_actions(); k++) {
      if ((actions[k].add.first_common_element(f_t) != no_such_index) &&
   (actions[k].del.first_common_element(f_t) == no_such_index)) {
 index_set c(f_t);
 c.subtract(actions[k].add);
 m.insert(c);
      }
    }
    if (trace_level > 2) {
      ::std::cerr << "completing negations of ";
      write_atom_set(std::cerr, m);
      std::cerr << "..." << ::std::endl;
    }
    complete_atom_negations(m);
    index_type n_act = n_actions();
    for (index_type k = 0; k < n_act; k++)
      if ((actions[k].add.first_common_element(f_c) != no_such_index) &&
   (actions[k].del.first_common_element(f_c) == no_such_index)) {
 index_set c(f_c);
 c.subtract(actions[k].add);
 c.subtract(actions[k].pre);
 if (c.empty()) {
   actions[k].add.insert(a_safe);
 }
 else {
   Action& a2 = copy_action(k);
   a2.pre.insert(c);
   a2.add.insert(a_safe);
 }
      }
    n_act = n_actions();
    for (index_type k = 0; k < n_act; k++)
      if ((actions[k].add.first_common_element(f_t) != no_such_index) &&
   (actions[k].del.first_common_element(f_t) == no_such_index)) {
 index_set c(f_t);
 c.subtract(actions[k].add);
 if (c.empty()) {
   actions[k].pre.insert(a_safe);
 }
 else {
   for (index_type i = 0; i < c.length(); i++) {
     assert(atoms[c[i]].neg != no_such_index);
     Action& a2 = copy_action(k);
     a2.pre.insert(atoms[c[i]].neg);
   }
   actions[k].pre.insert(a_safe);
 }
      }
  }
  clear_cross_reference();
}
void Instance::clear_cross_reference()
{
  max_pre = 0;
  max_add = 0;
  max_del = 0;
  max_lck = 0;
  max_req_by = 0;
  max_add_by = 0;
  max_del_by = 0;
  min_dur = POS_INF;
  max_dur = NEG_INF;
  min_cost = POS_INF;
  max_cost = NEG_INF;
  for (index_type k = 0; k < atoms.length(); k++) {
    atoms[k].req_by.clear();
    atoms[k].add_by.clear();
    atoms[k].del_by.clear();
  }
  init_atoms.clear();
  goal_atoms.clear();
  for (index_type k = 0; k < actions.length(); k++)
    actions[k].ncw_atms.clear();
  for (index_type k = 0; k < resources.length(); k++) {
    resources[k].used = false;
    resources[k].consumed = false;
  }
  xrf = false;
}
bool Instance::cross_referenced() const
{
  return xrf;
}
void Instance::save_durations(cost_vec& out) const
{
  out.assign_value(0, n_actions());
  for (index_type k = 0; k < n_actions(); k++)
    out[k] = actions[k].dur;
}
void Instance::set_durations(const cost_vec& in)
{
  for (index_type k = 0; k < n_actions(); k++)
    actions[k].dur = in[k];
}
void Instance::set_durations(const cost_vec& in, cost_vec& out)
{
  out.assign_value(0, n_actions());
  for (index_type k = 0; k < n_actions(); k++) {
    out[k] = actions[k].dur;
    actions[k].dur = in[k];
  }
}
void Instance::assign_unit_durations(hsps::rational unit)
{
  for (index_type k = 0; k < n_actions(); k++)
    actions[k].dur = unit;
  min_dur = unit;
  max_dur = unit;
}
void Instance::discretize_durations(hsps::rational interval_width)
{
  min_dur = POS_INF;
  max_dur = NEG_INF;
  for (index_type k = 0; k < n_actions(); k++) {
    hsps::rational d = (actions[k].dur / interval_width);
    if (!(d).integral()) d = (d).floor() + 1;
    actions[k].dur = d*interval_width;
    min_dur = hsps::rational::min(min_dur,actions[k].dur);
    max_dur = hsps::rational::max(max_dur,actions[k].dur);
  }
}
void Instance::quantize_durations(index_type n_intervals)
{
  max_dur = NEG_INF;
  for (index_type k = 0; k < n_actions(); k++)
    max_dur = hsps::rational::max(max_dur,actions[k].dur);
  hsps::rational w = max_dur / n_intervals;
  min_dur = POS_INF;
  max_dur = NEG_INF;
  for (index_type k = 0; k < n_actions(); k++) {
    hsps::rational d = (actions[k].dur / w);
    if (!(d).integral()) d = (d).floor() + 1;
    actions[k].dur = d*w;
    min_dur = hsps::rational::min(min_dur,actions[k].dur);
    max_dur = hsps::rational::max(max_dur,actions[k].dur);
  }
}
void Instance::round_durations_up()
{
  min_dur = POS_INF;
  max_dur = NEG_INF;
  for (index_type k = 0; k < n_actions(); k++) {
    if (!(actions[k].dur).integral()) {
      actions[k].dur = (actions[k].dur).floor() + 1;
    }
    min_dur = hsps::rational::min(min_dur,actions[k].dur);
    max_dur = hsps::rational::max(max_dur,actions[k].dur);
  }
}
void Instance::round_durations_down()
{
  min_dur = POS_INF;
  max_dur = NEG_INF;
  for (index_type k = 0; k < n_actions(); k++) {
    actions[k].dur = (actions[k].dur).floor();
    min_dur = hsps::rational::min(min_dur,actions[k].dur);
    max_dur = hsps::rational::max(max_dur,actions[k].dur);
  }
}
void Instance::round_durations()
{
  min_dur = POS_INF;
  max_dur = NEG_INF;
  for (index_type k = 0; k < n_actions(); k++) {
    if ((actions[k].dur).frac() > (hsps::rational(1,2).reduce())) {
      actions[k].dur = (actions[k].dur).floor() + 1;
    }
    else {
      actions[k].dur = (actions[k].dur).floor();
    }
    min_dur = hsps::rational::min(min_dur,actions[k].dur);
    max_dur = hsps::rational::max(max_dur,actions[k].dur);
  }
}
void Instance::assign_unit_costs(cost_vec& save)
{
  save.assign_value(0, n_actions());
  for (index_type k = 0; k < n_actions(); k++) {
    save[k] = actions[k].cost;
    actions[k].cost = 1;
  }
  min_cost = 1;
  max_cost = 1;
}
void Instance::restore_costs(const cost_vec& saved)
{
  for (index_type k = 0; k < n_actions(); k++) {
    actions[k].dur = saved[k];
  }
}
void Instance::assign_unlimited_resources(cost_vec& save)
{
  save.assign_value(0, n_resources());
  for (index_type k = 0; k < n_resources(); k++) {
    save[k] = resources[k].init;
    resources[k].init = POS_INF;
  }
}
void Instance::restore_resources(const cost_vec& saved)
{
  for (index_type k = 0; k < n_resources(); k++)
    resources[k].init = saved[k];
}
index_type Instance::n_reusable_resources() const
{
  index_type n = 0;
  for (index_type k = 0; k < n_resources(); k++)
    if (resources[k].used && !resources[k].consumed) n += 1;
  return n;
}
index_type Instance::n_consumable_resources() const
{
  index_type n = 0;
  for (index_type k = 0; k < n_resources(); k++)
    if (resources[k].consumed) n += 1;
  return n;
}
void Instance::write_atom_set
(::std::ostream& s, const index_vec& set, unsigned int c) const
{
  s << '{';
  for (index_type k = 0; k < set.length(); k++) {
    if (k > 0) s << ',';
    if (write_atom_set_with_symbolic_names)
      atoms[set[k]].name->write(s, c);
    else
      s << set[k];
  }
  s << '}';
}
void Instance::write_atom_set
(::std::ostream& s, const bool_vec& set, unsigned int c) const
{
  s << '{';
  bool need_comma = false;
  for (index_type k = 0; k < n_atoms(); k++) if (set[k]) {
    if (need_comma) s << ',';
    if (write_atom_set_with_symbolic_names)
      atoms[k].name->write(s, c);
    else
      s << k;
    need_comma = true;
  }
  s << '}';
}
void Instance::write_atom_sets
(::std::ostream& s, const index_set_vec& sets, unsigned int c) const
{
  s << '{';
  for (index_type k = 0; k < sets.length(); k++) {
    if (k > 0) s << ',';
    write_atom_set(s, sets[k], c);
  }
  s << '}';
}
void Instance::write_action_set
(::std::ostream& s, const index_vec& set, unsigned int c) const
{
  s << '{';
  for (index_type k = 0; k < set.length(); k++) {
    if (k > 0) s << ',';
    if (write_action_set_with_symbolic_names)
      actions[set[k]].name->write(s, c);
    else
      s << set[k];
  }
  s << '}';
}
void Instance::write_action_set
(::std::ostream& s, const bool_vec& set, unsigned int c) const
{
  s << '{';
  bool need_comma = false;
  for (index_type k = 0; k < n_actions(); k++) if (set[k]) {
    if (need_comma) s << ',';
    if (write_action_set_with_symbolic_names)
      actions[k].name->write(s, c);
    else
      s << k;
    need_comma = true;
  }
  s << '}';
}
void Instance::write_iff_axiom
(::std::ostream& s, const rule& r) const
{
  s << atoms[r.consequent].name << " <-> (";
  for (index_type k = 0; k < r.antecedent.length(); k++) {
    if (k > 0) s << " & ";
    s << atoms[r.antecedent[k]].name;
  }
  s << ")";
}
void Instance::write_iff_axiom_set
(::std::ostream& s, const rule_set& rset) const
{
  s << '{';
  for (index_type k = 0; k < rset.length(); k++) {
    if (k > 0) s << ", ";
    s << k << ": ";
    write_iff_axiom(s, rset[k]);
  }
  s << '}';
}
void Instance::write_atom_digraph
(::std::ostream& s,
 const graph& g,
 const index_set& atomset,
 const bool_vec& mark_shaded,
 const bool_vec& mark_dashed,
 const char* label) const
{
  s << "digraph ADG {" << ::std::endl;
  s << "label=\"" << label << "\";" << ::std::endl;
  s << "node [width=0,height=0];" << ::std::endl;
  for (index_type k = 0; k < atomset.length(); k++) {
    s << "A" << k << " [";
    if (mark_shaded[atomset[k]]) {
      s << "style=filled,";
    }
    if (mark_dashed[atomset[k]]) {
      s << "style=dashed,";
    }
    s << "label=\"" << atoms[atomset[k]].name << "\"];"
      << ::std::endl;
  }
  for (index_type i = 0; i < atomset.length(); i++)
    for (index_type j = 0; j < atomset.length(); j++)
      if (g.adjacent(i, j)) {
 s << "A" << i << " -> A" << j << ";" << ::std::endl;
      }
  s << "}" << ::std::endl;
}
void Instance::write_atom_digraph
(::std::ostream& s, const graph& g, const char* label) const
{
  index_set all_atoms;
  all_atoms.fill(n_atoms());
  bool_vec no_atoms(false, n_atoms());
  write_atom_digraph(s, g, all_atoms, no_atoms, no_atoms, label);
}
void Instance::write_atom_action_digraph
(::std::ostream& s,
 const graph& g,
 const index_set& atomset,
 const index_set& actionset,
 const bool_vec& mark_shaded,
 const bool_vec& mark_bold,
 const bool_vec& mark_dashed,
 const char* label) const
{
  s << "digraph AADG {" << ::std::endl;
  s << "label=\"" << label << "\";" << ::std::endl;
  s << "node [width=0,height=0];" << ::std::endl;
  for (index_type k = 0; k < atomset.length(); k++) {
    s << "ATM" << k << " [shape=ellipse,";
    if (mark_shaded[atomset[k]]) {
      s << "style=filled,";
    }
    if (mark_bold[atomset[k]]) {
      s << "style=bold,";
    }
    if (mark_dashed[atomset[k]]) {
      s << "style=dashed,";
    }
    s << "label=\"" << atoms[atomset[k]].name << "\"];"
      << ::std::endl;
  }
  for (index_type k = 0; k < actionset.length(); k++) {
    s << "ACT" << k << " [shape=box,";
    if (mark_shaded[atomset.length() + actionset[k]]) {
      s << "style=filled,";
    }
    if (mark_bold[atomset.length() + actionset[k]]) {
      s << "style=bold,";
    }
    if (mark_dashed[atomset.length() + actionset[k]]) {
      s << "style=dashed,";
    }
    s << "label=\"" << actions[actionset[k]].name << "\"];"
      << ::std::endl;
  }
  for (index_type i = 0; i < atomset.length(); i++) {
    for (index_type j = 0; j < atomset.length(); j++)
      if (g.adjacent(i, j))
 s << "ATM" << i << " -> ATM" << j << ";" << ::std::endl;
    for (index_type j = 0; j < actionset.length(); j++)
      if (g.adjacent(i, atomset.length() + j))
 s << "ATM" << i << " -> ACT" << j << ";" << ::std::endl;
  }
  for (index_type i = 0; i < actionset.length(); i++) {
    for (index_type j = 0; j < atomset.length(); j++)
      if (g.adjacent(atomset.length() + i, j))
 s << "ACT" << i << " -> ATM" << j << ";" << ::std::endl;
    for (index_type j = 0; j < actionset.length(); j++)
      if (g.adjacent(atomset.length() + i, atomset.length() + j))
 s << "ACT" << i << " -> ACT" << j << ";" << ::std::endl;
  }
  s << "}" << ::std::endl;
}
void Instance::write_atom_set_digraph
(::std::ostream& s, const index_set_graph& g, const char* label) const
{
  s << "digraph SDG {" << ::std::endl;
  s << "label=\"" << label << "\";" << ::std::endl;
  s << "node [width=0,height=0];" << ::std::endl;
  for (index_type k = 0; k < g.size(); k++) {
    s << "S" << k << " [label=\"";
    write_atom_set(s, g.node_label(k));
    s << "\"];" << ::std::endl;
  }
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j)) {
 s << "S" << i << " -> S" << j << ";" << ::std::endl;
      }
  s << "}" << ::std::endl;
}
void Instance::write_atom_set_graph
(::std::ostream& s, const index_set_graph& g, const char* label) const
{
  s << "graph SG {" << ::std::endl;
  s << "label=\"" << label << "\";" << ::std::endl;
  s << "node [width=0,height=0];" << ::std::endl;
  s << "edge [len=1.0];" << ::std::endl;
  s << "overlap=false;" << ::std::endl;
  for (index_type k = 0; k < g.size(); k++) {
    s << "S" << k << " [label=\"";
    if (g.node_has_label(k))
      write_atom_set(s, g.node_label(k));
    else
      s << "{}";
    s << "\"];" << ::std::endl;
  }
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = i + 1; j < g.size(); j++)
      if (g.adjacent(i, j) && g.adjacent(i, j)) {
 s << "S" << i << " -- S" << j;
 if (g.edge_has_label(i, j)) {
   if (g.edge_has_label(j, i)) {
     if (g.edge_label(i, j) == g.edge_label(j, i)) {
       s << "[label=\"";
       write_atom_set(s, g.edge_label(i, j));
       s << "\"]";
     }
     else {
       s << "[label=\"";
       write_atom_set(s, g.edge_label(i, j));
       s << " / ";
       write_atom_set(s, g.edge_label(j, i));
       s << "\"]";
     }
   }
   else {
     s << "[label=\"";
     write_atom_set(s, g.edge_label(i, j));
     s << " / {}\"]";
   }
 }
 else if (g.edge_has_label(j, i)) {
   s << "[label=\"{} / ";
   write_atom_set(s, g.edge_label(j, i));
   s << "\"]";
 }
 s << ";" << ::std::endl;
      }
  s << "}" << ::std::endl;
}
void Instance::write_axiom_dependency_graph
(::std::ostream& s, const index_graph& g, const char* label) const
{
  s << "digraph DG {" << ::std::endl;
  s << "label=\"" << label << "\";" << ::std::endl;
  s << "node [width=0,height=0];" << ::std::endl;
  for (index_type k = 0; k < g.size(); k++)
    if ((g.out_degree(k) > 0) || (g.in_degree(k) > 0)) {
      s << "N" << k << " [shape=ellipse,";
      if (g.out_degree(k) > 0) {
 s << "style=filled,";
      }
      if (g.node_label(k) != no_such_index) {
 assert(g.node_label(k) < n_atoms());
 s << "label=\""
   << atoms[g.node_label(k)].name
   << "\"];";
      }
      else {
 s << "label=\"?\"];";
      }
      s << ::std::endl;
    }
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j)) {
 s << "N" << i << " -> N" << j << " [label=\""
   << g.edge_label(i, j)
   << "\"];" << ::std::endl;
      }
  s << "}" << ::std::endl;
}
void Instance::write_PDDL_action(::std::ostream& s, const Action& act) const
{
  index_type n_use = 0;
  for (index_type i = 0; i < n_resources(); i++)
    if (act.use[i] > 0) n_use += 1;
  index_type n_cons = 0;
  for (index_type i = 0; i < n_resources(); i++)
    if (act.cons[i] > 0) n_cons += 1;
  s << " (:action ";
  act.name->write(s, Name::NC_INSTANCE);
  if (always_write_parameters) {
    s << ::std::endl << "  :parameters ()";
  }
  if (act.assoc && write_extra) {
    s << ::std::endl << "  :assoc \"" << act.assoc << "\"";
  }
  if (write_PDDL2) {
    if ((act.pre.length() + act.lck.length() + n_use + n_cons) > 0) {
      s << ::std::endl << "  :precondition";
      if (((act.pre.length() + act.lck.length() + n_use + n_cons) > 1) ||
   always_write_conjunction)
 s << " (and";
      for (index_type i = 0; i < act.pre.length(); i++)
 if (!act.lck.contains(act.pre[i])) {
   if (write_negation &&
       (atoms[act.pre[i]].neg != no_such_index) &&
       (atoms[act.pre[i]].neg < act.pre[i])) {
     s << " (not (";
     atoms[atoms[act.pre[i]].neg].name->write(s, Name::NC_INSTANCE);
     s << "))";
   }
   else {
     s << " (";
     atoms[act.pre[i]].name->write(s, Name::NC_INSTANCE);
     s << ")";
   }
 }
      if (write_time) {
 for (index_type i = 0; i < act.lck.length(); i++) {
   if (write_negation &&
       (atoms[act.lck[i]].neg != no_such_index) &&
       (atoms[act.lck[i]].neg < act.lck[i])) {
     s << " (at start (not (";
     atoms[atoms[act.lck[i]].neg].name->write(s, Name::NC_INSTANCE);
     s << ")))";
   }
   else {
     s << " (at start (";
     atoms[act.lck[i]].name->write(s, Name::NC_INSTANCE);
     s << "))";
   }
 }
      }
      for (index_type i = 0; i < n_resources(); i++) {
 if (write_time) {
   if (write_resource_constraints_at_start) {
     if ((act.use[i] + act.cons[i]) > 0) {
       s << " (at start (>= (";
       resources[i].name->write(s, Name::NC_INSTANCE);
       s << ") " << std::resetiosflags(std::ios::scientific) << ((act.use[i] + act.cons[i]).decimal()) << "))";
     }
   }
   else {
     if ((act.use[i] + act.cons[i]) > 0) {
       s << " (over all (>= (";
       resources[i].name->write(s, Name::NC_INSTANCE);
       s << ") 0))";
     }
   }
 }
 else {
   if ((act.use[i] + act.cons[i]) > 0) {
     s << " (>= (";
     resources[i].name->write(s, Name::NC_INSTANCE);
     s << ") " << std::resetiosflags(std::ios::scientific) << ((act.use[i] + act.cons[i]).decimal()) << ")";
   }
 }
      }
      if (((act.pre.length() + act.lck.length() + n_use + n_cons) > 1) ||
   always_write_conjunction)
 s << ")";
    }
    else if (always_write_precondition) {
      if (always_write_conjunction)
 s << ::std::endl << "  :precondition (and)";
      else
 s << ::std::endl << "  :precondition ()";
    }
  }
  else {
    if (act.pre.length() > 0) {
      s << ::std::endl << "  :precondition";
      if ((act.pre.length() > 1) || always_write_conjunction)
 s << " (and";
      for (index_type i = 0; i < act.pre.length(); i++) {
 if (write_negation &&
     (atoms[act.pre[i]].neg != no_such_index) &&
     (atoms[act.pre[i]].neg < act.pre[i])) {
   s << " (not (";
   atoms[atoms[act.pre[i]].neg].name->write(s, Name::NC_INSTANCE);
   s << "))";
 }
 else {
   s << " (";
   atoms[act.pre[i]].name->write(s, Name::NC_INSTANCE);
   s << ")";
 }
      }
      if ((act.pre.length() > 1) || always_write_conjunction)
 s << ")";
    }
    else if (always_write_precondition) {
      if (always_write_conjunction)
 s << ::std::endl << "  :precondition (and)";
      else
 s << ::std::endl << "  :precondition ()";
    }
  }
  if (write_PDDL2) {
    if (((act.add.length() + act.del.length() +
   act.lck.length() + n_use + n_cons) > 0) ||
 write_metric) {
      s << ::std::endl << "  :effect";
      if ((act.add.length() + act.del.length() +
    act.lck.length() + n_use + n_cons +
    (write_metric ? 1 : 0)) > 1)
 s << " (and";
      for (index_type i = 0; i < act.add.length(); i++) {
 if (write_negation &&
     (atoms[act.add[i]].neg != no_such_index) &&
     (atoms[act.add[i]].neg < act.add[i])) {
   s << " (not (";
   atoms[atoms[act.add[i]].neg].name->write(s, Name::NC_INSTANCE);
   s << "))";
 }
 else {
   s << " (";
   atoms[act.add[i]].name->write(s, Name::NC_INSTANCE);
   s << ")";
 }
      }
      for (index_type i = 0; i < act.del.length(); i++) {
 if (write_negation &&
     (atoms[act.del[i]].neg != no_such_index) &&
     (atoms[act.del[i]].neg < act.del[i])) {
   s << " (";
   atoms[atoms[act.del[i]].neg].name->write(s, Name::NC_INSTANCE);
   s << ")";
 }
 else {
   s << " (not (";
   atoms[act.del[i]].name->write(s, Name::NC_INSTANCE);
   s << "))";
 }
      }
      if (write_time) {
 for (index_type i = 0; i < act.lck.length(); i++) {
   if (write_negation &&
       (atoms[act.lck[i]].neg != no_such_index) &&
       (atoms[act.lck[i]].neg < act.lck[i])) {
     s << " (at start (";
     atoms[atoms[act.lck[i]].neg].name->write(s, Name::NC_INSTANCE);
     s << ")) (at end (not (";
     atoms[atoms[act.lck[i]].neg].name->write(s, Name::NC_INSTANCE);
     s << ")))";
   }
   else {
     s << " (at start (not (";
     atoms[act.lck[i]].name->write(s, Name::NC_INSTANCE);
     s << "))) (at end (";
     atoms[act.lck[i]].name->write(s, Name::NC_INSTANCE);
     s << "))";
   }
 }
      }
      for (index_type i = 0; i < n_resources(); i++) {
 if (write_time) {
   if ((act.use[i] + act.cons[i]) > 0) {
     s << " (at start (decrease (";
     resources[i].name->write(s, Name::NC_INSTANCE);
     s << ") " << std::resetiosflags(std::ios::scientific) << ((act.use[i] + act.cons[i]).decimal()) << "))";
   }
   if (act.use[i] > 0) {
     s << " (at end (increase (";
     resources[i].name->write(s, Name::NC_INSTANCE);
     s << ") " << std::resetiosflags(std::ios::scientific) << ((act.use[i]).decimal()) << "))";
   }
 }
 else {
   if (act.cons[i] > 0) {
     s << " (decrease (";
     resources[i].name->write(s, Name::NC_INSTANCE);
     s << ") " << std::resetiosflags(std::ios::scientific) << ((act.cons[i]).decimal()) << ")";
   }
 }
      }
      if (write_metric) {
 s << " (increase (_cost) " << act.cost << ")";
      }
      if ((act.add.length() + act.del.length() +
    act.lck.length() + n_use + n_cons +
    (write_metric ? 1 : 0)) > 1)
 s << ")";
    }
  }
  else {
    if ((act.add.length() + act.del.length()) > 0) {
      s << ::std::endl << "  :effect";
      if ((act.add.length() + act.del.length()) > 1)
 s << " (and";
      for (index_type i = 0; i < act.add.length(); i++) {
 if (write_negation &&
     (atoms[act.add[i]].neg != no_such_index) &&
     (atoms[act.add[i]].neg < act.add[i])) {
   s << " (not (";
   atoms[atoms[act.add[i]].neg].name->write(s, Name::NC_INSTANCE);
   s << "))";
 }
 else {
   s << " (";
   atoms[act.add[i]].name->write(s, Name::NC_INSTANCE);
   s << ")";
 }
      }
      for (index_type i = 0; i < act.del.length(); i++) {
 if (write_negation &&
     (atoms[act.del[i]].neg != no_such_index) &&
     (atoms[act.del[i]].neg < act.del[i])) {
   s << " (";
   atoms[atoms[act.del[i]].neg].name->write(s, Name::NC_INSTANCE);
   s << ")";
 }
 else {
   s << " (not (";
   atoms[act.del[i]].name->write(s, Name::NC_INSTANCE);
   s << "))";
 }
      }
      if ((act.add.length() + act.del.length()) > 1)
 s << ")";
    }
  }
  if (write_PDDL2 && write_time) {
    if (act.dmin == act.dmax) {
      s << ::std::endl
 << "  :duration (= ?duration "
 << std::resetiosflags(std::ios::scientific) << ((act.dur).decimal())
 << ")";
    }
    else {
      s << ::std::endl
 << "  :duration (and (>= ?duration "
 << std::resetiosflags(std::ios::scientific) << ((act.dmin).decimal())
 << ") (<= ?duration "
 << std::resetiosflags(std::ios::scientific) << ((act.dmax).decimal())
 << "))";
    }
  }
  s << ")" << ::std::endl;
}
void Instance::write_DKEL_invariant_item
(::std::ostream& s, const Constraint& inv, string_set& tags) const
{
  s << " (:invariant";
  if (inv.name) {
    s << " :name ";
    inv.name->write(s, Name::NC_INSTANCE);
  }
  for (index_type k = 0; k < tags.length(); k++)
    s << " :tag " << tags[k];
  s << " :set-constraint";
  if (inv.exact)
    s << " (exactly-n " << inv.lim;
  else
    s << " (at-most-n " << inv.lim;
  for (index_type i = 0; i < inv.set.length(); i++) {
    if (write_negation &&
 (atoms[inv.set[i]].neg != no_such_index) &&
 (atoms[inv.set[i]].neg < inv.set[i])) {
      s << " (not (";
      atoms[atoms[inv.set[i]].neg].name->write(s, Name::NC_INSTANCE);
      s << "))";
    }
    else {
      s << " (";
      atoms[inv.set[i]].name->write(s, Name::NC_INSTANCE);
      s << ")";
    }
  }
  s << "))" << ::std::endl;
}
void Instance::write_DKEL_irrelevant_atom_item
(::std::ostream& s, const Atom& atm, string_set& tags) const
{
  if (write_negation &&
      (atm.neg != no_such_index) &&
      (atm.neg < atm.index))
    return;
  s << " (:irrelevant";
  for (index_type k = 0; k < tags.length(); k++)
    s << " :tag " << tags[k];
  s << " :fact (";
  atm.name->write(s, Name::NC_INSTANCE);
  s << "))" << ::std::endl;
}
void Instance::write_DKEL_irrelevant_action_item
(::std::ostream& s, const Action& act, string_set& tags) const
{
  s << " (:irrelevant";
  for (index_type k = 0; k < tags.length(); k++)
    s << " :tag " << tags[k];
  s << " :action (";
  act.name->write(s, Name::NC_INSTANCE);
  s << "))" << ::std::endl;
}
void Instance::write_domain_atom_set
(::std::ostream& s, const index_set& set) const
{
  s << "(:set";
  for (index_type i = 0; i < set.length(); i++) {
    s << " (";
    atoms[set[i]].name->write(s, Name::NC_INSTANCE);
    s << ")";
  }
  s << ")" << ::std::endl;
}
void Instance::write_domain_action_set
(::std::ostream& s, const index_set& set) const
{
  s << "(:set";
  for (index_type i = 0; i < set.length(); i++) {
    s << " (";
    actions[set[i]].name->write(s, Name::NC_INSTANCE);
    s << ")";
  }
  s << ")" << ::std::endl;
}
void Instance::write_domain_action_set
(::std::ostream& s, const index_set& set, const Name* name) const
{
  s << "(:set";
  if (name) {
    s << " :name ";
    name->write(s, Name::NC_INSTANCE);
  }
  for (index_type i = 0; i < set.length(); i++) {
    s << " (";
    actions[set[i]].name->write(s, Name::NC_INSTANCE);
    s << ")";
  }
  s << ")" << ::std::endl;
}
void Instance::write_domain_init(::std::ostream& s) const
{
  if (name) {
    s << "(define (domain ";
    name->write(s, Name::NC_INSTANCE | Name::NC_DOMAIN);
    s << ")" << ::std::endl;
  }
  else {
    s << "(define (domain NONAME)" << ::std::endl;
  }
  if (always_write_requirements) {
    if (write_PDDL2) {
      s << " (:requirements :strips :durative-actions)" << ::std::endl;
    }
    else {
      s << " (:requirements :strips)" << ::std::endl;
    }
  }
}
void Instance::write_domain_declarations(::std::ostream& s) const
{
  if (n_atoms() > 0) {
    s << " (:predicates";
    for (index_type k = 0; k < n_atoms(); k++) {
      if (!write_negation ||
   (atoms[k].neg == no_such_index) ||
   (k < atoms[k].neg)) {
 s << " (";
 atoms[k].name->write(s, Name::NC_INSTANCE);
 s << ")";
      }
    }
    s << ")" << ::std::endl;
  }
  if (write_PDDL2 && ((n_resources() > 0) || write_metric)) {
    s << " (:functions";
    for (index_type k = 0; k < n_resources(); k++) {
      s << " (";
      resources[k].name->write(s, Name::NC_INSTANCE);
      s << ")";
    }
    if (write_metric) {
      s << " (_cost)";
    }
    s << ")" << ::std::endl;
  }
}
void Instance::write_domain_actions(::std::ostream& s) const
{
  for (index_type k = 0; k < n_actions(); k++) if (actions[k].sel) {
    write_PDDL_action(s, actions[k]);
  }
}
void Instance::write_domain_DKEL_items(::std::ostream& s) const
{
  if (!write_DKEL) return;
  string_set no_tags;
  for (index_type k = 0; k < n_invariants(); k++) {
    write_DKEL_invariant_item(s, invariants[k], no_tags);
  }
  for (index_type k = 0; k < n_atoms(); k++) if (atoms[k].irrelevant) {
    write_DKEL_irrelevant_atom_item(s, atoms[k], no_tags);
  }
}
void Instance::write_domain(::std::ostream& s) const
{
  write_domain_init(s);
  write_domain_declarations(s);
  write_domain_actions(s);
  write_domain_DKEL_items(s);
  s << ")" << ::std::endl;
}
void Instance::write_problem_init(::std::ostream& s) const
{
  bool write_init = write_metric;
  if (write_PDDL2) {
    write_init = (n_resources() > 0);
  }
  for (index_type k = 0; (k < n_atoms()) && !write_init; k++)
    if (atoms[k].init) write_init = true;
  if (write_init) {
    s << " (:init";
    for (index_type k = 0; k < n_atoms(); k++) if (atoms[k].init) {
      if (!write_negation ||
   (atoms[k].neg == no_such_index) ||
   (k < atoms[k].neg)) {
 s << " (";
 atoms[k].name->write(s, Name::NC_INSTANCE);
 s << ")";
      }
    }
    if (write_PDDL2) {
      for (index_type k = 0; k < n_resources(); k++) {
 s << " (= (";
 resources[k].name->write(s, Name::NC_INSTANCE);
 s << ") " << std::resetiosflags(std::ios::scientific) << ((resources[k].init).decimal()) << ")";
      }
      if (write_metric) {
 s << " (= (_cost) 0)";
      }
    }
    s << ")" << ::std::endl;
  }
}
void Instance::write_problem_goal(::std::ostream& s) const
{
  index_type write_goal = 0;
  for (index_type k = 0; (k < n_atoms()) && (write_goal < 2); k++)
    if (atoms[k].goal) write_goal += 1;
  if (write_goal > 0) {
    s << " (:goal";
    if (write_goal > 1) s << " (and";
    for (index_type k = 0; k < n_atoms(); k++) if (atoms[k].goal) {
      if (write_negation &&
   (atoms[k].neg != no_such_index) &&
   (atoms[k].neg < k)) {
 s << " (not (";
 atoms[atoms[k].neg].name->write(s, Name::NC_INSTANCE);
 s << "))";
      }
      else {
 s << " (";
 atoms[k].name->write(s, Name::NC_INSTANCE);
 s << ")";
      }
    }
    if (write_goal > 1) s << ")";
    s << ")" << ::std::endl;
  }
}
void Instance::write_problem_metric(::std::ostream& s) const
{
  if (write_PDDL2 && write_metric) {
    s << " (:metric minimize (_cost))" << ::std::endl;
  }
}
void Instance::write_problem(::std::ostream& s) const
{
  if (name) {
    s << "(define (problem ";
    name->write(s, Name::NC_INSTANCE | Name::NC_PROBLEM);
    s << ")" << ::std::endl;
    s << " (:domain ";
    name->write(s, Name::NC_INSTANCE | Name::NC_DOMAIN);
    s << ")" << ::std::endl;
  }
  else {
    s << "(define (problem NONAME)" << ::std::endl;
    s << " (:domain NONAME)" << ::std::endl;
  }
  write_problem_init(s);
  write_problem_goal(s);
  write_problem_metric(s);
  s << ")" << ::std::endl;
}
void Instance::print(::std::ostream& s) const
{
  s << "atoms:" << ::std::endl;
  for (index_type k = 0; k < n_atoms(); k++)
    print_atom(s, atoms[k]);
  s << "resources:" << ::std::endl;
  for (index_type k = 0; k < n_resources(); k++)
    print_resource(s, resources[k]);
  s << "actions:" << ::std::endl;
  for (index_type k = 0; k < n_actions(); k++)
    print_action(s, actions[k]);
  s << "invariants:" << ::std::endl;
  for (index_type k = 0; k < n_invariants(); k++)
    print_invariant(s, invariants[k]);
}
void Instance::print_atom(::std::ostream& s, const Atom& atm) const
{
  s << atm.index << ". " << atm.name;
  if (atm.neg != no_such_index) {
    s << " (neg: " << atoms[atm.neg].index
      << "." << atoms[atm.neg].name
      << ")";
  }
  else {
    s << " (no neg.)";
  }
  s << ::std::endl;
  s << "  init: " << (atm.init ? 'T' : 'F');
  if (atm.init) {
    s << " (init_t = " << atm.init_t << ")";
  }
  s << ", goal: " << (atm.goal ? 'T' : 'F');
  if (atm.goal) {
    s << " (goal_t = " << atm.goal_t << ")";
  }
  s << ", irrel: " << (atm.irrelevant ? 'T' : 'F')
    << ::std::endl;
  if (xrf) {
    s << "  req. by:";
    for (index_type i = 0; i < atm.req_by.length(); i++)
      s << ' ' << atm.req_by[i] << '.'
 << actions[atm.req_by[i]].name;
    s << ::std::endl;
    s << "  add by:";
    for (index_type i = 0; i < atm.add_by.length(); i++)
      s << ' ' << atm.add_by[i] << '.'
 << actions[atm.add_by[i]].name;
    s << ::std::endl;
    s << "  del by:";
    for (index_type i = 0; i < atm.del_by.length(); i++)
      s << ' ' << atm.del_by[i] << '.'
 << actions[atm.del_by[i]].name;
    s << ::std::endl;
  }
}
void Instance::print_resource(::std::ostream& s, const Resource& res) const
{
  s << res.index << ". " << res.name << " (";
  if (res.consumed) s << "consumed, ";
  if (res.used) s << "used, ";
  s << res.init << ")" << ::std::endl;
  s << " used by:";
  for (index_type i = 0; i < n_actions(); i++)
    if (actions[i].use[res.index] > 0)
      s << " " << i << "." << actions[i].name
 << "=" << actions[i].use[res.index];
  s << ::std::endl << " consumed by:";
  for (index_type i = 0; i < n_actions(); i++)
    if (actions[i].cons[res.index] > 0)
      s << " " << i << "." << actions[i].name
 << "=" << actions[i].cons[res.index];
  s << ::std::endl;
}
void Instance::print_action(::std::ostream& s, const Action& act) const
{
  s << act.index << ". " << act.name
    << (act.sel ? " (selectable)" : " (non-selectable)")
    << ":" << ::std::endl;
  s << "  pre:";
  for (index_type i = 0; i < act.pre.length(); i++) {
    s << ' ' << act.pre[i] << '.';
    if (act.pre[i] < n_atoms())
      s << atoms[act.pre[i]].name;
    else
      s << "?";
    if (act.del.contains(act.pre[i])) s << " (del)";
    if (act.lck.contains(act.pre[i])) s << " (lck)";
  }
  s << ::std::endl << "  add:";
  for (index_type i = 0; i < act.add.length(); i++) {
    s << ' ' << act.add[i] << '.';
    if (act.add[i] < n_atoms())
      s << atoms[act.add[i]].name;
    else
      s << "?";
  }
  s << ::std::endl << "  del:";
  for (index_type i = 0; i < act.del.length(); i++) {
    s << ' ' << act.del[i] << '.';
    if (act.del[i] < n_atoms())
      s << atoms[act.del[i]].name;
    else
      s << "?";
  }
  s << ::std::endl << "  lock:";
  for (index_type i = 0; i < act.lck.length(); i++)
    s << ' ' << act.lck[i] << '.' << atoms[act.lck[i]].name;
  s << ::std::endl << "  use:";
  for (index_type i = 0; i < n_resources(); i++)
    s << ' ' << i << '.' << resources[i].name << '=' << act.use[i];
  s << ::std::endl << "  cons:";
  for (index_type i = 0; i < n_resources(); i++)
    s << ' ' << i << '.' << resources[i].name << '=' << act.cons[i];
  s << ::std::endl << "  dur: " << act.dur
    << ::std::endl << "  cost: " << act.cost
    << ::std::endl;
  if (act.ncw_atms.length() > 0) {
    s << "  n.c.w. atoms:";
    for (index_type i = 0; i < act.ncw_atms.length(); i++)
      s << ' ' << act.ncw_atms[i] << '.'
 << atoms[act.ncw_atms[i]].name;
    s << ::std::endl;
  }
}
void Instance::print_invariant(::std::ostream& s, const Constraint& inv) const
{
  s << inv.index << ". ";
  if (inv.name) {
    s << inv.name << " ";
  }
  s << "|{";
  for (index_type k = 0; k < inv.set.length(); k++) {
    if (k > 0) s << ", ";
    s << k << "=" << inv.set[k] << "." << atoms[inv.set[k]].name;
  }
  s << "}|";
  if (inv.exact) {
    s << " = ";
  }
  else {
    s << " <= ";
  }
  s << inv.lim;
  s << " (size: " << inv.set.length();
  if (inv.verified) {
    s << ", verified";
  }
  s << ")" << ::std::endl;
}
PreconditionEvaluator::PreconditionEvaluator(Instance& ins)
  : instance(ins),
    node_type(undecided_leaf),
    i_test(no_such_index),
    next(0, 0),
    prev(0),
    n_positive(0)
{
}
PreconditionEvaluator::~PreconditionEvaluator()
{
  for (index_type k = 0; k < next.length(); k++) {
    assert(next[k]);
    delete next[k];
  }
}
void PreconditionEvaluator::construct
(Instance& ins,
 PreconditionEvaluator* p,
 bool_vec& s,
 bool_vec& ua,
 index_type n_ua,
 index_type n_pos,
 bool_vec& rem_invs,
 bool_vec& rem_atoms,
 hsps::rational T)
{
  assert(n_ua > 0);
  index_type best_option = no_such_index;
  hsps::rational best_option_val = POS_INF;
  index_type b = ins.n_invariants();
  if (n_ua > 2) {
    for (index_type k = 0; k < ins.n_invariants(); k++) if (rem_invs[k]) {
      Instance::Constraint& c = ins.invariants[k];
      index_type n1 = 0;
      for (index_type i = 0; i < c.set.length(); i++)
 n1 += ua.count_common(ins.atoms[c.set[i]].req_by);
      index_type n = 0;
      for (index_type i = 0; i < c.set.length(); i++) {
 n += ((n_ua - n1) + ua.count_common(ins.atoms[c.set[i]].req_by));
      }
      if (!c.exact) {
 n += (n_ua - n1);
      }
      index_type m = (c.exact ? c.set.length() : c.set.length() + 1);
      hsps::rational val = (hsps::rational(n,m).reduce());
      if (val < best_option_val) {
 best_option = k;
 best_option_val = val;
      }
    }
    for (index_type k = 0; k < ins.n_atoms(); k++) if (rem_atoms[k]) {
      index_type n = 0;
      s[k] = true;
      for (index_type i = 0; i < ins.n_actions(); i++) if (ua[i]) {
 if (s.contains(ins.actions[i].pre)) n += 1;
      }
      s[k] = false;
      hsps::rational val = (hsps::rational((n_ua - ua.count_common(ins.atoms[k].req_by)) + (n_ua - n),2).reduce());
      if (val < best_option_val) {
 best_option = k + b;
 best_option_val = val;
      }
    }
  }
  if (best_option_val > (T * n_ua)) {
    if (p->n_positive > 0) {
      PreconditionEvaluator* pp = new PreconditionEvaluator(ins);
      pp->prev = p;
      pp->node_type = undecided_leaf;
      for (index_type k = 0; k < ins.n_actions(); k++)
 if (ua[k]) pp->acts.append(k);
      pp->n_positive = p->n_positive;
      p->node_type = no_test;
      p->next.set_length(1);
      p->next[0] = pp;
    }
    else {
      p->node_type = undecided_leaf;
      for (index_type k = 0; k < ins.n_actions(); k++)
 if (ua[k]) p->acts.append(k);
    }
  }
  else if (best_option < b) {
    assert(best_option < ins.n_invariants());
    assert(rem_invs[best_option]);
    assert(p->next.empty());
    Instance::Constraint& c = ins.invariants[best_option];
    bool_vec rem_invs_copy(rem_invs);
    bool_vec rem_atoms_copy(rem_atoms);
    for (index_type k = 0; k < c.set.length(); k++)
      rem_atoms_copy[c.set[k]] = false;
    bool_vec ua_copy(ua);
    for (index_type k = 0; k < c.set.length(); k++) {
      if (k > 0) ua_copy.assign_copy(ua);
      PreconditionEvaluator* pp = new PreconditionEvaluator(ins);
      pp->prev = p;
      for (index_type i = 0; i < c.set.length(); i++) if (i != k) {
 for (index_type j = 0; j < ins.atoms[c.set[i]].req_by.length(); j++)
   ua_copy[ins.atoms[c.set[i]].req_by[j]] = false;
      }
      s[c.set[k]] = true;
      for (index_type i = 0; i < ins.n_actions(); i++) if (ua_copy[i]) {
 if (s.contains(ins.actions[i].pre)) {
   pp->acts.append(i);
   pp->n_positive += 1;
   ua_copy[i] = false;
 }
      }
      index_type r_ua = ua_copy.count(true);
      if (r_ua == 0) {
 pp->node_type = positive_leaf;
      }
      else {
 if (k > 0) rem_invs_copy.assign_copy(rem_invs);
 rem_invs_copy[best_option] = false;
 for (index_type j = 0; j < ins.n_invariants(); j++)
   if (ins.invariants[j].set.contains(c.set[k]))
     rem_invs_copy[j] = false;
 construct(ins, pp, s, ua_copy, r_ua, n_pos + p->n_positive,
    rem_invs_copy, rem_atoms_copy, T);
      }
      s[c.set[k]] = false;
      p->next.append(pp);
    }
    if (!c.exact) {
      PreconditionEvaluator* pp = new PreconditionEvaluator(ins);
      pp->prev = p;
      ua_copy.assign_copy(ua);
      for (index_type i = 0; i < c.set.length(); i++)
 for (index_type j = 0; j < ins.atoms[c.set[i]].req_by.length(); j++)
   ua_copy[ins.atoms[c.set[i]].req_by[j]] = false;
      index_type r_ua = ua_copy.count(true);
      if (r_ua == 0) {
 pp->node_type = positive_leaf;
      }
      else {
 rem_invs_copy.assign_copy(rem_invs);
 rem_invs_copy[best_option] = false;
 construct(ins, pp, s, ua_copy, r_ua, n_pos + p->n_positive,
    rem_invs_copy, rem_atoms_copy, T);
      }
      p->next.append(pp);
    }
    p->node_type = test_invariant;
    p->i_test = best_option;
  }
  else {
    assert((best_option >= b) && ((best_option - b) < ins.n_atoms()));
    best_option -= b;
    assert(rem_atoms[best_option]);
    assert(p->next.empty());
    rem_atoms[best_option] = false;
    bool_vec ua_copy(ua);
    PreconditionEvaluator* p_true = new PreconditionEvaluator(ins);
    p_true->prev = p;
    s[best_option] = true;
    for (index_type i = 0; i < ins.n_actions(); i++) if (ua_copy[i]) {
      if (s.contains(ins.actions[i].pre)) {
 p_true->acts.append(i);
 p_true->n_positive += 1;
 ua_copy[i] = false;
      }
    }
    index_type r_ua = ua_copy.count(true);
    if (r_ua == 0) {
      p_true->node_type = positive_leaf;
    }
    else {
      bool_vec rem_invs_copy(rem_invs);
      for (index_type j = 0; j < ins.n_invariants(); j++)
 if (ins.invariants[j].set.contains(best_option))
   rem_invs_copy[j] = false;
      construct(ins, p_true, s, ua_copy, r_ua, n_pos + p->n_positive,
  rem_invs_copy, rem_atoms, T);
    }
    s[best_option] = false;
    p->next.append(p_true);
    ua_copy.assign_copy(ua);
    PreconditionEvaluator* p_false = new PreconditionEvaluator(ins);
    p_false->prev = p;
    for (index_type j = 0; j < ins.atoms[best_option].req_by.length(); j++)
      ua_copy[ins.atoms[best_option].req_by[j]] = false;
    r_ua = ua_copy.count(true);
    if (r_ua == 0) {
      p_false->node_type = positive_leaf;
    }
    else {
      construct(ins, p_false, s, ua_copy, r_ua, n_pos + p->n_positive,
  rem_invs, rem_atoms, T);
    }
    p->next.append(p_false);
    p->node_type = test_atom;
    p->i_test = best_option;
    rem_atoms[best_option] = true;
  }
  p->n_positive += n_pos;
}
PreconditionEvaluator* PreconditionEvaluator::construct
(Instance& ins, hsps::rational T)
{
  PreconditionEvaluator* root = new PreconditionEvaluator(ins);
  bool_vec ua(true, ins.n_actions());
  for (index_type k = 0; k < ins.n_actions(); k++)
    if (ins.actions[k].pre.empty()) {
      root->acts.append(k);
      root->n_positive += 1;
      ua[k] = false;
    }
  if (ua.count(true) == 0) {
    root->node_type = positive_leaf;
    return root;
  }
  bool_vec s(false, ins.n_atoms());
  bool_vec rem_invs(false, ins.n_invariants());
  for (index_type k = 0; k < ins.n_invariants(); k++)
    if ((ins.invariants[k].lim == 1) && (ins.invariants[k].set.length() > 1))
      rem_invs[k] = true;
  bool_vec rem_atoms(true, ins.n_atoms());
  construct(ins, root, s, ua, ua.count(true), 0, rem_invs, rem_atoms, T);
  return root;
}
PreconditionEvaluator* PreconditionEvaluator::node(const bool_vec& s)
{
  PreconditionEvaluator* p = this;
  while ((p->node_type != positive_leaf) && (p->node_type != undecided_leaf)) {
    if (p->node_type == no_test) {
      assert(p->next[0]);
      p = p->next[0];
    }
    else if (p->node_type == test_invariant) {
      assert(p->i_test < instance.n_invariants());
      Instance::Constraint& inv = instance.invariants[p->i_test];
      assert(inv.lim == 1);
      index_type k = 0;
      bool hit = false;
      while ((k < inv.set.length()) && !hit) {
 if (s[inv.set[k]]) {
   assert(p->next[k]);
   p = p->next[k];
   hit = true;
 }
 k += 1;
      }
      if (!hit) {
 assert(!inv.exact);
 assert(p->next[inv.set.length()]);
 p = p->next[inv.set.length()];
      }
    }
    else if (p->node_type == test_atom) {
      assert(p->i_test < instance.n_atoms());
      if (s[p->i_test]) {
 assert(p->next[0]);
 p = p->next[0];
      }
      else {
 assert(p->next[1]);
 p = p->next[1];
      }
    }
    else {
      assert(0);
    }
  }
  return p;
}
index_type PreconditionEvaluator::eval
(const bool_vec& s, const bool_vec& a, index_type* app, index_type c)
{
  PreconditionEvaluator* p = node(s);
  if (p->node_type == undecided_leaf) {
    for (index_type k = 0; k < p->acts.length(); k++) if (a[p->acts[k]]) {
      bool f = true;
      for (index_type i = 0;
    (i < instance.actions[p->acts[k]].pre.length()) && f; i++)
 if (!s[instance.actions[p->acts[k]].pre[i]]) f = false;
      if (f) {
 app[c++] = p->acts[k];
      }
    }
  }
  else {
    assert(p->node_type == positive_leaf);
    for (index_type k = 0; k < p->acts.length(); k++)
      if (a[p->acts[k]]) app[c++] = p->acts[k];
  }
  p = p->prev;
  while (p) {
    if (p->n_positive == 0) return c;
    for (index_type k = 0; k < p->acts.length(); k++)
      if (a[p->acts[k]]) app[c++] = p->acts[k];
    p = p->prev;
  }
  return c;
}
void PreconditionEvaluator::write_graph(std::ostream& s, bool root)
{
  if (root) {
    s << "digraph PreconditionEvaluator {" << std::endl;
  }
  s << "N" << this << " [shape=box,label=\"";
  if (node_type == test_invariant) {
    s << "inv #" << i_test;
  }
  else if (node_type == test_atom) {
    s << "atom #" << i_test;
  }
  else {
    s << "no test";
  }
  s << " :" << n_positive
    << " / " << acts.length()
    << "\\n" << acts
    << "\"";
  if (node_type == positive_leaf) {
    s << ",style=bold";
  }
  else if (node_type == undecided_leaf) {
    s << ",style=dashed";
  }
  s << "];" << std::endl;
  for (index_type k = 0; k < next.length(); k++) {
    assert(next[k]);
    next[k]->write_graph(s, false);
  }
  for (index_type k = 0; k < next.length(); k++) {
    s << "N" << this << " -> N" << next[k];
    if (node_type == test_invariant) {
      s << " [label=\"" << k
 << "=" << instance.invariants[i_test].set[k] << "\"];"
 << std::endl;
    }
    else if (node_type == test_atom) {
      if (k == 0) s << " [label=\"T\"];" << std::endl;
      else s << " [label=\"F\"];" << std::endl;
    }
    else {
      s << ";" << std::endl;
    }
  }
  if (root) {
    s << "}" << std::endl;
  }
}
}
