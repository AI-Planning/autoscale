#include <string.h>
inline char* strndup(char* s, unsigned int n)
{
  char* d = new char[n+1];
  strncpy(s, d, n);
  return d;
}
#include <assert.h>
#include <limits.h>
#include <vector>
#include <utility>
#include <iostream>
namespace hsps {
typedef unsigned int index_type;
const index_type index_type_max = (UINT_MAX - 1);

const index_type LARGE_PRIME = 2147483629U;
const index_type no_such_index = UINT_MAX;

typedef unsigned long count_type;
const count_type count_type_max = ULONG_MAX;

template<class T> class swapable_pair : public std::pair<T, T>
{
 public:
  swapable_pair()
    : std::pair<T, T>() { };
  swapable_pair(const T& v1, const T& v2)
    : std::pair<T, T>(v1, v2) { };
  swapable_pair(const T& v)
    : std::pair<T, T>(v, v) { };
  swapable_pair(const swapable_pair& p)
    : std::pair<T, T>(p) { };

  void swap();
};

template<class T> class comparable_pair : public swapable_pair<T>
{
 public:
  comparable_pair()
    : swapable_pair<T>() { };
  comparable_pair(const T& v1, const T& v2)
    : swapable_pair<T>(v1, v2) { };
  comparable_pair(const T& v)
    : swapable_pair<T>(v) { };
  comparable_pair(const comparable_pair& p)
    : swapable_pair<T>(p) { };

  void sort_ascending();
  void sort_descending();
};

typedef comparable_pair<index_type> index_pair;

template<class T> class zero_init_pair : public comparable_pair<T>
{
 public:
  zero_init_pair()
    : comparable_pair<T>(0) { };
  zero_init_pair(const T& v1, const T& v2)
    : comparable_pair<T>(v1, v2) { };
  zero_init_pair(const T& v)
    : comparable_pair<T>(v) { };
  zero_init_pair(const zero_init_pair& p)
    : comparable_pair<T>(p) { };
};




class index_set;
class bool_vec;

template<class T> class lvector : public std::vector<T>
{
 public:
  lvector() : std::vector<T>() { };
  lvector(const T& v, index_type l) : std::vector<T>(l, v) { };
  lvector(const lvector<T>& vec) : std::vector<T>(vec) { };




  class element_reference {
    lvector* _vec;
    index_type _pos;
  public:
    element_reference() : _vec(0), _pos(no_such_index) { };
    element_reference(lvector& v, index_type p) : _vec(&v), _pos(p) { };
    operator T*() const {
      if (_vec == 0) return 0;
      return &((*_vec)[_pos]);
    };
  };

  class order {
   public:
    virtual bool operator()(const T& v0, const T& v1) const = 0;
  };

  index_type length() const;
  bool contains(const T& v) const;
  index_type first(const T& v) const;
  index_type next(const T& v, index_type i) const;
  index_type find(const T& v, bool_vec& s) const;
  index_type count(const T& v) const;
  index_type arg_max() const;
  index_type arg_min() const;
  index_type arg_first(const order& o) const;
  index_type arg_last(const order& o) const;
  index_pair first_common(const lvector<T>& vec) const;
  index_pair next_common(const lvector<T>& vec, index_pair p) const;
  void difference(const lvector& v1, lvector& d0, lvector& d1);
  bool operator==(const lvector& _vec) const;
  bool operator!=(const lvector& _vec) const;
  bool operator<(const lvector& vec) const;
  bool operator>(const lvector& vec) const;
  bool operator<=(const lvector& vec) const;
  bool operator>=(const lvector& vec) const;
  void assign_copy(const lvector& _vec);
  void assign_copy(const T* _arr, index_type n);
  void assign_value(const T& val);
  void assign_value(const T& val, index_type l);
  void assign_remap(const lvector& vec, const lvector<index_type>& map);
  void remap(const lvector<index_type>& map);
  void assign_select(const lvector& _vec, const index_set& s);
  void assign_select(const lvector& _vec, const bool_vec& s);
  const lvector& operator=(const lvector& _vec);
  void set_length(index_type l);
  void set_length(index_type l, const T& v);
  void inc_length_to(index_type l);
  void inc_length_to(index_type l, const T& v);
  index_type inc_length() { return inc_length(1); };
  index_type inc_length(index_type d);
  index_type inc_length(index_type d, const T& v);
  index_type dec_length() { return dec_length(1); };
  index_type dec_length(index_type d);
  void clear();
  void append(const T& v);
  void append(const lvector& v);
  T& append();
  void insert(const T& v, index_type p);
  index_type insert_ordered(const T& v, const order& o, index_type f = 0);
  index_type insert_ordered(const lvector& vec, const order& o);
  void remove(index_type p);
  void remove(index_type p0, index_type p1);
  void remove(const index_set& s);
  void remove(const index_set& s, lvector<index_type>& map);
  void remove(const bool_vec& s);
  void remove(const bool_vec& s, lvector<index_type>& map);
  void remove_duplicate_elements();
  void swap(index_type i, index_type j);
};
template<class T> class auto_expanding_vector : public lvector<T>
{
  T _default;
 public:
  auto_expanding_vector() : lvector<T>() { };
  auto_expanding_vector(const T& v, index_type l)
    : lvector<T>(v, l), _default(v) { };
  auto_expanding_vector(const lvector<T>& vec)
    : lvector<T>(vec) { };
  auto_expanding_vector(const auto_expanding_vector<T>& vec)
    : lvector<T>(vec), _default(vec._default) { };
  typename std::vector<T>::reference
  operator[](typename std::vector<T>::size_type k)
  {
    inc_length_to(k + 1, _default);
    return lvector<T>::operator[](k);
  };
  typename std::vector<T>::const_reference
  operator[](typename std::vector<T>::size_type k) const
  {
    if (k >= std::vector<T>::size())
      return _default;
    else
      return lvector<T>::operator[](k);
  };
  void assign_value(const T& val)
  {
    _default = val;
    lvector<T>::assign_value(val);
  };
  void assign_value(const T& val, index_type l)
  {
    _default = val;
    lvector<T>::assign_value(val, l);
  };
};
typedef lvector<index_type> index_vec;
typedef lvector<index_pair> pair_vec;
class index_vec_util : public index_vec
{
 public:
  class decreasing_index_order : public index_vec::order {
  public:
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      { return (v0 > v1); };
  };
  class increasing_index_order : public index_vec::order {
  public:
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      { return (v0 < v1); };
  };
  class increasing_value_order : public index_vec::order {
    const index_vec& value;
  public:
    increasing_value_order(const index_vec& v) : value(v) { };
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      {
 assert(v0 < value.length());
 assert(v1 < value.length());
 return (value[v0] < value[v1]);
      };
  };
  static class decreasing_index_order decreasing;
  static class increasing_index_order increasing;
  static void fill(index_vec& vec, index_type max);
  static index_type min(const index_vec& vec, index_type def = no_such_index);
  static index_type max(const index_vec& vec, index_type def = no_such_index);
  static int compare(const index_vec& v0, const index_vec& v1);
  static index_type hash(const index_vec& vec);
  void fill(index_type max);
  int compare(const index_vec& v1) const;
  index_type hash() const;
};
void factors(index_type n, index_vec& f);
template<class T> class svector : public lvector<T>
{
 public:
  svector() : lvector<T>() { };
  svector(const svector<T>& _svec) : lvector<T>(_svec) { };
  svector(const lvector<T>& _lvec) : lvector<T>() {
    for (index_type k = 0; k < _lvec.size(); k++) insert(_lvec[k]);
  };
  bool contains(const T& v) const;
  bool contains(const svector& vec) const;
  bool subset(const svector& vec) const;
  index_pair first_common(const lvector<T>& vec) const;
  index_pair next_common(const lvector<T>& vec, index_pair p) const;
  index_pair first_common(const svector<T>& vec) const;
  index_pair next_common(const svector<T>& vec, index_pair p) const;
  index_type count_common(const svector& vec) const;
  void assign_singleton(const T& _val);
  void assign_values(const lvector<T>& vec);
  void insert(const T& v);
  void insert(const lvector<T>& vec);
  void intersect(const svector& vec);
  void difference(const svector& vec);
  void subtract(const svector& vec);
  void subtract(const T& v);
};
class index_set : public svector<index_type>
{
 public:
  index_set()
    : svector<index_type>() { };
  index_set(const index_set& _svec)
    : svector<index_type>(_svec) { };
  index_set(const lvector<index_type>& _lvec)
    : svector<index_type>(_lvec) { };
  index_set(const bool* _arr, index_type n);
  index_set(const bool_vec& _vec);
  index_set(const index_set& s0, const index_set& s);
  index_set(const index_set& s0, const bool_vec& s);
  index_set(const index_set& s0, const index_vec& map);
  index_type first_common_element(const index_set& set) const;
  index_type first_common_element(const index_vec& vec) const;
  index_type first_common_element(const bool_vec vec) const;
  index_type first_common_element(const bool* vec, index_type n) const;
  index_type count_common(const index_set& set) const;
  index_type count_common(const bool_vec& set) const;
  bool have_common_element(const index_set& set) const;
  bool have_common_element(const bool_vec& set) const;
  void insert(const index_type& v);
  void insert(const index_vec& vec);
  void insert(const bool_vec& set);
  void intersect(const index_set& vec);
  void intersect(const bool_vec& set);
  void subtract(const index_vec& vec);
  void subtract(const bool_vec& set);
  void subtract(const index_type& v);
  bool* copy_to(bool* s, index_type n) const;
  void fill(index_type to);
  void assign_remap(const index_set& set, const index_vec& map);
  void remap(const index_vec& map);
};
extern const index_set EMPTYSET;
typedef svector<index_pair> pair_set;
class bool_vec : public lvector<bool>
{
 public:
  bool_vec() : lvector<bool>() { };
  bool_vec(bool _val, index_type l) : lvector<bool>(_val, l) { };
  bool_vec(const bool_vec& _vec) : lvector<bool>(_vec) { };
  bool_vec(const bool* _arr, index_type n) : lvector<bool>(false, n) {
    for (index_type k = 0; k < n; k++) {
      if (_arr[k])
 (*this)[k] = true;
      else
 (*this)[k] = false;
    }
  };
  bool_vec(const index_set& set, index_type l);
  void complement();
  void insert(const bool_vec& vec);
  void insert(const index_set& set);
  void intersect(const bool_vec& vec);
  void intersect(const index_set& set);
  void subtract(const bool_vec& vec);
  void subtract(const index_set& set);
  bool subset(const bool_vec& vec) const;
  bool strict_subset(const bool_vec& vec) const;
  bool superset(const bool_vec& vec) const;
  bool strict_superset(const bool_vec& vec) const;
  bool contains(const bool& v) const;
  bool contains(const bool_vec& set) const;
  bool contains(const index_set& set) const;
  bool contains_any(const index_set& set) const;
  index_type first_common_element(const index_set& vec) const;
  index_type first_common_element(const bool_vec vec) const;
  index_type count_common(const bool_vec& vec) const;
  index_type count_common(const index_set& set) const;
  index_set& copy_to(index_set& set) const;
  index_set& insert_into(index_set& set) const;
  index_set& subtract_from(index_set& set) const;
  bool* copy_to(bool* s, index_type n) const;
  int compare(const bool_vec& vec) const;
  index_type hash() const;
};
class index_set_vec : public lvector<index_set>
{
 public:
  index_set_vec()
    : lvector<index_set>() { };
  index_set_vec(const index_set& set, index_type l)
    : lvector<index_set>(set, l) { };
  index_set_vec(index_type l)
    : lvector<index_set>(EMPTYSET, l) { };
  index_set_vec(const index_set_vec& vec)
    : lvector<index_set>(vec) { };
  class decreasing_cardinality_order : public index_set_vec::order {
  public:
    virtual bool operator()
      (const index_set& v0, const index_set& v1) const
      { return (v0.size() > v1.size()); };
  };
  decreasing_cardinality_order decreasing_cardinality;
  index_type minimum_cardinality() const;
  index_type maxmimum_cardinality() const;
  index_type selected_minimum_cardinality(const index_set& sel) const;
  index_type selected_maximum_cardinality(const index_set& sel) const;
  index_type first_minimum_cardinality_set() const;
  index_type first_maxmimum_cardinality_set() const;
  index_type first_superset(const index_set& set) const;
  index_type first_strict_superset(const index_set& set) const;
  index_type first_subset(const index_set& set) const;
  index_type first_strict_subset(const index_set& set) const;
  index_set& union_set(index_set& set) const;
  index_set& selected_union_set(const index_set& sel, index_set& set) const;
  index_set& intersection_set(index_set& set) const;
  void insert_maximal(const index_set& set);
  void insert_minimal(const index_set& set);
  void reduce_to_maximal();
  void reduce_to_minimal();
  void append_if_not_subset(const index_set& set);
  void append_if_not_superset(const index_set& set);
  void append_if_new(const index_set& set);
  void remove_sets_size_le(index_type l);
  void remove_empty_sets();
  void insert_in_all(index_type i);
  void insert_in_all(const index_set& set);
  void subtract_from_all(index_type i);
  void subtract_from_all(const index_set& set);
  void combinations_by_union(const index_set_vec& sv);
  void combinations_by_union(const index_set_vec& sv1,
        const index_set_vec& sv2);
};
template<class T> class matrix : public lvector< lvector<T> >
{
 public:
  typedef lvector<T> row_type;
  matrix()
    : lvector<row_type>() { };
  matrix(const T& _val, index_type r, index_type c)
    : lvector<row_type>(row_type(_val, c), r) { };
  matrix(const matrix& _mat)
    : lvector<row_type>(_mat) { };
  index_type rows() const
  {
    return lvector<row_type>::length();
  };
  index_type columns() const
  {
    if (lvector<row_type>::length() == 0) return 0;
    else return (*this)[0].length();
  };
  void set_size(index_type r, index_type c);
  void assign_value(const T& _val);
  void assign_value(const T& _val, index_type r, index_type c);
};
class bool_matrix : public matrix<bool> {
 public:
  bool_matrix()
    : matrix<bool>() { };
  bool_matrix(const bool& v, index_type r, index_type c)
    : matrix<bool>(v, c, r) { };
  bool_matrix(const bool_matrix& m)
    : matrix<bool>(m) { };
  void complement();
  void insert(const bool_matrix& m);
  void intersect(const bool_matrix& m);
  void subtract(const bool_matrix& m);
  void multiply(const bool_matrix& m0, const bool_matrix& m1);
  void transitive_closure();
};
typedef matrix<index_type> index_matrix;
class mapping : public index_vec
{
 public:
  static void identity_map
    (index_type n, index_vec& map)
    { index_vec_util::fill(map, n); };
  static bool invert_map
    (const index_vec& map, index_vec& inv, index_type m = 0);
  static void delete_index_map
    (index_type n, index_type i, index_vec& map);
  static void compose
    (const index_vec& m0, const index_vec& m1, index_vec& cm);
  static void map_image
    (const index_vec& map, const index_vec& vec, index_vec& img);
  static void inverse_map_image
    (const index_vec& map, index_type x, index_set& img);
  static void inverse_map_image
    (const index_vec& map, const index_set& x, index_set& img);
  static index_type range(const index_vec& map, index_type d);
  mapping()
    : index_vec() { };
  mapping(index_type n)
    : index_vec() { identity_map(n, *this); };
  mapping(index_type n, index_type i, bool out) : index_vec() {
    if (out) delete_index_map(n, i, *this); else assign_value(i, n);
  };
  mapping(const mapping& map)
    : index_vec(map) { };
  void assign_identity(index_type n)
    { identity_map(n, *this); };
  index_type operator()(index_type x) const
    { assert(x < size()); return (*this)[x]; };
  index_vec operator()(const index_vec& vec) const
    { index_vec res; map_image(*this, vec, res); return res; };
  index_vec& inverse(index_type x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  index_vec& inverse(const index_set& x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  bool invert(index_vec& rmap) const
    { return invert_map(*this, rmap); };
  bool invert()
    { index_vec tmp(*this); return invert_map(tmp, *this); };
  index_type range() const
    { return range(*this, length()); };
};
class sparse_mapping : public pair_vec
{
 public:
  static void dense_to_sparse(const index_vec& dm, pair_vec sm);
  static void sparse_to_dense(const pair_vec& sm, index_vec dm);
  static index_type map_image
    (const pair_vec& map, index_type x);
  static void map_image
    (const pair_vec& map, const index_vec& vec, index_vec& img);
  static void inverse_map_image
    (const pair_vec& map, index_type x, index_set& img);
  static void inverse_map_image
    (const pair_vec& map, const index_set& x, index_set& img);
  sparse_mapping()
    : pair_vec() { };
  sparse_mapping(const pair_vec& m)
    : pair_vec(m) { };
  sparse_mapping(const index_vec& m)
    : pair_vec() { dense_to_sparse(m, *this); };
  index_type operator()(index_type x) const
    { return map_image(*this, x); };
  index_vec operator()(const index_vec& vec) const
    { index_vec res; map_image(*this, vec, res); return res; };
  index_set& inverse(index_type x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  index_set& inverse(const index_set& x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
};
class equivalence : public index_vec
{
 public:
  equivalence()
    : index_vec() { };
  equivalence(index_type n)
    : index_vec(no_such_index, n) { index_vec_util::fill(*this, n); };
  equivalence(const equivalence& eq)
    : index_vec(eq) { };
  bool operator()(index_type a, index_type b) const;
  index_type canonical(index_type a) const;
  void extend(index_type a);
  void merge(index_type a, index_type b);
  void merge(const equivalence& eq);
  void merge(const index_set& set);
  void merge(const index_set& sa, const index_set& sb);
  void reset();
  void reset(index_type n);
  void canonical_set(index_set& set) const;
  void canonical_elements(index_set& set) const;
  void class_elements(index_type rep, index_set& set) const;
  index_type n_class_elements(index_type rep) const;
  void classes(index_set_vec& sets) const;
  void make_map(index_vec& map) const;
  index_type n_classes() const;
  index_type n_squeezed() const;
};
class set_hash_function : index_vec
{
 public:
  set_hash_function(index_type n)
    : index_vec() { init(n); };
  void init(index_type n);
  index_type operator()(index_type& i, index_type v) const;
  index_type operator()(const index_set& set) const;
  index_type operator()(const bool_vec& set) const;
  index_type operator()(const bool* set, index_type n) const;
};
template<class T, class N> struct weighted
{
  T value;
  N weight;
  weighted() : weight(0) { };
  weighted(const T& v) : value(v), weight(0) { };
  weighted(const T& v, const N& w) : value(v), weight(w) { };
  weighted(const weighted& w) : value(w.value), weight(w.weight) { };
  ~weighted() { };
  weighted& operator=(const T& v)
  {
    value = v;
    weight = 0;
    return *this;
  };
  weighted& operator=(const weighted& w)
  {
    value = w.value;
    weight = w.weight;
    return *this;
  };
  bool operator==(const weighted& w) const
  {
    return (value == w.value);
  };
  bool operator!=(const weighted& w) const
  {
    return (value != w.value);
  };
  bool operator<(const weighted& w) const
  {
    return (value < w.value);
  };
  bool operator<=(const weighted& w) const
  {
    return (value <= w.value);
  };
  bool operator>(const weighted& w) const
  {
    return (value > w.value);
  };
  bool operator>=(const weighted& w) const
  {
    return (value >= w.value);
  };
};
template<class T, class N> class weighted_vec
: public lvector< weighted<T, N> >
{
 public:
  class decreasing_weight_order : public lvector< weighted<T,N> >::order {
  public:
    virtual bool operator()
      (const weighted<T,N>& v0, const weighted<T,N>& v1) const
      { return (v0.weight > v1.weight); };
  };
  class increasing_weight_order : public lvector< weighted<T,N> >::order {
  public:
    virtual bool operator()
      (const weighted<T,N>& v0, const weighted<T,N>& v1) const
      { return (v0.weight < v1.weight); };
  };
  static class decreasing_weight_order decreasing;
  static class increasing_weight_order increasing;
  void insert_increasing(const weighted<T,N>& v);
  void insert_decreasing(const weighted<T,N>& v);
  void insert_increasing(const T& v, const N& w);
  void insert_decreasing(const T& v, const N& w);
};
template<class T, class N> class weighted_set
: public svector< weighted<T,N> >
{
 public:
  void insert(const T& v, const N& w);
  void insert(const T& v);
  index_type arg_max();
  index_type arg_min();
};
template<class T>
bool lvector<T>::operator==(const lvector& _vec) const
{
  if (lvector<T>::size() != _vec.size()) return false;
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if (!((*this)[k] == _vec[k])) return false;
  return true;
}
template<class T>
bool lvector<T>::operator!=(const lvector& _vec) const
{
  if (*this == _vec) return false;
  else return true;
}
template<class T>
bool lvector<T>::operator<(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return true;
  else if (lvector<T>::size() > vec.size()) return false;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return true;
      else if ((*this)[k] > vec[k]) return false;
    }
    return false;
  }
}
template<class T>
bool lvector<T>::operator<=(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return true;
  else if (lvector<T>::size() > vec.size()) return false;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return true;
      else if ((*this)[k] > vec[k]) return false;
    }
    return true;
  }
}
template<class T>
bool lvector<T>::operator>(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return false;
  else if (lvector<T>::size() > vec.size()) return true;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return false;
      else if ((*this)[k] > vec[k]) return true;
    }
    return false;
  }
}
template<class T>
bool lvector<T>::operator>=(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return false;
  else if (lvector<T>::size() > vec.size()) return true;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return false;
      else if ((*this)[k] > vec[k]) return true;
    }
    return true;
  }
}
template<class T>
bool lvector<T>::contains(const T& v) const
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return true;
  return false;
}
template<class T>
index_type lvector<T>::first(const T& v) const
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return k;
  return no_such_index;
}
template<class T>
index_type lvector<T>::next(const T& v, index_type p) const
{
  for (index_type k = p + 1; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return k;
  return no_such_index;
}
template<class T>
index_type lvector<T>::find(const T& v, bool_vec& s) const
{
  index_type n = 0;
  s.assign_value(false, lvector<T>::size());
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) {
      s[k] = true;
      n += 1;
    }
  return n;
}
template<class T>
index_type lvector<T>::count(const T& v) const
{
  index_type c = 0;
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) c += 1;
  return c;
}
template<class T>
index_type lvector<T>::length() const
{
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::arg_max() const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if ((*this)[k] > (*this)[m]) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_min() const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if ((*this)[k] < (*this)[m]) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_first(const order& o) const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if (o((*this)[k], (*this)[m])) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_last(const order& o) const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if (o((*this)[m], (*this)[k])) m = k;
  return m;
}
template<class T>
index_pair lvector<T>::first_common(const lvector<T>& vec) const
{
  for (index_type i = 0; i < lvector<T>::size(); i++) {
    for (index_type j = 0; j < vec.size(); j++)
      if ((*this)[i] == vec[j]) return index_pair(i, j);
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_pair lvector<T>::next_common(const lvector<T>& vec, index_pair p) const
{
  index_type i = p.first;
  index_type j = p.second + 1;
  while (j < vec.size()) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    j += 1;
  }
  i += 1;
  while (i < lvector<T>::size()) {
    j = 0;
    while (j < vec.size()) {
      if ((*this)[i] == vec[j])
 return index_pair(i, j);
      j += 1;
    }
    i += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
void lvector<T>::difference
(const lvector& v1, lvector& d0, lvector& d1)
{
  d0.assign_copy(*this);
  d1.assign_copy(v1);
  index_type i0 = 0;
  while (i0 < d0.size()) {
    index_type i1 = d1.first(d0[i0]);
    if (i1 != no_such_index) {
      d0.remove(i0);
      d1.remove(i1);
    }
    else {
      i0 += 1;
    }
  }
}
template<class T>
void lvector<T>::assign_copy(const lvector& _vec)
{
  std::vector<T>::resize(_vec.size());
  for (index_type k = 0; k < _vec.size(); k++)
    (*this)[k] = _vec[k];
}
template<class T>
void lvector<T>::assign_copy(const T* _arr, index_type n)
{
  std::vector<T>::resize(n);
  for (index_type k = 0; k < n; k++)
    (*this)[k] = _arr[k];
}
template<class T>
void lvector<T>::assign_value(const T& _val)
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    (*this)[k] = _val;
}
template<class T>
void lvector<T>::assign_value(const T& _val, index_type l)
{
  std::vector<T>::resize(l);
  for (index_type k = 0; k < lvector<T>::size(); k++)
    (*this)[k] = _val;
}
template<class T>
void lvector<T>::assign_remap(const lvector<T>& vec, const index_vec& map)
{
  assert(map.length() == vec.length());
  index_type m = 0;
  for (index_type k = 0; k < vec.length(); k++)
    if (map[k] != no_such_index)
      if (map[k] > m) m = map[k];
  set_length(m + 1);
  for (index_type k = 0; k < vec.length(); k++)
    if (map[k] != no_such_index)
      (*this)[map[k]] = vec[k];
}
template<class T>
void lvector<T>::remap(const index_vec& map)
{
  lvector v0(*this);
  assign_remap(v0, map);
}
template<class T>
void lvector<T>::assign_select(const lvector& _vec, const index_set& s)
{
  set_length(s.length());
  for (index_type k = 0; k < s.length(); k++)
    (*this)[k] = _vec[s[k]];
}
template<class T>
void lvector<T>::assign_select(const lvector& _vec, const bool_vec& s)
{
  clear();
  for (index_type k = 0; k < _vec.length(); k++)
    if (s[k]) append(_vec[k]);
}
template<class T>
const lvector<T>& lvector<T>::operator=(const lvector<T>& _vec)
{
  assign_copy(_vec);
  return _vec;
}
template<class T>
void lvector<T>::set_length(index_type l)
{
  std::vector<T>::resize(l);
}
template<class T>
void lvector<T>::set_length(index_type l, const T& v)
{
  std::vector<T>::resize(l, v);
}
template<class T>
void lvector<T>::inc_length_to(index_type l)
{
  if (std::vector<T>::size() < l)
    std::vector<T>::resize(l);
}
template<class T>
void lvector<T>::inc_length_to(index_type l, const T& v)
{
  if (std::vector<T>::size() < l)
    std::vector<T>::resize(l, v);
}
template<class T>
index_type lvector<T>::inc_length(index_type d)
{
  std::vector<T>::resize(std::vector<T>::size() + d);
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::inc_length(index_type d, const T& v)
{
  std::vector<T>::resize(std::vector<T>::size() + d, v);
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::dec_length(index_type d)
{
  assert(std::vector<T>::size() >= d);
  std::vector<T>::resize(std::vector<T>::size() - d);
  return std::vector<T>::size();
}
template<class T>
void lvector<T>::clear()
{
  std::vector<T>::clear();
}
template<class T>
void lvector<T>::append(const T& v)
{
  std::vector<T>::push_back(v);
}
template<class T>
void lvector<T>::append(const lvector<T>& v)
{
  for (index_type k = 0; k < v.size(); k++) append(v[k]);
}
template<class T>
T& lvector<T>::append()
{
  T v;
  std::vector<T>::push_back(v);
  return (*this)[std::vector<T>::size() - 1];
}
template<class T>
void lvector<T>::insert(const T& v, index_type p)
{
  if (p < lvector<T>::size()) {
    std::vector<T>::insert(std::vector<T>::begin() + p, v);
  }
  else {
    std::vector<T>::resize(p + 1);
    (*this)[p] = v;
  }
}
template<class T>
index_type lvector<T>::insert_ordered(const T& v, const order& o, index_type f)
{
  assert(f <= lvector<T>::size());
  for (index_type k = f; k < lvector<T>::size(); k++) {
    if (o(v, (*this)[k])) {
      insert(v, k);
      return k;
    }
  }
  append(v);
  return (lvector<T>::size() - 1);
}
template<class T>
index_type lvector<T>::insert_ordered(const lvector& vec, const order& o)
{
  if (vec.empty()) return no_such_index;
  index_type p0 = insert_ordered(vec[0], o);
  for (index_type k = 1; k < vec.size(); k++) {
    index_type p1 = insert_ordered(vec[k], o);
    if (p1 < p0) p0 = p1;
  }
  return p0;
}
template<class T>
void lvector<T>::remove(index_type p)
{
  if (p < lvector<T>::size())
    std::vector<T>::erase(std::vector<T>::begin() + p);
}
template<class T>
void lvector<T>::remove(index_type p0, index_type p1)
{
  assert(p0 < p1);
  if (p1 < lvector<T>::size())
    std::vector<T>::erase(std::vector<T>::begin() + p0,
     std::vector<T>::begin() + p1);
  else
    std::vector<T>::erase(std::vector<T>::begin() + p0,
     std::vector<T>::end());
}
template<class T>
void lvector<T>::remove(const bool_vec& s, index_vec& map)
{
  assert(s.size() >= lvector<T>::size());
  index_type scan_p = 0;
  index_type put_p = 0;
  index_vec rm_map(no_such_index, lvector<T>::size());
  while (scan_p < lvector<T>::size()) {
    if (!s[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      rm_map[scan_p] = put_p;
      put_p += 1;
    }
    else {
      rm_map[scan_p] = no_such_index;
    }
    scan_p += 1;
  }
  std::vector<T>::resize(put_p);
  for (index_type k = 0; k < map.size(); k++)
    if (map[k] != no_such_index) {
      assert(map[k] < rm_map.size());
      map[k] = rm_map[map[k]];
    }
}
template<class T>
void lvector<T>::remove(const bool_vec& s)
{
  assert(s.size() >= lvector<T>::size());
  index_type scan_p = 0;
  index_type put_p = 0;
  while (scan_p < lvector<T>::size()) {
    if (!s[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      put_p += 1;
    }
    scan_p += 1;
  }
  std::vector<T>::resize(put_p);
}
template<class T>
void lvector<T>::remove(const index_set& s)
{
  bool_vec s1(s, lvector<T>::size());
  remove(s1);
}
template<class T>
void lvector<T>::remove(const index_set& s, index_vec& map)
{
  bool_vec s1(s, std::vector<T>::size());
  lvector<T>::remove(s1, map);
}
template<class T>
void lvector<T>::remove_duplicate_elements()
{
  equivalence eq(lvector<T>::size());
  for (index_type i = 0; i < lvector<T>::size(); i++)
    for (index_type j = i+1; j < lvector<T>::size(); j++)
      if ((*this)[i] == (*this)[j])
 eq.merge(i, j);
  bool_vec s(false, lvector<T>::size());
  for (index_type i = 0; i < lvector<T>::size(); i++)
    if (eq.canonical(i) != i)
      s[i] = true;
  remove(s);
}
template<class T>
void lvector<T>::swap(index_type i, index_type j)
{
  T tmp = (*this)[i];
  (*this)[i] = (*this)[j];
  (*this)[j] = tmp;
}
template<class T>
void svector<T>::assign_singleton(const T& _val)
{
  lvector<T>::set_length(1);
  (*this)[0] = _val;
}
template<class T>
void svector<T>::assign_values(const lvector<T>& vec)
{
  lvector<T>::clear();
  for (index_type k = 0; k < vec.size(); k++)
    insert(vec[k]);
}
template<class T>
void svector<T>::insert(const T& v) {
  index_type i = 0;
  bool seeking = (i < std::vector<T>::size());
  while (seeking) {
    if ((*this)[i] < v) {
      i += 1;
      if (i >= std::vector<T>::size())
 seeking = false;
    }
    else {
      seeking = false;
    }
  }
  if (i < lvector<T>::size()) {
    if ((*this)[i] == v)
      return;
    else
      lvector<T>::insert(v, i);
  }
  else {
    lvector<T>::append(v);
  }
}
template<class T>
void svector<T>::insert(const lvector<T>& vec)
{
  for (index_type k = 0; k < vec.size(); k++) insert(vec[k]);
}
template<class T>
bool svector<T>::contains(const T& v) const
{
  index_type i = 0;
  while ((i < lvector<T>::size()) &&
  ((*this)[i] < v)) i += 1;
  if (i < lvector<T>::size())
    if ((*this)[i] == v) return true;
  return false;
}
template<class T>
bool svector<T>::contains(const svector& vec) const
{
  index_type v_i = 0;
  index_type i = 0;
  while (v_i < vec.size()) {
    if (i >= lvector<T>::size()) return false;
    if ((*this)[i] == vec[v_i]) {
      v_i += 1;
      i += 1;
    }
    else if ((*this)[i] > vec[v_i]) {
      return false;
    }
    else {
      while ((i < lvector<T>::size()) && ((*this)[i] < vec[v_i]))
 i += 1;
    }
  }
  return true;
}
template<class T>
bool svector<T>::subset(const svector& vec) const
{
  return vec.contains(*this);
}
template<class T>
void svector<T>::intersect(const svector& vec)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if (!vec.contains((*this)[i]))
      lvector<T>::remove(i);
    else
      i += 1;
  }
}
template<class T>
void svector<T>::difference(const svector& vec)
{
  svector d(vec);
  d.subtract(*this);
  subtract(vec);
  insert(d);
}
template<class T>
index_pair svector<T>::first_common(const lvector<T>& vec) const
{
  return lvector<T>::first_common(vec);
}
template<class T>
index_pair svector<T>::next_common(const lvector<T>& vec, index_pair p) const
{
  return lvector<T>::next_common(vec, p);
}
template<class T>
index_pair svector<T>::first_common(const svector<T>& vec) const
{
  index_type i = 0;
  index_type j = 0;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    else if
      ((*this)[i] < vec[j]) i += 1;
    else
      j += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_pair svector<T>::next_common(const svector<T>& vec, index_pair p) const
{
  index_type i = p.first + 1;
  index_type j = p.second + 1;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    else if ((*this)[i] < vec[j])
      i += 1;
    else
      j += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_type svector<T>::count_common(const svector& vec) const
{
  index_type i = 0;
  index_type j = 0;
  index_type c = 0;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j]) {
      c += 1;
      i += 1;
      j += 1;
    }
    else if ((*this)[i] < vec[j])
      i += 1;
    else
      j += 1;
  }
  return c;
}
template<class T>
void svector<T>::subtract(const svector& vec)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if (vec.contains((*this)[i]))
      lvector<T>::remove(i);
    else
      i += 1;
  }
}
template<class T>
void svector<T>::subtract(const T& v)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if ((*this)[i] == v) {
      lvector<T>::remove(i);
      return;
    }
    else {
      i += 1;
    }
  }
}
template<class T>
void matrix<T>::set_size(index_type r, index_type c)
{
  lvector<row_type>::set_length(r);
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].set_length(c);
}
template<class T>
void matrix<T>::assign_value(const T& _val)
{
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].assign_value(_val);
}
template<class T>
void matrix<T>::assign_value(const T& _val, index_type r, index_type c)
{
  lvector<row_type>::set_length(r);
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].assign_value(_val, c);
}
template<class T>
void swapable_pair<T>::swap()
{
  T tmp = this->first;
  this->first = this->second;
  this->second = tmp;
}
template<class T>
void comparable_pair<T>::sort_ascending()
{
  if (this->first > this->second) swapable_pair<T>::swap();
}
template<class T>
void comparable_pair<T>::sort_descending()
{
  if (this->first < this->second) swapable_pair<T>::swap();
}
template<class T, class N>
class weighted_vec<T,N>::decreasing_weight_order
  weighted_vec<T,N>::decreasing;
template<class T, class N>
class weighted_vec<T,N>::increasing_weight_order
  weighted_vec<T,N>::increasing;
template<class T, class N>
void weighted_vec<T,N>::insert_increasing(const weighted<T,N>& v)
{
  insert_ordered(v, increasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_decreasing(const weighted<T,N>& v)
{
  insert_ordered(v, decreasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_increasing(const T& v, const N& w)
{
  insert_ordered(weighted<T,N>(v, w), increasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_decreasing(const T& v, const N& w)
{
  insert_ordered(weighted<T,N>(v, w), decreasing);
}
template<class T, class N>
void weighted_set<T,N>::insert(const T& v, const N& w)
{
  index_type p = svector< weighted<T,N> >::first(v);
  if (p == no_such_index) {
    svector< weighted<T,N> >::insert(weighted<T,N>(v, w));
  }
  else {
    (*this)[p].weight += w;
  }
}
template<class T, class N>
void weighted_set<T,N>::insert(const T& v)
{
  index_type p = svector< weighted<T,N> >::first(v);
  if (p == no_such_index) {
    svector< weighted<T,N> >::insert(weighted<T,N>(v, 1));
  }
  else {
    (*this)[p].weight += 1;
  }
}
template<class T, class N>
index_type weighted_set<T,N>::arg_max()
{
  if (weighted_set<T,N>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < weighted_set<T,N>::size(); k++)
    if ((*this)[k].weight > (*this)[m].weight) m = k;
  return m;
}
template<class T, class N>
index_type weighted_set<T,N>::arg_min()
{
  if (weighted_set<T,N>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < weighted_set<T,N>::size(); k++)
    if ((*this)[k].weight < (*this)[m].weight) m = k;
  return m;
}
template<class T>
inline std::ostream& operator<<(std::ostream& s, const swapable_pair<T>& p)
{
  return s << '(' << p.first << ',' << p.second << ')';
}
template<class T>
::std::ostream& operator<<(::std::ostream& s, const lvector<T>& _vec)
{
  s << '[';
  for (index_type k = 0; k < _vec.size(); k++) {
    if (k > 0) s << ',';
    s << _vec[k];
  }
  s << ']';
  return s;
}
inline std::ostream& operator<<(std::ostream& s, const mapping& m)
{
  s << '{';
  for (index_type k = 0; k < m.length(); k++) {
    if (k > 0) s << ',';
    s << k << '-' << '>';
    if (m[k] == no_such_index)
      s << '_';
    else
      s << m[k];
  }
  return s << '}';
}
inline std::ostream& operator<<(std::ostream& s, const equivalence& eq)
{
  s << '{';
  bool first = true;
  for (index_type k = 0; k < eq.length(); k++) {
    index_type c = eq.canonical(k);
    if (!first) {
      s << ',';
    }
    else {
      first = false;
    }
    s << k << '=' << c;
  }
  return s << '}';
}
template<class T, class N>
std::ostream& operator<<(::std::ostream& s, const weighted<T,N>& w)
{
  s << '<' << w.value << ':' << w.weight << '>';
}
}
namespace hsps {
const index_set EMPTYSET;
index_vec_util::decreasing_index_order index_vec_util::decreasing;
index_vec_util::increasing_index_order index_vec_util::increasing;
void factors(index_type n, index_vec& f)
{
  f.set_length(0);
  bool prime = false;
  while (!prime) {
    prime = true;
    for (index_type k = 2; (k < (n/k)) && prime; k++) {
      if ((n % k) == 0) {
 f.append(k);
 n = n/k;
 prime = false;
      }
    }
  }
  if ((n > 1) || (f.length() == 0)) f.append(n);
}
void index_vec_util::fill(index_vec& vec, index_type max)
{
  vec.set_length(max);
  for (index_type k = 0; k < max; k++) vec[k] = k;
}
index_type index_vec_util::min(const index_vec& vec, index_type def)
{
  index_type a_max = vec.arg_max();
  if (a_max != no_such_index)
    return vec[a_max];
  else
    return def;
}
index_type index_vec_util::max(const index_vec& vec, index_type def)
{
  index_type a_max = vec.arg_max();
  if (a_max != no_such_index)
    return vec[a_max];
  else
    return def;
}
int index_vec_util::compare(const index_vec& v0, const index_vec& v1)
{
  if (v0.length() < v1.length()) return -1;
  if (v0.length() > v1.length()) return 1;
  for (index_type k = 0; k < v0.length(); k++) {
    if (v0[k] < v1[k]) return -1;
    if (v0[k] > v1[k]) return 1;
  }
  return 0;
}
index_type index_vec_util::hash(const index_vec& vec)
{
  index_type v = 0;
  for (index_type k = 0; k < vec.length(); k++)
    v = ((v + (vec[k] * k)) % LARGE_PRIME);
  return v;
}
int index_vec_util::compare(const index_vec& v1) const
{
  return compare(*this, v1);
}
void index_vec_util::fill(index_type max)
{
  fill(*this, max);
}
index_type index_vec_util::hash() const
{
  return hash(*this);
}
index_set::index_set(const bool* _arr, index_type n)
{
  for (index_type k = 0; k < n; k++)
    if (_arr[k]) append(k);
}
index_set::index_set(const bool_vec& _vec)
{
  for (index_type k = 0; k < _vec.length(); k++)
    if (_vec[k]) append(k);
}
index_set::index_set(const index_set& s0, const index_set& s)
{
  for (index_type k = 0; k < s.length(); k++) {
    assert(s[k] < s0.length());
    append(s0[s[k]]);
  }
}
index_set::index_set(const index_set& s0, const bool_vec& s)
{
  assert(s.length() >= s0.length());
  for (index_type k = 0; k < s0.length(); k++) if (s[k]) {
    append(s0[k]);
  }
}
index_set::index_set(const index_set& s0, const index_vec& map)
{
  for (index_type k = 0; k < s0.length(); k++) {
    assert(s0[k] < map.length());
    if (map[s0[k]] != no_such_index)
      insert(map[s0[k]]);
  }
}
void index_set::insert(const index_type& v)
{
  svector<index_type>::insert(v);
}
void index_set::insert(const index_vec& vec)
{
  svector<index_type>::insert(vec);
}
void index_set::insert(const bool_vec& set)
{
  for (index_type k = 0; k < set.length(); k++)
    if (set[k]) insert(k);
}
void index_set::intersect(const index_set& set)
{
  svector<index_type>::intersect(set);
}
void index_set::intersect(const bool_vec& set)
{
  index_type k = 0;
  while (k < size()) {
    if ((*this)[k] < set.length()) {
      if (!set[(*this)[k]]) {
 remove(k);
      }
      else {
 k += 1;
      }
    }
    else {
      remove(k, length());
    }
  }
}
void index_set::subtract(const index_vec& vec)
{
  svector<index_type>::subtract(vec);
}
void index_set::subtract(const bool_vec& set)
{
  index_type k = 0;
  while (k < length()) {
    if ((*this)[k] < set.length()) {
      if (set[k]) {
 remove(k);
      }
      else {
 k += 1;
      }
    }
  }
}
void index_set::subtract(const index_type& v)
{
  svector<index_type>::subtract(v);
}
void index_set::fill(index_type max)
{
  index_vec_util::fill(*this, max);
}
void index_set::assign_remap
(const index_set& set, const index_vec& map)
{
  clear();
  for (index_type k = 0; k < set.length(); k++) {
    assert(set[k] < map.length());
    if (map[set[k]] != no_such_index)
      insert(map[set[k]]);
  }
}
void index_set::remap(const index_vec& map)
{
  index_set s0(*this);
  assign_remap(s0, map);
}
index_type index_set::first_common_element(const index_set& vec) const
{
  index_pair p = svector<index_type>::first_common(vec);
  if (p.first != no_such_index)
    return (*this)[p.first];
  else
    return no_such_index;
}
index_type index_set::first_common_element(const index_vec& vec) const
{
  index_pair p = svector<index_type>::first_common(vec);
  if (p.first != no_such_index)
    return (*this)[p.first];
  else
    return no_such_index;
}
bool index_set::have_common_element(const index_set& vec) const
{
  return (first_common_element(vec) != no_such_index);
}
bool index_set::have_common_element(const bool_vec& set) const
{
  return (first_common_element(set) != no_such_index);
}
index_type index_set::first_common_element(const bool_vec vec) const
{
  for (index_type i = 0; i < length(); i++) {
    if ((*this)[i] < vec.length()) {
      if (vec[(*this)[i]])
 return (*this)[i];
    }
    else {
      return no_such_index;
    }
  }
  return no_such_index;
}
index_type index_set::first_common_element(const bool* vec, index_type n) const
{
  for (index_type i = 0; i < length(); i++) {
    if ((*this)[i] < n) {
      if (vec[(*this)[i]])
 return (*this)[i];
    }
    else {
      return no_such_index;
    }
  }
  return no_such_index;
}
index_type index_set::count_common(const index_set& vec) const
{
  return svector<index_type>::count_common(vec);
}
index_type index_set::count_common(const bool_vec& set) const
{
  index_type c = 0;
  for (index_type k = 0; k < size(); k++)
    if ((*this)[k] < set.length())
      if (set[(*this)[k]]) c += 1;
  return c;
}
bool* index_set::copy_to(bool* s, index_type n) const
{
  for (index_type k = 0; k < n; k++)
    s[k] = false;
  for (index_type k = 0; k < size(); k++)
    if ((*this)[k] < n) s[(*this)[k]] = true;
  return s;
}
bool_vec::bool_vec(const index_set& set, index_type l)
  : lvector<bool>(false, l)
{
  for (index_type k = 0; k < set.length(); k++) {
    if (set[k] < l) (*this)[set[k]] = true;
  }
}
void bool_vec::complement()
{
  for (index_type i = 0; i < length(); i++) (*this)[i] = !((*this)[i]);
}
void bool_vec::insert(const bool_vec& vec)
{
  for (index_type i = 0; i < length(); i++) if (vec[i]) (*this)[i] = true;
}
void bool_vec::insert(const index_set& set)
{
  for (index_type i = 0; i < set.length(); i++) {
    assert(set[i] < length());
    (*this)[set[i]] = true;
  }
}
void bool_vec::intersect(const bool_vec& vec)
{
  for (index_type i = 0; i < length(); i++) if (!vec[i]) (*this)[i] = false;
}
void bool_vec::intersect(const index_set& set)
{
  for (index_type i = 0; i < length(); i++)
    if (!set.contains(i)) (*this)[i] = false;
}
void bool_vec::subtract(const bool_vec& vec)
{
  for (index_type i = 0; i < length(); i++) if (vec[i]) (*this)[i] = false;
}
void bool_vec::subtract(const index_set& set)
{
  for (index_type i = 0; i < set.length(); i++) {
    assert(set[i] < length());
    (*this)[set[i]] = false;
  }
}
bool bool_vec::subset(const bool_vec& vec) const
{
  assert(length() == vec.length());
  for (index_type i = 0; i < length(); i++)
    if ((*this)[i] && !vec[i]) return false;
  return true;
}
bool bool_vec::strict_subset(const bool_vec& vec) const
{
  assert(length() == vec.length());
  bool strict = false;
  for (index_type i = 0; i < length(); i++) {
    if ((*this)[i] && !vec[i]) return false;
    if (vec[i] && !(*this)[i]) strict = true;
  }
  return strict;
}
bool bool_vec::superset(const bool_vec& vec) const
{
  assert(length() == vec.length());
  for (index_type i = 0; i < length(); i++)
    if (!(*this)[i] && vec[i]) return false;
  return true;
}
bool bool_vec::strict_superset(const bool_vec& vec) const
{
  assert(length() == vec.length());
  bool strict = false;
  for (index_type i = 0; i < length(); i++) {
    if (!(*this)[i] && vec[i]) return false;
    if (!vec[i] && (*this)[i]) strict = true;
  }
  return strict;
}
bool bool_vec::contains(const bool& v) const
{
  for (index_type k = 0; k < length(); k++)
    if ((*this)[k] == v) return true;
  return false;
}
bool bool_vec::contains(const bool_vec& set) const
{
  index_type n = (set.length() > length() ? set.length() : length());
  for (index_type k = 0; k < n; k++)
    if (set[k] && !(*this)[k]) return false;
  return true;
}
bool bool_vec::contains(const index_set& set) const
{
  for (index_type k = 0; k < set.length(); k++)
    if (!(*this)[set[k]]) return false;
  return true;
}
bool bool_vec::contains_any(const index_set& set) const
{
  for (index_type k = 0; k < set.length(); k++)
    if ((*this)[set[k]]) return true;
  return false;
}
index_type bool_vec::first_common_element(const index_set& vec) const
{
  return vec.first_common_element(*this);
}
index_type bool_vec::first_common_element(const bool_vec vec) const
{
  for (index_type k = 0; (k < length()) && (k < vec.length()); k++)
    if ((*this)[k] && vec[k])
      return k;
  return no_such_index;
}
index_type bool_vec::count_common(const bool_vec& vec) const
{
  index_type c = 0;
  index_type l = (size() < vec.size() ? size() : vec.size());
  for (index_type k = 0; k < l; k++)
    if ((*this)[k] && vec[k]) c += 1;
  return c;
}
index_type bool_vec::count_common(const index_set& set) const
{
  return set.count_common(*this);
}
index_set& bool_vec::copy_to(index_set& set) const
{
  set.set_length(0);
  for (index_type i = 0; i < length(); i++) if ((*this)[i]) set.insert(i);
  return set;
}
index_set& bool_vec::insert_into(index_set& set) const
{
  for (index_type i = 0; i < length(); i++) if ((*this)[i]) set.insert(i);
  return set;
}
index_set& bool_vec::subtract_from(index_set& set) const
{
  for (index_type i = 0; i < length(); i++) if ((*this)[i]) set.subtract(i);
  return set;
}
bool* bool_vec::copy_to(bool* s, index_type n) const
{
  for (index_type i = 0; i < n; i++) s[i] = (*this)[i];
}
int bool_vec::compare(const bool_vec& vec) const
{
  if (length() < vec.length()) return -1;
  if (length() > vec.length()) return 1;
  for (index_type k = 0; k < length(); k++) {
    if (vec[k] && !(*this)[k]) return -1;
    if (!vec[k] && (*this)[k]) return 1;
  }
  return 0;
}
index_type bool_vec::hash() const
{
  index_type v = 0;
  index_type vi = 0;
  for (index_type k = 0; k < length(); k++) {
    if ((*this)[k]) vi += (1 << (k % (32 - 1)));
    if ((k % (32 - 1)) == 0) {
      v += vi;
      vi = 0;
    }
  }
}
void mapping::delete_index_map
(index_type n, index_type i, index_vec& map)
{
  assert(i < n);
  index_vec_util::fill(map, n);
  map[i] = no_such_index;
  for (index_type k = i + 1; k < n; k++)
    map[k] = (k - 1);
}
bool mapping::invert_map(const index_vec& map, index_vec& inv, index_type m)
{
  index_type n = m;
  for (index_type k = 0; k < map.length(); k++)
    if (map[k] != no_such_index)
      if (map[k] > n) n = map[k];
  inv.assign_value(no_such_index, n + 1);
  bool ok = true;
  for (index_type k = 0; k < map.length(); k++)
    if (map[k] != no_such_index) {
      if (inv[map[k]] == no_such_index)
 inv[map[k]] = k;
      else
 ok = false;
    }
  return ok;
}
void mapping::compose
(const index_vec& m0, const index_vec& m1, index_vec& cm)
{
  cm.set_length(m0.length());
  for (index_type k = 0; k < m0.length(); k++)
    if (m0[k] != no_such_index) {
      assert(m0[k] < m1.length());
      cm[k] = m1[m0[k]];
    }
    else {
      cm[k] = no_such_index;
    }
}
void mapping::map_image
(const index_vec& map, const index_vec& vec, index_vec& img)
{
  img.clear();
  for (index_type k = 0; k < vec.length(); k++) {
    assert(vec[k] < map.length());
    if (map[vec[k]] != no_such_index)
      img.append(map[vec[k]]);
  }
}
void mapping::inverse_map_image
(const index_vec& map, index_type v, index_set& img)
{
  img.clear();
  for (index_type k = 0; k < map.length(); k++)
    if (map[k] == v)
      img.insert(k);
}
void mapping::inverse_map_image
(const index_vec& map, const index_set& vs, index_set& img)
{
  img.clear();
  for (index_type k = 0; k < map.length(); k++)
    if (vs.contains(map[k]))
      img.insert(k);
}
index_type mapping::range(const index_vec& map, index_type d)
{
  if (d == 0) return 0;
  assert(map.length() >= d);
  index_type m = 0;
  for (index_type k = 0; k <= (d - 1); k++)
    if (map[k] != no_such_index)
      if (map[k] > m) m = map[k];
  return m + 1;
}
void sparse_mapping::dense_to_sparse
(const index_vec& dm, pair_vec sm)
{
  sm.clear();
  for (index_type k = 0; k < dm.length(); k++)
    if (dm[k] != no_such_index)
      sm.append(index_pair(k, dm[k]));
}
void sparse_mapping::sparse_to_dense
(const pair_vec& sm, index_vec dm)
{
  dm.clear();
  index_type m = no_such_index;
  for (index_type k = 0; k < sm.length(); k++)
    if ((m == no_such_index) || (sm[k].first > m))
      m = sm[k].first;
  dm.assign_value(no_such_index, m);
  for (index_type k = 0; k < sm.length(); k++)
    if (dm[sm[k].first] == no_such_index)
      dm[sm[k].first] = sm[k].second;
}
index_type sparse_mapping::map_image
(const pair_vec& map, index_type x)
{
  for (index_type k = 0; k < map.length(); k++)
    if (map[k].first == x)
      return map[k].second;
    else if (map[k].first > x)
      return no_such_index;
  return no_such_index;
}
void sparse_mapping::map_image
(const pair_vec& map, const index_vec& vec, index_vec& img)
{
  img.clear();
  for (index_type k = 0; k < vec.length(); k++) {
    index_type i = map_image(map, vec[k]);
    if (i != no_such_index)
      img.append(i);
  }
}
void sparse_mapping::inverse_map_image
(const pair_vec& map, index_type x, index_set& img)
{
  img.clear();
  for (index_type k = 0; k < map.length(); k++)
    if (map[k].second == x)
      img.insert(map[k].first);
}
void sparse_mapping::inverse_map_image
(const pair_vec& map, const index_set& x, index_set& img)
{
  img.clear();
  for (index_type k = 0; k < map.length(); k++)
    if (x.contains(map[k].second))
      img.insert(map[k].first);
}
index_type index_set_vec::minimum_cardinality() const
{
  if (length() == 0) return no_such_index;
  index_type lmin = (*this)[0].length();
  for (index_type k = 1; k < length(); k++)
    if ((*this)[k].length() < lmin)
      lmin = (*this)[k].length();
  return lmin;
}
index_type index_set_vec::maxmimum_cardinality() const
{
  if (length() == 0) return no_such_index;
  index_type lmax = (*this)[0].length();
  for (index_type k = 1; k < length(); k++)
    if ((*this)[k].length() > lmax)
      lmax = (*this)[k].length();
  return lmax;
}
index_type index_set_vec::selected_minimum_cardinality
(const index_set& sel) const
{
  if (sel.length() == 0) return no_such_index;
  assert(sel[0] < length());
  index_type lmin = (*this)[sel[0]].length();
  for (index_type k = 1; k < sel.length(); k++) {
    assert(sel[k] < length());
    if ((*this)[sel[k]].length() < lmin)
      lmin = (*this)[sel[k]].length();
  }
  return lmin;
}
index_type index_set_vec::selected_maximum_cardinality
(const index_set& sel) const
{
  if (sel.length() == 0) return no_such_index;
  assert(sel[0] < length());
  index_type lmax = (*this)[sel[0]].length();
  for (index_type k = 1; k < sel.length(); k++) {
    assert(sel[k] < length());
    if ((*this)[sel[k]].length() > lmax)
      lmax = (*this)[sel[k]].length();
  }
  return lmax;
}
index_type index_set_vec::first_minimum_cardinality_set() const
{
  if (length() == 0) return no_such_index;
  index_type lmin = (*this)[0].length();
  index_type imin = 0;
  for (index_type k = 1; k < length(); k++)
    if ((*this)[k].length() < lmin) {
      lmin = (*this)[k].length();
      imin = k;
    }
  return imin;
}
index_type index_set_vec::first_maxmimum_cardinality_set() const
{
  if (length() == 0) return no_such_index;
  index_type lmax = (*this)[0].length();
  index_type imax = 0;
  for (index_type k = 1; k < length(); k++)
    if ((*this)[k].length() > lmax) {
      lmax = (*this)[k].length();
      imax = k;
    }
  return imax;
}
index_type index_set_vec::first_superset(const index_set& set) const
{
  index_type k = 0;
  while (k < length()) {
    if ((*this)[k].contains(set))
      return k;
    k += 1;
  }
  return no_such_index;
}
index_type index_set_vec::first_strict_superset(const index_set& set) const
{
  index_type k = 0;
  while (k < length()) {
    if ((*this)[k].contains(set) && !set.contains((*this)[k]))
      return k;
    k += 1;
  }
  return no_such_index;
}
index_type index_set_vec::first_subset(const index_set& set) const
{
  index_type k = 0;
  while (k < length()) {
    if (set.contains((*this)[k]))
      return k;
    k += 1;
  }
  return no_such_index;
}
index_type index_set_vec::first_strict_subset(const index_set& set) const
{
  index_type k = 0;
  while (k < length()) {
    if (set.contains((*this)[k]) && !(*this)[k].contains(set))
      return k;
    k += 1;
  }
  return no_such_index;
}
index_set& index_set_vec::union_set(index_set& set) const
{
  set.clear();
  for (index_type k = 0; k < length(); k++)
    set.insert((*this)[k]);
  return set;
}
index_set& index_set_vec::selected_union_set
(const index_set& sel, index_set& set) const
{
  set.clear();
  for (index_type k = 0; k < sel.length(); k++) {
    assert(sel[k] < length());
    set.insert((*this)[sel[k]]);
  }
  return set;
}
index_set& index_set_vec::intersection_set(index_set& set) const
{
  if (length() == 0) {
    set.clear();
    return set;
  }
  set.assign_copy((*this)[0]);
  for (index_type k = 1; k < length(); k++)
    set.intersect((*this)[k]);
  return set;
}
void index_set_vec::append_if_not_subset(const index_set& set)
{
  for (index_type k = 0; k < length(); k++)
    if ((*this)[k].contains(set)) return;
  append(set);
}
void index_set_vec::append_if_not_superset(const index_set& set)
{
  for (index_type k = 0; k < length(); k++)
    if (set.contains((*this)[k])) return;
  append(set);
}
void index_set_vec::append_if_new(const index_set& set)
{
  for (index_type k = 0; k < length(); k++)
    if (set == (*this)[k]) return;
  append(set);
}
void index_set_vec::insert_maximal(const index_set& set)
{
  for (index_type k = 0; k < length(); k++)
    if ((*this)[k].contains(set)) return;
  index_type r = 0;
  index_type w = 0;
  while (r < length()) {
    if (!set.contains((*this)[r])) {
      if (w < r) (*this)[w] = (*this)[r];
      w += 1;
    }
    r += 1;
  }
  set_length(w);
  append(set);
}
void index_set_vec::insert_minimal(const index_set& set)
{
  for (index_type k = 0; k < length(); k++)
    if (set.contains((*this)[k])) return;
  index_type r = 0;
  index_type w = 0;
  while (r < length()) {
    if (!(*this)[r].contains(set)) {
      if (w < r) (*this)[w] = (*this)[r];
      w += 1;
    }
    r += 1;
  }
  set_length(w);
  append(set);
}
void index_set_vec::reduce_to_maximal()
{
  bool_vec d(false, length());
  for (index_type i = 0; i < length(); i++) if (!d[i])
    for (index_type j = 0; j < length(); j++) if ((j != i) && !d[j])
      if ((*this)[i].contains((*this)[j]))
 d[j] = true;
  assert(d.count(false) > 0);
  remove(d);
}
void index_set_vec::reduce_to_minimal()
{
  bool_vec d(false, length());
  for (index_type i = 0; i < length(); i++) if (!d[i])
    for (index_type j = 0; j < length(); j++) if ((j != i) && !d[j])
      if ((*this)[j].contains((*this)[i]))
 d[j] = true;
  assert(d.count(false) > 0);
  remove(d);
}
void index_set_vec::remove_sets_size_le(index_type l)
{
  index_type r = 0;
  index_type w = 0;
  while (r < length()) {
    if ((*this)[r].length() > l) {
      if (w < r) (*this)[w] = (*this)[r];
      w += 1;
    }
    r += 1;
  }
  set_length(w);
}
void index_set_vec::remove_empty_sets()
{
  index_type r = 0;
  index_type w = 0;
  while (r < length()) {
    if (!(*this)[r].empty()) {
      if (w < r) (*this)[w] = (*this)[r];
      w += 1;
    }
    r += 1;
  }
  set_length(w);
}
void index_set_vec::insert_in_all(index_type i)
{
  for (index_type k = 0; k < length(); k++)
    (*this)[k].insert(i);
}
void index_set_vec::insert_in_all(const index_set& set)
{
  for (index_type k = 0; k < length(); k++)
    (*this)[k].insert(set);
}
void index_set_vec::subtract_from_all(index_type i)
{
  for (index_type k = 0; k < length(); k++)
    (*this)[k].subtract(i);
}
void index_set_vec::subtract_from_all(const index_set& set)
{
  for (index_type k = 0; k < length(); k++)
    (*this)[k].subtract(set);
}
void index_set_vec::combinations_by_union(const index_set_vec& sv)
{
  index_type l = length();
  index_type k = 0;
  while (k < sv.length()) {
    index_type i_from = length() - l;
    index_type i_to = length();
    if (k < (sv.length() - 1)) {
      for (index_type i = i_from; i < i_to; i++)
 append((*this)[i]);
    }
    for (index_type i = i_from; i < i_to; i++)
      (*this)[i].insert(sv[k]);
    k += 1;
  }
  if (sv.length() == 0) clear();
}
void index_set_vec::combinations_by_union
(const index_set_vec& sv1, const index_set_vec& sv2)
{
  for (index_type i = 0; i < sv1.length(); i++)
    for (index_type j = 0; j < sv2.length(); j++) {
      append(sv1[i]);
      (*this)[length() - 1].insert(sv2.length());
    }
}
void bool_matrix::complement()
{
  for (index_type i = 0; i < rows(); i++)
    for (index_type j = 0; j < columns(); j++)
      (*this)[i][j] = !((*this)[i][j]);
}
void bool_matrix::insert(const bool_matrix& m)
{
  assert(m.rows() == rows());
  assert(m.columns() == columns());
  for (index_type i = 0; i < rows(); i++)
    for (index_type j = 0; j < columns(); j++)
      if (m[i][j])
 (*this)[i][j] = true;
}
void bool_matrix::intersect(const bool_matrix& m)
{
  assert(m.rows() == rows());
  assert(m.columns() == columns());
  for (index_type i = 0; i < rows(); i++)
    for (index_type j = 0; j < columns(); j++)
      if (!m[i][j])
 (*this)[i][j] = false;
}
void bool_matrix::subtract(const bool_matrix& m)
{
  assert(m.rows() == rows());
  assert(m.columns() == columns());
  for (index_type i = 0; i < rows(); i++)
    for (index_type j = 0; j < columns(); j++)
      if (m[i][j])
 (*this)[i][j] = false;
}
void bool_matrix::multiply(const bool_matrix& m0, const bool_matrix& m1)
{
  assert(m0.columns() == m1.rows());
  set_size(m0.rows(), m1.columns());
  for (index_type i = 0; i < rows(); i++)
    for (index_type j = 0; j < columns(); j++) {
      bool p = false;
      for (index_type k = 0; (k < m0.columns()) && !p; k++)
 if (m0[i][k] && m1[k][j]) p = true;
      (*this)[i][j] = p;
    }
}
void bool_matrix::transitive_closure()
{
  assert(rows() == columns());
  for (index_type k = 0; k < rows(); k++)
    for (index_type i = 0; i < rows(); i++)
      if ((*this)[i][k])
 for (index_type j = 0; j < rows(); j++)
   if ((*this)[k][j])
     (*this)[i][j] = true;
}
bool equivalence::operator()(index_type a, index_type b) const
{
  return (canonical(a) == canonical(b));
}
index_type equivalence::canonical(index_type a) const
{
  assert(a < length());
  index_type x = a;
  index_type y = (*this)[x];
  while ((x != y) && (y != no_such_index)) {
    x = y;
    y = (*this)[x];
  }
  if (y == no_such_index) return a;
  else return y;
}
void equivalence::extend(index_type a)
{
  for (index_type k = length(); k < a; k++) append(k);
}
void equivalence::merge(index_type a, index_type b)
{
  index_type c_a = canonical(a);
  index_type c_b = canonical(b);
  ((*this)[c_a]) = c_b;
}
void equivalence::merge(const index_set& set)
{
  for (index_type i = 1; i < set.length(); i++)
    merge(set[0], set[i]);
}
void equivalence::merge(const index_set& sa, const index_set& sb)
{
  for (index_type i = 0; i < sa.length(); i++)
    for (index_type j = 0; j < sb.length(); j++)
      merge(sa[i], sb[j]);
}
void equivalence::merge(const equivalence& eq)
{
  for (index_type k = 0; k < eq.length(); k++) {
    index_type i = eq.canonical(k);
    if (i != k) merge(i, k);
  }
}
void equivalence::reset()
{
  for (index_type k = 0; k < length(); k++) ((*this)[k]) = k;
}
void equivalence::reset(index_type n)
{
  set_length(n);
  reset();
}
void equivalence::canonical_set(index_set& set) const
{
  index_set tmp(set);
  set.clear();
  for (index_type k = 0; k < tmp.length(); k++)
    set.insert(canonical(tmp[k]));
}
index_type equivalence::n_squeezed() const
{
  index_type n = 0;
  for (index_type k = 0; k < length(); k++) if (canonical(k) != k) n += 1;
  return n;
}
index_type equivalence::n_classes() const
{
  index_type n = 0;
  for (index_type k = 0; k < length(); k++) if (canonical(k) == k) n += 1;
  return n;
}
void equivalence::canonical_elements(index_set& set) const
{
  for (index_type k = 0; k < length(); k++)
    if (canonical(k) == k) set.insert(k);
}
void equivalence::class_elements(index_type c, index_set& set) const
{
  for (index_type k = 0; k < length(); k++)
    if (canonical(k) == c) set.insert(k);
}
void equivalence::classes(index_set_vec& sets) const
{
  index_set c;
  canonical_elements(c);
  sets.assign_value(EMPTYSET, c.length());
  for (index_type k = 0; k < c.length(); k++)
    class_elements(c[k], sets[k]);
}
index_type equivalence::n_class_elements(index_type c) const
{
  index_type n = 0;
  for (index_type k = 0; k < length(); k++)
    if (canonical(k) == c) n += 1;
  return n;
}
void equivalence::make_map(index_vec& map) const
{
  index_set ce;
  canonical_elements(ce);
  map.assign_value(no_such_index, length());
  for (index_type k = 0; k < length(); k++) {
    index_type c = canonical(k);
    map[k] = ce.first(c);
  }
}
void set_hash_function::init(index_type n)
{
  resize(n);
  if (n == 0) return;
  (*this)[0] = 1;
  for (index_type k = 1; k < size(); k++) {
    (*this)[k] = ((2 * (*this)[k - 1]) % LARGE_PRIME);
  }
}
index_type set_hash_function::operator()(index_type& i, index_type v) const
{
  assert(i < size());
  return ((v + (*this)[i]) % LARGE_PRIME);
}
index_type set_hash_function::operator()(const index_set& set) const
{
  index_type h = 0;
  for (index_type k = 0; k < set.length(); k++) {
    assert(set[k] < size());
    h = ((h + (*this)[set[k]]) % LARGE_PRIME);
  }
  return h;
}
index_type set_hash_function::operator()(const bool_vec& set) const
{
  assert(set.size() <= size());
  index_type h = 0;
  for (index_type k = 0; k < set.length(); k++) {
    if (set[k]) h = ((h + (*this)[k]) % LARGE_PRIME);
  }
  return h;
}
index_type set_hash_function::operator()(const bool* set, index_type n) const
{
  assert(n <= size());
  index_type h = 0;
  for (index_type k = 0; k < n; k++) {
    if (set[k]) h = ((h + (*this)[k]) % LARGE_PRIME);
  }
  return h;
}
}
