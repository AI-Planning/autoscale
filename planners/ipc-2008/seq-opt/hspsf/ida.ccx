#include <string.h>
inline char* strndup(char* s, unsigned int n)
{
  char* d = new char[n+1];
  strncpy(s, d, n);
  return d;
}
#include <assert.h>
#include <limits.h>
#include <vector>
#include <utility>
#include <iostream>
namespace hsps {
typedef unsigned int index_type;
const index_type index_type_max = (UINT_MAX - 1);

const index_type LARGE_PRIME = 2147483629U;
const index_type no_such_index = UINT_MAX;

typedef unsigned long count_type;
const count_type count_type_max = ULONG_MAX;

template<class T> class swapable_pair : public std::pair<T, T>
{
 public:
  swapable_pair()
    : std::pair<T, T>() { };
  swapable_pair(const T& v1, const T& v2)
    : std::pair<T, T>(v1, v2) { };
  swapable_pair(const T& v)
    : std::pair<T, T>(v, v) { };
  swapable_pair(const swapable_pair& p)
    : std::pair<T, T>(p) { };

  void swap();
};

template<class T> class comparable_pair : public swapable_pair<T>
{
 public:
  comparable_pair()
    : swapable_pair<T>() { };
  comparable_pair(const T& v1, const T& v2)
    : swapable_pair<T>(v1, v2) { };
  comparable_pair(const T& v)
    : swapable_pair<T>(v) { };
  comparable_pair(const comparable_pair& p)
    : swapable_pair<T>(p) { };

  void sort_ascending();
  void sort_descending();
};

typedef comparable_pair<index_type> index_pair;

template<class T> class zero_init_pair : public comparable_pair<T>
{
 public:
  zero_init_pair()
    : comparable_pair<T>(0) { };
  zero_init_pair(const T& v1, const T& v2)
    : comparable_pair<T>(v1, v2) { };
  zero_init_pair(const T& v)
    : comparable_pair<T>(v) { };
  zero_init_pair(const zero_init_pair& p)
    : comparable_pair<T>(p) { };
};




class index_set;
class bool_vec;

template<class T> class lvector : public std::vector<T>
{
 public:
  lvector() : std::vector<T>() { };
  lvector(const T& v, index_type l) : std::vector<T>(l, v) { };
  lvector(const lvector<T>& vec) : std::vector<T>(vec) { };




  class element_reference {
    lvector* _vec;
    index_type _pos;
  public:
    element_reference() : _vec(0), _pos(no_such_index) { };
    element_reference(lvector& v, index_type p) : _vec(&v), _pos(p) { };
    operator T*() const {
      if (_vec == 0) return 0;
      return &((*_vec)[_pos]);
    };
  };

  class order {
   public:
    virtual bool operator()(const T& v0, const T& v1) const = 0;
  };

  index_type length() const;
  bool contains(const T& v) const;
  index_type first(const T& v) const;
  index_type next(const T& v, index_type i) const;
  index_type find(const T& v, bool_vec& s) const;
  index_type count(const T& v) const;
  index_type arg_max() const;
  index_type arg_min() const;
  index_type arg_first(const order& o) const;
  index_type arg_last(const order& o) const;
  index_pair first_common(const lvector<T>& vec) const;
  index_pair next_common(const lvector<T>& vec, index_pair p) const;
  void difference(const lvector& v1, lvector& d0, lvector& d1);
  bool operator==(const lvector& _vec) const;
  bool operator!=(const lvector& _vec) const;
  bool operator<(const lvector& vec) const;
  bool operator>(const lvector& vec) const;
  bool operator<=(const lvector& vec) const;
  bool operator>=(const lvector& vec) const;
  void assign_copy(const lvector& _vec);
  void assign_copy(const T* _arr, index_type n);
  void assign_value(const T& val);
  void assign_value(const T& val, index_type l);
  void assign_remap(const lvector& vec, const lvector<index_type>& map);
  void remap(const lvector<index_type>& map);
  void assign_select(const lvector& _vec, const index_set& s);
  void assign_select(const lvector& _vec, const bool_vec& s);
  const lvector& operator=(const lvector& _vec);
  void set_length(index_type l);
  void set_length(index_type l, const T& v);
  void inc_length_to(index_type l);
  void inc_length_to(index_type l, const T& v);
  index_type inc_length() { return inc_length(1); };
  index_type inc_length(index_type d);
  index_type inc_length(index_type d, const T& v);
  index_type dec_length() { return dec_length(1); };
  index_type dec_length(index_type d);
  void clear();
  void append(const T& v);
  void append(const lvector& v);
  T& append();
  void insert(const T& v, index_type p);
  index_type insert_ordered(const T& v, const order& o, index_type f = 0);
  index_type insert_ordered(const lvector& vec, const order& o);
  void remove(index_type p);
  void remove(index_type p0, index_type p1);
  void remove(const index_set& s);
  void remove(const index_set& s, lvector<index_type>& map);
  void remove(const bool_vec& s);
  void remove(const bool_vec& s, lvector<index_type>& map);
  void remove_duplicate_elements();
  void swap(index_type i, index_type j);
};
template<class T> class auto_expanding_vector : public lvector<T>
{
  T _default;
 public:
  auto_expanding_vector() : lvector<T>() { };
  auto_expanding_vector(const T& v, index_type l)
    : lvector<T>(v, l), _default(v) { };
  auto_expanding_vector(const lvector<T>& vec)
    : lvector<T>(vec) { };
  auto_expanding_vector(const auto_expanding_vector<T>& vec)
    : lvector<T>(vec), _default(vec._default) { };
  typename std::vector<T>::reference
  operator[](typename std::vector<T>::size_type k)
  {
    this->inc_length_to(k + 1, _default);
    return lvector<T>::operator[](k);
  };
  typename std::vector<T>::const_reference
  operator[](typename std::vector<T>::size_type k) const
  {
    if (k >= std::vector<T>::size())
      return _default;
    else
      return lvector<T>::operator[](k);
  };
  void assign_value(const T& val)
  {
    _default = val;
    lvector<T>::assign_value(val);
  };
  void assign_value(const T& val, index_type l)
  {
    _default = val;
    lvector<T>::assign_value(val, l);
  };
};
typedef lvector<index_type> index_vec;
typedef lvector<index_pair> pair_vec;
class index_vec_util : public index_vec
{
 public:
  class decreasing_index_order : public index_vec::order {
  public:
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      { return (v0 > v1); };
  };
  class increasing_index_order : public index_vec::order {
  public:
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      { return (v0 < v1); };
  };
  class increasing_value_order : public index_vec::order {
    const index_vec& value;
  public:
    increasing_value_order(const index_vec& v) : value(v) { };
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      {
 assert(v0 < value.length());
 assert(v1 < value.length());
 return (value[v0] < value[v1]);
      };
  };
  static class decreasing_index_order decreasing;
  static class increasing_index_order increasing;
  static void fill(index_vec& vec, index_type max);
  static index_type min(const index_vec& vec, index_type def = no_such_index);
  static index_type max(const index_vec& vec, index_type def = no_such_index);
  static int compare(const index_vec& v0, const index_vec& v1);
  static index_type hash(const index_vec& vec);
  void fill(index_type max);
  int compare(const index_vec& v1) const;
  index_type hash() const;
};
void factors(index_type n, index_vec& f);
template<class T> class svector : public lvector<T>
{
 public:
  svector() : lvector<T>() { };
  svector(const svector<T>& _svec) : lvector<T>(_svec) { };
  svector(const lvector<T>& _lvec) : lvector<T>() {
    for (index_type k = 0; k < _lvec.size(); k++) insert(_lvec[k]);
  };
  bool contains(const T& v) const;
  bool contains(const svector& vec) const;
  bool subset(const svector& vec) const;
  index_pair first_common(const lvector<T>& vec) const;
  index_pair next_common(const lvector<T>& vec, index_pair p) const;
  index_pair first_common(const svector<T>& vec) const;
  index_pair next_common(const svector<T>& vec, index_pair p) const;
  index_type count_common(const svector& vec) const;
  void assign_singleton(const T& _val);
  void assign_values(const lvector<T>& vec);
  void insert(const T& v);
  void insert(const lvector<T>& vec);
  void intersect(const svector& vec);
  void difference(const svector& vec);
  void subtract(const svector& vec);
  void subtract(const T& v);
};
class index_set : public svector<index_type>
{
 public:
  index_set()
    : svector<index_type>() { };
  index_set(const index_set& _svec)
    : svector<index_type>(_svec) { };
  index_set(const lvector<index_type>& _lvec)
    : svector<index_type>(_lvec) { };
  index_set(const bool* _arr, index_type n);
  index_set(const bool_vec& _vec);
  index_set(const index_set& s0, const index_set& s);
  index_set(const index_set& s0, const bool_vec& s);
  index_set(const index_set& s0, const index_vec& map);
  index_type first_common_element(const index_set& set) const;
  index_type first_common_element(const index_vec& vec) const;
  index_type first_common_element(const bool_vec vec) const;
  index_type first_common_element(const bool* vec, index_type n) const;
  index_type count_common(const index_set& set) const;
  index_type count_common(const bool_vec& set) const;
  bool have_common_element(const index_set& set) const;
  bool have_common_element(const bool_vec& set) const;
  void insert(const index_type& v);
  void insert(const index_vec& vec);
  void insert(const bool_vec& set);
  void intersect(const index_set& vec);
  void intersect(const bool_vec& set);
  void subtract(const index_vec& vec);
  void subtract(const bool_vec& set);
  void subtract(const index_type& v);
  bool* copy_to(bool* s, index_type n) const;
  void fill(index_type to);
  void assign_remap(const index_set& set, const index_vec& map);
  void remap(const index_vec& map);
};
extern const index_set EMPTYSET;
typedef svector<index_pair> pair_set;
class bool_vec : public lvector<bool>
{
 public:
  bool_vec() : lvector<bool>() { };
  bool_vec(bool _val, index_type l) : lvector<bool>(_val, l) { };
  bool_vec(const bool_vec& _vec) : lvector<bool>(_vec) { };
  bool_vec(const bool* _arr, index_type n) : lvector<bool>(false, n) {
    for (index_type k = 0; k < n; k++) {
      if (_arr[k])
 (*this)[k] = true;
      else
 (*this)[k] = false;
    }
  };
  bool_vec(const index_set& set, index_type l);
  void complement();
  void insert(const bool_vec& vec);
  void insert(const index_set& set);
  void intersect(const bool_vec& vec);
  void intersect(const index_set& set);
  void subtract(const bool_vec& vec);
  void subtract(const index_set& set);
  bool subset(const bool_vec& vec) const;
  bool strict_subset(const bool_vec& vec) const;
  bool superset(const bool_vec& vec) const;
  bool strict_superset(const bool_vec& vec) const;
  bool contains(const bool& v) const;
  bool contains(const bool_vec& set) const;
  bool contains(const index_set& set) const;
  bool contains_any(const index_set& set) const;
  index_type first_common_element(const index_set& vec) const;
  index_type first_common_element(const bool_vec vec) const;
  index_type count_common(const bool_vec& vec) const;
  index_type count_common(const index_set& set) const;
  index_set& copy_to(index_set& set) const;
  index_set& insert_into(index_set& set) const;
  index_set& subtract_from(index_set& set) const;
  bool* copy_to(bool* s, index_type n) const;
  int compare(const bool_vec& vec) const;
  index_type hash() const;
};
class index_set_vec : public lvector<index_set>
{
 public:
  index_set_vec()
    : lvector<index_set>() { };
  index_set_vec(const index_set& set, index_type l)
    : lvector<index_set>(set, l) { };
  index_set_vec(index_type l)
    : lvector<index_set>(EMPTYSET, l) { };
  index_set_vec(const index_set_vec& vec)
    : lvector<index_set>(vec) { };
  class decreasing_cardinality_order : public index_set_vec::order {
  public:
    virtual bool operator()
      (const index_set& v0, const index_set& v1) const
      { return (v0.size() > v1.size()); };
  };
  decreasing_cardinality_order decreasing_cardinality;
  index_type minimum_cardinality() const;
  index_type maxmimum_cardinality() const;
  index_type selected_minimum_cardinality(const index_set& sel) const;
  index_type selected_maximum_cardinality(const index_set& sel) const;
  index_type first_minimum_cardinality_set() const;
  index_type first_maxmimum_cardinality_set() const;
  index_type first_superset(const index_set& set) const;
  index_type first_strict_superset(const index_set& set) const;
  index_type first_subset(const index_set& set) const;
  index_type first_strict_subset(const index_set& set) const;
  index_set& union_set(index_set& set) const;
  index_set& selected_union_set(const index_set& sel, index_set& set) const;
  index_set& intersection_set(index_set& set) const;
  void insert_maximal(const index_set& set);
  void insert_minimal(const index_set& set);
  void reduce_to_maximal();
  void reduce_to_minimal();
  void append_if_not_subset(const index_set& set);
  void append_if_not_superset(const index_set& set);
  void append_if_new(const index_set& set);
  void remove_sets_size_le(index_type l);
  void remove_empty_sets();
  void insert_in_all(index_type i);
  void insert_in_all(const index_set& set);
  void subtract_from_all(index_type i);
  void subtract_from_all(const index_set& set);
  void combinations_by_union(const index_set_vec& sv);
  void combinations_by_union(const index_set_vec& sv1,
        const index_set_vec& sv2);
};
template<class T> class matrix : public lvector< lvector<T> >
{
 public:
  typedef lvector<T> row_type;
  matrix()
    : lvector<row_type>() { };
  matrix(const T& _val, index_type r, index_type c)
    : lvector<row_type>(row_type(_val, c), r) { };
  matrix(const matrix& _mat)
    : lvector<row_type>(_mat) { };
  index_type rows() const
  {
    return lvector<row_type>::length();
  };
  index_type columns() const
  {
    if (lvector<row_type>::length() == 0) return 0;
    else return (*this)[0].length();
  };
  void set_size(index_type r, index_type c);
  void assign_value(const T& _val);
  void assign_value(const T& _val, index_type r, index_type c);
};
class bool_matrix : public matrix<bool> {
 public:
  bool_matrix()
    : matrix<bool>() { };
  bool_matrix(const bool& v, index_type r, index_type c)
    : matrix<bool>(v, c, r) { };
  bool_matrix(const bool_matrix& m)
    : matrix<bool>(m) { };
  void complement();
  void insert(const bool_matrix& m);
  void intersect(const bool_matrix& m);
  void subtract(const bool_matrix& m);
  void multiply(const bool_matrix& m0, const bool_matrix& m1);
  void transitive_closure();
};
typedef matrix<index_type> index_matrix;
class mapping : public index_vec
{
 public:
  static void identity_map
    (index_type n, index_vec& map)
    { index_vec_util::fill(map, n); };
  static bool invert_map
    (const index_vec& map, index_vec& inv, index_type m = 0);
  static void delete_index_map
    (index_type n, index_type i, index_vec& map);
  static void compose
    (const index_vec& m0, const index_vec& m1, index_vec& cm);
  static void map_image
    (const index_vec& map, const index_vec& vec, index_vec& img);
  static void inverse_map_image
    (const index_vec& map, index_type x, index_set& img);
  static void inverse_map_image
    (const index_vec& map, const index_set& x, index_set& img);
  static index_type range(const index_vec& map, index_type d);
  mapping()
    : index_vec() { };
  mapping(index_type n)
    : index_vec() { identity_map(n, *this); };
  mapping(index_type n, index_type i, bool out) : index_vec() {
    if (out) delete_index_map(n, i, *this); else assign_value(i, n);
  };
  mapping(const mapping& map)
    : index_vec(map) { };
  void assign_identity(index_type n)
    { identity_map(n, *this); };
  index_type operator()(index_type x) const
    { assert(x < size()); return (*this)[x]; };
  index_vec operator()(const index_vec& vec) const
    { index_vec res; map_image(*this, vec, res); return res; };
  index_vec& inverse(index_type x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  index_vec& inverse(const index_set& x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  bool invert(index_vec& rmap) const
    { return invert_map(*this, rmap); };
  bool invert()
    { index_vec tmp(*this); return invert_map(tmp, *this); };
  index_type range() const
    { return range(*this, length()); };
};
class sparse_mapping : public pair_vec
{
 public:
  static void dense_to_sparse(const index_vec& dm, pair_vec sm);
  static void sparse_to_dense(const pair_vec& sm, index_vec dm);
  static index_type map_image
    (const pair_vec& map, index_type x);
  static void map_image
    (const pair_vec& map, const index_vec& vec, index_vec& img);
  static void inverse_map_image
    (const pair_vec& map, index_type x, index_set& img);
  static void inverse_map_image
    (const pair_vec& map, const index_set& x, index_set& img);
  sparse_mapping()
    : pair_vec() { };
  sparse_mapping(const pair_vec& m)
    : pair_vec(m) { };
  sparse_mapping(const index_vec& m)
    : pair_vec() { dense_to_sparse(m, *this); };
  index_type operator()(index_type x) const
    { return map_image(*this, x); };
  index_vec operator()(const index_vec& vec) const
    { index_vec res; map_image(*this, vec, res); return res; };
  index_set& inverse(index_type x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  index_set& inverse(const index_set& x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
};
class equivalence : public index_vec
{
 public:
  equivalence()
    : index_vec() { };
  equivalence(index_type n)
    : index_vec(no_such_index, n) { index_vec_util::fill(*this, n); };
  equivalence(const equivalence& eq)
    : index_vec(eq) { };
  bool operator()(index_type a, index_type b) const;
  index_type canonical(index_type a) const;
  void extend(index_type a);
  void merge(index_type a, index_type b);
  void merge(const equivalence& eq);
  void merge(const index_set& set);
  void merge(const index_set& sa, const index_set& sb);
  void reset();
  void reset(index_type n);
  void canonical_set(index_set& set) const;
  void canonical_elements(index_set& set) const;
  void class_elements(index_type rep, index_set& set) const;
  index_type n_class_elements(index_type rep) const;
  void classes(index_set_vec& sets) const;
  void make_map(index_vec& map) const;
  index_type n_classes() const;
  index_type n_squeezed() const;
};
class set_hash_function : index_vec
{
 public:
  set_hash_function(index_type n)
    : index_vec() { init(n); };
  void init(index_type n);
  index_type operator()(index_type& i, index_type v) const;
  index_type operator()(const index_set& set) const;
  index_type operator()(const bool_vec& set) const;
  index_type operator()(const bool* set, index_type n) const;
};
template<class T, class N> struct weighted
{
  T value;
  N weight;
  weighted() : weight(0) { };
  weighted(const T& v) : value(v), weight(0) { };
  weighted(const T& v, const N& w) : value(v), weight(w) { };
  weighted(const weighted& w) : value(w.value), weight(w.weight) { };
  ~weighted() { };
  weighted& operator=(const T& v)
  {
    value = v;
    weight = 0;
    return *this;
  };
  weighted& operator=(const weighted& w)
  {
    value = w.value;
    weight = w.weight;
    return *this;
  };
  bool operator==(const weighted& w) const
  {
    return (value == w.value);
  };
  bool operator!=(const weighted& w) const
  {
    return (value != w.value);
  };
  bool operator<(const weighted& w) const
  {
    return (value < w.value);
  };
  bool operator<=(const weighted& w) const
  {
    return (value <= w.value);
  };
  bool operator>(const weighted& w) const
  {
    return (value > w.value);
  };
  bool operator>=(const weighted& w) const
  {
    return (value >= w.value);
  };
};
template<class T, class N> class weighted_vec
: public lvector< weighted<T, N> >
{
 public:
  class decreasing_weight_order : public lvector< weighted<T,N> >::order {
  public:
    virtual bool operator()
      (const weighted<T,N>& v0, const weighted<T,N>& v1) const
      { return (v0.weight > v1.weight); };
  };
  class increasing_weight_order : public lvector< weighted<T,N> >::order {
  public:
    virtual bool operator()
      (const weighted<T,N>& v0, const weighted<T,N>& v1) const
      { return (v0.weight < v1.weight); };
  };
  static class decreasing_weight_order decreasing;
  static class increasing_weight_order increasing;
  void insert_increasing(const weighted<T,N>& v);
  void insert_decreasing(const weighted<T,N>& v);
  void insert_increasing(const T& v, const N& w);
  void insert_decreasing(const T& v, const N& w);
};
template<class T, class N> class weighted_set
: public svector< weighted<T,N> >
{
 public:
  void insert(const T& v, const N& w);
  void insert(const T& v);
  index_type arg_max();
  index_type arg_min();
};
template<class T>
bool lvector<T>::operator==(const lvector& _vec) const
{
  if (lvector<T>::size() != _vec.size()) return false;
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if (!((*this)[k] == _vec[k])) return false;
  return true;
}
template<class T>
bool lvector<T>::operator!=(const lvector& _vec) const
{
  if (*this == _vec) return false;
  else return true;
}
template<class T>
bool lvector<T>::operator<(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return true;
  else if (lvector<T>::size() > vec.size()) return false;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return true;
      else if ((*this)[k] > vec[k]) return false;
    }
    return false;
  }
}
template<class T>
bool lvector<T>::operator<=(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return true;
  else if (lvector<T>::size() > vec.size()) return false;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return true;
      else if ((*this)[k] > vec[k]) return false;
    }
    return true;
  }
}
template<class T>
bool lvector<T>::operator>(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return false;
  else if (lvector<T>::size() > vec.size()) return true;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return false;
      else if ((*this)[k] > vec[k]) return true;
    }
    return false;
  }
}
template<class T>
bool lvector<T>::operator>=(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return false;
  else if (lvector<T>::size() > vec.size()) return true;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return false;
      else if ((*this)[k] > vec[k]) return true;
    }
    return true;
  }
}
template<class T>
bool lvector<T>::contains(const T& v) const
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return true;
  return false;
}
template<class T>
index_type lvector<T>::first(const T& v) const
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return k;
  return no_such_index;
}
template<class T>
index_type lvector<T>::next(const T& v, index_type p) const
{
  for (index_type k = p + 1; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return k;
  return no_such_index;
}
template<class T>
index_type lvector<T>::find(const T& v, bool_vec& s) const
{
  index_type n = 0;
  s.assign_value(false, lvector<T>::size());
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) {
      s[k] = true;
      n += 1;
    }
  return n;
}
template<class T>
index_type lvector<T>::count(const T& v) const
{
  index_type c = 0;
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) c += 1;
  return c;
}
template<class T>
index_type lvector<T>::length() const
{
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::arg_max() const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if ((*this)[k] > (*this)[m]) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_min() const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if ((*this)[k] < (*this)[m]) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_first(const order& o) const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if (o((*this)[k], (*this)[m])) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_last(const order& o) const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if (o((*this)[m], (*this)[k])) m = k;
  return m;
}
template<class T>
index_pair lvector<T>::first_common(const lvector<T>& vec) const
{
  for (index_type i = 0; i < lvector<T>::size(); i++) {
    for (index_type j = 0; j < vec.size(); j++)
      if ((*this)[i] == vec[j]) return index_pair(i, j);
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_pair lvector<T>::next_common(const lvector<T>& vec, index_pair p) const
{
  index_type i = p.first;
  index_type j = p.second + 1;
  while (j < vec.size()) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    j += 1;
  }
  i += 1;
  while (i < lvector<T>::size()) {
    j = 0;
    while (j < vec.size()) {
      if ((*this)[i] == vec[j])
 return index_pair(i, j);
      j += 1;
    }
    i += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
void lvector<T>::difference
(const lvector& v1, lvector& d0, lvector& d1)
{
  d0.assign_copy(*this);
  d1.assign_copy(v1);
  index_type i0 = 0;
  while (i0 < d0.size()) {
    index_type i1 = d1.first(d0[i0]);
    if (i1 != no_such_index) {
      d0.remove(i0);
      d1.remove(i1);
    }
    else {
      i0 += 1;
    }
  }
}
template<class T>
void lvector<T>::assign_copy(const lvector& _vec)
{
  std::vector<T>::resize(_vec.size());
  for (index_type k = 0; k < _vec.size(); k++)
    (*this)[k] = _vec[k];
}
template<class T>
void lvector<T>::assign_copy(const T* _arr, index_type n)
{
  std::vector<T>::resize(n);
  for (index_type k = 0; k < n; k++)
    (*this)[k] = _arr[k];
}
template<class T>
void lvector<T>::assign_value(const T& _val)
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    (*this)[k] = _val;
}
template<class T>
void lvector<T>::assign_value(const T& _val, index_type l)
{
  std::vector<T>::resize(l);
  for (index_type k = 0; k < lvector<T>::size(); k++)
    (*this)[k] = _val;
}
template<class T>
void lvector<T>::assign_remap(const lvector<T>& vec, const index_vec& map)
{
  assert(map.length() == vec.length());
  index_type m = 0;
  for (index_type k = 0; k < vec.length(); k++)
    if (map[k] != no_such_index)
      if (map[k] > m) m = map[k];
  set_length(m + 1);
  for (index_type k = 0; k < vec.length(); k++)
    if (map[k] != no_such_index)
      (*this)[map[k]] = vec[k];
}
template<class T>
void lvector<T>::remap(const index_vec& map)
{
  lvector v0(*this);
  assign_remap(v0, map);
}
template<class T>
void lvector<T>::assign_select(const lvector& _vec, const index_set& s)
{
  set_length(s.length());
  for (index_type k = 0; k < s.length(); k++)
    (*this)[k] = _vec[s[k]];
}
template<class T>
void lvector<T>::assign_select(const lvector& _vec, const bool_vec& s)
{
  clear();
  for (index_type k = 0; k < _vec.length(); k++)
    if (s[k]) append(_vec[k]);
}
template<class T>
const lvector<T>& lvector<T>::operator=(const lvector<T>& _vec)
{
  assign_copy(_vec);
  return _vec;
}
template<class T>
void lvector<T>::set_length(index_type l)
{
  std::vector<T>::resize(l);
}
template<class T>
void lvector<T>::set_length(index_type l, const T& v)
{
  std::vector<T>::resize(l, v);
}
template<class T>
void lvector<T>::inc_length_to(index_type l)
{
  if (std::vector<T>::size() < l)
    std::vector<T>::resize(l);
}
template<class T>
void lvector<T>::inc_length_to(index_type l, const T& v)
{
  if (std::vector<T>::size() < l)
    std::vector<T>::resize(l, v);
}
template<class T>
index_type lvector<T>::inc_length(index_type d)
{
  std::vector<T>::resize(std::vector<T>::size() + d);
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::inc_length(index_type d, const T& v)
{
  std::vector<T>::resize(std::vector<T>::size() + d, v);
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::dec_length(index_type d)
{
  assert(std::vector<T>::size() >= d);
  std::vector<T>::resize(std::vector<T>::size() - d);
  return std::vector<T>::size();
}
template<class T>
void lvector<T>::clear()
{
  std::vector<T>::clear();
}
template<class T>
void lvector<T>::append(const T& v)
{
  std::vector<T>::push_back(v);
}
template<class T>
void lvector<T>::append(const lvector<T>& v)
{
  for (index_type k = 0; k < v.size(); k++) append(v[k]);
}
template<class T>
T& lvector<T>::append()
{
  T v;
  std::vector<T>::push_back(v);
  return (*this)[std::vector<T>::size() - 1];
}
template<class T>
void lvector<T>::insert(const T& v, index_type p)
{
  if (p < lvector<T>::size()) {
    std::vector<T>::insert(std::vector<T>::begin() + p, v);
  }
  else {
    std::vector<T>::resize(p + 1);
    (*this)[p] = v;
  }
}
template<class T>
index_type lvector<T>::insert_ordered(const T& v, const order& o, index_type f)
{
  assert(f <= lvector<T>::size());
  for (index_type k = f; k < lvector<T>::size(); k++) {
    if (o(v, (*this)[k])) {
      insert(v, k);
      return k;
    }
  }
  append(v);
  return (lvector<T>::size() - 1);
}
template<class T>
index_type lvector<T>::insert_ordered(const lvector& vec, const order& o)
{
  if (vec.empty()) return no_such_index;
  index_type p0 = insert_ordered(vec[0], o);
  for (index_type k = 1; k < vec.size(); k++) {
    index_type p1 = insert_ordered(vec[k], o);
    if (p1 < p0) p0 = p1;
  }
  return p0;
}
template<class T>
void lvector<T>::remove(index_type p)
{
  if (p < lvector<T>::size())
    std::vector<T>::erase(std::vector<T>::begin() + p);
}
template<class T>
void lvector<T>::remove(index_type p0, index_type p1)
{
  assert(p0 < p1);
  if (p1 < lvector<T>::size())
    std::vector<T>::erase(std::vector<T>::begin() + p0,
     std::vector<T>::begin() + p1);
  else
    std::vector<T>::erase(std::vector<T>::begin() + p0,
     std::vector<T>::end());
}
template<class T>
void lvector<T>::remove(const bool_vec& s, index_vec& map)
{
  assert(s.size() >= lvector<T>::size());
  index_type scan_p = 0;
  index_type put_p = 0;
  index_vec rm_map(no_such_index, lvector<T>::size());
  while (scan_p < lvector<T>::size()) {
    if (!s[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      rm_map[scan_p] = put_p;
      put_p += 1;
    }
    else {
      rm_map[scan_p] = no_such_index;
    }
    scan_p += 1;
  }
  std::vector<T>::resize(put_p);
  for (index_type k = 0; k < map.size(); k++)
    if (map[k] != no_such_index) {
      assert(map[k] < rm_map.size());
      map[k] = rm_map[map[k]];
    }
}
template<class T>
void lvector<T>::remove(const bool_vec& s)
{
  assert(s.size() >= lvector<T>::size());
  index_type scan_p = 0;
  index_type put_p = 0;
  while (scan_p < lvector<T>::size()) {
    if (!s[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      put_p += 1;
    }
    scan_p += 1;
  }
  std::vector<T>::resize(put_p);
}
template<class T>
void lvector<T>::remove(const index_set& s)
{
  bool_vec s1(s, lvector<T>::size());
  remove(s1);
}
template<class T>
void lvector<T>::remove(const index_set& s, index_vec& map)
{
  bool_vec s1(s, std::vector<T>::size());
  lvector<T>::remove(s1, map);
}
template<class T>
void lvector<T>::remove_duplicate_elements()
{
  equivalence eq(lvector<T>::size());
  for (index_type i = 0; i < lvector<T>::size(); i++)
    for (index_type j = i+1; j < lvector<T>::size(); j++)
      if ((*this)[i] == (*this)[j])
 eq.merge(i, j);
  bool_vec s(false, lvector<T>::size());
  for (index_type i = 0; i < lvector<T>::size(); i++)
    if (eq.canonical(i) != i)
      s[i] = true;
  remove(s);
}
template<class T>
void lvector<T>::swap(index_type i, index_type j)
{
  T tmp = (*this)[i];
  (*this)[i] = (*this)[j];
  (*this)[j] = tmp;
}
template<class T>
void svector<T>::assign_singleton(const T& _val)
{
  lvector<T>::set_length(1);
  (*this)[0] = _val;
}
template<class T>
void svector<T>::assign_values(const lvector<T>& vec)
{
  lvector<T>::clear();
  for (index_type k = 0; k < vec.size(); k++)
    insert(vec[k]);
}
template<class T>
void svector<T>::insert(const T& v) {
  index_type i = 0;
  bool seeking = (i < std::vector<T>::size());
  while (seeking) {
    if ((*this)[i] < v) {
      i += 1;
      if (i >= std::vector<T>::size())
 seeking = false;
    }
    else {
      seeking = false;
    }
  }
  if (i < lvector<T>::size()) {
    if ((*this)[i] == v)
      return;
    else
      lvector<T>::insert(v, i);
  }
  else {
    lvector<T>::append(v);
  }
}
template<class T>
void svector<T>::insert(const lvector<T>& vec)
{
  for (index_type k = 0; k < vec.size(); k++) insert(vec[k]);
}
template<class T>
bool svector<T>::contains(const T& v) const
{
  index_type i = 0;
  while ((i < lvector<T>::size()) &&
  ((*this)[i] < v)) i += 1;
  if (i < lvector<T>::size())
    if ((*this)[i] == v) return true;
  return false;
}
template<class T>
bool svector<T>::contains(const svector& vec) const
{
  index_type v_i = 0;
  index_type i = 0;
  while (v_i < vec.size()) {
    if (i >= lvector<T>::size()) return false;
    if ((*this)[i] == vec[v_i]) {
      v_i += 1;
      i += 1;
    }
    else if ((*this)[i] > vec[v_i]) {
      return false;
    }
    else {
      while ((i < lvector<T>::size()) && ((*this)[i] < vec[v_i]))
 i += 1;
    }
  }
  return true;
}
template<class T>
bool svector<T>::subset(const svector& vec) const
{
  return vec.contains(*this);
}
template<class T>
void svector<T>::intersect(const svector& vec)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if (!vec.contains((*this)[i]))
      lvector<T>::remove(i);
    else
      i += 1;
  }
}
template<class T>
void svector<T>::difference(const svector& vec)
{
  svector d(vec);
  d.subtract(*this);
  subtract(vec);
  insert(d);
}
template<class T>
index_pair svector<T>::first_common(const lvector<T>& vec) const
{
  return lvector<T>::first_common(vec);
}
template<class T>
index_pair svector<T>::next_common(const lvector<T>& vec, index_pair p) const
{
  return lvector<T>::next_common(vec, p);
}
template<class T>
index_pair svector<T>::first_common(const svector<T>& vec) const
{
  index_type i = 0;
  index_type j = 0;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    else if
      ((*this)[i] < vec[j]) i += 1;
    else
      j += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_pair svector<T>::next_common(const svector<T>& vec, index_pair p) const
{
  index_type i = p.first + 1;
  index_type j = p.second + 1;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    else if ((*this)[i] < vec[j])
      i += 1;
    else
      j += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_type svector<T>::count_common(const svector& vec) const
{
  index_type i = 0;
  index_type j = 0;
  index_type c = 0;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j]) {
      c += 1;
      i += 1;
      j += 1;
    }
    else if ((*this)[i] < vec[j])
      i += 1;
    else
      j += 1;
  }
  return c;
}
template<class T>
void svector<T>::subtract(const svector& vec)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if (vec.contains((*this)[i]))
      lvector<T>::remove(i);
    else
      i += 1;
  }
}
template<class T>
void svector<T>::subtract(const T& v)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if ((*this)[i] == v) {
      lvector<T>::remove(i);
      return;
    }
    else {
      i += 1;
    }
  }
}
template<class T>
void matrix<T>::set_size(index_type r, index_type c)
{
  lvector<row_type>::set_length(r);
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].set_length(c);
}
template<class T>
void matrix<T>::assign_value(const T& _val)
{
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].assign_value(_val);
}
template<class T>
void matrix<T>::assign_value(const T& _val, index_type r, index_type c)
{
  lvector<row_type>::set_length(r);
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].assign_value(_val, c);
}
template<class T>
void swapable_pair<T>::swap()
{
  T tmp = this->first;
  this->first = this->second;
  this->second = tmp;
}
template<class T>
void comparable_pair<T>::sort_ascending()
{
  if (this->first > this->second) swapable_pair<T>::swap();
}
template<class T>
void comparable_pair<T>::sort_descending()
{
  if (this->first < this->second) swapable_pair<T>::swap();
}
template<class T, class N>
class weighted_vec<T,N>::decreasing_weight_order
  weighted_vec<T,N>::decreasing;
template<class T, class N>
class weighted_vec<T,N>::increasing_weight_order
  weighted_vec<T,N>::increasing;
template<class T, class N>
void weighted_vec<T,N>::insert_increasing(const weighted<T,N>& v)
{
  insert_ordered(v, increasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_decreasing(const weighted<T,N>& v)
{
  insert_ordered(v, decreasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_increasing(const T& v, const N& w)
{
  insert_ordered(weighted<T,N>(v, w), increasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_decreasing(const T& v, const N& w)
{
  insert_ordered(weighted<T,N>(v, w), decreasing);
}
template<class T, class N>
void weighted_set<T,N>::insert(const T& v, const N& w)
{
  index_type p = svector< weighted<T,N> >::first(v);
  if (p == no_such_index) {
    svector< weighted<T,N> >::insert(weighted<T,N>(v, w));
  }
  else {
    (*this)[p].weight += w;
  }
}
template<class T, class N>
void weighted_set<T,N>::insert(const T& v)
{
  index_type p = svector< weighted<T,N> >::first(v);
  if (p == no_such_index) {
    svector< weighted<T,N> >::insert(weighted<T,N>(v, 1));
  }
  else {
    (*this)[p].weight += 1;
  }
}
template<class T, class N>
index_type weighted_set<T,N>::arg_max()
{
  if (weighted_set<T,N>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < weighted_set<T,N>::size(); k++)
    if ((*this)[k].weight > (*this)[m].weight) m = k;
  return m;
}
template<class T, class N>
index_type weighted_set<T,N>::arg_min()
{
  if (weighted_set<T,N>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < weighted_set<T,N>::size(); k++)
    if ((*this)[k].weight < (*this)[m].weight) m = k;
  return m;
}
template<class T>
inline std::ostream& operator<<(std::ostream& s, const swapable_pair<T>& p)
{
  return s << '(' << p.first << ',' << p.second << ')';
}
template<class T>
::std::ostream& operator<<(::std::ostream& s, const lvector<T>& _vec)
{
  s << '[';
  for (index_type k = 0; k < _vec.size(); k++) {
    if (k > 0) s << ',';
    s << _vec[k];
  }
  s << ']';
  return s;
}
inline std::ostream& operator<<(std::ostream& s, const mapping& m)
{
  s << '{';
  for (index_type k = 0; k < m.length(); k++) {
    if (k > 0) s << ',';
    s << k << '-' << '>';
    if (m[k] == no_such_index)
      s << '_';
    else
      s << m[k];
  }
  return s << '}';
}
inline std::ostream& operator<<(std::ostream& s, const equivalence& eq)
{
  s << '{';
  bool first = true;
  for (index_type k = 0; k < eq.length(); k++) {
    index_type c = eq.canonical(k);
    if (!first) {
      s << ',';
    }
    else {
      first = false;
    }
    s << k << '=' << c;
  }
  return s << '}';
}
template<class T, class N>
std::ostream& operator<<(::std::ostream& s, const weighted<T,N>& w)
{
  s << '<' << w.value << ':' << w.weight << '>';
}
}
#include <iostream>
#include <limits.h>
namespace hsps {
long euclid(long n, long k, long& a, long& b);
long gcd(long n, long k);
long lcm(long n, long k);
unsigned long ilog(unsigned long n);
long imag(long n);
class rational {
  long nm;
  long dv;
 public:
  rational();
  rational(long n);
  rational(long n, long d);
  rational(const rational& r);
  struct XR {
    long x_nm;
    long x_dv;
    XR& operator=(const rational r);
  };
  rational(const XR& x);
  long numerator() const;
  long divisor() const;
  long sign() const;
  bool zero() const;
  bool finite() const;
  bool infinite() const;
  bool integral() const;
  static rational reduce(rational r);
  static rational invert(const rational r);
  static rational infinity(const rational r);
  static rational infinity(const long s);
  static rational floor(const rational r);
  static rational floor_to(const rational r, long div);
  static rational ceil(const rational r);
  static rational ceil_to(const rational r, long div);
  static rational frac(const rational r);
  static rational round(const rational r, long div_max);
  static rational min(const rational r0, const rational r1);
  static rational max(const rational r0, const rational r1);
  static rational rgcd(const rational r0, const rational r1);
  static rational dtor(double v);
  static rational ator(const char* s);
  rational reduce() const;
  rational invert() const;
  rational floor() const;
  rational floor_to(long d) const;
  rational ceil() const;
  rational frac() const;
  rational round(long div_max) const;
  rational round() const;
  rational operator=(const rational r);
  rational operator=(long n);
  rational operator+=(const rational r);
  rational operator-=(const rational r);
  rational operator*=(const rational r);
  rational operator/=(const rational r);
  rational operator+=(long n);
  rational operator-=(long n);
  rational operator*=(long n);
  rational operator/=(long n);
  double decimal() const;
};
bool operator==(const rational r0, const rational r1);
bool operator==(const rational r0, long n1);
bool operator==(long n0, const rational r1);
bool operator!=(const rational r0, const rational r1);
bool operator!=(const rational r0, long n1);
bool operator!=(long n0, const rational r1);
bool operator<(const rational r0, const rational r1);
bool operator<=(const rational r0, const rational r1);
bool operator>(const rational r0, const rational r1);
bool operator>=(const rational r0, const rational r1);
rational operator+(const rational r0, const rational r1);
rational operator-(const rational r0, const rational r1);
rational operator*(const rational r0, const rational r1);
rational operator/(const rational r0, const rational r1);
rational operator+(const rational r0, long n1);
rational operator-(const rational r0, long n1);
rational operator*(const rational r0, long n1);
rational operator/(const rational r0, long n1);
rational operator+(long n0, const rational r1);
rational operator-(long n0, const rational r1);
rational operator*(long n0, const rational r1);
rational operator/(long n0, const rational r1);
rational safeadd(const rational r0, const rational r1);
rational safemul(const rational r0, const rational r1);
::std::ostream& operator<<(::std::ostream& s, const rational r);
inline rational::XR& rational::XR::operator=(const rational r)
{
  x_nm = r.numerator();
  x_dv = r.divisor();
  return *this;
}
inline rational::rational()
  : nm(0), dv(1) { }
inline rational::rational(long n)
  : nm(n), dv(1) { }
inline rational::rational(long n, long d)
  : nm(d < 0 ? -1*n : n), dv(d < 0 ? -1*d : d) { }
inline rational::rational(const rational& r)
  : nm(r.nm), dv(r.dv) { }
inline rational::rational(const rational::XR& x)
  : nm(x.x_nm), dv(x.x_dv) { };
inline long rational::numerator() const { return nm; }
inline long rational::divisor() const { return dv; }
inline long rational::sign() const
{
  return (nm < 0 ? -1 : (nm > 0 ? 1 : 0));
}
inline bool rational::zero() const
{
  return nm == 0;
}
inline bool rational::finite() const
{
  return dv != 0;
}
inline bool rational::infinite() const
{
  return dv == 0;
}
inline bool rational::integral() const
{
  return dv == 1;
}
inline rational rational::reduce(rational r)
{
  if (r.infinite()) return infinity(r.sign());
  if (r.sign() == 0) return rational(0,1);
  long c = gcd(r.nm, r.dv);
  return rational(r.nm / c, r.dv / c);
}
inline rational rational::invert(const rational r)
{
  return rational(r.dv, r.nm);
}
inline rational rational::infinity(const long s)
{
  return rational((s < 0 ? -1 : (s > 0 ? 1 : 0)), 0);
}
inline rational rational::infinity(const rational r)
{
  return rational(r.sign(),0);
}
inline rational rational::floor(const rational r)
{
  if (r.infinite()) return r;
  return rational(r.nm / r.dv);
}
inline rational rational::floor_to(const rational r, long d)
{
  if (r.infinite()) return r;
  return rational((r.nm * d) / r.dv, d);
}
inline rational rational::ceil(const rational r)
{
  if (r.infinite()) return r;
  if (r.dv == 1) return r;
  return rational((r.nm / r.dv) + 1, 1);
}
inline rational rational::ceil_to(const rational r, long d)
{
  if (r.infinite()) return r;
  long x = (r.nm * d);
  long y = x / r.dv;
  if ((y * r.dv) == x)
    return rational(y, d);
  else
    return rational(y + 1, d);
}
inline rational rational::frac(const rational r) {
  if (r.infinite()) return r;
  return reduce(rational(r.nm % r.dv, r.dv));
}
inline rational rational::round(const rational r, long d_max)
{
  if (r.infinite()) return r;
  rational s(r);
  while (s.dv > d_max) {
    s.dv = (s.dv / 2);
    s.nm = (s.nm / 2);
    s.reduce();
  }
  return s;
}
inline rational rational::rgcd(const rational r0, const rational r1)
{
  long c = gcd(r0.divisor(), r1.divisor());
  long a0 = r0.numerator() * (r1.divisor() / c);
  long a1 = r1.numerator() * (r0.divisor() / c);
  long d = gcd(a0, a1);
  return rational(d, (r0.divisor() / c) * (r1.divisor() / c) * c).reduce();
}
inline rational rational::min(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    if (r0.sign() < 0) return r0;
    else return r1;
  }
  else if (r1.infinite()) {
    if (r1.sign() < 0) return r1;
    else return r0;
  }
  else if (r0 < r1) return r0;
  else return r1;
}
inline rational rational::max(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    if (r0.sign() > 0) return r0;
    else return r1;
  }
  else if (r1.infinite()) {
    if (r1.sign() > 0) return r1;
    else return r0;
  }
  else if (r0 < r1) return r1;
  else return r0;
}
inline rational rational::reduce() const
{
  return reduce(*this);
}
inline rational rational::invert() const
{
  return invert(*this);
}
inline rational rational::floor() const
{
  return floor(*this);
}
inline rational rational::floor_to(long d) const
{
  return floor_to(*this, d);
}
inline rational rational::ceil() const
{
  return ceil(*this);
}
inline rational rational::frac() const
{
  return frac(*this);
}
inline rational rational::round(long d_max) const
{
  return round(*this, d_max);
}
inline rational rational::round() const
{
  return round(*this, (LONG_MAX/16));
}
inline rational rational::operator=(const rational r)
{
  nm = r.nm;
  dv = r.dv;
  return *this;
}
inline rational rational::operator=(long n)
{
  nm = n;
  dv = 1;
  return *this;
}
inline rational rational::operator+=(const rational r)
{
  return *this = (*this + r);
}
inline rational rational::operator-=(const rational r)
{
  return *this = (*this - r);
}
inline rational rational::operator*=(const rational r)
{
  return *this = (*this * r);
}
inline rational rational::operator/=(const rational r)
{
  return *this = (*this / r);
}
inline rational rational::operator+=(long n)
{
  return *this = (*this + n);
}
inline rational rational::operator-=(long n)
{
  return *this = (*this - n);
}
inline rational rational::operator*=(long n)
{
  return *this = (*this * n);
}
inline rational rational::operator/=(long n)
{
  return *this = (*this / n);
}
inline double rational::decimal() const { return nm/(double)dv; };
inline bool operator==(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite()) return r0.sign() == r1.sign();
  else return ((r0.numerator() == r1.numerator()) &&
        (r0.divisor() == r1.divisor()));
}
inline bool operator==(const rational r0, long n1)
{
  return ((r0.numerator() == n1) && (r0.divisor() == 1));
}
inline bool operator==(long n0, const rational r1)
{
  return ((r1.numerator() == n0) && (r1.divisor() == 1));
}
inline bool operator!=(const rational r0, const rational r1)
{
  return !(r0 == r1);
}
inline bool operator!=(const rational r0, long n1)
{
  return !(r0 == n1);
}
inline bool operator!=(long n0, const rational r1)
{
  return !(n0 == r1);
}
inline bool operator<(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return false;
  else return (r0 - r1).sign() < 0;
}
inline bool operator<=(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return true;
  else return (r0 - r1).sign() <= 0;
}
inline bool operator>(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return false;
  else return (r0 - r1).sign() > 0;
}
inline bool operator>=(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return true;
  else return (r0 - r1).sign() >= 0;
}
inline rational operator+(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() == r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " + " << r1 << " not defined"
           << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() + r1.numerator(), 1);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n = (r0.numerator() * (r1.divisor() / c) +
       r1.numerator() * (r0.divisor() / c));
    long d = ((r0.divisor() / c) * r1.divisor());
    return rational(n, d).reduce();
  }
}
inline rational operator-(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() != r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " - " << r1 << " not defined"
      << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1.sign() * -1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() - r1.numerator(), 1);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n = (r0.numerator() * (r1.divisor() / c) -
       r1.numerator() * (r0.divisor() / c));
    long d = ((r0.divisor() / c) * r1.divisor());
    return rational(n, d).reduce();
  }
}
inline rational operator*(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else if (r1.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() * r1.numerator(), 1);
  }
  else {
    long c0 = gcd(r0.numerator(), r1.divisor());
    long c1 = gcd(r1.numerator(), r0.divisor());
    return rational((r0.numerator() / c0) * (r1.numerator() / c1),
      (r0.divisor() / c1) * (r1.divisor() / c0)).reduce();
  }
}
inline rational operator/(const rational r0, const rational r1)
{
  return (r0 * r1.invert());
}
inline rational operator+(const rational r0, long n1)
{
  return rational(r0.numerator() + (n1 * r0.divisor()), r0.divisor()).reduce();
}
inline rational operator-(const rational r0, long n1)
{
  return rational(r0.numerator() - (n1 * r0.divisor()), r0.divisor()).reduce();
}
inline rational operator*(const rational r0, long n1)
{
  return rational(r0.numerator() * n1, r0.divisor()).reduce();
}
inline rational operator/(const rational r0, long n1)
{
  return rational((n1 < 0 ? r0.numerator() * -1 : r0.numerator()),
    r0.divisor() * (n1 < 0 ? n1 * -1 : n1)).reduce();
}
inline rational operator+(long n0, const rational r1)
{
  return rational(r1.numerator() + (n0 * r1.divisor()), r1.divisor()).reduce();
}
inline rational operator-(long n0, const rational r1)
{
  return rational((n0 * r1.divisor()) - r1.numerator(), r1.divisor()).reduce();
}
inline rational operator*(long n0, const rational r1)
{
  return rational(r1.numerator() * n0, r1.divisor()).reduce();
}
inline rational operator/(long n0, const rational r1)
{
  return (n0 * r1.invert());
}
inline rational safeadd(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() == r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " + " << r1 << " not defined"
      << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n0 = r0.numerator();
    long d0 = r0.divisor() / c;
    long n1 = r1.numerator();
    long d1 = r1.divisor() / c;
    assert(d0 > 0);
    assert(d1 > 0);
    while (((LONG_MAX / (2*d1)) < (imag(n0) + 1)) ||
    ((LONG_MAX / (2*d0)) < (imag(n1) + 1)) ||
    ((LONG_MAX / (d0 * c)) < (d1 + 1))) {
      if ((d1 < 2) && (d0 < 2)) {
 std::cerr << "error: overflow in safeadd(" << r0 << ", " << r1 << ")"
    << std::endl;
 abort();
      }
      if (d0 < 2) {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
      else if (d1 < 2) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else if ((imag(n0) - d0) > (imag(n1) - d1)) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
    }
    long f0 = n0 * d1;
    long f1 = n1 * d0;
    long n = f0 + f1;
    long d = d0 * d1 * c;
    return rational(n, d).reduce();
  }
}
inline rational safemul(const rational r0, const rational r1)
{
  if (r0.infinite() || r1.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else {
    long c0 = gcd(r0.numerator(), r1.divisor());
    long c1 = gcd(r1.numerator(), r0.divisor());
    long n0 = r0.numerator() / c0;
    long n1 = r1.numerator() / c1;
    long d0 = r0.divisor() / c1;
    long d1 = r1.divisor() / c0;
    while (((LONG_MAX / imag(n0)) < (imag(n1) + 1)) ||
    ((LONG_MAX / d0) < (d1 + 1))) {
      if ((d1 < 2) && (d0 < 2)) {
 std::cerr << "error: overflow in safeadd(" << r0 << ", " << r1 << ")"
    << std::endl;
 abort();
      }
      if (d0 < 2) {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
      else if (d1 < 2) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else if ((imag(n0) - d0) > (imag(n1) - d1)) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
    }
    return rational(n0 * n1, d0 * d1).reduce();
  }
}
inline ::std::ostream& operator<<(::std::ostream& s, const rational r)
{
  if (r.infinite()) {
    if (r.sign() < 0) return s << "-INF";
    else return s << "INF";
  }
  else if (r.integral()) {
    return s << r.numerator();
  }
  else {
    return s << r.numerator() << '/' << r.divisor();
  }
}
}
namespace hsps {
class RNG {
 public:
  virtual ~RNG() { };
  virtual void seed(unsigned long s) = 0;
  virtual unsigned long seed_value() = 0;
  virtual unsigned long random() = 0;
  void seed_with_pid();
  void seed_with_time();
  unsigned long random_in_range(unsigned long range);
  unsigned long random_in_range(unsigned long range, unsigned long except);
  double random_double(unsigned long div);
  double normal_sample(double mean, double var);
  unsigned long binomial_sample(unsigned long n, double p);
  index_type select_one_of(const bool_vec& sel);
  index_type select_one_of(const index_vec& sel);
  void select_fixed_set(index_set& s, index_type m, index_type n);
  void select_variable_set(index_set& s, index_type m, index_type n);
  void select_non_empty_variable_set(index_set& s, index_type m, index_type n);
  virtual unsigned long max() = 0;
};
class LC_RNG : public RNG {
  unsigned long a;
  unsigned long b;
  unsigned long mod;
  unsigned long x;
 public:
  LC_RNG()
    : a(23), b(0), mod(100000001), x(100000001 - 1) { };
  LC_RNG(unsigned long _a, unsigned long _b, unsigned long m)
    : a(_a), b(_b), mod(m), x(m - 1) { };
  LC_RNG(unsigned long s)
    : a(23), b(0), mod(100000001), x(s) { };
  LC_RNG(unsigned long _a, unsigned long _b, unsigned long m, unsigned long s)
    : a(_a), b(_b), mod(m), x(s) { };
  virtual ~LC_RNG() { };
  virtual void seed(unsigned long s);
  virtual unsigned long seed_value();
  virtual unsigned long random();
  virtual unsigned long max();
};
}
#include <iostream>
#include <iomanip>
const hsps::rational POS_INF(1,0);
const hsps::rational NEG_INF(-1,0);
const hsps::rational ZERO(0,1);
namespace hsps {
inline hsps::rational random_numeric
(hsps::rational min, hsps::rational max, unsigned long prec, RNG& rng)
{
  hsps::rational d = (max - min);
  hsps::rational s = (d / prec);
  unsigned long r = rng.random_in_range(prec + 1);
  return ((r*s) + min);
}
class amt_vec : public auto_expanding_vector<hsps::rational> {
 public:
  amt_vec()
    : auto_expanding_vector<hsps::rational>() { };
  amt_vec(const hsps::rational& v, index_type l)
    : auto_expanding_vector<hsps::rational>(v, l) { };
  amt_vec(const amt_vec& vec)
    : auto_expanding_vector<hsps::rational>(vec) { };
  int compare(const amt_vec& vec, index_type n);
  int dcompare(const amt_vec& vec, index_type n);
  index_type hash(index_type n);
  void write(std::ostream& s, index_type n);
};
inline int amt_vec::compare(const amt_vec& vec, index_type n)
{
  for (index_type k = 0; k < n; k++) {
    if ((*this)[k] < vec[k]) return -1;
    else if ((*this)[k] > vec[k]) return 1;
  }
  return 0;
}
inline int amt_vec::dcompare(const amt_vec& vec, index_type n)
{
  bool this_less_than_vec = false;
  bool vec_less_than_this = false;
  for (index_type k = 0; k < n; k++) {
    if ((*this)[k] < vec[k]) this_less_than_vec = true;
    else if ((*this)[k] > vec[k]) vec_less_than_this = true;
  }
  if (this_less_than_vec && !vec_less_than_this) return -1;
  else if (!this_less_than_vec && vec_less_than_this) return 1;
  else return 0;
}
inline index_type amt_vec::hash(index_type n)
{
  if (n == 0) return 0;
  if (n == 1) return ((index_type)(((*this)[0]).numerator() - ((*this)[0]).divisor()));
  index_type h = 0;
  for (index_type k = 0; k < n - 1; k++) {
    h += ((index_type)(((((*this)[k]) + 1) * (((*this)[k + 1]) + 1)).numerator() - ((((*this)[k]) + 1) * (((*this)[k + 1]) + 1)).divisor()));
  }
  return h;
}
inline void amt_vec::write(std::ostream& s, index_type n)
{
  s << '[';
  for (index_type k = 0; k < n; k++) {
    if (k > 0) s << ',';
    s << std::resetiosflags(std::ios::scientific) << (((*this)[k]).decimal());
  }
  s << ']';
}
typedef lvector<hsps::rational> cost_vec;
typedef svector<hsps::rational> cost_set;
typedef matrix<hsps::rational> cost_matrix;
class cost_vec_util : public cost_vec
{
 public:
  class decreasing_cost_order : public cost_vec::order {
  public:
    virtual bool operator()
      (const hsps::rational& v0, const hsps::rational& v1) const
      { return (v0 > v1); };
  };
  class increasing_cost_order : public cost_vec::order {
  public:
    virtual bool operator()
      (const hsps::rational& v0, const hsps::rational& v1) const
      { return (v0 < v1); };
  };
  static class decreasing_cost_order decreasing;
  static class increasing_cost_order increasing;
  static hsps::rational max(const cost_vec& v);
  static hsps::rational min(const cost_vec& v);
  hsps::rational max() const { return max(*this); };
  hsps::rational min() const { return min(*this); };
};
struct interval : public comparable_pair<hsps::rational> {
  interval(const hsps::rational& v1, const hsps::rational& v2) :
    comparable_pair<hsps::rational>(v1, v2) { };
  interval(const hsps::rational& v) :
    comparable_pair<hsps::rational>(v) { };
  interval(const interval& p) :
    comparable_pair<hsps::rational>(p) { };
  interval() :
    comparable_pair<hsps::rational>(NEG_INF, POS_INF) { };
};
typedef std::pair<index_type, hsps::rational> index_cost_pair;
typedef lvector<index_cost_pair> index_cost_vec;
inline std::ostream& operator<<(std::ostream& s, const index_cost_pair& p)
{
  s << '(' << p.first << ',' << p.second << ')';
}
inline std::ostream& operator<<(std::ostream& s, const interval& i)
{
  s << '[' << i.first << ',' << i.second << ']';
}
}
#include <string>
#include <iostream>
namespace hsps {
class Name {
 public:
  static const unsigned int NC_DEFAULT = 0;
  static const unsigned int NC_INSTANCE = 1;
  static const unsigned int NC_DOMAIN = 2;
  static const unsigned int NC_PROBLEM = 4;
  static const unsigned int NC_PLAN = 8;
  static const unsigned int NC_ESCAPE = 16 + 32;
  static const unsigned int NC_PDDL = 16;
  static const unsigned int NC_XML = 32;
  static const unsigned int NC_LATEX = 16 + 32;
  static const unsigned int NC_IPC = 64;
  static bool context_is_instance(unsigned int c)
    { return ((c & NC_INSTANCE) == NC_INSTANCE); };
  static bool context_is_domain(unsigned int c)
    { return ((c & NC_DOMAIN) == NC_DOMAIN); };
  static bool context_is_problem(unsigned int c)
    { return ((c & NC_PROBLEM) == NC_PROBLEM); };
  static bool context_is_plan(unsigned int c)
    { return ((c & NC_PLAN) == NC_PLAN); };
  static bool escape_for_pddl(unsigned int c)
    { return ((c & NC_ESCAPE) == NC_PDDL); };
  static bool escape_for_xml(unsigned int c)
    { return ((c & NC_ESCAPE) == NC_XML); };
  static bool escape_for_latex(unsigned int c)
    { return ((c & NC_ESCAPE) == NC_LATEX); };
  static bool conform_to_IPC(unsigned int c)
    { return ((c & NC_IPC) == NC_IPC); };
  virtual ~Name();
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const = 0;
  virtual const Name* cast_to(const char* cname) const;
  ::std::string to_string(unsigned int c = NC_DEFAULT) const;
  char* to_cstring(unsigned int c = NC_DEFAULT) const;
  bool equals(const Name* name) const;
  void write_char_escaped(::std::ostream& s,
     char ch,
     unsigned int c) const;
  void write_string_escaped(::std::ostream& s,
       ::std::string& str,
       unsigned int c) const;
  void write_string_escaped(::std::ostream& s,
       const char* str,
       unsigned int c) const;
};
typedef lvector<const Name*> name_vec;
inline ::std::ostream& operator<<(::std::ostream& s, const Name& n) {
  n.write(s, false);
  return s;
}
inline ::std::ostream& operator<<(::std::ostream& s, const Name* n) {
  n->write(s, false);
  return s;
}
inline void Name::write_char_escaped
(::std::ostream& s, char ch, unsigned int c) const
{
  if (escape_for_latex(c)) {
    if (ch == '_') s << '\\' << '_';
    else if (ch == '%') s << '\\' << '%';
    else if (ch == '#') s << '\\' << '#';
    else s << ch;
  }
  else if (escape_for_xml(c)) {
    if (ch == '<') s << "&lt;";
    else if (ch == '>') s << "&gt;";
    else if (ch == '&') s << "&amp;";
    else if (ch == '"') s << "&quot;";
    else s << ch;
  }
  else if (escape_for_pddl(c)) {
    if (ch == ' ') s << '_';
    else s << ch;
  }
  else {
    s << ch;
  }
}
inline void Name::write_string_escaped
(::std::ostream& s, const char* str, unsigned int c) const
{
  while (*str) {
    write_char_escaped(s, *str, c);
    str++;
  }
}
inline void Name::write_string_escaped
(::std::ostream& s, ::std::string& str, unsigned int c) const
{
  for (index_type i = 0; i < str.length(); i++)
    write_char_escaped(s, str[i], c);
}
class NameWithContext : public Name {
  const Name* name;
  unsigned int c_on;
  unsigned int c_off;
 public:
  NameWithContext(const Name* n, unsigned int on, unsigned int off)
    : name(n), c_on(on), c_off(off) { };
  virtual ~NameWithContext() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class StringName : public Name {
  const char* _string;
  bool _own;
 public:
  StringName(const char* s, bool c = false)
    : _string(c ? strdup(s) : s), _own(c) { };
  virtual ~StringName() { if (_own) delete (char*)_string; };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class ConcatenatedName : public Name {
  name_vec elements;
  char catc;
 public:
  ConcatenatedName() : elements((Name*)0, 0), catc('+') { };
  ConcatenatedName(const Name* n) : elements(n, 1), catc('+') { };
  ConcatenatedName(char c) : elements((Name*)0, 0), catc(c) { };
  ConcatenatedName(const Name* n1, const Name* n2, char c)
    : elements((Name*)0, 0), catc(c)
  {
    elements.append(n1);
    elements.append(n2);
  };
  virtual ~ConcatenatedName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
  void append(const Name* n) { elements.append(n); };
};
class ModName : public Name {
  const char* _mod;
  const Name* _name;
 public:
  ModName(const Name* n, const char* m) : _mod(m), _name(n) { };
  virtual ~ModName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class CopyName : public Name {
  const Name* _name;
  index_type _num;
 public:
  CopyName(const Name* n) : _name(n), _num(no_such_index) { };
  CopyName(const Name* n, index_type m) : _name(n), _num(m) { };
  virtual ~CopyName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class NameAtIndex : public Name {
  const Name* _name;
  index_type _index;
 public:
  NameAtIndex(const Name* n, index_type i) : _name(n), _index(i) { };
  virtual ~NameAtIndex() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
class EnumName : public Name {
  const char* prefix;
  index_type index;
 public:
  EnumName(const char* p, index_type i) : prefix(p), index(i) { };
  virtual ~EnumName() { };
  virtual void write(::std::ostream& s, unsigned int c = NC_DEFAULT) const;
};
}
namespace hsps {
class Search;
class Plan;
class State {
 protected:
  State* pre;
 public:
  State() : pre(0) { };
  State(const State& s) : pre(s.pre) { };
  virtual ~State();
  virtual const State* predecessor() const;
  virtual State* predecessor();
  virtual void set_predecessor(State* p);
  virtual bool is_encapsulated();
  virtual hsps::rational delta_cost() = 0;
  virtual hsps::rational acc_cost();
  virtual index_type depth() const;
  virtual hsps::rational est_cost() = 0;
  virtual bool is_final() = 0;
  virtual bool is_max() = 0;
  virtual hsps::rational expand(Search& s, hsps::rational bound) = 0;
  virtual void store(hsps::rational cost, bool opt) = 0;
  virtual void reevaluate() = 0;
  virtual int compare(const State& s) = 0;
  virtual index_type hash() = 0;
  virtual State* copy() = 0;
  virtual void insert(Plan& p) = 0;
  virtual void insert_path(Plan& p) = 0;
  virtual void write(::std::ostream& s) = 0;
  virtual void write_plan(::std::ostream& s) = 0;
  virtual void write_eval(::std::ostream& s, char* p = 0, bool e = true);
  State* copy_path();
  void delete_path();
  int compare_path(const State* s);
  void write_path(::std::ostream& s);
  virtual void write_path_as_graph(::std::ostream& s);
};
inline bool operator==(State& s0, State& s1) {
  return (s0.compare(s1) == 0);
}
inline bool operator<(State& s0, State& s1) {
  return (s0.compare(s1) < 0);
}
inline bool operator<=(State& s0, State& s1) {
  return (s0.compare(s1) <= 0);
}
inline bool operator>(State& s0, State& s1) {
  return (s0.compare(s1) > 0);
}
inline bool operator>=(State& s0, State& s1) {
  return (s0.compare(s1) >= 0);
}
inline ::std::ostream& operator<<(::std::ostream& s, State& state) {
  state.write(s);
  return s;
}
class ProgressionState : public State {
 public:
  ProgressionState() { };
  ProgressionState(const ProgressionState& s) : State(s) { };
  virtual ~ProgressionState() { };
  virtual void insert_path(Plan& p);
};
class RegressionState : public State {
 public:
  RegressionState() { };
  RegressionState(const RegressionState& s) : State(s) { };
  virtual ~RegressionState() { };
  virtual void insert_path(Plan& p);
};
typedef lvector<State*> state_vec;
class PlanTrait {
 public:
  PlanTrait() { };
  virtual ~PlanTrait();
  virtual const PlanTrait* cast_to(const char* class_name) const;
};
typedef lvector<PlanTrait*> plan_trait_vec;
class Plan {
 public:
  virtual ~Plan();
  virtual void protect(index_type atom) = 0;
  virtual void insert(index_type act) = 0;
  virtual void advance(hsps::rational delta) = 0;
  virtual void end() = 0;
  virtual void output(Plan& to);
  virtual void set_name(const Name* n);
  virtual void set_optimal(bool o);
  virtual void add_trait(PlanTrait* t);
};
class Search {
 public:
  virtual ~Search();
  virtual hsps::rational new_state(State& s, hsps::rational bound) = 0;
  virtual bool solved() const = 0;
  virtual bool optimal() const = 0;
  virtual bool done() const = 0;
};
class NoSearch : public Search {
  bool _solved;
 public:
  NoSearch() : _solved(false) { };
  virtual ~NoSearch();
  void reset();
  virtual hsps::rational new_state(State& s, hsps::rational bound);
  virtual bool solved() const;
  virtual bool optimal() const;
  virtual bool done() const;
};
class Transitions : public state_vec, public Search {
  State* target_state;
  hsps::rational delta_bound;
  bool bound_is_exact;
 public:
  Transitions();
  Transitions(State* from, State* to, hsps::rational db);
  virtual ~Transitions();
  void clear();
  bool find(State* from, State* to, hsps::rational d, bool x);
  virtual hsps::rational new_state(State& s, hsps::rational bound);
  virtual bool solved() const;
  virtual bool optimal() const;
  virtual bool done() const;
};
class StateFactory {
 public:
  virtual ~StateFactory();
  virtual State* new_state(const index_set& s, State* pre) = 0;
  virtual State* new_state(const bool_vec& s, State* pre) = 0;
};
class PlanSet {
 public:
  virtual ~PlanSet();
  virtual Plan* new_plan() = 0;
  virtual void output(PlanSet& to);
  virtual void output(PlanSet& to, const bool_vec& s);
};
}
namespace hsps {
extern const double D_INF;
class Stopwatch {
  double start_t;
  double current_t;
  double total_t;
  static constexpr double TIME_OUT_TOLERANCE = 1.1;
  static bool interrupt_signal_trapped;
  static volatile bool interrupt_signal_raised;
  static bool alarm_signal_trapped;
  static volatile bool alarm_signal_raised;
  bool interrupt_enabled;
  bool time_out_enabled;
  double time_out_t;
  bool memory_limit_enabled;
  unsigned long memory_limit;
  bool stack_limit_enabled;
  unsigned long stack_limit;
  static void alarm_handler(int sig);
  static void interrupt_handler(int sig);
  static void check_stack();
  void set_interrupt();
  void clear_interrupt();
  void set_alarm(double t);
  void clear_alarm();
  void check_signals();
  static unsigned long peak_mem;
  static unsigned long peak_size;
  static unsigned long peak_stack;
  static unsigned long init_stack;
 protected:
  bool interrupt_flag;
  bool time_out_flag;
  bool out_of_memory_flag;
  bool out_of_stack_flag;
  bool error_flag;
  count_type running;
  bool terminate_on_interrupt;
  bool terminate_on_time_out;
  bool terminate_on_out_of_memory;
  bool terminate_on_out_of_stack;
  bool terminate_on_error;
 public:
  static const long FLAG_INTERRUPTED = 1;
  static const long FLAG_TIME_OUT = 2;
  static const long FLAG_OUT_OF_MEMORY = 4;
  static const long FLAG_OUT_OF_STACK = 8;
  static const long FLAG_ERROR = 16;
  Stopwatch();
  ~Stopwatch();
  static double seconds();
  void enable_interrupt(bool terminate);
  void disable_interrupt();
  void enable_time_out(double t, bool terminate);
  void disable_time_out();
  void enable_memory_limit(unsigned long l, bool terminate);
  void disable_memory_limit();
  void enable_stack_limit(unsigned long l, bool terminate);
  void disable_stack_limit();
  void set_terminate_flags(bool on_interrupt,
      bool on_time_out,
      bool on_out_of_memory,
      bool on_out_of_stack,
      bool on_error);
  bool interrupt_raised();
  bool time_out_raised();
  bool out_of_memory_raised();
  bool out_of_stack_raised();
  bool error_raised();
  double remaining();
  bool break_signal_raised();
  virtual void interrupt();
  virtual void time_out();
  virtual void out_of_memory();
  virtual void out_of_stack();
  virtual void error();
  virtual void start();
  virtual void stop();
  virtual void reset();
  count_type run_level() { return running; };
  void add(Stopwatch& s);
  void add_total(Stopwatch& s);
  double time();
  double total_time();
  unsigned long peak_memory() const;
  unsigned long peak_total_size() const;
  unsigned long peak_stack_size() const;
  unsigned long flags();
  void print(::std::ostream& s);
};
class Statistics : public Stopwatch {
  count_type min_nodes_created;
  count_type max_nodes_created;
  count_type min_nodes_expanded;
  count_type max_nodes_expanded;
  count_type iterations_started;
  count_type iterations_finished;
  count_type total_min_nodes_created;
  count_type total_max_nodes_created;
  count_type total_min_nodes_expanded;
  count_type total_max_nodes_expanded;
  count_type total_iterations_started;
  count_type total_iterations_finished;
  index_type max_depth;
  hsps::rational max_lb;
  count_type nodes_to_prove_lb;
 public:
  static bool long_print_format;
  static bool running_print_max;
  Statistics()
    : min_nodes_created(0), max_nodes_created(0),
    min_nodes_expanded(0), max_nodes_expanded(0),
    iterations_started(0), iterations_finished(0),
    total_min_nodes_created(0), total_max_nodes_created(0),
    total_min_nodes_expanded(0), total_max_nodes_expanded(0),
    total_iterations_started(0), total_iterations_finished(0),
    max_depth(0), max_lb(0), nodes_to_prove_lb(0)
    { };
  void create_node(State& s);
  void expand_node(State& s);
  void current_lower_bound(hsps::rational b);
  void begin_iteration();
  void end_iteration();
  virtual void start();
  virtual void stop();
  virtual void reset();
  virtual void time_out();
  virtual void interrupt();
  virtual void out_of_memory();
  virtual void out_of_stack();
  void add(Statistics& s);
  void add_nodes(Statistics& s);
  void add_total(Statistics& s);
  void add_nodes_total(Statistics& s);
  double branching_factor() const {
    return ((min_nodes_created + max_nodes_created)/
     ((double)(min_nodes_expanded + max_nodes_expanded)));
  };
  count_type nodes() const {
    return (min_nodes_expanded + max_nodes_expanded);
  };
  count_type total_nodes() const {
    if (running)
      return (total_min_nodes_expanded + total_max_nodes_expanded +
       min_nodes_expanded + max_nodes_expanded);
    else
      return (total_min_nodes_expanded + total_max_nodes_expanded);
  };
  count_type total_min_nodes() const {
    if (running) return (total_min_nodes_expanded + min_nodes_expanded);
    else return total_min_nodes_expanded;
  };
  count_type total_max_nodes() const {
    if (running) return (total_max_nodes_expanded + max_nodes_expanded);
    else return total_max_nodes_expanded;
  };
  hsps::rational max_lower_bound() const {
    return max_lb;
  };
  count_type nodes_at_max_lower_bound() const {
    return nodes_to_prove_lb;
  };
  count_type iterations() {
    return iterations_started;
  };
  count_type complete_iterations() {
    return iterations_finished;
  };
  count_type total_iterations() {
    if (running) return iterations_started + total_iterations_started;
    else return total_iterations_started;
  };
  count_type total_complete_iterations() {
    if (running) return iterations_finished + total_iterations_finished;
    else return total_iterations_finished;
  };
  void print_brief(::std::ostream& s, const char* p = 0);
  void print(::std::ostream& s, const char* p = 0);
  void print_total(::std::ostream& s, const char* p = 0);
};
inline ::std::ostream& operator<<(::std::ostream& s, Stopwatch& t) {
  return s << t.total_time();
}
inline ::std::ostream& operator<<(::std::ostream& s, Statistics& t) {
  if (Statistics::long_print_format) {
    t.print_total(s);
    return s;
  }
  else {
    return s << t.total_nodes() << " nodes, "
      << t.total_time() << " seconds, "
      << t.peak_memory() << "k heap, "
      << t.peak_stack_size() << "k stack";
  }
}
}
namespace hsps {
class SearchResult {
 public:
  SearchResult() { };
  virtual ~SearchResult();
  virtual void solution(State& s, hsps::rational cost) = 0;
  virtual void no_more_solutions(hsps::rational cost) = 0;
  virtual bool more() = 0;
};
class Result : public SearchResult {
 public:
  enum stop_condition { stop_at_first,
   stop_at_nth,
   stop_at_all_optimal,
   stop_at_all };
 private:
  stop_condition sc;
  count_type find_n;
  PlanSet* plans;
  count_type n_found;
  hsps::rational min_cost;
  hsps::rational max_ex;
 public:
  Result() : sc(stop_at_first), find_n(1), plans(0), n_found(0),
    min_cost(POS_INF), max_ex(NEG_INF) { };
  Result(PlanSet* s) : sc(stop_at_first), find_n(1), plans(s), n_found(0),
    min_cost(POS_INF), max_ex(NEG_INF) { };
  virtual ~Result() { };
  void set_stop_condition(stop_condition c);
  void set_n_to_find(count_type n);
  void set_plan_set(PlanSet* s);
  count_type solution_count();
  bool search_space_exhausted();
  void reset();
  virtual void solution(State& s, hsps::rational cost);
  virtual void no_more_solutions(hsps::rational cost);
  virtual bool more();
};
class SearchStats : public Search {
 protected:
  Statistics& stats;
  hsps::rational cost_limit;
  count_type node_limit;
  count_type node_count;
  count_type work_limit;
  count_type work_count;
  count_type zero_eval_count;
  void start_count();
  void stop_count();
  void reset();
 public:
  SearchStats(Statistics& s);
  SearchStats(Statistics& s, hsps::rational limit);
  virtual ~SearchStats();
  void set_cost_limit(hsps::rational c_max);
  hsps::rational get_cost_limit() const;
  bool cost_limit_reached() const;
  void set_node_limit(count_type n);
  count_type get_node_limit() const;
  bool node_limit_reached() const;
  void set_work_limit(count_type n);
  count_type get_work_limit() const;
  bool work_limit_reached() const;
  bool break_signal_raised() const;
  virtual hsps::rational cost() const = 0;
  count_type work() const;
};
class SearchAlgorithm : public SearchStats {
  bool is_solved;
  bool is_optimal;
 protected:
  SearchResult& result;
  const Name* problem_name;
  int trace_level;
  void set_solved(bool s, bool o);
  void set_solved(bool s);
  void reset();
 public:
  static int default_trace_level;
  void set_problem_name(const Name* n);
  void set_trace_level(int level);
  SearchAlgorithm(Statistics& s, SearchResult& r);
  SearchAlgorithm(Statistics& s, SearchResult& r, hsps::rational limit);
  virtual ~SearchAlgorithm();
  virtual hsps::rational start(State& s, hsps::rational b) = 0;
  virtual hsps::rational start(State& s) = 0;
  virtual bool solved() const;
  virtual bool optimal() const;
  virtual bool done() const;
};
class SingleSearchAlgorithm : public SearchAlgorithm {
 public:
  SingleSearchAlgorithm(Statistics& s, SearchResult& r)
    : SearchAlgorithm(s, r) { };
  SingleSearchAlgorithm(Statistics& s, SearchResult& r, hsps::rational limit)
    : SearchAlgorithm(s, r, limit) { };
  virtual ~SingleSearchAlgorithm() { };
  virtual hsps::rational resume() = 0;
};
class MultiSearchAlgorithm : public SearchAlgorithm {
 public:
  MultiSearchAlgorithm(Statistics& s, SearchResult& r)
    : SearchAlgorithm(s, r) { };
  MultiSearchAlgorithm(Statistics& s, SearchResult& r, hsps::rational limit)
    : SearchAlgorithm(s, r, limit) { };
  virtual ~MultiSearchAlgorithm() { };
  virtual hsps::rational resume(State& s, hsps::rational b) = 0;
  virtual hsps::rational resume(State& s);
};
}
namespace hsps {
class HashTable {
 public:
  struct Entry {
    State* state;
    index_type depth;
    hsps::rational cost;
  };
 private:
  index_type size;
  index_type nocc;
  Entry* tab;
  count_type hits;
  count_type cols;
  count_type miss;
 public:
  HashTable(index_type s);
  ~HashTable();
  void inc_occ_count() { nocc += 1; };
  Entry& operator[](index_type i);
  index_type index(State& s);
  Entry* find(State& s);
  void insert(State& s, hsps::rational v, index_type d);
  void insert(State& s, hsps::rational v);
  void clear();
  double hit_ratio();
  double HCF();
  double TUF();
};
}
namespace hsps {
class IDA : public MultiSearchAlgorithm {
  HashTable* ttab;
  bool cycle_check;
  hsps::rational current_bound;
  count_type iteration_limit;
  count_type iteration_count;
  static const count_type TRACE_LEVEL_2_NOTIFY = 100000;
 public:
  IDA(Statistics& s, SearchResult& r);
  IDA(Statistics& s, SearchResult& r, HashTable* t);
  virtual ~IDA();
  void set_iteration_limit(count_type i_max) { iteration_limit = i_max; };
  void increase_iteration_limit(count_type i) { iteration_limit += i; };
  count_type get_iteration_limit() { return iteration_limit; };
  void set_cycle_check(bool cc) { cycle_check = cc; };
  hsps::rational main(State& s, hsps::rational bound);
  virtual hsps::rational new_state(State& s, hsps::rational bound);
  virtual hsps::rational start(State& s, hsps::rational b);
  virtual hsps::rational start(State& s);
  virtual hsps::rational cost() const;
  virtual hsps::rational resume(State& s, hsps::rational b);
};
}
namespace hsps {
IDA::IDA(Statistics& s, SearchResult& r)
  : MultiSearchAlgorithm(s, r),
    ttab(0),
    cycle_check(false),
    current_bound(0),
    iteration_limit(count_type_max),
    iteration_count(0)
{
}
IDA::IDA(Statistics& s, SearchResult& r, HashTable* tt)
  : MultiSearchAlgorithm(s, r),
    ttab(tt),
    cycle_check(false),
    current_bound(0),
    iteration_limit(count_type_max),
    iteration_count(0)
{
}
IDA::~IDA()
{
}
hsps::rational IDA::start(State& s, hsps::rational b)
{
  if (ttab) ttab->clear();
  iteration_count = 0;
  reset();
  start_count();
  hsps::rational val = main(s, b);
  stop_count();
  return val;
}
hsps::rational IDA::start(State& s)
{
  stats.current_lower_bound(s.est_cost());
  return start(s, s.est_cost());
}
hsps::rational IDA::resume(State& s, hsps::rational b)
{
  start_count();
  hsps::rational val = main(s, b);
  stop_count();
  return val;
}
hsps::rational IDA::main(State& s, hsps::rational bound)
{
  current_bound = bound;
  while (!solved()) {
    if ((current_bound).infinite()) {
      if (trace_level > 1) {
 std::cerr << "break on cost = +INF" << std::endl;
      }
      return current_bound;
    }
    if (current_bound > cost_limit) {
      if (trace_level > 1) {
 std::cerr << "break on cost > " << cost_limit << std::endl;
      }
      return current_bound;
    }
    if (iteration_count >= iteration_limit) {
      if (trace_level > 1) {
 std::cerr << "break on iteration count > "
    << iteration_limit << std::endl;
      }
      return current_bound;
    }
    if (trace_level > 0) {
      std::cerr << "bound = " << std::resetiosflags(std::ios::scientific) << ((current_bound).decimal()) << ": ";
    }
    stats.begin_iteration();
    hsps::rational new_bound = new_state(s, current_bound);
    if (break_signal_raised()) return current_bound;
    if (!solved()) stats.current_lower_bound(new_bound);
    result.no_more_solutions(current_bound);
    stats.end_iteration();
    iteration_count += 1;
    current_bound = new_bound;
    if ((trace_level > 0) && !solved()) {
      std::cerr << stats;
      if (ttab) {
 std::cerr << ", TUF: " << ttab->TUF() << ", HCF: " << ttab->HCF();
      }
      std::cerr << std::endl;
    }
  }
  return current_bound;
}
hsps::rational IDA::new_state(State& s, hsps::rational bound)
{
  assert(!s.is_max());
  stats.create_node(s);
  if (s.is_final()) {
    if (trace_level > 1) {
      std::cerr << "solution (cost = " << s.acc_cost()
  << ", depth = " << s.depth() << ")" << std::endl;
      if (trace_level > 2) {
 std::cerr << "solution path:" << std::endl;
 s.write_path(std::cerr);
      }
    }
    set_solved(true);
    result.solution(s, current_bound - bound);
    return 0;
  }
  hsps::rational c_est = s.est_cost();
  HashTable::Entry* entry = 0;
  if (ttab) {
    entry = ttab->find(s);
    if (entry) c_est = hsps::rational::max(c_est,entry->cost);
  }
  if (c_est <= bound) {
    if (cycle_check) {
      for (State* sp = s.predecessor(); sp; sp = sp->predecessor())
 if (s.compare(*sp) == 0) return POS_INF;
    }
    stats.expand_node(s);
    if (trace_level > 2) {
      std::cerr << "expanding " << s
  << " (" << (s.is_max() ? "max, " : "min, ")
  << c_est << ") at bound " << bound
  << " and depth " << s.depth()
  << std::endl;
    }
    else if (trace_level > 1) {
      if ((stats.nodes() % TRACE_LEVEL_2_NOTIFY) == 0) {
 std::cerr << stats;
 if (ttab) {
   std::cerr << ", TUF: " << ttab->TUF() << ", HCF: " << ttab->HCF();
 }
 std::cerr << std::endl;
      }
    }
    hsps::rational val = s.expand(*this, bound);
    if (entry) {
      entry->cost = val;
    }
    else if (ttab) {
      index_type h = ttab->index(s);
      if ((*ttab)[h].state) {
 if ((*ttab)[h].depth > s.depth()) {
   delete (*ttab)[h].state;
   (*ttab)[h].state = 0;
 }
      }
      else {
 ttab->inc_occ_count();
      }
      if (!(*ttab)[h].state) {
 (*ttab)[h].state = s.copy();
 (*ttab)[h].depth = s.depth();
 (*ttab)[h].cost = val;
      }
    }
    return val;
  }
  else return c_est;
}
hsps::rational IDA::cost() const
{
  return current_bound;
}
}
