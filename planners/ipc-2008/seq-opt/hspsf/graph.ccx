#include <string.h>
inline char* strndup(char* s, unsigned int n)
{
  char* d = new char[n+1];
  strncpy(s, d, n);
  return d;
}
#include <assert.h>
#include <limits.h>
#include <vector>
#include <utility>
#include <iostream>
namespace hsps {
typedef unsigned int index_type;
const index_type index_type_max = (UINT_MAX - 1);

const index_type LARGE_PRIME = 2147483629U;
const index_type no_such_index = UINT_MAX;

typedef unsigned long count_type;
const count_type count_type_max = ULONG_MAX;

template<class T> class swapable_pair : public std::pair<T, T>
{
 public:
  swapable_pair()
    : std::pair<T, T>() { };
  swapable_pair(const T& v1, const T& v2)
    : std::pair<T, T>(v1, v2) { };
  swapable_pair(const T& v)
    : std::pair<T, T>(v, v) { };
  swapable_pair(const swapable_pair& p)
    : std::pair<T, T>(p) { };

  void swap();
};

template<class T> class comparable_pair : public swapable_pair<T>
{
 public:
  comparable_pair()
    : swapable_pair<T>() { };
  comparable_pair(const T& v1, const T& v2)
    : swapable_pair<T>(v1, v2) { };
  comparable_pair(const T& v)
    : swapable_pair<T>(v) { };
  comparable_pair(const comparable_pair& p)
    : swapable_pair<T>(p) { };

  void sort_ascending();
  void sort_descending();
};

typedef comparable_pair<index_type> index_pair;

template<class T> class zero_init_pair : public comparable_pair<T>
{
 public:
  zero_init_pair()
    : comparable_pair<T>(0) { };
  zero_init_pair(const T& v1, const T& v2)
    : comparable_pair<T>(v1, v2) { };
  zero_init_pair(const T& v)
    : comparable_pair<T>(v) { };
  zero_init_pair(const zero_init_pair& p)
    : comparable_pair<T>(p) { };
};




class index_set;
class bool_vec;

template<class T> class lvector : public std::vector<T>
{
 public:
  lvector() : std::vector<T>() { };
  lvector(const T& v, index_type l) : std::vector<T>(l, v) { };
  lvector(const lvector<T>& vec) : std::vector<T>(vec) { };




  class element_reference {
    lvector* _vec;
    index_type _pos;
  public:
    element_reference() : _vec(0), _pos(no_such_index) { };
    element_reference(lvector& v, index_type p) : _vec(&v), _pos(p) { };
    operator T*() const {
      if (_vec == 0) return 0;
      return &((*_vec)[_pos]);
    };
  };

  class order {
   public:
    virtual bool operator()(const T& v0, const T& v1) const = 0;
  };

  index_type length() const;
  bool contains(const T& v) const;
  index_type first(const T& v) const;
  index_type next(const T& v, index_type i) const;
  index_type find(const T& v, bool_vec& s) const;
  index_type count(const T& v) const;
  index_type arg_max() const;
  index_type arg_min() const;
  index_type arg_first(const order& o) const;
  index_type arg_last(const order& o) const;
  index_pair first_common(const lvector<T>& vec) const;
  index_pair next_common(const lvector<T>& vec, index_pair p) const;
  void difference(const lvector& v1, lvector& d0, lvector& d1);
  bool operator==(const lvector& _vec) const;
  bool operator!=(const lvector& _vec) const;
  bool operator<(const lvector& vec) const;
  bool operator>(const lvector& vec) const;
  bool operator<=(const lvector& vec) const;
  bool operator>=(const lvector& vec) const;
  void assign_copy(const lvector& _vec);
  void assign_copy(const T* _arr, index_type n);
  void assign_value(const T& val);
  void assign_value(const T& val, index_type l);
  void assign_remap(const lvector& vec, const lvector<index_type>& map);
  void remap(const lvector<index_type>& map);
  void assign_select(const lvector& _vec, const index_set& s);
  void assign_select(const lvector& _vec, const bool_vec& s);
  const lvector& operator=(const lvector& _vec);
  void set_length(index_type l);
  void set_length(index_type l, const T& v);
  void inc_length_to(index_type l);
  void inc_length_to(index_type l, const T& v);
  index_type inc_length() { return inc_length(1); };
  index_type inc_length(index_type d);
  index_type inc_length(index_type d, const T& v);
  index_type dec_length() { return dec_length(1); };
  index_type dec_length(index_type d);
  void clear();
  void append(const T& v);
  void append(const lvector& v);
  T& append();
  void insert(const T& v, index_type p);
  index_type insert_ordered(const T& v, const order& o, index_type f = 0);
  index_type insert_ordered(const lvector& vec, const order& o);
  void remove(index_type p);
  void remove(index_type p0, index_type p1);
  void remove(const index_set& s);
  void remove(const index_set& s, lvector<index_type>& map);
  void remove(const bool_vec& s);
  void remove(const bool_vec& s, lvector<index_type>& map);
  void remove_duplicate_elements();
  void swap(index_type i, index_type j);
};
template<class T> class auto_expanding_vector : public lvector<T>
{
  T _default;
 public:
  auto_expanding_vector() : lvector<T>() { };
  auto_expanding_vector(const T& v, index_type l)
    : lvector<T>(v, l), _default(v) { };
  auto_expanding_vector(const lvector<T>& vec)
    : lvector<T>(vec) { };
  auto_expanding_vector(const auto_expanding_vector<T>& vec)
    : lvector<T>(vec), _default(vec._default) { };
  typename std::vector<T>::reference
  operator[](typename std::vector<T>::size_type k)
  {
    inc_length_to(k + 1, _default);
    return lvector<T>::operator[](k);
  };
  typename std::vector<T>::const_reference
  operator[](typename std::vector<T>::size_type k) const
  {
    if (k >= std::vector<T>::size())
      return _default;
    else
      return lvector<T>::operator[](k);
  };
  void assign_value(const T& val)
  {
    _default = val;
    lvector<T>::assign_value(val);
  };
  void assign_value(const T& val, index_type l)
  {
    _default = val;
    lvector<T>::assign_value(val, l);
  };
};
typedef lvector<index_type> index_vec;
typedef lvector<index_pair> pair_vec;
class index_vec_util : public index_vec
{
 public:
  class decreasing_index_order : public index_vec::order {
  public:
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      { return (v0 > v1); };
  };
  class increasing_index_order : public index_vec::order {
  public:
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      { return (v0 < v1); };
  };
  class increasing_value_order : public index_vec::order {
    const index_vec& value;
  public:
    increasing_value_order(const index_vec& v) : value(v) { };
    virtual bool operator()
      (const index_type& v0, const index_type& v1) const
      {
 assert(v0 < value.length());
 assert(v1 < value.length());
 return (value[v0] < value[v1]);
      };
  };
  static class decreasing_index_order decreasing;
  static class increasing_index_order increasing;
  static void fill(index_vec& vec, index_type max);
  static index_type min(const index_vec& vec, index_type def = no_such_index);
  static index_type max(const index_vec& vec, index_type def = no_such_index);
  static int compare(const index_vec& v0, const index_vec& v1);
  static index_type hash(const index_vec& vec);
  void fill(index_type max);
  int compare(const index_vec& v1) const;
  index_type hash() const;
};
void factors(index_type n, index_vec& f);
template<class T> class svector : public lvector<T>
{
 public:
  svector() : lvector<T>() { };
  svector(const svector<T>& _svec) : lvector<T>(_svec) { };
  svector(const lvector<T>& _lvec) : lvector<T>() {
    for (index_type k = 0; k < _lvec.size(); k++) insert(_lvec[k]);
  };
  bool contains(const T& v) const;
  bool contains(const svector& vec) const;
  bool subset(const svector& vec) const;
  index_pair first_common(const lvector<T>& vec) const;
  index_pair next_common(const lvector<T>& vec, index_pair p) const;
  index_pair first_common(const svector<T>& vec) const;
  index_pair next_common(const svector<T>& vec, index_pair p) const;
  index_type count_common(const svector& vec) const;
  void assign_singleton(const T& _val);
  void assign_values(const lvector<T>& vec);
  void insert(const T& v);
  void insert(const lvector<T>& vec);
  void intersect(const svector& vec);
  void difference(const svector& vec);
  void subtract(const svector& vec);
  void subtract(const T& v);
};
class index_set : public svector<index_type>
{
 public:
  index_set()
    : svector<index_type>() { };
  index_set(const index_set& _svec)
    : svector<index_type>(_svec) { };
  index_set(const lvector<index_type>& _lvec)
    : svector<index_type>(_lvec) { };
  index_set(const bool* _arr, index_type n);
  index_set(const bool_vec& _vec);
  index_set(const index_set& s0, const index_set& s);
  index_set(const index_set& s0, const bool_vec& s);
  index_set(const index_set& s0, const index_vec& map);
  index_type first_common_element(const index_set& set) const;
  index_type first_common_element(const index_vec& vec) const;
  index_type first_common_element(const bool_vec vec) const;
  index_type first_common_element(const bool* vec, index_type n) const;
  index_type count_common(const index_set& set) const;
  index_type count_common(const bool_vec& set) const;
  bool have_common_element(const index_set& set) const;
  bool have_common_element(const bool_vec& set) const;
  void insert(const index_type& v);
  void insert(const index_vec& vec);
  void insert(const bool_vec& set);
  void intersect(const index_set& vec);
  void intersect(const bool_vec& set);
  void subtract(const index_vec& vec);
  void subtract(const bool_vec& set);
  void subtract(const index_type& v);
  bool* copy_to(bool* s, index_type n) const;
  void fill(index_type to);
  void assign_remap(const index_set& set, const index_vec& map);
  void remap(const index_vec& map);
};
extern const index_set EMPTYSET;
typedef svector<index_pair> pair_set;
class bool_vec : public lvector<bool>
{
 public:
  bool_vec() : lvector<bool>() { };
  bool_vec(bool _val, index_type l) : lvector<bool>(_val, l) { };
  bool_vec(const bool_vec& _vec) : lvector<bool>(_vec) { };
  bool_vec(const bool* _arr, index_type n) : lvector<bool>(false, n) {
    for (index_type k = 0; k < n; k++) {
      if (_arr[k])
 (*this)[k] = true;
      else
 (*this)[k] = false;
    }
  };
  bool_vec(const index_set& set, index_type l);
  void complement();
  void insert(const bool_vec& vec);
  void insert(const index_set& set);
  void intersect(const bool_vec& vec);
  void intersect(const index_set& set);
  void subtract(const bool_vec& vec);
  void subtract(const index_set& set);
  bool subset(const bool_vec& vec) const;
  bool strict_subset(const bool_vec& vec) const;
  bool superset(const bool_vec& vec) const;
  bool strict_superset(const bool_vec& vec) const;
  bool contains(const bool& v) const;
  bool contains(const bool_vec& set) const;
  bool contains(const index_set& set) const;
  bool contains_any(const index_set& set) const;
  index_type first_common_element(const index_set& vec) const;
  index_type first_common_element(const bool_vec vec) const;
  index_type count_common(const bool_vec& vec) const;
  index_type count_common(const index_set& set) const;
  index_set& copy_to(index_set& set) const;
  index_set& insert_into(index_set& set) const;
  index_set& subtract_from(index_set& set) const;
  bool* copy_to(bool* s, index_type n) const;
  int compare(const bool_vec& vec) const;
  index_type hash() const;
};
class index_set_vec : public lvector<index_set>
{
 public:
  index_set_vec()
    : lvector<index_set>() { };
  index_set_vec(const index_set& set, index_type l)
    : lvector<index_set>(set, l) { };
  index_set_vec(index_type l)
    : lvector<index_set>(EMPTYSET, l) { };
  index_set_vec(const index_set_vec& vec)
    : lvector<index_set>(vec) { };
  class decreasing_cardinality_order : public index_set_vec::order {
  public:
    virtual bool operator()
      (const index_set& v0, const index_set& v1) const
      { return (v0.size() > v1.size()); };
  };
  decreasing_cardinality_order decreasing_cardinality;
  index_type minimum_cardinality() const;
  index_type maxmimum_cardinality() const;
  index_type selected_minimum_cardinality(const index_set& sel) const;
  index_type selected_maximum_cardinality(const index_set& sel) const;
  index_type first_minimum_cardinality_set() const;
  index_type first_maxmimum_cardinality_set() const;
  index_type first_superset(const index_set& set) const;
  index_type first_strict_superset(const index_set& set) const;
  index_type first_subset(const index_set& set) const;
  index_type first_strict_subset(const index_set& set) const;
  index_set& union_set(index_set& set) const;
  index_set& selected_union_set(const index_set& sel, index_set& set) const;
  index_set& intersection_set(index_set& set) const;
  void insert_maximal(const index_set& set);
  void insert_minimal(const index_set& set);
  void reduce_to_maximal();
  void reduce_to_minimal();
  void append_if_not_subset(const index_set& set);
  void append_if_not_superset(const index_set& set);
  void append_if_new(const index_set& set);
  void remove_sets_size_le(index_type l);
  void remove_empty_sets();
  void insert_in_all(index_type i);
  void insert_in_all(const index_set& set);
  void subtract_from_all(index_type i);
  void subtract_from_all(const index_set& set);
  void combinations_by_union(const index_set_vec& sv);
  void combinations_by_union(const index_set_vec& sv1,
        const index_set_vec& sv2);
};
template<class T> class matrix : public lvector< lvector<T> >
{
 public:
  typedef lvector<T> row_type;
  matrix()
    : lvector<row_type>() { };
  matrix(const T& _val, index_type r, index_type c)
    : lvector<row_type>(row_type(_val, c), r) { };
  matrix(const matrix& _mat)
    : lvector<row_type>(_mat) { };
  index_type rows() const
  {
    return lvector<row_type>::length();
  };
  index_type columns() const
  {
    if (lvector<row_type>::length() == 0) return 0;
    else return (*this)[0].length();
  };
  void set_size(index_type r, index_type c);
  void assign_value(const T& _val);
  void assign_value(const T& _val, index_type r, index_type c);
};
class bool_matrix : public matrix<bool> {
 public:
  bool_matrix()
    : matrix<bool>() { };
  bool_matrix(const bool& v, index_type r, index_type c)
    : matrix<bool>(v, c, r) { };
  bool_matrix(const bool_matrix& m)
    : matrix<bool>(m) { };
  void complement();
  void insert(const bool_matrix& m);
  void intersect(const bool_matrix& m);
  void subtract(const bool_matrix& m);
  void multiply(const bool_matrix& m0, const bool_matrix& m1);
  void transitive_closure();
};
typedef matrix<index_type> index_matrix;
class mapping : public index_vec
{
 public:
  static void identity_map
    (index_type n, index_vec& map)
    { index_vec_util::fill(map, n); };
  static bool invert_map
    (const index_vec& map, index_vec& inv, index_type m = 0);
  static void delete_index_map
    (index_type n, index_type i, index_vec& map);
  static void compose
    (const index_vec& m0, const index_vec& m1, index_vec& cm);
  static void map_image
    (const index_vec& map, const index_vec& vec, index_vec& img);
  static void inverse_map_image
    (const index_vec& map, index_type x, index_set& img);
  static void inverse_map_image
    (const index_vec& map, const index_set& x, index_set& img);
  static index_type range(const index_vec& map, index_type d);
  mapping()
    : index_vec() { };
  mapping(index_type n)
    : index_vec() { identity_map(n, *this); };
  mapping(index_type n, index_type i, bool out) : index_vec() {
    if (out) delete_index_map(n, i, *this); else assign_value(i, n);
  };
  mapping(const mapping& map)
    : index_vec(map) { };
  void assign_identity(index_type n)
    { identity_map(n, *this); };
  index_type operator()(index_type x) const
    { assert(x < size()); return (*this)[x]; };
  index_vec operator()(const index_vec& vec) const
    { index_vec res; map_image(*this, vec, res); return res; };
  index_vec& inverse(index_type x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  index_vec& inverse(const index_set& x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  bool invert(index_vec& rmap) const
    { return invert_map(*this, rmap); };
  bool invert()
    { index_vec tmp(*this); return invert_map(tmp, *this); };
  index_type range() const
    { return range(*this, length()); };
};
class sparse_mapping : public pair_vec
{
 public:
  static void dense_to_sparse(const index_vec& dm, pair_vec sm);
  static void sparse_to_dense(const pair_vec& sm, index_vec dm);
  static index_type map_image
    (const pair_vec& map, index_type x);
  static void map_image
    (const pair_vec& map, const index_vec& vec, index_vec& img);
  static void inverse_map_image
    (const pair_vec& map, index_type x, index_set& img);
  static void inverse_map_image
    (const pair_vec& map, const index_set& x, index_set& img);
  sparse_mapping()
    : pair_vec() { };
  sparse_mapping(const pair_vec& m)
    : pair_vec(m) { };
  sparse_mapping(const index_vec& m)
    : pair_vec() { dense_to_sparse(m, *this); };
  index_type operator()(index_type x) const
    { return map_image(*this, x); };
  index_vec operator()(const index_vec& vec) const
    { index_vec res; map_image(*this, vec, res); return res; };
  index_set& inverse(index_type x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
  index_set& inverse(const index_set& x, index_set& res) const
    { inverse_map_image(*this, x, res); return res; };
};
class equivalence : public index_vec
{
 public:
  equivalence()
    : index_vec() { };
  equivalence(index_type n)
    : index_vec(no_such_index, n) { index_vec_util::fill(*this, n); };
  equivalence(const equivalence& eq)
    : index_vec(eq) { };
  bool operator()(index_type a, index_type b) const;
  index_type canonical(index_type a) const;
  void extend(index_type a);
  void merge(index_type a, index_type b);
  void merge(const equivalence& eq);
  void merge(const index_set& set);
  void merge(const index_set& sa, const index_set& sb);
  void reset();
  void reset(index_type n);
  void canonical_set(index_set& set) const;
  void canonical_elements(index_set& set) const;
  void class_elements(index_type rep, index_set& set) const;
  index_type n_class_elements(index_type rep) const;
  void classes(index_set_vec& sets) const;
  void make_map(index_vec& map) const;
  index_type n_classes() const;
  index_type n_squeezed() const;
};
class set_hash_function : index_vec
{
 public:
  set_hash_function(index_type n)
    : index_vec() { init(n); };
  void init(index_type n);
  index_type operator()(index_type& i, index_type v) const;
  index_type operator()(const index_set& set) const;
  index_type operator()(const bool_vec& set) const;
  index_type operator()(const bool* set, index_type n) const;
};
template<class T, class N> struct weighted
{
  T value;
  N weight;
  weighted() : weight(0) { };
  weighted(const T& v) : value(v), weight(0) { };
  weighted(const T& v, const N& w) : value(v), weight(w) { };
  weighted(const weighted& w) : value(w.value), weight(w.weight) { };
  ~weighted() { };
  weighted& operator=(const T& v)
  {
    value = v;
    weight = 0;
    return *this;
  };
  weighted& operator=(const weighted& w)
  {
    value = w.value;
    weight = w.weight;
    return *this;
  };
  bool operator==(const weighted& w) const
  {
    return (value == w.value);
  };
  bool operator!=(const weighted& w) const
  {
    return (value != w.value);
  };
  bool operator<(const weighted& w) const
  {
    return (value < w.value);
  };
  bool operator<=(const weighted& w) const
  {
    return (value <= w.value);
  };
  bool operator>(const weighted& w) const
  {
    return (value > w.value);
  };
  bool operator>=(const weighted& w) const
  {
    return (value >= w.value);
  };
};
template<class T, class N> class weighted_vec
: public lvector< weighted<T, N> >
{
 public:
  class decreasing_weight_order : public lvector< weighted<T,N> >::order {
  public:
    virtual bool operator()
      (const weighted<T,N>& v0, const weighted<T,N>& v1) const
      { return (v0.weight > v1.weight); };
  };
  class increasing_weight_order : public lvector< weighted<T,N> >::order {
  public:
    virtual bool operator()
      (const weighted<T,N>& v0, const weighted<T,N>& v1) const
      { return (v0.weight < v1.weight); };
  };
  static class decreasing_weight_order decreasing;
  static class increasing_weight_order increasing;
  void insert_increasing(const weighted<T,N>& v);
  void insert_decreasing(const weighted<T,N>& v);
  void insert_increasing(const T& v, const N& w);
  void insert_decreasing(const T& v, const N& w);
};
template<class T, class N> class weighted_set
: public svector< weighted<T,N> >
{
 public:
  void insert(const T& v, const N& w);
  void insert(const T& v);
  index_type arg_max();
  index_type arg_min();
};
template<class T>
bool lvector<T>::operator==(const lvector& _vec) const
{
  if (lvector<T>::size() != _vec.size()) return false;
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if (!((*this)[k] == _vec[k])) return false;
  return true;
}
template<class T>
bool lvector<T>::operator!=(const lvector& _vec) const
{
  if (*this == _vec) return false;
  else return true;
}
template<class T>
bool lvector<T>::operator<(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return true;
  else if (lvector<T>::size() > vec.size()) return false;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return true;
      else if ((*this)[k] > vec[k]) return false;
    }
    return false;
  }
}
template<class T>
bool lvector<T>::operator<=(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return true;
  else if (lvector<T>::size() > vec.size()) return false;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return true;
      else if ((*this)[k] > vec[k]) return false;
    }
    return true;
  }
}
template<class T>
bool lvector<T>::operator>(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return false;
  else if (lvector<T>::size() > vec.size()) return true;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return false;
      else if ((*this)[k] > vec[k]) return true;
    }
    return false;
  }
}
template<class T>
bool lvector<T>::operator>=(const lvector& vec) const
{
  if (lvector<T>::size() < vec.size()) return false;
  else if (lvector<T>::size() > vec.size()) return true;
  else {
    for (index_type k = 0; k < lvector<T>::size(); k++) {
      if ((*this)[k] < vec[k]) return false;
      else if ((*this)[k] > vec[k]) return true;
    }
    return true;
  }
}
template<class T>
bool lvector<T>::contains(const T& v) const
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return true;
  return false;
}
template<class T>
index_type lvector<T>::first(const T& v) const
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return k;
  return no_such_index;
}
template<class T>
index_type lvector<T>::next(const T& v, index_type p) const
{
  for (index_type k = p + 1; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) return k;
  return no_such_index;
}
template<class T>
index_type lvector<T>::find(const T& v, bool_vec& s) const
{
  index_type n = 0;
  s.assign_value(false, lvector<T>::size());
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) {
      s[k] = true;
      n += 1;
    }
  return n;
}
template<class T>
index_type lvector<T>::count(const T& v) const
{
  index_type c = 0;
  for (index_type k = 0; k < lvector<T>::size(); k++)
    if ((*this)[k] == v) c += 1;
  return c;
}
template<class T>
index_type lvector<T>::length() const
{
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::arg_max() const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if ((*this)[k] > (*this)[m]) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_min() const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if ((*this)[k] < (*this)[m]) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_first(const order& o) const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if (o((*this)[k], (*this)[m])) m = k;
  return m;
}
template<class T>
index_type lvector<T>::arg_last(const order& o) const
{
  if (lvector<T>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < lvector<T>::size(); k++)
    if (o((*this)[m], (*this)[k])) m = k;
  return m;
}
template<class T>
index_pair lvector<T>::first_common(const lvector<T>& vec) const
{
  for (index_type i = 0; i < lvector<T>::size(); i++) {
    for (index_type j = 0; j < vec.size(); j++)
      if ((*this)[i] == vec[j]) return index_pair(i, j);
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_pair lvector<T>::next_common(const lvector<T>& vec, index_pair p) const
{
  index_type i = p.first;
  index_type j = p.second + 1;
  while (j < vec.size()) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    j += 1;
  }
  i += 1;
  while (i < lvector<T>::size()) {
    j = 0;
    while (j < vec.size()) {
      if ((*this)[i] == vec[j])
 return index_pair(i, j);
      j += 1;
    }
    i += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
void lvector<T>::difference
(const lvector& v1, lvector& d0, lvector& d1)
{
  d0.assign_copy(*this);
  d1.assign_copy(v1);
  index_type i0 = 0;
  while (i0 < d0.size()) {
    index_type i1 = d1.first(d0[i0]);
    if (i1 != no_such_index) {
      d0.remove(i0);
      d1.remove(i1);
    }
    else {
      i0 += 1;
    }
  }
}
template<class T>
void lvector<T>::assign_copy(const lvector& _vec)
{
  std::vector<T>::resize(_vec.size());
  for (index_type k = 0; k < _vec.size(); k++)
    (*this)[k] = _vec[k];
}
template<class T>
void lvector<T>::assign_copy(const T* _arr, index_type n)
{
  std::vector<T>::resize(n);
  for (index_type k = 0; k < n; k++)
    (*this)[k] = _arr[k];
}
template<class T>
void lvector<T>::assign_value(const T& _val)
{
  for (index_type k = 0; k < lvector<T>::size(); k++)
    (*this)[k] = _val;
}
template<class T>
void lvector<T>::assign_value(const T& _val, index_type l)
{
  std::vector<T>::resize(l);
  for (index_type k = 0; k < lvector<T>::size(); k++)
    (*this)[k] = _val;
}
template<class T>
void lvector<T>::assign_remap(const lvector<T>& vec, const index_vec& map)
{
  assert(map.length() == vec.length());
  index_type m = 0;
  for (index_type k = 0; k < vec.length(); k++)
    if (map[k] != no_such_index)
      if (map[k] > m) m = map[k];
  set_length(m + 1);
  for (index_type k = 0; k < vec.length(); k++)
    if (map[k] != no_such_index)
      (*this)[map[k]] = vec[k];
}
template<class T>
void lvector<T>::remap(const index_vec& map)
{
  lvector v0(*this);
  assign_remap(v0, map);
}
template<class T>
void lvector<T>::assign_select(const lvector& _vec, const index_set& s)
{
  set_length(s.length());
  for (index_type k = 0; k < s.length(); k++)
    (*this)[k] = _vec[s[k]];
}
template<class T>
void lvector<T>::assign_select(const lvector& _vec, const bool_vec& s)
{
  clear();
  for (index_type k = 0; k < _vec.length(); k++)
    if (s[k]) append(_vec[k]);
}
template<class T>
const lvector<T>& lvector<T>::operator=(const lvector<T>& _vec)
{
  assign_copy(_vec);
  return _vec;
}
template<class T>
void lvector<T>::set_length(index_type l)
{
  std::vector<T>::resize(l);
}
template<class T>
void lvector<T>::set_length(index_type l, const T& v)
{
  std::vector<T>::resize(l, v);
}
template<class T>
void lvector<T>::inc_length_to(index_type l)
{
  if (std::vector<T>::size() < l)
    std::vector<T>::resize(l);
}
template<class T>
void lvector<T>::inc_length_to(index_type l, const T& v)
{
  if (std::vector<T>::size() < l)
    std::vector<T>::resize(l, v);
}
template<class T>
index_type lvector<T>::inc_length(index_type d)
{
  std::vector<T>::resize(std::vector<T>::size() + d);
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::inc_length(index_type d, const T& v)
{
  std::vector<T>::resize(std::vector<T>::size() + d, v);
  return std::vector<T>::size();
}
template<class T>
index_type lvector<T>::dec_length(index_type d)
{
  assert(std::vector<T>::size() >= d);
  std::vector<T>::resize(std::vector<T>::size() - d);
  return std::vector<T>::size();
}
template<class T>
void lvector<T>::clear()
{
  std::vector<T>::clear();
}
template<class T>
void lvector<T>::append(const T& v)
{
  std::vector<T>::push_back(v);
}
template<class T>
void lvector<T>::append(const lvector<T>& v)
{
  for (index_type k = 0; k < v.size(); k++) append(v[k]);
}
template<class T>
T& lvector<T>::append()
{
  T v;
  std::vector<T>::push_back(v);
  return (*this)[std::vector<T>::size() - 1];
}
template<class T>
void lvector<T>::insert(const T& v, index_type p)
{
  if (p < lvector<T>::size()) {
    std::vector<T>::insert(std::vector<T>::begin() + p, v);
  }
  else {
    std::vector<T>::resize(p + 1);
    (*this)[p] = v;
  }
}
template<class T>
index_type lvector<T>::insert_ordered(const T& v, const order& o, index_type f)
{
  assert(f <= lvector<T>::size());
  for (index_type k = f; k < lvector<T>::size(); k++) {
    if (o(v, (*this)[k])) {
      insert(v, k);
      return k;
    }
  }
  append(v);
  return (lvector<T>::size() - 1);
}
template<class T>
index_type lvector<T>::insert_ordered(const lvector& vec, const order& o)
{
  if (vec.empty()) return no_such_index;
  index_type p0 = insert_ordered(vec[0], o);
  for (index_type k = 1; k < vec.size(); k++) {
    index_type p1 = insert_ordered(vec[k], o);
    if (p1 < p0) p0 = p1;
  }
  return p0;
}
template<class T>
void lvector<T>::remove(index_type p)
{
  if (p < lvector<T>::size())
    std::vector<T>::erase(std::vector<T>::begin() + p);
}
template<class T>
void lvector<T>::remove(index_type p0, index_type p1)
{
  assert(p0 < p1);
  if (p1 < lvector<T>::size())
    std::vector<T>::erase(std::vector<T>::begin() + p0,
     std::vector<T>::begin() + p1);
  else
    std::vector<T>::erase(std::vector<T>::begin() + p0,
     std::vector<T>::end());
}
template<class T>
void lvector<T>::remove(const bool_vec& s, index_vec& map)
{
  assert(s.size() >= lvector<T>::size());
  index_type scan_p = 0;
  index_type put_p = 0;
  index_vec rm_map(no_such_index, lvector<T>::size());
  while (scan_p < lvector<T>::size()) {
    if (!s[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      rm_map[scan_p] = put_p;
      put_p += 1;
    }
    else {
      rm_map[scan_p] = no_such_index;
    }
    scan_p += 1;
  }
  std::vector<T>::resize(put_p);
  for (index_type k = 0; k < map.size(); k++)
    if (map[k] != no_such_index) {
      assert(map[k] < rm_map.size());
      map[k] = rm_map[map[k]];
    }
}
template<class T>
void lvector<T>::remove(const bool_vec& s)
{
  assert(s.size() >= lvector<T>::size());
  index_type scan_p = 0;
  index_type put_p = 0;
  while (scan_p < lvector<T>::size()) {
    if (!s[scan_p]) {
      if (put_p < scan_p) {
 (*this)[put_p] = (*this)[scan_p];
      }
      put_p += 1;
    }
    scan_p += 1;
  }
  std::vector<T>::resize(put_p);
}
template<class T>
void lvector<T>::remove(const index_set& s)
{
  bool_vec s1(s, lvector<T>::size());
  remove(s1);
}
template<class T>
void lvector<T>::remove(const index_set& s, index_vec& map)
{
  bool_vec s1(s, std::vector<T>::size());
  lvector<T>::remove(s1, map);
}
template<class T>
void lvector<T>::remove_duplicate_elements()
{
  equivalence eq(lvector<T>::size());
  for (index_type i = 0; i < lvector<T>::size(); i++)
    for (index_type j = i+1; j < lvector<T>::size(); j++)
      if ((*this)[i] == (*this)[j])
 eq.merge(i, j);
  bool_vec s(false, lvector<T>::size());
  for (index_type i = 0; i < lvector<T>::size(); i++)
    if (eq.canonical(i) != i)
      s[i] = true;
  remove(s);
}
template<class T>
void lvector<T>::swap(index_type i, index_type j)
{
  T tmp = (*this)[i];
  (*this)[i] = (*this)[j];
  (*this)[j] = tmp;
}
template<class T>
void svector<T>::assign_singleton(const T& _val)
{
  lvector<T>::set_length(1);
  (*this)[0] = _val;
}
template<class T>
void svector<T>::assign_values(const lvector<T>& vec)
{
  lvector<T>::clear();
  for (index_type k = 0; k < vec.size(); k++)
    insert(vec[k]);
}
template<class T>
void svector<T>::insert(const T& v) {
  index_type i = 0;
  bool seeking = (i < std::vector<T>::size());
  while (seeking) {
    if ((*this)[i] < v) {
      i += 1;
      if (i >= std::vector<T>::size())
 seeking = false;
    }
    else {
      seeking = false;
    }
  }
  if (i < lvector<T>::size()) {
    if ((*this)[i] == v)
      return;
    else
      lvector<T>::insert(v, i);
  }
  else {
    lvector<T>::append(v);
  }
}
template<class T>
void svector<T>::insert(const lvector<T>& vec)
{
  for (index_type k = 0; k < vec.size(); k++) insert(vec[k]);
}
template<class T>
bool svector<T>::contains(const T& v) const
{
  index_type i = 0;
  while ((i < lvector<T>::size()) &&
  ((*this)[i] < v)) i += 1;
  if (i < lvector<T>::size())
    if ((*this)[i] == v) return true;
  return false;
}
template<class T>
bool svector<T>::contains(const svector& vec) const
{
  index_type v_i = 0;
  index_type i = 0;
  while (v_i < vec.size()) {
    if (i >= lvector<T>::size()) return false;
    if ((*this)[i] == vec[v_i]) {
      v_i += 1;
      i += 1;
    }
    else if ((*this)[i] > vec[v_i]) {
      return false;
    }
    else {
      while ((i < lvector<T>::size()) && ((*this)[i] < vec[v_i]))
 i += 1;
    }
  }
  return true;
}
template<class T>
bool svector<T>::subset(const svector& vec) const
{
  return vec.contains(*this);
}
template<class T>
void svector<T>::intersect(const svector& vec)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if (!vec.contains((*this)[i]))
      lvector<T>::remove(i);
    else
      i += 1;
  }
}
template<class T>
void svector<T>::difference(const svector& vec)
{
  svector d(vec);
  d.subtract(*this);
  subtract(vec);
  insert(d);
}
template<class T>
index_pair svector<T>::first_common(const lvector<T>& vec) const
{
  return lvector<T>::first_common(vec);
}
template<class T>
index_pair svector<T>::next_common(const lvector<T>& vec, index_pair p) const
{
  return lvector<T>::next_common(vec, p);
}
template<class T>
index_pair svector<T>::first_common(const svector<T>& vec) const
{
  index_type i = 0;
  index_type j = 0;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    else if
      ((*this)[i] < vec[j]) i += 1;
    else
      j += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_pair svector<T>::next_common(const svector<T>& vec, index_pair p) const
{
  index_type i = p.first + 1;
  index_type j = p.second + 1;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j])
      return index_pair(i, j);
    else if ((*this)[i] < vec[j])
      i += 1;
    else
      j += 1;
  }
  return index_pair(no_such_index, no_such_index);
}
template<class T>
index_type svector<T>::count_common(const svector& vec) const
{
  index_type i = 0;
  index_type j = 0;
  index_type c = 0;
  while ((i < svector<T>::size()) && (j < vec.size())) {
    if ((*this)[i] == vec[j]) {
      c += 1;
      i += 1;
      j += 1;
    }
    else if ((*this)[i] < vec[j])
      i += 1;
    else
      j += 1;
  }
  return c;
}
template<class T>
void svector<T>::subtract(const svector& vec)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if (vec.contains((*this)[i]))
      lvector<T>::remove(i);
    else
      i += 1;
  }
}
template<class T>
void svector<T>::subtract(const T& v)
{
  index_type i = 0;
  while (i < lvector<T>::size()) {
    if ((*this)[i] == v) {
      lvector<T>::remove(i);
      return;
    }
    else {
      i += 1;
    }
  }
}
template<class T>
void matrix<T>::set_size(index_type r, index_type c)
{
  lvector<row_type>::set_length(r);
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].set_length(c);
}
template<class T>
void matrix<T>::assign_value(const T& _val)
{
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].assign_value(_val);
}
template<class T>
void matrix<T>::assign_value(const T& _val, index_type r, index_type c)
{
  lvector<row_type>::set_length(r);
  for (index_type k = 0; k < lvector<row_type>::size(); k++)
    (*this)[k].assign_value(_val, c);
}
template<class T>
void swapable_pair<T>::swap()
{
  T tmp = this->first;
  this->first = this->second;
  this->second = tmp;
}
template<class T>
void comparable_pair<T>::sort_ascending()
{
  if (this->first > this->second) swapable_pair<T>::swap();
}
template<class T>
void comparable_pair<T>::sort_descending()
{
  if (this->first < this->second) swapable_pair<T>::swap();
}
template<class T, class N>
class weighted_vec<T,N>::decreasing_weight_order
  weighted_vec<T,N>::decreasing;
template<class T, class N>
class weighted_vec<T,N>::increasing_weight_order
  weighted_vec<T,N>::increasing;
template<class T, class N>
void weighted_vec<T,N>::insert_increasing(const weighted<T,N>& v)
{
  insert_ordered(v, increasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_decreasing(const weighted<T,N>& v)
{
  insert_ordered(v, decreasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_increasing(const T& v, const N& w)
{
  insert_ordered(weighted<T,N>(v, w), increasing);
}
template<class T, class N>
void weighted_vec<T,N>::insert_decreasing(const T& v, const N& w)
{
  insert_ordered(weighted<T,N>(v, w), decreasing);
}
template<class T, class N>
void weighted_set<T,N>::insert(const T& v, const N& w)
{
  index_type p = svector< weighted<T,N> >::first(v);
  if (p == no_such_index) {
    svector< weighted<T,N> >::insert(weighted<T,N>(v, w));
  }
  else {
    (*this)[p].weight += w;
  }
}
template<class T, class N>
void weighted_set<T,N>::insert(const T& v)
{
  index_type p = svector< weighted<T,N> >::first(v);
  if (p == no_such_index) {
    svector< weighted<T,N> >::insert(weighted<T,N>(v, 1));
  }
  else {
    (*this)[p].weight += 1;
  }
}
template<class T, class N>
index_type weighted_set<T,N>::arg_max()
{
  if (weighted_set<T,N>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < weighted_set<T,N>::size(); k++)
    if ((*this)[k].weight > (*this)[m].weight) m = k;
  return m;
}
template<class T, class N>
index_type weighted_set<T,N>::arg_min()
{
  if (weighted_set<T,N>::empty()) return no_such_index;
  index_type m = 0;
  for (index_type k = 1; k < weighted_set<T,N>::size(); k++)
    if ((*this)[k].weight < (*this)[m].weight) m = k;
  return m;
}
template<class T>
inline std::ostream& operator<<(std::ostream& s, const swapable_pair<T>& p)
{
  return s << '(' << p.first << ',' << p.second << ')';
}
template<class T>
::std::ostream& operator<<(::std::ostream& s, const lvector<T>& _vec)
{
  s << '[';
  for (index_type k = 0; k < _vec.size(); k++) {
    if (k > 0) s << ',';
    s << _vec[k];
  }
  s << ']';
  return s;
}
inline std::ostream& operator<<(std::ostream& s, const mapping& m)
{
  s << '{';
  for (index_type k = 0; k < m.length(); k++) {
    if (k > 0) s << ',';
    s << k << '-' << '>';
    if (m[k] == no_such_index)
      s << '_';
    else
      s << m[k];
  }
  return s << '}';
}
inline std::ostream& operator<<(std::ostream& s, const equivalence& eq)
{
  s << '{';
  bool first = true;
  for (index_type k = 0; k < eq.length(); k++) {
    index_type c = eq.canonical(k);
    if (!first) {
      s << ',';
    }
    else {
      first = false;
    }
    s << k << '=' << c;
  }
  return s << '}';
}
template<class T, class N>
std::ostream& operator<<(::std::ostream& s, const weighted<T,N>& w)
{
  s << '<' << w.value << ':' << w.weight << '>';
}
}
#include <iostream>
#include <limits.h>
namespace hsps {
long euclid(long n, long k, long& a, long& b);
long gcd(long n, long k);
long lcm(long n, long k);
unsigned long ilog(unsigned long n);
long imag(long n);
class rational {
  long nm;
  long dv;
 public:
  rational();
  rational(long n);
  rational(long n, long d);
  rational(const rational& r);
  struct XR {
    long x_nm;
    long x_dv;
    XR& operator=(const rational r);
  };
  rational(const XR& x);
  long numerator() const;
  long divisor() const;
  long sign() const;
  bool zero() const;
  bool finite() const;
  bool infinite() const;
  bool integral() const;
  static rational reduce(rational r);
  static rational invert(const rational r);
  static rational infinity(const rational r);
  static rational infinity(const long s);
  static rational floor(const rational r);
  static rational floor_to(const rational r, long div);
  static rational ceil(const rational r);
  static rational ceil_to(const rational r, long div);
  static rational frac(const rational r);
  static rational round(const rational r, long div_max);
  static rational min(const rational r0, const rational r1);
  static rational max(const rational r0, const rational r1);
  static rational rgcd(const rational r0, const rational r1);
  static rational dtor(double v);
  static rational ator(const char* s);
  rational reduce() const;
  rational invert() const;
  rational floor() const;
  rational floor_to(long d) const;
  rational ceil() const;
  rational frac() const;
  rational round(long div_max) const;
  rational round() const;
  rational operator=(const rational r);
  rational operator=(long n);
  rational operator+=(const rational r);
  rational operator-=(const rational r);
  rational operator*=(const rational r);
  rational operator/=(const rational r);
  rational operator+=(long n);
  rational operator-=(long n);
  rational operator*=(long n);
  rational operator/=(long n);
  double decimal() const;
};
bool operator==(const rational r0, const rational r1);
bool operator==(const rational r0, long n1);
bool operator==(long n0, const rational r1);
bool operator!=(const rational r0, const rational r1);
bool operator!=(const rational r0, long n1);
bool operator!=(long n0, const rational r1);
bool operator<(const rational r0, const rational r1);
bool operator<=(const rational r0, const rational r1);
bool operator>(const rational r0, const rational r1);
bool operator>=(const rational r0, const rational r1);
rational operator+(const rational r0, const rational r1);
rational operator-(const rational r0, const rational r1);
rational operator*(const rational r0, const rational r1);
rational operator/(const rational r0, const rational r1);
rational operator+(const rational r0, long n1);
rational operator-(const rational r0, long n1);
rational operator*(const rational r0, long n1);
rational operator/(const rational r0, long n1);
rational operator+(long n0, const rational r1);
rational operator-(long n0, const rational r1);
rational operator*(long n0, const rational r1);
rational operator/(long n0, const rational r1);
rational safeadd(const rational r0, const rational r1);
rational safemul(const rational r0, const rational r1);
::std::ostream& operator<<(::std::ostream& s, const rational r);
inline rational::XR& rational::XR::operator=(const rational r)
{
  x_nm = r.numerator();
  x_dv = r.divisor();
  return *this;
}
inline rational::rational()
  : nm(0), dv(1) { }
inline rational::rational(long n)
  : nm(n), dv(1) { }
inline rational::rational(long n, long d)
  : nm(d < 0 ? -1*n : n), dv(d < 0 ? -1*d : d) { }
inline rational::rational(const rational& r)
  : nm(r.nm), dv(r.dv) { }
inline rational::rational(const rational::XR& x)
  : nm(x.x_nm), dv(x.x_dv) { };
inline long rational::numerator() const { return nm; }
inline long rational::divisor() const { return dv; }
inline long rational::sign() const
{
  return (nm < 0 ? -1 : (nm > 0 ? 1 : 0));
}
inline bool rational::zero() const
{
  return nm == 0;
}
inline bool rational::finite() const
{
  return dv != 0;
}
inline bool rational::infinite() const
{
  return dv == 0;
}
inline bool rational::integral() const
{
  return dv == 1;
}
inline rational rational::reduce(rational r)
{
  if (r.infinite()) return infinity(r.sign());
  if (r.sign() == 0) return rational(0,1);
  long c = gcd(r.nm, r.dv);
  return rational(r.nm / c, r.dv / c);
}
inline rational rational::invert(const rational r)
{
  return rational(r.dv, r.nm);
}
inline rational rational::infinity(const long s)
{
  return rational((s < 0 ? -1 : (s > 0 ? 1 : 0)), 0);
}
inline rational rational::infinity(const rational r)
{
  return rational(r.sign(),0);
}
inline rational rational::floor(const rational r)
{
  if (r.infinite()) return r;
  return rational(r.nm / r.dv);
}
inline rational rational::floor_to(const rational r, long d)
{
  if (r.infinite()) return r;
  return rational((r.nm * d) / r.dv, d);
}
inline rational rational::ceil(const rational r)
{
  if (r.infinite()) return r;
  if (r.dv == 1) return r;
  return rational((r.nm / r.dv) + 1, 1);
}
inline rational rational::ceil_to(const rational r, long d)
{
  if (r.infinite()) return r;
  long x = (r.nm * d);
  long y = x / r.dv;
  if ((y * r.dv) == x)
    return rational(y, d);
  else
    return rational(y + 1, d);
}
inline rational rational::frac(const rational r) {
  if (r.infinite()) return r;
  return reduce(rational(r.nm % r.dv, r.dv));
}
inline rational rational::round(const rational r, long d_max)
{
  if (r.infinite()) return r;
  rational s(r);
  while (s.dv > d_max) {
    s.dv = (s.dv / 2);
    s.nm = (s.nm / 2);
    s.reduce();
  }
  return s;
}
inline rational rational::rgcd(const rational r0, const rational r1)
{
  long c = gcd(r0.divisor(), r1.divisor());
  long a0 = r0.numerator() * (r1.divisor() / c);
  long a1 = r1.numerator() * (r0.divisor() / c);
  long d = gcd(a0, a1);
  return rational(d, (r0.divisor() / c) * (r1.divisor() / c) * c).reduce();
}
inline rational rational::min(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    if (r0.sign() < 0) return r0;
    else return r1;
  }
  else if (r1.infinite()) {
    if (r1.sign() < 0) return r1;
    else return r0;
  }
  else if (r0 < r1) return r0;
  else return r1;
}
inline rational rational::max(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    if (r0.sign() > 0) return r0;
    else return r1;
  }
  else if (r1.infinite()) {
    if (r1.sign() > 0) return r1;
    else return r0;
  }
  else if (r0 < r1) return r1;
  else return r0;
}
inline rational rational::reduce() const
{
  return reduce(*this);
}
inline rational rational::invert() const
{
  return invert(*this);
}
inline rational rational::floor() const
{
  return floor(*this);
}
inline rational rational::floor_to(long d) const
{
  return floor_to(*this, d);
}
inline rational rational::ceil() const
{
  return ceil(*this);
}
inline rational rational::frac() const
{
  return frac(*this);
}
inline rational rational::round(long d_max) const
{
  return round(*this, d_max);
}
inline rational rational::round() const
{
  return round(*this, (LONG_MAX/16));
}
inline rational rational::operator=(const rational r)
{
  nm = r.nm;
  dv = r.dv;
  return *this;
}
inline rational rational::operator=(long n)
{
  nm = n;
  dv = 1;
  return *this;
}
inline rational rational::operator+=(const rational r)
{
  return *this = (*this + r);
}
inline rational rational::operator-=(const rational r)
{
  return *this = (*this - r);
}
inline rational rational::operator*=(const rational r)
{
  return *this = (*this * r);
}
inline rational rational::operator/=(const rational r)
{
  return *this = (*this / r);
}
inline rational rational::operator+=(long n)
{
  return *this = (*this + n);
}
inline rational rational::operator-=(long n)
{
  return *this = (*this - n);
}
inline rational rational::operator*=(long n)
{
  return *this = (*this * n);
}
inline rational rational::operator/=(long n)
{
  return *this = (*this / n);
}
inline double rational::decimal() const { return nm/(double)dv; };
inline bool operator==(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite()) return r0.sign() == r1.sign();
  else return ((r0.numerator() == r1.numerator()) &&
        (r0.divisor() == r1.divisor()));
}
inline bool operator==(const rational r0, long n1)
{
  return ((r0.numerator() == n1) && (r0.divisor() == 1));
}
inline bool operator==(long n0, const rational r1)
{
  return ((r1.numerator() == n0) && (r1.divisor() == 1));
}
inline bool operator!=(const rational r0, const rational r1)
{
  return !(r0 == r1);
}
inline bool operator!=(const rational r0, long n1)
{
  return !(r0 == n1);
}
inline bool operator!=(long n0, const rational r1)
{
  return !(n0 == r1);
}
inline bool operator<(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return false;
  else return (r0 - r1).sign() < 0;
}
inline bool operator<=(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return true;
  else return (r0 - r1).sign() <= 0;
}
inline bool operator>(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return false;
  else return (r0 - r1).sign() > 0;
}
inline bool operator>=(const rational r0, const rational r1)
{
  if (r0.infinite() && r1.infinite() && (r0.sign() == r1.sign())) return true;
  else return (r0 - r1).sign() >= 0;
}
inline rational operator+(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() == r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " + " << r1 << " not defined"
           << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() + r1.numerator(), 1);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n = (r0.numerator() * (r1.divisor() / c) +
       r1.numerator() * (r0.divisor() / c));
    long d = ((r0.divisor() / c) * r1.divisor());
    return rational(n, d).reduce();
  }
}
inline rational operator-(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() != r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " - " << r1 << " not defined"
      << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1.sign() * -1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() - r1.numerator(), 1);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n = (r0.numerator() * (r1.divisor() / c) -
       r1.numerator() * (r0.divisor() / c));
    long d = ((r0.divisor() / c) * r1.divisor());
    return rational(n, d).reduce();
  }
}
inline rational operator*(const rational r0, const rational r1)
{
  if (r0.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else if (r1.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else if ((r0.divisor() == 1) && (r1.divisor() == 1)) {
    return rational(r0.numerator() * r1.numerator(), 1);
  }
  else {
    long c0 = gcd(r0.numerator(), r1.divisor());
    long c1 = gcd(r1.numerator(), r0.divisor());
    return rational((r0.numerator() / c0) * (r1.numerator() / c1),
      (r0.divisor() / c1) * (r1.divisor() / c0)).reduce();
  }
}
inline rational operator/(const rational r0, const rational r1)
{
  return (r0 * r1.invert());
}
inline rational operator+(const rational r0, long n1)
{
  return rational(r0.numerator() + (n1 * r0.divisor()), r0.divisor()).reduce();
}
inline rational operator-(const rational r0, long n1)
{
  return rational(r0.numerator() - (n1 * r0.divisor()), r0.divisor()).reduce();
}
inline rational operator*(const rational r0, long n1)
{
  return rational(r0.numerator() * n1, r0.divisor()).reduce();
}
inline rational operator/(const rational r0, long n1)
{
  return rational((n1 < 0 ? r0.numerator() * -1 : r0.numerator()),
    r0.divisor() * (n1 < 0 ? n1 * -1 : n1)).reduce();
}
inline rational operator+(long n0, const rational r1)
{
  return rational(r1.numerator() + (n0 * r1.divisor()), r1.divisor()).reduce();
}
inline rational operator-(long n0, const rational r1)
{
  return rational((n0 * r1.divisor()) - r1.numerator(), r1.divisor()).reduce();
}
inline rational operator*(long n0, const rational r1)
{
  return rational(r1.numerator() * n0, r1.divisor()).reduce();
}
inline rational operator/(long n0, const rational r1)
{
  return (n0 * r1.invert());
}
inline rational safeadd(const rational r0, const rational r1)
{
  if (r1.infinite()) {
    if (r0.infinite()) {
      if (r1.sign() == r0.sign()) return rational::infinity(r0);
      else {
 ::std::cerr << "error: " << r0 << " + " << r1 << " not defined"
      << ::std::endl;
 abort();
      }
    }
    else {
      return rational::infinity(r1);
    }
  }
  else if (r0.infinite()) {
    return rational::infinity(r0);
  }
  else {
    long c = gcd(r0.divisor(), r1.divisor());
    long n0 = r0.numerator();
    long d0 = r0.divisor() / c;
    long n1 = r1.numerator();
    long d1 = r1.divisor() / c;
    assert(d0 > 0);
    assert(d1 > 0);
    while (((LONG_MAX / (2*d1)) < (imag(n0) + 1)) ||
    ((LONG_MAX / (2*d0)) < (imag(n1) + 1)) ||
    ((LONG_MAX / (d0 * c)) < (d1 + 1))) {
      if ((d1 < 2) && (d0 < 2)) {
 std::cerr << "error: overflow in safeadd(" << r0 << ", " << r1 << ")"
    << std::endl;
 abort();
      }
      if (d0 < 2) {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
      else if (d1 < 2) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else if ((imag(n0) - d0) > (imag(n1) - d1)) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
    }
    long f0 = n0 * d1;
    long f1 = n1 * d0;
    long n = f0 + f1;
    long d = d0 * d1 * c;
    return rational(n, d).reduce();
  }
}
inline rational safemul(const rational r0, const rational r1)
{
  if (r0.infinite() || r1.infinite()) {
    return rational::infinity(r0.sign() * r1.sign());
  }
  else {
    long c0 = gcd(r0.numerator(), r1.divisor());
    long c1 = gcd(r1.numerator(), r0.divisor());
    long n0 = r0.numerator() / c0;
    long n1 = r1.numerator() / c1;
    long d0 = r0.divisor() / c1;
    long d1 = r1.divisor() / c0;
    while (((LONG_MAX / imag(n0)) < (imag(n1) + 1)) ||
    ((LONG_MAX / d0) < (d1 + 1))) {
      if ((d1 < 2) && (d0 < 2)) {
 std::cerr << "error: overflow in safeadd(" << r0 << ", " << r1 << ")"
    << std::endl;
 abort();
      }
      if (d0 < 2) {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
      else if (d1 < 2) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else if ((imag(n0) - d0) > (imag(n1) - d1)) {
 n0 = (n0 / 2);
 d0 = (d0 / 2);
      }
      else {
 n1 = (n1 / 2);
 d1 = (d1 / 2);
      }
    }
    return rational(n0 * n1, d0 * d1).reduce();
  }
}
inline ::std::ostream& operator<<(::std::ostream& s, const rational r)
{
  if (r.infinite()) {
    if (r.sign() < 0) return s << "-INF";
    else return s << "INF";
  }
  else if (r.integral()) {
    return s << r.numerator();
  }
  else {
    return s << r.numerator() << '/' << r.divisor();
  }
}
}
namespace hsps {
class RNG {
 public:
  virtual ~RNG() { };
  virtual void seed(unsigned long s) = 0;
  virtual unsigned long seed_value() = 0;
  virtual unsigned long random() = 0;
  void seed_with_pid();
  void seed_with_time();
  unsigned long random_in_range(unsigned long range);
  unsigned long random_in_range(unsigned long range, unsigned long except);
  double random_double(unsigned long div);
  double normal_sample(double mean, double var);
  unsigned long binomial_sample(unsigned long n, double p);
  index_type select_one_of(const bool_vec& sel);
  index_type select_one_of(const index_vec& sel);
  void select_fixed_set(index_set& s, index_type m, index_type n);
  void select_variable_set(index_set& s, index_type m, index_type n);
  void select_non_empty_variable_set(index_set& s, index_type m, index_type n);
  virtual unsigned long max() = 0;
};
class LC_RNG : public RNG {
  unsigned long a;
  unsigned long b;
  unsigned long mod;
  unsigned long x;
 public:
  LC_RNG()
    : a(23), b(0), mod(100000001), x(100000001 - 1) { };
  LC_RNG(unsigned long _a, unsigned long _b, unsigned long m)
    : a(_a), b(_b), mod(m), x(m - 1) { };
  LC_RNG(unsigned long s)
    : a(23), b(0), mod(100000001), x(s) { };
  LC_RNG(unsigned long _a, unsigned long _b, unsigned long m, unsigned long s)
    : a(_a), b(_b), mod(m), x(s) { };
  virtual ~LC_RNG() { };
  virtual void seed(unsigned long s);
  virtual unsigned long seed_value();
  virtual unsigned long random();
  virtual unsigned long max();
};
}
#include <iostream>
#include <iomanip>
const hsps::rational POS_INF(1,0);
const hsps::rational NEG_INF(-1,0);
const hsps::rational ZERO(0,1);
namespace hsps {
inline hsps::rational random_numeric
(hsps::rational min, hsps::rational max, unsigned long prec, RNG& rng)
{
  hsps::rational d = (max - min);
  hsps::rational s = (d / prec);
  unsigned long r = rng.random_in_range(prec + 1);
  return ((r*s) + min);
}
class amt_vec : public auto_expanding_vector<hsps::rational> {
 public:
  amt_vec()
    : auto_expanding_vector<hsps::rational>() { };
  amt_vec(const hsps::rational& v, index_type l)
    : auto_expanding_vector<hsps::rational>(v, l) { };
  amt_vec(const amt_vec& vec)
    : auto_expanding_vector<hsps::rational>(vec) { };
  int compare(const amt_vec& vec, index_type n);
  int dcompare(const amt_vec& vec, index_type n);
  index_type hash(index_type n);
  void write(std::ostream& s, index_type n);
};
inline int amt_vec::compare(const amt_vec& vec, index_type n)
{
  for (index_type k = 0; k < n; k++) {
    if ((*this)[k] < vec[k]) return -1;
    else if ((*this)[k] > vec[k]) return 1;
  }
  return 0;
}
inline int amt_vec::dcompare(const amt_vec& vec, index_type n)
{
  bool this_less_than_vec = false;
  bool vec_less_than_this = false;
  for (index_type k = 0; k < n; k++) {
    if ((*this)[k] < vec[k]) this_less_than_vec = true;
    else if ((*this)[k] > vec[k]) vec_less_than_this = true;
  }
  if (this_less_than_vec && !vec_less_than_this) return -1;
  else if (!this_less_than_vec && vec_less_than_this) return 1;
  else return 0;
}
inline index_type amt_vec::hash(index_type n)
{
  if (n == 0) return 0;
  if (n == 1) return ((index_type)(((*this)[0]).numerator() - ((*this)[0]).divisor()));
  index_type h = 0;
  for (index_type k = 0; k < n - 1; k++) {
    h += ((index_type)(((((*this)[k]) + 1) * (((*this)[k + 1]) + 1)).numerator() - ((((*this)[k]) + 1) * (((*this)[k + 1]) + 1)).divisor()));
  }
  return h;
}
inline void amt_vec::write(std::ostream& s, index_type n)
{
  s << '[';
  for (index_type k = 0; k < n; k++) {
    if (k > 0) s << ',';
    s << std::resetiosflags(std::ios::scientific) << (((*this)[k]).decimal());
  }
  s << ']';
}
typedef lvector<hsps::rational> cost_vec;
typedef svector<hsps::rational> cost_set;
typedef matrix<hsps::rational> cost_matrix;
class cost_vec_util : public cost_vec
{
 public:
  class decreasing_cost_order : public cost_vec::order {
  public:
    virtual bool operator()
      (const hsps::rational& v0, const hsps::rational& v1) const
      { return (v0 > v1); };
  };
  class increasing_cost_order : public cost_vec::order {
  public:
    virtual bool operator()
      (const hsps::rational& v0, const hsps::rational& v1) const
      { return (v0 < v1); };
  };
  static class decreasing_cost_order decreasing;
  static class increasing_cost_order increasing;
  static hsps::rational max(const cost_vec& v);
  static hsps::rational min(const cost_vec& v);
  hsps::rational max() const { return max(*this); };
  hsps::rational min() const { return min(*this); };
};
struct interval : public comparable_pair<hsps::rational> {
  interval(const hsps::rational& v1, const hsps::rational& v2) :
    comparable_pair<hsps::rational>(v1, v2) { };
  interval(const hsps::rational& v) :
    comparable_pair<hsps::rational>(v) { };
  interval(const interval& p) :
    comparable_pair<hsps::rational>(p) { };
  interval() :
    comparable_pair<hsps::rational>(NEG_INF, POS_INF) { };
};
typedef std::pair<index_type, hsps::rational> index_cost_pair;
typedef lvector<index_cost_pair> index_cost_vec;
inline std::ostream& operator<<(std::ostream& s, const index_cost_pair& p)
{
  s << '(' << p.first << ',' << p.second << ')';
}
inline std::ostream& operator<<(std::ostream& s, const interval& i)
{
  s << '[' << i.first << ',' << i.second << ']';
}
}
#include <map>
#include <iostream>
namespace hsps {
class graph {
 private:
  index_type _size;
  bool_matrix adj;
  index_set_vec in;
  index_set_vec out;
  index_set_vec bi;
  index_vec comp;
  index_type n_comp;
 public:
  graph();
  graph(index_type s);
  graph(const graph& g);
  graph(const graph& g, const index_set& n);
  graph(const graph& g, const equivalence& eq);
  ~graph();
  index_type size() const { return _size; };
  bool adjacent(index_type i, index_type j) const { return adj[i][j]; };
  bool adjacent(index_type i, const index_set& n) const;
  bool adjacent(const index_set& n, index_type i) const;
  bool adjacent(const index_set& n0, const index_set& n1) const;
  bool bi_adjacent(index_type i, index_type j) const
    { return (adj[i][j] && adj[j][i]); };
  bool bi_adjacent(index_type i, const index_set& n) const;
  index_type n_edges() const;
  index_type n_edges(const index_set& from, const index_set& to) const;
  pair_set& edges(pair_set& s) const;
  index_type n_induced_undirected_edges() const;
  index_type n_induced_undirected_edges(const index_set& n0,
     const index_set& n1) const;
  index_type n_bidirectional_edges() const;
  index_type n_bidirectional_edges(const index_set& n0,
       const index_set& n1) const;
  const index_set& successors(index_type i) const { return out[i]; };
  index_type out_degree(index_type i) const { return out[i].length(); };
  const index_set& predecessors(index_type i) const { return in[i]; };
  index_type in_degree(index_type i) const { return in[i].length(); };
  const index_set& bidirectional(index_type i) const { return bi[i]; };
  index_type bi_degree(index_type i) const { return bi[i].length(); };
  pair_set& bidirectional_edges(pair_set& s) const;
  void descendants(index_type n0, bool_vec& s) const;
  void descendants(const index_set& s0, bool_vec& s) const;
  void descendants(index_type n0, index_set& s) const;
  void descendants(const index_set& s0, index_set& s) const;
  void ancestors(index_type n0, bool_vec& s) const;
  void ancestors(const index_set& s0, bool_vec& s) const;
  void ancestors(index_type n0, index_set& s) const;
  void ancestors(const index_set& s0, index_set& s) const;
  index_type max_out_degree() const;
  index_type max_in_degree() const;
  index_type max_bi_degree() const;
  index_type min_out_degree() const;
  index_type min_in_degree() const;
  index_type min_bi_degree() const;
  bool empty() const;
  bool connected() const;
  bool strongly_connected() const;
  bool reachable(index_type n0, index_type n1) const;
  void reachable(bool_vec& v) const;
  index_type count_reachable(index_type n0) const;
  bool acyclic() const;
  bool top_sort(index_vec& s) const;
  index_type first_root() const;
  index_type first_leaf() const;
  void fringe(const index_set& n, index_set& fn) const;
  void bi_fringe(const index_set& n, index_set& fn) const;
  void distance(index_type s0, index_vec& d) const;
  void distance(const index_set& s0, index_vec& d) const;
  index_type distance(index_type s0, index_type s1) const;
  void strongly_connected_components();
  index_type component(index_type i) const { return comp[i]; };
  index_type n_components() const { return n_comp; };
  index_type component_node(index_type i) const;
  index_type component_size(index_type i) const;
  void component_node_set(index_type i, index_set& set) const;
  graph& component_tree(graph& cg) const;
  equivalence& component_partitioning(equivalence& eq) const;
  index_type maximal_non_unit_component() const;
  graph& subgraph(graph& g, const index_set& n) const;
  graph& edge_subgraph(graph& g, const index_set& nodes) const;
  equivalence& induced_partitioning(equivalence& eq) const;
  graph& induced_undirected_graph(graph& g) const;
  graph& minimal_equivalent_digraph(graph& g) const;
  graph& minimal_distance_graph(graph& g, const index_set& s0) const;
  graph& quotient(graph& g, const equivalence& eq) const;
  bool equals(const graph& g) const;
  bool equals(const graph& g, const index_vec& c) const;
  void difference(const graph& g,
    const index_vec& c,
    pair_set& d0,
    pair_set& d1) const;
  void difference(const graph& g,
    pair_set& d0,
    pair_set& d1) const;
  index_type cardinality_of_difference(const graph& g) const;
  void init(index_type s);
  void copy(const graph& g);
  void copy(const graph& g, const index_vec& map);
  void copy_and_rename(const graph& g, const index_vec& map);
  index_type add_node();
  void remove_node(index_type n);
  void add_graph(const graph& g, mapping& m);
  void add_edge(index_type src, index_type dst);
  void add_edge(const index_set& srcs, index_type dst);
  void add_edge(index_type src, const index_set& dsts);
  void add_edge_to_transitive_closure(index_type src,
          index_type dst,
          pair_set& e);
  void remove_edge(index_type src, index_type dst);
  void remove_edges_from(index_type src);
  void remove_edges_to(index_type dst);
  void remove_edges_incident_on(index_type n);
  void remove_edges(const pair_set& e);
  void add_undirected_edge(index_type n0, index_type n1);
  void remove_undirected_edge(index_type n0, index_type n1);
  void remove_undirected_edges(const pair_set& e);
  void clear_edges();
  void recalculate();
  void complement();
  void complement_with_loops();
  void remove_loops();
  void reverse();
  void transitive_closure();
  void missing_transitive_edges(pair_set& e) const;
  void transitive_reduction();
  void intersect(const graph& g);
  void randomize(count_type n, RNG& rnd);
  void randomize_connected(count_type n, RNG& rnd);
  void randomize_strongly_connected(count_type n, RNG& rnd);
  void random_digraph(count_type n, RNG& rnd);
  void random_connected_digraph(count_type n, RNG& rnd);
  void random_strongly_connected_digraph(count_type n, RNG& rnd);
  void random_digraph_with_density(rational density, RNG& rnd);
  void random_tree(RNG& rnd);
  void random_tree(index_type b, index_type d, RNG& rnd);
  bool is_clique(const index_set& nodes) const;
  bool is_independent(const index_set& nodes) const;
  bool is_independent_range(index_type l, index_type u) const;
  void maximal_clique(index_set& clique) const;
  void maximal_clique_including(index_type node, index_set& clique) const;
  void maximal_clique_cover(index_set_vec& sets) const;
  void all_maximal_cliques(index_set_vec& cliques) const;
  void all_maximal_cliques_including(index_type node, index_set_vec& cliques)
    const;
  void apx_independent_set(index_set& set) const;
  void apx_independent_set_including(index_type node, index_set& set) const;
  void apx_independent_set_cover(index_set_vec& sets) const;
  void apx_independent_set_disjoint_cover(index_set_vec& sets) const;
  void all_nondominated_cliques(index_set_vec &cliques) const;
  void all_cliques_geq(index_type k, index_set_vec& cliques) const;
  void write_node_set(::std::ostream& s) const;
  void write_edge_set(::std::ostream& s) const;
  void write_compact(::std::ostream& s) const;
  void write_undirected_edge_set(::std::ostream& s) const;
  void write_adjacency_lists(::std::ostream& s) const;
  void write_digraph(::std::ostream& s,
       bool with_node_indices,
       const char* name) const;
  void write_component_labeled_digraph(::std::ostream& s,
           const char* name) const;
  void write_graph_correspondance(::std::ostream& s,
      const graph& g,
      const index_vec& c,
      const char* name) const;
 public:
  void max_clique(index_set& sel,
    index_type next,
    index_set& clique) const;
  void all_max_cliques(index_set& sel,
         index_type next,
         index_set_vec& cliques) const;
  void all_nondominated_cliques_aux(index_set_vec &cliques,
                                    index_set &current_clique,
                                    const index_set &candidates,
        index_type min) const;
  void ramsey(const index_set& nodes, index_set& I, index_set& C) const;
  void apx_independent_set(const index_set& nodes, index_set& set) const;
  void undirected_dfs(index_type n, bool_vec& visited) const;
  void reachable(index_type n, bool_vec& v) const;
  void reverse_reachable(index_type n, bool_vec& v) const;
 private:
  void scc_first_dfs(index_type n, bool_vec& visited, index_vec& num) const;
  void scc_second_dfs(index_type n, bool_vec& visited, index_type c_id);
};
template<class LS>
void write_labeled_digraph
(std::ostream& s,
 const graph& g,
 const LS& ls,
 bool with_node_indices = false,
 const char* name = 0,
 index_type c_id = no_such_index)
{
  if (c_id != no_such_index) {
    s << "subgraph cluster" << c_id << "{" << std::endl;
  }
  else if (name) {
    s << "digraph \"" << name << "\" {" << ::std::endl;
  }
  s << "node [width=0,height=0];" << ::std::endl;
  for (index_type k = 0; k < g.size(); k++) {
    if (with_node_indices) {
      s << "\t" << k + (c_id == no_such_index ? 0 : c_id)
 << " [label=\"(" << k << ") " << ls[k] << "\"];"
 << ::std::endl;
    }
    else {
      s << "\t" << k + (c_id == no_such_index ? 0 : c_id)
 << " [label=\"" << ls[k] << "\"];"
 << ::std::endl;
    }
  }
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j))
 s << "\t" << i + (c_id == no_such_index ? 0 : c_id)
   << " -> " << j + (c_id == no_such_index ? 0 : c_id)
   << ";" << ::std::endl;
  if ((c_id != no_such_index) || (name != 0)) {
    s << "}" << ::std::endl;
  }
}
typedef lvector<graph> graph_vec;
template<class N, class E> class labeled_graph : public graph {
 public:
  typedef std::map<index_type, N> node_label_map;
  typedef std::map<index_pair, E> edge_label_map;
  typedef lvector<N> node_label_vec;
  typedef lvector<E> edge_label_vec;
 protected:
  node_label_map _node_label;
  edge_label_map _edge_label;
 public:
  labeled_graph();
  labeled_graph(index_type size);
  labeled_graph(const graph& g);
  labeled_graph(const labeled_graph& g);
  labeled_graph(const graph& g, const index_set& nodes);
  labeled_graph(const labeled_graph& g, const index_set& nodes);
  labeled_graph(const graph& g, const equivalence& eq);
  ~labeled_graph();
  N& node_label(index_type n);
  E& edge_label(index_type i, index_type j);
  const N& node_label(index_type n) const;
  const E& edge_label(index_type i, index_type j) const;
  bool node_has_label(index_type n) const;
  bool edge_has_label(index_type i, index_type j) const;
  labeled_graph& subgraph(labeled_graph& g, const index_set& n) const;
  index_type node_with_label(const N& l) const;
  index_pair edge_with_label(const E& l) const;
  void init(index_type size);
  void init(index_type size, const N& n, const E& e);
  void copy(const graph& g);
  void copy(const labeled_graph& g);
  void add_graph(const graph& g, mapping& m);
  void add_graph(const labeled_graph& g, mapping& m);
  void add_edge(index_type src, index_type dst);
  void add_edge(index_type src, index_type dst, const E& lbl);
  void add_edge(const index_set& srcs, index_type dst);
  void add_edge(const index_set& srcs, index_type dst, const E& lbl);
  void add_edge(index_type src, const index_set& dsts);
  void add_edge(index_type src, const index_set& dsts, const E& lbl);
  index_type add_node();
  index_type add_node(const N& l);
  void remove_node(index_type n);
  void remove_edge(index_type src, index_type dst);
  void remove_edges_from(index_type src);
  void remove_edges_to(index_type dst);
  void remove_edges_incident_on(index_type n);
  void remove_undirected_edge(index_type n0, index_type n1);
  void remove_edges(const pair_set& e);
  void remove_undirected_edges(const pair_set& e);
  void clear_edges();
  void clear_node_labels();
  void clear_edge_labels();
  void remove_edges_with_label(const E& l);
  void write_digraph(::std::ostream& s,
       bool with_node_indices,
       bool with_node_labels,
       bool with_edge_labels,
       bool compact_edges,
       const char* name) const;
  void write_matrix(::std::ostream& s,
      const char* unlabeled_edge,
      const char* missing_edge) const;
};
template<class N, class E>
labeled_graph<N,E>::labeled_graph()
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(index_type s)
  : graph(s)
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(const graph& g)
  : graph(g)
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(const labeled_graph& g)
  : graph(g), _node_label(g._node_label), _edge_label(g._edge_label)
{
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph(const graph& g, const index_set& n)
{
  g.subgraph(*this, n);
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph
(const labeled_graph& g, const index_set& n)
{
  g.subgraph(*this, n);
}
template<class N, class E>
labeled_graph<N,E>::labeled_graph
(const graph& g, const equivalence& eq)
{
  g.quotient(*this, eq);
}
template<class N, class E>
labeled_graph<N,E>::~labeled_graph()
{
}
template<class N, class E>
N& labeled_graph<N,E>::node_label(index_type n)
{
  assert(n < size());
  return _node_label[n];
}
template<class N, class E>
E& labeled_graph<N,E>::edge_label(index_type i, index_type j)
{
  assert((i < size()) && (j < size()));
  return _edge_label[index_pair(i, j)];
}
template<class N, class E>
const N& labeled_graph<N,E>::node_label(index_type n) const
{
  assert(node_has_label(n));
  return (_node_label.find(n)->second);
}
template<class N, class E>
const E& labeled_graph<N,E>::edge_label(index_type i, index_type j) const
{
  assert(edge_has_label(i, j));
  return (_edge_label.find(index_pair(i, j))->second);
}
template<class N, class E>
bool labeled_graph<N,E>::node_has_label(index_type n) const
{
  assert(n < size());
  return (_node_label.find(n) != _node_label.end());
}
template<class N, class E>
bool labeled_graph<N,E>::edge_has_label(index_type i, index_type j) const
{
  assert((i < size()) && (j < size()));
  return (_edge_label.find(index_pair(i, j)) != _edge_label.end());
}
template<class N, class E>
void labeled_graph<N,E>::init(index_type s)
{
  graph::init(s);
  _node_label.clear();
  _edge_label.clear();
}
template<class N, class E>
void labeled_graph<N,E>::copy(const labeled_graph& g)
{
  graph::copy(g);
  _node_label = g._node_label;
  _edge_label = g._edge_label;
}
template<class N, class E>
labeled_graph<N,E>& labeled_graph<N,E>::subgraph
(labeled_graph& g, const index_set& n) const
{
  g.init(n.length());
  for (index_type k = 0; k < n.length(); k++) {
    assert(n[k] < size());
    if (node_has_label(n[k])) {
      g.node_label(k) = node_label(n[k]);
    }
  }
  for (index_type i = 0; i < n.length(); i++)
    for (index_type j = 0; j < n.length(); j++)
      if (adjacent(n[i], n[j])) {
 g.add_edge(i, j);
 if (edge_has_label(n[i], n[j])) {
   g.edge_label(i, j) = edge_label(n[i], n[j]);
 }
      }
}
template<class N, class E>
index_type labeled_graph<N,E>::node_with_label(const N& l) const
{
  for (index_type k = 0; k < size(); k++)
    if (node_has_label(k))
      if (node_label(k) == l)
 return k;
  return no_such_index;
}
template<class N, class E>
index_pair labeled_graph<N,E>::edge_with_label(const E& l) const
{
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) && edge_has_label(i, j))
 if (edge_label(i, j) == l)
   return index_pair(i, j);
  return no_such_index;
}
template<class N, class E>
void labeled_graph<N,E>::add_graph
(const graph& g, mapping& m)
{
  graph::add_graph(g, m);
}
template<class N, class E>
void labeled_graph<N,E>::add_graph
(const labeled_graph& g, mapping& m)
{
  graph::add_graph(g, m);
  for (index_type i = 0; i < g.size(); i++) {
    if (g.node_has_label(i))
      node_label(m[i]) = g.node_label(i);
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j) && g.edge_has_label(i, j))
 edge_label(m[i], m[j]) = g.edge_label(i, j);
  }
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, index_type dst)
{
  graph::add_edge(src, dst);
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, index_type dst, const E& lbl)
{
  graph::add_edge(src, dst);
  edge_label(src, dst) = lbl;
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(const index_set& srcs, index_type dst)
{
  graph::add_edge(srcs, dst);
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(const index_set& srcs, index_type dst, const E& lbl)
{
  graph::add_edge(srcs, dst);
  for (index_type k = 0; k < srcs.length(); k++)
    edge_label(srcs[k], dst) = lbl;
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, const index_set& dsts)
{
  graph::add_edge(src, dsts);
}
template<class N, class E>
void labeled_graph<N,E>::add_edge
(index_type src, const index_set& dsts, const E& lbl)
{
  graph::add_edge(src, dsts);
  for (index_type k = 0; k < dsts.length(); k++)
    edge_label(src, dsts[k]) = lbl;
}
template<class N, class E>
index_type labeled_graph<N,E>::add_node()
{
  return graph::add_node();
}
template<class N, class E>
index_type labeled_graph<N,E>::add_node(const N& l)
{
  index_type n = graph::add_node();
  node_label(n) = l;
  return n;
}
template<class N, class E>
void labeled_graph<N,E>::remove_node(index_type n)
{
  assert(n < size());
  labeled_graph g(*this);
  index_set ns;
  ns.fill(size());
  ns.subtract(n);
  g.subgraph(*this, ns);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edge(index_type src, index_type dst)
{
  _edge_label.erase(index_pair(src, dst));
  graph::remove_edge(src, dst);
}
template<class N, class E>
void labeled_graph<N,E>::remove_undirected_edge(index_type n0, index_type n1)
{
  _edge_label.erase(index_pair(n0, n1));
  _edge_label.erase(index_pair(n1, n0));
  graph::remove_undirected_edge(n0, n1);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_from(index_type src)
{
  index_set ns(successors(src));
  for (index_type k = 0; k < ns.length(); k++)
    remove_edge(src, ns[k]);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_to(index_type dst)
{
  index_set ns(predecessors(dst));
  for (index_type k = 0; k < ns.length(); k++)
    remove_edge(ns[k], dst);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_incident_on(index_type n)
{
  remove_edges_from(n);
  remove_edges_to(n);
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges(const pair_set& e)
{
  for (index_type k = 0; k < e.length(); k++) {
    remove_edge(e[k].first, e[k].second);
  }
}
template<class N, class E>
void labeled_graph<N,E>::remove_undirected_edges(const pair_set& e)
{
  for (index_type k = 0; k < e.length(); k++) {
    remove_undirected_edge(e[k].first, e[k].second);
  }
}
template<class N, class E>
void labeled_graph<N,E>::clear_edges()
{
  _edge_label.clear();
  graph::clear_edges();
}
template<class N, class E>
void labeled_graph<N,E>::clear_node_labels()
{
  _node_label.clear();
}
template<class N, class E>
void labeled_graph<N,E>::clear_edge_labels()
{
  _edge_label.clear();
}
template<class N, class E>
void labeled_graph<N,E>::remove_edges_with_label(const E& l)
{
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) && (edge_label(i, j) == l))
 remove_edge(i, j);
}
template<class N, class E>
void labeled_graph<N,E>::write_digraph
(::std::ostream& s,
 bool with_node_indices,
 bool with_node_labels,
 bool with_edge_labels,
 bool compact_edges,
 const char* name) const
{
  if (strncmp(name, "cluster", 7) == 0)
    s << "subgraph";
  else
    s << "digraph";
  s << " \"" << name << "\"" << ::std::endl << "{" << ::std::endl;
  if (with_node_indices || with_node_labels) {
    s << "\tnode [shape=ellipse];" << ::std::endl;
  }
  else {
    s << "\tnode [shape=point];" << ::std::endl;
  }
  for (index_type i = 0; i < size(); i++) {
    s << "\t" << i;
    if (with_node_indices || with_node_labels) {
      s << " [label=\"";
      if (with_node_indices) {
 if (with_node_labels) {
   s << i << ": ";
   if (node_has_label(i)) {
     s << node_label(i);
   }
 }
 else {
   s << i;
 }
      }
      else {
 if (node_has_label(i)) {
   s << node_label(i);
 }
      }
      s << "\"]";
    }
    s << ";" << std::endl;
  }
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j)) {
 if (adjacent(j, i) && compact_edges) {
   if (i < j) {
     s << "\t" << i << " -> " << j;
     s << " [dir=both";
     if (with_edge_labels &&
  (edge_has_label(i, j) || edge_has_label(j, i))) {
       if (!edge_has_label(i, j)) {
  s << ",label=\"" << edge_label(j, i) << "\"";
       }
       else if (!edge_has_label(j, i)) {
  s << ",label=\"" << edge_label(i, j) << "\"";
       }
       else if (edge_label(i, j) == edge_label(j, i)) {
  s << ",label=\"" << edge_label(i, j) << "\"";
       }
       else {
  s << ",label=\"" << edge_label(i, j) << ", "
    << edge_label(j, i) << "\"";
       }
     }
     s << "]" << ::std::endl;
   }
 }
 else {
   s << "\t" << i << " -> " << j;
   if (with_edge_labels && edge_has_label(i, j)) {
     s << " [label=\"" << edge_label(i, j) << "\"]";
   }
   s << ";" << ::std::endl;
 }
      }
  s << "}" << ::std::endl;
}
template<class N, class E>
void labeled_graph<N,E>::write_matrix
(::std::ostream& s, const char* unlabeled_edge, const char* missing_edge) const
{
  s << '[';
  for (index_type i = 0; i < size(); i++) {
    if (i > 0) s << ' ';
    s << '[';
    for (index_type j = 0; j < size(); j++) {
      if (j > 0) s << ',';
      if (adjacent(i, j)) {
 if (edge_has_label(i, j)) {
   s << edge_label(i, j);
 }
 else {
   s << unlabeled_edge;
 }
      }
      else {
 s << missing_edge;
      }
    }
    s << ']';
    if (i + 1 < size()) {
      s << ',' << '\n';
    }
    else {
      s << ']' << '\n';
    }
  }
}
class index_graph : public labeled_graph<index_type,index_type> {
  static const index_type NODE_SHAPE = 2 + 4 + 8 + 16;
  static const index_type NODE_STYLE = 64 + 128 + 256;
  static const index_type EDGE_STYLE = 64 + 128;
  static const index_type EDGE_DIR = 512 + 1024;
 public:
  static const index_type NS_CIRCLE = 0;
  static const index_type NS_ELLIPSE = 2;
  static const index_type NS_BOX = 4;
  static const index_type NS_POINT = 6;
  static const index_type NS_DIAMOND = 8;
  static const index_type NS_HEXAGON = 10;
  static const index_type NS_OCTAGON = 12;
  static const index_type NS_PLAINTEXT = 14;
  static const index_type NS_NORMAL = 0;
  static const index_type NS_DOUBLE = 32;
  static const index_type NS_BOLD = 64;
  static const index_type NS_DASHED = 128;
  static const index_type NS_DOTTED = 192;
  static const index_type NS_FILLED = 256;
  static const index_type ED_NONE = 0;
  static const index_type ED_FORWARD = 512;
  static const index_type ED_BACK = 1024;
  static const index_type ED_BOTH = ED_FORWARD + ED_BACK;
  static const index_type ES_NORMAL = NS_NORMAL;
  static const index_type ES_BOLD = NS_BOLD;
  static const index_type ES_DASHED = NS_DASHED;
  static const index_type ES_DOTTED = NS_DOTTED;
  static const index_type STYLE_MAX = 2048;
  index_graph()
    : labeled_graph<index_type, index_type>() { };
  index_graph(index_type size)
    : labeled_graph<index_type, index_type>(size) { };
  index_graph(const graph& g)
    : labeled_graph<index_type, index_type>(g) { };
  index_graph(const index_graph& g)
    : labeled_graph<index_type, index_type>(g) { };
  index_graph(const graph& g, const index_set& nodes)
    : labeled_graph<index_type, index_type>(g, nodes) { };
  index_graph(const index_graph& g, const index_set& nodes)
    : labeled_graph<index_type, index_type>(g, nodes) { };
  index_graph(const graph& g, const equivalence& eq)
    : labeled_graph<index_type, index_type>(g, eq) { };
  ~index_graph() { };
  void reverse();
  void reflect();
  static void write_node_style(std::ostream& s, index_type l);
  static void write_edge_style(std::ostream& s, index_type l);
  void write_styled_digraph(std::ostream& s,
       bool with_node_indices = false,
       const char* name = 0,
       index_type c_id = no_such_index) const;
  void write_matrix(std::ostream& s) const;
  void write_MATLAB(std::ostream& s,
      const char* n,
      const char* t) const;
};
template<class LS>
void write_styled_digraph
(std::ostream& s,
 const index_graph& g,
 const LS& ls,
 bool with_node_indices = false,
 const char* name = 0,
 index_type c_id = no_such_index)
{
  if (c_id != no_such_index) {
    s << "subgraph cluster" << c_id << " {" << std::endl;
    s << "node [width=0.5,height=0.5];" << ::std::endl;
  }
  else if (name) {
    s << "digraph \"" << name << "\" {" << std::endl;
    s << "node [width=0.5,height=0.5];" << ::std::endl;
  }
  for (index_type k = 0; k < g.size(); k++) {
    s << "\t" << k + (c_id != no_such_index ? c_id : 0) << " [";
    index_graph::write_node_style(s, g.node_has_label(k) ? g.node_label(k) : 0);
    if (with_node_indices)
      s << ",label=\"(" << k << ") " << ls[k] << "\"];" << std::endl;
    else
      s << ",label=\"" << ls[k] << "\"];" << std::endl;
  }
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j)) {
 s << "\t" << i + (c_id != no_such_index ? c_id : 0)
   << " -> " << j + (c_id != no_such_index ? c_id : 0) << " [";
 index_graph::write_edge_style(s, g.edge_has_label(i, j) ? g.edge_label(i, j) : 0);
 s << "];" << std::endl;
      }
  if ((c_id != no_such_index) || (name != 0)) {
    s << "}" << ::std::endl;
  }
}
class weighted_graph : public labeled_graph<hsps::rational,hsps::rational> {
 public:
  weighted_graph() { };
  weighted_graph(index_type s)
    : labeled_graph<hsps::rational,hsps::rational>(s) { };
  weighted_graph(const graph& g)
    : labeled_graph<hsps::rational,hsps::rational>(g) { };
  weighted_graph(const weighted_graph& g)
    : labeled_graph<hsps::rational,hsps::rational>(g) { };
  weighted_graph(const graph& g, const index_set& n)
    : labeled_graph<hsps::rational,hsps::rational>(g, n) { };
  weighted_graph(const weighted_graph& g, const index_set& n)
    : labeled_graph<hsps::rational,hsps::rational>(g, n) { };
  weighted_graph(const graph& g, const equivalence& eq)
    : labeled_graph<hsps::rational,hsps::rational>(g, eq) { };
  weighted_graph(const weighted_graph& g, const equivalence& eq);
  ~weighted_graph() { };
  weighted_graph& quotient(weighted_graph& g, const equivalence& eq) const;
  hsps::rational apx_weighted_independent_set_1(index_set& set) const;
  hsps::rational apx_weighted_independent_set_2(index_set& set) const;
  hsps::rational apx_weighted_independent_set(index_set& set) const;
  void add_edge(index_type src, index_type dst);
  void add_edge(index_type src, index_type dst, hsps::rational w);
  void add_undirected_edge(index_type n0, index_type n1);
  void add_undirected_edge(index_type n0, index_type n1, hsps::rational w);
  hsps::rational weight(index_type n) const;
  hsps::rational weight(index_type n0, index_type n1) const;
  hsps::rational weight(const index_set& ns) const;
  void set_weight(index_type n, hsps::rational w);
  void set_weight(index_type n0, index_type n1, hsps::rational w);
  void increment_edge_weight(index_type src, index_type dst, hsps::rational w);
  hsps::rational max_node_weight() const;
  void transitive_closure();
  hsps::rational critical_path(cost_vec& s);
  hsps::rational max_flow(index_type s, index_type t);
  hsps::rational max_flow(index_type s, index_type t, weighted_graph& rg);
  hsps::rational max_flow(index_type s, index_type t, cost_matrix& f);
  hsps::rational min_cut(index_type s, index_type t, bool_vec& s_set);
  hsps::rational min_cut(index_type s, index_type t, pair_set& e_set);
  index_pair max_weight_edge() const;
  void min_and_max_edges(const index_set& nodes,
    pair_set& e_min, hsps::rational& w_min,
    pair_set& e_max, hsps::rational& w_max) const;
  hsps::rational maximal_matching(weighted_graph& matching);
  hsps::rational apx_matching(bool_vec& nodes);
  void write_node_set(::std::ostream& s) const;
  void write_edge_set(::std::ostream& s) const;
  void write_compact(::std::ostream& s) const;
  void write_matrix(::std::ostream& s) const;
 private:
  hsps::rational augmenting_path(index_type s, index_type t, const cost_matrix& f,
   pair_vec& p);
};
class index_set_graph : public labeled_graph<index_set,index_set> {
 public:
  index_set_graph() { };
  index_set_graph(index_type s)
    : labeled_graph<index_set,index_set>(s) { };
  index_set_graph(const graph& g)
    : labeled_graph<index_set,index_set>(g) { };
  index_set_graph(const index_set_graph& g)
    : labeled_graph<index_set,index_set>(g) { };
  index_set_graph(const graph& g, const index_set& n)
    : labeled_graph<index_set,index_set>(g, n) { };
  index_set_graph(const index_set_graph& g, const index_set& n)
    : labeled_graph<index_set,index_set>(g, n) { };
  index_set_graph(const graph& g, const equivalence& eq);
  index_set_graph(const index_set_graph& g, const equivalence& eq);
  ~index_set_graph() { };
  void union_reachable();
  void merge_labels(const index_set& ns);
  void merge_labels_upwards();
  void merge_labels_downwards();
  index_set_graph& quotient(index_set_graph& g, const equivalence& eq) const;
  index_set_graph& union_reachable(index_set_graph& g) const;
  index_set_graph& subgraph_set_size_gt(index_set_graph& g, index_type l);
  void write_edge_set(::std::ostream& s) const;
  void write_digraph(::std::ostream& s, const char* name) const;
};
inline ::std::ostream& operator<<(::std::ostream& s, const graph& g)
{
  g.write_compact(s);
  return s;
};
inline ::std::ostream& operator<<(::std::ostream& s, const weighted_graph& g)
{
  g.write_compact(s);
  return s;
};
inline ::std::ostream& operator<<(::std::ostream& s, const index_set_graph& g)
{
  g.write_edge_set(s);
  return s;
};
}
namespace hsps {
graph::graph()
  : _size(0), comp()
{
}
graph::graph(index_type s)
  : _size(0), comp()
{
  init(s);
}
graph::graph(const graph& g)
  : _size(0), comp()
{
  copy(g);
}
graph::graph(const graph& g, const index_set& n)
  : _size(0), comp()
{
  g.subgraph(*this, n);
}
graph::graph(const graph& g, const equivalence& eq)
  : _size(0), comp()
{
  g.quotient(*this, eq);
}
graph::~graph()
{
}
bool graph::empty() const
{
  for (index_type i = 0; i < _size; i++)
    for (index_type j = 0; j < _size; j++)
      if (adj[i][j]) return false;
  return true;
}
bool graph::reachable(index_type n0, index_type n1) const
{
  assert(n0 < _size);
  assert(n1 < _size);
  bool_vec v(false, _size);
  reachable(n0, v);
  return v[n1];
}
index_type graph::count_reachable(index_type n0) const
{
  bool_vec v(false, _size);
  reachable(n0, v);
  return v.count(true);
}
void graph::reachable(bool_vec& v) const
{
  for (index_type k = 0; k < _size; k++)
    if (v[k])
      reachable(k, v);
}
void graph::descendants(index_type n0, bool_vec& s) const
{
  s.assign_value(false, _size);
  reachable(n0, s);
}
void graph::descendants(const index_set& s0, bool_vec& s) const
{
  s.assign_value(false, _size);
  for (index_type k = 0; k < s0.length(); k++)
    reachable(s0[k], s);
}
void graph::descendants(index_type n0, index_set& s) const
{
  bool_vec v(false, _size);
  reachable(n0, v);
  v.copy_to(s);
}
void graph::descendants(const index_set& s0, index_set& s) const
{
  bool_vec v(false, _size);
  for (index_type k = 0; k < s0.length(); k++)
    reachable(s0[k], v);
  v.copy_to(s);
}
void graph::ancestors(index_type n0, bool_vec& s) const
{
  s.assign_value(false, _size);
  reverse_reachable(n0, s);
}
void graph::ancestors(const index_set& s0, bool_vec& s) const
{
  s.assign_value(false, _size);
  for (index_type k = 0; k < s0.length(); k++)
    reverse_reachable(s0[k], s);
}
void graph::ancestors(index_type n0, index_set& s) const
{
  bool_vec v(false, _size);
  reverse_reachable(n0, v);
  v.copy_to(s);
}
void graph::ancestors(const index_set& s0, index_set& s) const
{
  bool_vec v(false, _size);
  for (index_type k = 0; k < s0.length(); k++)
    reverse_reachable(s0[k], v);
  v.copy_to(s);
}
bool graph::acyclic() const
{
  bool_vec _reach(false, _size);
  for (index_type k = 0; k < _size; k++) {
    _reach.assign_value(false, _size);
    for (index_type i = 0; i < out[k].length(); i++)
      reachable(out[k][i], _reach);
    if (_reach[k]) return false;
  }
  return true;
}
bool graph::top_sort(index_vec& s) const
{
  s.clear();
  bool_vec rem(true, size());
  while (rem.count(true) > 0) {
    index_type n = no_such_index;
    for (index_type i = 0; (i < size()) && (n == no_such_index); i++)
      if (rem[i] && (in[i].count_common(rem) == 0))
 n = i;
    if (n == no_such_index)
      return false;
    s.append(n);
    rem[n] = false;
  }
  return true;
}
index_type graph::max_out_degree() const
{
  assert(_size > 0);
  index_type m = out[0].length();
  for (index_type k = 1; k < _size; k++)
    if (out[k].length() > m) m = out[k].length();
  return m;
}
index_type graph::max_in_degree() const
{
  assert(_size > 0);
  index_type m = in[0].length();
  for (index_type k = 1; k < _size; k++)
    if (in[k].length() > m) m = in[k].length();
  return m;
}
index_type graph::max_bi_degree() const
{
  assert(_size > 0);
  index_type m = bi[0].length();
  for (index_type k = 1; k < _size; k++)
    if (bi[k].length() > m) m = bi[k].length();
  return m;
}
index_type graph::min_out_degree() const
{
  assert(_size > 0);
  index_type m = out[0].length();
  for (index_type k = 1; k < _size; k++)
    if (out[k].length() < m) m = out[k].length();
  return m;
}
index_type graph::min_in_degree() const
{
  assert(_size > 0);
  index_type m = in[0].length();
  for (index_type k = 1; k < _size; k++)
    if (in[k].length() < m) m = in[k].length();
  return m;
}
index_type graph::min_bi_degree() const
{
  assert(_size > 0);
  index_type m = bi[0].length();
  for (index_type k = 1; k < _size; k++)
    if (bi[k].length() < m) m = bi[k].length();
  return m;
}
index_type graph::first_root() const
{
  for (index_type k = 0; k < size(); k++)
    if (in_degree(k) == 0) return k;
  return no_such_index;
}
index_type graph::first_leaf() const
{
  for (index_type k = 0; k < size(); k++)
    if (out_degree(k) == 0) return k;
  return no_such_index;
}
void graph::fringe(const index_set& n, index_set& fn) const
{
  fn.clear();
  for (index_type k = 0; k < n.length(); k++) {
    fn.insert(successors(n[k]));
  }
  fn.subtract(n);
}
void graph::bi_fringe(const index_set& n, index_set& fn) const
{
  fn.clear();
  for (index_type k = 0; k < n.length(); k++) {
    fn.insert(bidirectional(n[k]));
  }
  fn.subtract(n);
}
void graph::distance(index_type s0, index_vec& d) const
{
  index_set s0s;
  s0s.assign_singleton(s0);
  distance(s0s, d);
}
void graph::distance(const index_set& s0, index_vec& d) const
{
  d.assign_value(no_such_index, size());
  for (index_type k = 0; k < s0.length(); k++) {
    assert(s0[k] < size());
    d[s0[k]] = 0;
  }
  bool done = false;
  while (!done) {
    done = true;
    for (index_type i = 0; i < size(); i++)
      for (index_type j = 0; j < out[i].length(); j++)
 if (d[i] != no_such_index) {
   if ((d[i] + 1) < d[out[i][j]]) {
     d[out[i][j]] = d[i] + 1;
     done = false;
   }
 }
  }
}
index_type graph::distance(index_type s0, index_type s1) const
{
  index_vec d;
  distance(s0, d);
  return d[s1];
}
pair_set& graph::bidirectional_edges(pair_set& s) const
{
  s.clear();
  for (index_type i = 0; i < _size; i++)
    for (index_type j = i+1; j < _size; j++)
      if (adj[i][j] && adj[j][i]) s.insert(index_pair(i, j));
  return s;
}
bool graph::adjacent(index_type i, const index_set& n) const
{
  for (index_type j = 0; j < n.length(); j++)
    if (adjacent(i, n[j])) return true;
  return false;
}
bool graph::adjacent(const index_set& n, index_type i) const
{
  for (index_type j = 0; j < n.length(); j++)
    if (adjacent(n[j], i)) return true;
  return false;
}
bool graph::adjacent(const index_set& n0, const index_set& n1) const
{
  for (index_type i = 0; i < n0.length(); i++)
    for (index_type j = 0; j < n1.length(); j++)
      if (adjacent(n0[i], n1[j])) return true;
  return false;
}
bool graph::bi_adjacent(index_type i, const index_set& n) const
{
  for (index_type j = 0; j < n.length(); j++)
    if (bi_adjacent(i, n[j])) return true;
  return false;
}
index_type graph::n_edges() const
{
  index_type n = 0;
  for (index_type i = 0; i < _size; i++)
    for (index_type j = 0; j < _size; j++)
      if (adj[i][j]) n += 1;
  return n;
}
index_type graph::n_edges(const index_set& from, const index_set& to) const
{
  index_type n = 0;
  for (index_type i = 0; i < from.length(); i++)
    for (index_type j = 0; j < to.length(); j++)
      if (adj[from[i]][to[j]]) n += 1;
  return n;
}
pair_set& graph::edges(pair_set& s) const
{
  s.clear();
  for (index_type i = 0; i < _size; i++)
    for (index_type j = 0; j < _size; j++)
      if (adj[i][j]) s.insert(index_pair(i, j));
  return s;
}
index_type graph::n_induced_undirected_edges() const
{
  index_type n = 0;
  for (index_type i = 0; i < _size; i++)
    for (index_type j = i; j < _size; j++)
      if (adj[i][j] || adj[j][i]) n += 1;
  return n;
}
index_type graph::n_induced_undirected_edges
(const index_set& n0, const index_set& n1) const
{
  index_type n = 0;
  for (index_type i = 0; i < n0.length(); i++)
    for (index_type j = 0; j < n1.length(); j++)
      if (adj[n0[i]][n1[j]] || adj[n1[j]][n0[i]]) n += 1;
  return n;
}
index_type graph::n_bidirectional_edges() const
{
  index_type n = 0;
  for (index_type i = 0; i < _size; i++)
    for (index_type j = i; j < _size; j++)
      if (adj[i][j] && adj[j][i]) n += 1;
  return n;
}
index_type graph::n_bidirectional_edges
(const index_set& n0, const index_set& n1) const
{
  index_type n = 0;
  for (index_type i = 0; i < n0.length(); i++)
    for (index_type j = 0; j < n1.length(); j++)
      if (adj[n0[i]][n1[j]] && adj[n1[j]][n0[i]]) n += 1;
  return n;
}
index_type graph::component_node(index_type i) const
{
  for (index_type k = 0; k < _size; k++)
    if (comp[k] == i) return k;
  return no_such_index;
}
index_type graph::component_size(index_type i) const
{
  index_type n = 0;
  for (index_type k = 0; k < _size; k++)
    if (comp[k] == i) n += 1;
  return n;
}
void graph::component_node_set(index_type i, index_set& set) const
{
  set.clear();
  for (index_type k = 0; k < _size; k++)
    if (comp[k] == i) set.insert(k);
}
index_type graph::maximal_non_unit_component() const
{
  index_type k_max = no_such_index;
  index_type s_max = 1;
  for (index_type k = 0; k < n_components(); k++)
    if (component_size(k) > s_max) {
      k_max = k;
      s_max = component_size(k);
    }
  return k_max;
}
bool graph::equals(const graph& g) const
{
  if (g.size() != size()) return false;
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) != g.adjacent(i, j)) return false;
  return true;
}
bool graph::equals(const graph& g, const index_vec& c) const
{
  if (g.size() != size()) return false;
  if (c.length() != g.size()) {
    ::std::cerr << "error: size of graph " << g
       << " and permutation vector " << c
       << " do not agree"
       << ::std::endl;
    exit(255);
  }
  for (index_type i = 0; i < size(); i++) {
    assert(c[i] < g.size());
    for (index_type j = 0; j < size(); j++) {
      assert(c[j] < g.size());
      if (adjacent(i, j) != g.adjacent(c[i], c[j])) return false;
    }
  }
  return true;
}
void graph::difference
(const graph& g, const index_vec& c, pair_set& d0, pair_set& d1) const
{
  assert(g.size() == size());
  assert(c.length() == g.size());
  d0.clear();
  d1.clear();
  for (index_type i = 0; i < size(); i++) {
    assert(c[i] < g.size());
    for (index_type j = 0; j < size(); j++) {
      assert(c[j] < g.size());
      if (adjacent(i, j) && !g.adjacent(c[i], c[j]))
 d0.insert(index_pair(i, j));
      if (!adjacent(i, j) && g.adjacent(c[i], c[j]))
 d1.insert(index_pair(c[i], c[j]));
    }
  }
}
void graph::difference
(const graph& g, pair_set& d0, pair_set& d1) const
{
  assert(g.size() == size());
  d0.clear();
  d1.clear();
  for (index_type i = 0; i < size(); i++) {
    for (index_type j = 0; j < size(); j++) {
      if (adjacent(i, j) && !g.adjacent(i, j))
 d0.insert(index_pair(i, j));
      if (!adjacent(i, j) && g.adjacent(i, j))
 d1.insert(index_pair(i, j));
    }
  }
}
index_type graph::cardinality_of_difference(const graph& g) const
{
  assert(g.size() == size());
  index_type d = 0;
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adj[i][j] != g.adj[i][j]) d += 1;
  return d;
}
void graph::init(index_type size)
{
  _size = size;
  adj.assign_value(false, _size, _size);
  in.assign_value(EMPTYSET, _size);
  out.assign_value(EMPTYSET, _size);
  bi.assign_value(EMPTYSET, _size);
  comp.assign_value(0, _size);
  n_comp = 0;
}
void graph::copy(const graph& g)
{
  _size = g._size;
  adj.assign_copy(g.adj);
  in.assign_copy(g.in);
  out.assign_copy(g.out);
  bi.assign_copy(g.bi);
  comp.assign_copy(g.comp);
  n_comp = g.n_comp;
}
void graph::copy(const graph& g, const index_vec& map)
{
  assert(map.length() == g.size());
  index_type m = mapping::range(map, map.length());
  init(m);
  for (index_type i = 0; i < g.size(); i++)
    if (map[i] != no_such_index) {
      assert(map[i] < size());
      for (index_type j = 0; j < g.size(); j++)
 if (map[j] != no_such_index) {
   assert(map[j] < _size);
   if (g.adjacent(i, j))
     add_edge(map[i], map[j]);
 }
    }
}
void graph::copy_and_rename(const graph& g, const index_vec& map)
{
  assert(map.length() == g.size());
  init(g.size());
  for (index_type i = 0; i < _size; i++) {
    assert(map[i] < _size);
    for (index_type j = 0; j < _size; j++) {
      assert(map[j] < _size);
      if (g.adjacent(i, j))
 add_edge(map[i], map[j]);
    }
  }
}
index_type graph::add_node()
{
  adj.set_size(_size + 1, _size + 1);
  for (index_type k = 0; k < _size; k++) {
    adj[k][_size] = false;
    adj[_size][k] = false;
  }
  adj[_size][_size] = false;
  in.set_length(_size + 1);
  in[_size].clear();
  out.set_length(_size + 1);
  out[_size].clear();
  bi.set_length(_size + 1);
  bi[_size].clear();
  comp.set_length(_size + 1);
  comp[_size] = 0;
  _size += 1;
  return _size - 1;
}
void graph::add_graph(const graph& g, mapping& m)
{
  index_type _new_size = _size + g.size();
  adj.set_size(_new_size, _new_size);
  in.set_length(_new_size);
  out.set_length(_new_size);
  bi.set_length(_new_size);
  comp.set_length(_new_size);
  m.assign_identity(g.size());
  for (index_type k = 0; k < g.size(); k++) {
    m[k] = _size + k;
    for (index_type i = 0; i < _new_size; i++) {
      adj[i][m[k]] = false;
      adj[m[k]][i] = false;
    }
    in[m[k]].clear();
    out[m[k]].clear();
    bi[m[k]].clear();
    comp[m[k]] = 0;
  }
  _size = _new_size;
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j))
 add_edge(m[i], m[j]);
}
void graph::add_edge(index_type src, index_type dst)
{
  assert((src < _size) && (dst < _size));
  if (adj[src][dst]) return;
  adj[src][dst] = true;
  out[src].insert(dst);
  in[dst].insert(src);
  if (adj[dst][src]) {
    bi[src].insert(dst);
    bi[dst].insert(src);
  }
}
void graph::add_edge(const index_set& srcs, index_type dst)
{
  for (index_type k = 0; k < srcs.length(); k++)
    if (!adj[srcs[k]][dst])
      add_edge(srcs[k], dst);
}
void graph::add_edge(index_type src, const index_set& dsts)
{
  for (index_type k = 0; k < dsts.length(); k++)
    if (!adj[src][dsts[k]])
      add_edge(src, dsts[k]);
}
void graph::add_edge_to_transitive_closure
(index_type src, index_type dst, pair_set& e)
{
  if (!adj[src][dst]) {
    add_edge(src, dst);
    e.insert(index_pair(src, dst));
  }
  for (index_type i = 0; i < in[src].length(); i++) {
    if (!adj[in[src][i]][dst]) {
      e.insert(index_pair(in[src][i], dst));
    }
    for (index_type j = 0; j < out[dst].length(); j++) {
      if (!adj[in[src][i]][out[dst][j]]) {
 e.insert(index_pair(in[src][i], out[dst][j]));
      }
    }
  }
  for (index_type j = 0; j < out[dst].length(); j++) {
    if (!adj[src][out[dst][j]]) {
      e.insert(index_pair(src, out[dst][j]));
    }
  }
  for (index_type k = 0; k < e.length(); k++)
    add_edge(e[k].first, e[k].second);
}
void graph::remove_edge(index_type src, index_type dst)
{
  assert((src < _size) && (dst < _size));
  if (adj[src][dst]) {
    adj[src][dst] = false;
    out[src].subtract(dst);
    in[dst].subtract(src);
    if (adj[dst][src]) {
      bi[src].subtract(dst);
      bi[dst].subtract(src);
    }
  }
}
void graph::remove_undirected_edge(index_type n0, index_type n1)
{
  assert((n0 < _size) && (n1 < _size));
  if (adj[n0][n1]) {
    adj[n0][n1] = false;
    out[n0].subtract(n1);
    in[n1].subtract(n0);
    bi[n0].subtract(n1);
  }
  if (adj[n1][n0]) {
    adj[n1][n0] = false;
    out[n1].subtract(n0);
    in[n0].subtract(n1);
    bi[n1].subtract(n0);
  }
}
void graph::remove_edges_from(index_type src)
{
  index_set ns(successors(src));
  for (index_type k = 0; k < ns.length(); k++)
    remove_edge(src, ns[k]);
}
void graph::remove_edges_to(index_type dst)
{
  index_set ns(predecessors(dst));
  for (index_type k = 0; k < ns.length(); k++)
    remove_edge(ns[k], dst);
}
void graph::remove_edges_incident_on(index_type n)
{
  remove_edges_from(n);
  remove_edges_to(n);
}
void graph::remove_edges(const pair_set& e)
{
  for (index_type k = 0; k < e.length(); k++)
    remove_edge(e[k].first, e[k].second);
}
void graph::remove_undirected_edges(const pair_set& e)
{
  for (index_type k = 0; k < e.length(); k++)
    remove_undirected_edge(e[k].first, e[k].second);
}
void graph::add_undirected_edge(index_type n0, index_type n1)
{
  add_edge(n0, n1);
  add_edge(n1, n0);
}
void graph::remove_node(index_type n)
{
  assert(n < _size);
  graph g(*this);
  init(g.size() - 1);
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j) && (i != n) && (j != n)) {
 index_type s = (i > n ? i - 1 : i);
 index_type d = (j > n ? j - 1 : j);
 add_edge(s, d);
      }
}
void graph::clear_edges()
{
  adj.assign_value(false);
  in.assign_value(EMPTYSET);
  out.assign_value(EMPTYSET);
  bi.assign_value(EMPTYSET);
}
void graph::recalculate()
{
  for (index_type i = 0; i < _size; i++) {
    in[i].clear();
    out[i].clear();
  }
  for (index_type i = 0; i < _size; i++)
    for (index_type j = 0; j < _size; j++)
      if (adj[i][j]) {
 out[i].insert(j);
 in[j].insert(i);
      }
  for (index_type k = 0; k < _size; k++) {
    bi[k].assign_copy(out[k]);
    bi[k].intersect(in[k]);
  }
  comp.set_length(_size);
  comp.assign_value(0);
  n_comp = 0;
}
void graph::complement()
{
  for (index_type i = 0; i < _size; i++) {
    for (index_type j = 0; j < _size; j++)
      adj[i][j] = !adj[i][j];
    adj[i][i] = false;
  }
  recalculate();
}
void graph::complement_with_loops()
{
  for (index_type i = 0; i < _size; i++) {
    for (index_type j = 0; j < _size; j++)
      adj[i][j] = !adj[i][j];
  }
  recalculate();
}
void graph::remove_loops()
{
  for (index_type i = 0; i < _size; i++) if (adj[i][i]) {
    adj[i][i] = false;
    out[i].subtract(i);
    in[i].subtract(i);
    bi[i].subtract(i);
  }
}
void graph::reverse()
{
  for (index_type i = 0; i < _size; i++)
    for (index_type j = i+1; j < _size; j++) {
      if (adj[i][j] && !adj[j][i]) {
 adj[i][j] = false;
 adj[j][i] = true;
      }
      else if (!adj[i][j] && adj[j][i]) {
 adj[i][j] = true;
 adj[j][i] = false;
      }
    }
  recalculate();
}
void graph::transitive_closure()
{
  for (index_type k = 0; k < _size; k++)
    for (index_type i = 0; i < _size; i++)
      if (adj[i][k])
 for (index_type j = 0; j < _size; j++)
   if (adj[k][j]) adj[i][j] = true;
  recalculate();
}
void graph::missing_transitive_edges(pair_set& e) const
{
  e.clear();
  for (index_type i = 0; i < _size; i++) {
    bool_vec v(false, _size);
    reachable(i, v);
    for (index_type j = 0; j < _size; j++)
      if ((i != j) && v[j] && (!adj[i][j]))
 e.insert(index_pair(i, j));
  }
}
void graph::transitive_reduction()
{
  bool_matrix m2(adj);
  m2.transitive_closure();
  bool_matrix m3;
  m3.multiply(adj, m2);
  adj.subtract(m3);
  recalculate();
}
void graph::intersect(const graph& g)
{
  if (g._size != _size) {
    ::std::cerr << "error: can't intersect " << *this << " of size " << _size
       << " with graph " << g << " of size" << g._size << ::std::endl;
    exit(255);
  }
  for (index_type i = 0; i < _size; i++)
    for (index_type j = 0; j < _size; j++)
      if (!g.adj[i][j]) adj[i][j] = false;
  recalculate();
}
graph& graph::subgraph(graph& sg, const index_set& nodes) const
{
  sg.init(nodes.length());
  for (index_type i = 0; i < nodes.length(); i++)
    for (index_type j = 0; j < nodes.length(); j++)
      if (adj[nodes[i]][nodes[j]]) sg.add_edge(i, j);
  return sg;
}
graph& graph::edge_subgraph(graph& sg, const index_set& nodes) const
{
  sg.init(size());
  for (index_type i = 0; i < nodes.length(); i++)
    for (index_type j = 0; j < nodes.length(); j++)
      if (adj[nodes[i]][nodes[j]]) sg.add_edge(nodes[i], nodes[j]);
  return sg;
}
graph& graph::component_tree(graph& cg) const
{
  cg.init(n_comp);
  for (index_type i = 0; i < _size; i++)
    for (index_type j = 0; j < _size; j++)
      if (adj[i][j] && (comp[i] != comp[j])) cg.add_edge(comp[i], comp[j]);
  return cg;
}
equivalence& graph::component_partitioning(equivalence& eq) const
{
  eq.extend(_size);
  for (index_type i = 0; i < _size; i++)
    for (index_type j = i + 1; j < _size; j++)
      if ((comp[i] == comp[j])) eq.merge(i, j);
  return eq;
}
equivalence& graph::induced_partitioning(equivalence& eq) const
{
  eq.clear();
  eq.extend(_size);
  for (index_type i = 0; i < _size; i++)
    for (index_type j = 0; j < _size; j++)
      if (adj[i][j]) eq.merge(i, j);
  return eq;
}
graph& graph::induced_undirected_graph(graph& g) const
{
  g.copy(*this);
  for (index_type i = 0; i < g._size; i++)
    for (index_type j = 0; j < g._size; j++)
      if (g.adj[i][j] && !g.adj[j][i]) g.add_edge(j, i);
  return g;
}
graph& graph::minimal_equivalent_digraph(graph& g) const
{
  graph cg;
  component_tree(cg);
  cg.transitive_reduction();
  g.init(size());
  for (index_type k = 0; k < n_components(); k++) {
    index_set c;
    component_node_set(k, c);
    if (c.length() > 1) {
      for (index_type i = 0; i < (c.length() - 1); i++)
 g.add_edge(c[i], c[i+1]);
      g.add_edge(c[c.length() - 1], c[0]);
    }
  }
  for (index_type i = 0; i < cg.size(); i++)
    for (index_type j = 0; j < cg.size(); j++)
      if (cg.adjacent(i, j)) {
 index_type ci = component_node(i);
 index_type cj = component_node(j);
 assert(ci != no_such_index);
 assert(cj != no_such_index);
 g.add_edge(ci, cj);
      }
  return g;
}
graph& graph::minimal_distance_graph(graph& g, const index_set& s0) const
{
  index_vec d;
  distance(s0, d);
  g.init(size());
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) && (d[i] != no_such_index) && (d[j] == (d[i] + 1)))
 g.add_edge(i, j);
  return g;
}
graph& graph::quotient(graph& g, const equivalence& eq) const
{
  g.init(eq.n_classes());
  index_vec m;
  eq.make_map(m);
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) && !eq(i, j)) {
 assert(m[i] < eq.n_classes());
 assert(m[j] < eq.n_classes());
 g.add_edge(m[i], m[j]);
      }
}
bool graph::is_clique(const index_set& nodes) const
{
  for (index_type i = 0; i < nodes.length(); i++)
    for (index_type j = i + 1; j < nodes.length(); j++)
      if (!adj[nodes[i]][nodes[j]] || !adj[nodes[j]][nodes[i]])
 return false;
  return true;
}
bool graph::is_independent(const index_set& nodes) const
{
  for (index_type i = 0; i < nodes.length(); i++)
    for (index_type j = i + 1; j < nodes.length(); j++)
      if (adj[nodes[i]][nodes[j]] || adj[nodes[j]][nodes[i]])
 return false;
  return true;
}
bool graph::is_independent_range(index_type l, index_type u) const
{
  for (index_type i = l; i <= u; i++)
    for (index_type j = i + 1; j <= u; j++)
      if (adjacent(i, j) || adjacent(j, i)) return false;
  return true;
}
void graph::write_node_set(::std::ostream& s) const
{
  s << '{';
  for (index_type i = 0; i < _size; i++) {
    if (i > 0) s << ',';
    s << i << "[" << comp[i] << "]";
  }
  s << '}';
}
void graph::write_edge_set(::std::ostream& s) const
{
  s << '{';
  bool first = true;
  for (index_type i = 0; i < _size; i++)
    for (index_type j = 0; j < _size; j++)
      if (adj[i][j]) {
 if (!first) s << ',';
 first = false;
 s << i << "->" << j;
      }
  s << '}';
}
void graph::write_compact(::std::ostream& s) const
{
  s << '(';
  write_node_set(s);
  s << ',';
  write_edge_set(s);
  s << '}';
}
void graph::write_undirected_edge_set(::std::ostream& s) const
{
  s << '{';
  bool first = true;
  for (index_type i = 0; i < _size; i++)
    for (index_type j = i+1; j < _size; j++)
      if (adj[i][j]) {
 if (!first) s << ',';
 first = false;
 s << i << "-" << j;
      }
  s << '}';
}
void graph::write_adjacency_lists(::std::ostream& s) const
{
  for (index_type k = 0; k < _size; k++) {
    s << "node " << k << " (component " << comp[k] << "):" << ::std::endl;
    s << " in (" << in[k].length() << "):";
    for (index_type i = 0; i < _size; i++)
      if (adj[i][k]) s << " " << i;
    s << ::std::endl << " out (" << out[k].length() << "):";
    for (index_type i = 0; i < _size; i++)
      if (adj[k][i]) s << " " << i;
    s << ::std::endl;
  }
}
void graph::randomize(count_type n, RNG& rnd)
{
  assert(_size > 1);
  for (index_type s = 0; s < n; s++) {
    index_type i = rnd.random_in_range(_size);
    index_type j = rnd.random_in_range(_size);
    if (i != j) {
      if (adj[i][j]) {
 adj[i][j] = false;
      }
      else {
 adj[i][j] = true;
      }
    }
  }
  recalculate();
}
void graph::randomize_connected(count_type n, RNG& rnd)
{
  assert(_size > 1);
  for (index_type s = 0; s < n; s++) {
    index_type i = rnd.random_in_range(_size);
    index_type j = rnd.random_in_range(_size, i);
    if (adj[i][j]) {
      adj[i][j] = false;
      if (!connected()) adj[i][j] = true;
    }
    else {
      adj[i][j] = true;
    }
  }
  recalculate();
}
void graph::randomize_strongly_connected(count_type n, RNG& rnd)
{
  assert(_size > 1);
  strongly_connected_components();
  index_type c = n_components();
  for (index_type s = 0; s < n; s++) {
    index_type i = rnd.random_in_range(_size);
    index_type j = rnd.random_in_range(_size, i);
    if (adj[i][j]) {
      adj[i][j] = false;
      strongly_connected_components();
      if (n_components() > c)
 adj[i][j] = true;
    }
    else {
      adj[i][j] = true;
    }
  }
  recalculate();
}
void graph::random_digraph(count_type n, RNG& rnd)
{
  clear_edges();
  randomize(n, rnd);
}
void graph::random_connected_digraph(count_type n, RNG& rnd)
{
  assert(_size > 1);
  clear_edges();
  for (index_type i = 0; i < _size - 1; i++) {
    adj[i][i+1] = true;
  }
  randomize_connected(n, rnd);
}
void graph::random_strongly_connected_digraph(count_type n, RNG& rnd)
{
  assert(_size > 1);
  clear_edges();
  for (index_type i = 0; i < _size - 1; i++) {
    adj[i][i+1] = true;
  }
  adj[_size - 1][0] = true;
  randomize_strongly_connected(n, rnd);
}
void graph::random_digraph_with_density(rational density, RNG& rnd)
{
  clear_edges();
  index_set e;
  index_type n = (_size * (_size - 1));
  index_type m = rational::floor(density*n).numerator();
  rnd.select_fixed_set(e, m, n);
  for (index_type k = 0; k < e.length(); k++) {
    index_type s = e[k] / (_size - 1);
    index_type t = e[k] % (_size - 1);
    if (t >= s) t += 1;
    add_edge(s, t);
  }
}
void graph::random_tree(RNG& rnd)
{
  clear_edges();
  for (index_type k = 1; k < size(); k++) {
    index_type i = rnd.random_in_range(k);
    add_edge(i, k);
  }
}
void graph::random_tree(index_type b, index_type d, RNG& rnd)
{
  clear_edges();
  for (index_type k = 1; k < size(); k++) {
    index_set c;
    for (index_type i = 0; i < k; i++) {
      if ((out_degree(i) < b) && (distance(0, i) < d))
 c.insert(i);
    }
    assert(!c.empty());
    index_type j = rnd.select_one_of(c);
    add_edge(j, k);
  }
}
void graph::max_clique
(index_set& sel, index_type next, index_set& clique) const
{
  if (next >= _size) {
    if (sel.length() > clique.length()) clique = sel;
  }
  else if (sel.contains(next)) {
    max_clique(sel, next + 1, clique);
  }
  else {
    if (bi[next].contains(sel)) {
      sel.insert(next);
      max_clique(sel, next + 1, clique);
      sel.subtract(next);
    }
    max_clique(sel, next + 1, clique);
  }
}
void graph::maximal_clique(index_set& clique) const
{
  assert(_size > 0);
  clique.clear();
  index_set sel;
  max_clique(sel, 0, clique);
}
void graph::maximal_clique_including
(index_type node, index_set& clique) const
{
  assert((0 <= node) && (node < _size) && (_size > 0));
  clique.clear();
  index_set sel;
  sel.assign_singleton(node);
  max_clique(sel, 0, clique);
}
void graph::maximal_clique_cover(index_set_vec& sets) const
{
  sets.clear();
  index_set clique;
  index_set uncovered;
  uncovered.fill(_size);
  while (!uncovered.empty()) {
    maximal_clique_including(uncovered[0], clique);
    assert(!clique.empty());
    sets.append(clique);
    uncovered.subtract(clique);
  }
}
void graph::all_max_cliques
(index_set& sel, index_type next, index_set_vec& cliques) const
{
  if (next >= _size) {
    if (sel.length() > cliques[0].length()) {
      cliques[0] = sel;
      cliques.set_length(1);
    }
    else if (sel.length() == cliques[0].length()) {
      cliques.append(sel);
    }
  }
  else if (sel.contains(next)) {
    all_max_cliques(sel, next + 1, cliques);
  }
  else {
    if (bi[next].contains(sel)) {
      sel.insert(next);
      all_max_cliques(sel, next + 1, cliques);
      sel.subtract(next);
    }
    all_max_cliques(sel, next + 1, cliques);
  }
}
void graph::all_maximal_cliques(index_set_vec& cliques) const
{
  assert(_size > 0);
  cliques.assign_value(EMPTYSET, 1);
  index_set sel;
  all_max_cliques(sel, 0, cliques);
}
void graph::all_maximal_cliques_including
(index_type node, index_set_vec& cliques) const
{
  assert(_size > 0);
  cliques.assign_value(EMPTYSET, 1);
  index_set sel;
  sel.assign_singleton(node);
  all_max_cliques(sel, 0, cliques);
}
void graph::scc_first_dfs
(index_type n, bool_vec& visited, index_vec& num) const
{
  visited[n] = true;
  for (index_type k = 0; k < _size; k++)
    if (adj[n][k] && !visited[k])
      scc_first_dfs(k, visited, num);
  num.append(n);
}
void graph::scc_second_dfs
(index_type n, bool_vec& visited, index_type c_id)
{
  visited[n] = true;
  comp[n] = c_id;
  for (index_type k = 0; k < _size; k++)
    if (adj[k][n] && !visited[k])
      scc_second_dfs(k, visited, c_id);
}
void graph::undirected_dfs
(index_type n, bool_vec& visited) const
{
  visited[n] = true;
  for (index_type k = 0; k < _size; k++)
    if ((adj[n][k] || adj[k][n]) && !visited[k])
      undirected_dfs(k, visited);
}
void graph::reachable(index_type n, bool_vec& visited) const
{
  visited[n] = true;
  for (index_type k = 0; k < _size; k++)
    if (adj[n][k] && !visited[k])
      reachable(k, visited);
}
void graph::reverse_reachable(index_type n, bool_vec& visited) const
{
  visited[n] = true;
  for (index_type k = 0; k < _size; k++)
    if (adj[k][n] && !visited[k])
      reverse_reachable(k, visited);
}
void graph::strongly_connected_components()
{
  index_vec num(no_such_index, 0);
  bool_vec visited(false, _size);
  visited.set_length(_size);
  for (index_type k = 0; k < _size; k++) {
    if (!visited[k]) {
      scc_first_dfs(k, visited, num);
    }
  }
  assert(num.length() == _size);
  visited.assign_value(false);
  n_comp = 0;
  for (index_type k = num.length(); k > 0; k--) if (!visited[num[k - 1]]) {
    scc_second_dfs(num[k - 1], visited, n_comp);
    n_comp += 1;
  }
}
void graph::ramsey(const index_set& nodes, index_set& I, index_set& C) const
{
  I.clear();
  C.clear();
  if (nodes.empty()) return;
  index_type v = nodes[0];
  index_set n_v(nodes);
  n_v.intersect(bi[v]);
  n_v.subtract(v);
  ramsey(n_v, I, C);
  C.insert(v);
  index_set I2;
  index_set C2;
  n_v.assign_copy(nodes);
  n_v.subtract(out[v]);
  n_v.subtract(in[v]);
  n_v.subtract(v);
  ramsey(n_v, I2, C2);
  I2.insert(v);
  if (C2.length() > C.length()) C.assign_copy(C2);
  if (I2.length() > I.length()) I.assign_copy(I2);
}
void graph::apx_independent_set(const index_set& nodes, index_set& set) const
{
  set.clear();
  index_set n(nodes);
  index_set nextI;
  index_set nextC;
  while (!n.empty()) {
    ramsey(n, nextI, nextC);
    if (nextI.length() > set.length()) set.assign_copy(nextI);
    n.subtract(nextC);
  }
}
void graph::apx_independent_set(index_set& set) const
{
  index_set nodes;
  nodes.fill(_size);
  apx_independent_set(nodes, set);
}
void graph::apx_independent_set_including
(index_type node, index_set& set) const
{
  assert((0 <= node) && (node < _size) && (_size > 0));
  set.clear();
  index_set nodes;
  nodes.fill(_size);
  nodes.subtract(in[node]);
  nodes.subtract(out[node]);
  nodes.subtract(node);
  index_set nextI;
  index_set nextC;
  while (!nodes.empty()) {
    ramsey(nodes, nextI, nextC);
    if (nextI.length() > set.length()) set.assign_copy(nextI);
    nodes.subtract(nextC);
  }
  set.insert(node);
}
void graph::apx_independent_set_cover(index_set_vec& sets) const
{
  sets.clear();
  index_set I;
  apx_independent_set(I);
  assert(!I.empty());
  sets.append(I);
  index_set uncovered;
  uncovered.fill(_size);
  uncovered.subtract(I);
  while (!uncovered.empty()) {
    apx_independent_set_including(uncovered[0], I);
    assert(!I.empty());
    sets.append(I);
    uncovered.subtract(I);
  }
}
void graph::apx_independent_set_disjoint_cover(index_set_vec& sets) const
{
  sets.clear();
  index_set uncovered;
  uncovered.fill(_size);
  index_set I;
  while (!uncovered.empty()) {
    apx_independent_set(uncovered, I);
    assert(!I.empty());
    sets.append(I);
    uncovered.subtract(I);
  }
}
void graph::all_nondominated_cliques(index_set_vec &cliques) const
{
  assert(cliques.empty());
  if (_size > 0) {
    for (index_type i = 0; i < _size; i++)
      assert(!adjacent(i, i));
    index_set current_clique;
    index_set candidates;
    candidates.fill(_size);
    all_nondominated_cliques_aux(cliques, current_clique, candidates, 1);
  }
}
void graph::all_cliques_geq
(index_type k, index_set_vec& cliques) const
{
  cliques.clear();
  if (_size > 0) {
    for (index_type i = 0; i < _size; i++)
      assert(!adjacent(i, i));
    index_set current_clique;
    index_set candidates;
    candidates.fill(_size);
    all_nondominated_cliques_aux(cliques, current_clique, candidates, k);
  }
}
void graph::all_nondominated_cliques_aux
(index_set_vec& cliques,
 index_set& current_clique,
 const index_set& candidates,
 index_type min) const
{
  if (candidates.empty()) {
    cliques.append(current_clique);
  }
  else {
    index_type best_vertex = no_such_index;
    int max_degree = 0;
    for (index_type i = 0; i < candidates.length(); i++) {
      index_type vertex = candidates[i];
      index_set neighbors = successors(vertex);
      neighbors.intersect(candidates);
      if (i == 0 || neighbors.length() > max_degree) {
        max_degree = neighbors.length();
        best_vertex = vertex;
      }
    }
    assert(best_vertex != no_such_index);
    index_set chosen_set = candidates;
    chosen_set.subtract(successors(best_vertex));
    for (index_type i = 0; i < chosen_set.length(); i++) {
      index_type chosen = chosen_set[i];
      index_set new_candidates = candidates;
      new_candidates.intersect(successors(chosen));
      if ((current_clique.length() + new_candidates.length() + 1) >= min) {
 current_clique.insert(chosen);
 all_nondominated_cliques_aux(cliques,
         current_clique,
         new_candidates,
         min);
 current_clique.subtract(chosen);
      }
    }
  }
}
bool graph::connected() const
{
  if (_size == 0) return true;
  bool_vec visited(false, _size);
  undirected_dfs(0, visited);
  return (visited.count(true) == _size);
}
bool graph::strongly_connected() const
{
  if (_size == 0) return true;
  bool_vec visited(false, _size);
  index_vec num(no_such_index, 0);
  scc_first_dfs(0, visited, num);
  return (visited.count(true) == _size);
}
void graph::write_digraph
(::std::ostream& s, bool with_node_indices, const char* name) const
{
  s << "digraph \"" << name << "\"" << "{" << ::std::endl;
  if (with_node_indices) {
    s << "node [shape=circle,width=0.5,height=0.5];" << ::std::endl;
    for (index_type k = 0; k < size(); k++)
      s << "\t" << k << " [label=\"" << k << "\"];" << std::endl;
  }
  else {
    s << "node [shape=point];" << ::std::endl;
  }
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j))
 s << "\t" << i << " -> " << j << ";" << ::std::endl;
  s << "}" << ::std::endl;
}
void graph::write_component_labeled_digraph
(::std::ostream& s, const char* name) const
{
  write_labeled_digraph<index_vec>(s, *this, comp, false, name, no_such_index);
}
void graph::write_graph_correspondance
(::std::ostream& s,
 const graph& g,
 const index_vec& c,
 const char* name) const
{
  assert(g.size() == size());
  assert(c.length() == g.size());
  s << "digraph \"" << name << "\"" << ::std::endl << "{" << ::std::endl;
  s << "node [width=0,height=0];" << ::std::endl;
  s << "subgraph cluster0 {" << ::std::endl;
  for (index_type k = 0; k < size(); k++) {
    s << "\tG0_" << k << " [label=\"" << k << "\"]"
      << ::std::endl;
  }
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j)) {
 if (!g.adjacent(c[i], c[j])) {
   s << "\tG0_" << i << " -> G0_" << j << " [style=bold];" << ::std::endl;
 }
 else {
   s << "\tG0_" << i << " -> G0_" << j << ";" << ::std::endl;
 }
      }
  s << "}" << ::std::endl;
  s << "subgraph cluster1 {" << ::std::endl;
  for (index_type k = 0; k < g.size(); k++) {
    s << "\tG1_" << k << " [label=\"" << k << "\"]"
      << ::std::endl;
  }
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (g.adjacent(c[i], c[j])) {
 if (!adjacent(i, j)) {
   s << "\tG1_" << i << " -> G1_" << j << " [style=bold];" << ::std::endl;
 }
 else {
   s << "\tG1_" << i << " -> G1_" << j << ";" << ::std::endl;
 }
      }
  s << "}" << ::std::endl;
  for (index_type k = 0; k < size(); k++) {
    s << "G0_" << k << " -> G1_" << c[k] << " [style=dashed,dir=none];"
      << ::std::endl;
  }
  s << "}" << ::std::endl;
}
void index_graph::reverse()
{
  for (index_type i = 0; i < size(); i++)
    for (index_type j = i+1; j < size(); j++) {
      if (adjacent(i, j) && !adjacent(j, i)) {
 index_type l = (edge_has_label(i, j) ? edge_label(i, j) : 0);
 remove_edge(i, j);
 if ((l & EDGE_DIR) == ED_FORWARD)
   l += (ED_BACK - ED_FORWARD);
 else if ((l & EDGE_DIR) == ED_BACK)
   l -= (ED_BACK - ED_FORWARD);
 add_edge(j, i, l);
      }
      else if (!adjacent(i, j) && adjacent(j, i)) {
 index_type l = (edge_has_label(j, i) ? edge_label(j, i) : 0);
 remove_edge(j, i);
 if ((l & EDGE_DIR) == ED_FORWARD)
   l += (ED_BACK - ED_FORWARD);
 else if ((l & EDGE_DIR) == ED_BACK)
   l -= (ED_BACK - ED_FORWARD);
 add_edge(i, j, l);
      }
    }
}
void index_graph::reflect()
{
  for (index_type i = 0; i < size(); i++)
    for (index_type j = i + 1; j < size(); j++)
      if (adjacent(i, j)) {
 assert(!adjacent(j, i));
 add_edge(j, i);
 index_type l = (edge_has_label(i, j) ? edge_label(i, j) : 0);
 edge_label(j, i) = l;
 if ((l & EDGE_DIR) == ED_FORWARD)
   edge_label(j, i) += (ED_BACK - ED_FORWARD);
 else if ((l & EDGE_DIR) == ED_BACK)
   edge_label(j, i) -= (ED_BACK - ED_FORWARD);
      }
      else if (adjacent(j, i)) {
 add_edge(i, j);
 index_type l = (edge_has_label(j, i) ? edge_label(j, i) : 0);
 edge_label(i, j) = l;
 if ((l & EDGE_DIR) == ED_FORWARD)
   edge_label(i, j) += (ED_BACK - ED_FORWARD);
 else if ((l & EDGE_DIR) == ED_BACK)
   edge_label(i, j) -= (ED_BACK - ED_FORWARD);
      }
}
void index_graph::write_node_style
(std::ostream& s, index_type l)
{
  s << "shape=";
  if ((l & NODE_SHAPE) == NS_ELLIPSE)
    s << "ellipse";
  else if ((l & NODE_SHAPE) == NS_BOX)
    s << "box";
  else if ((l & NODE_SHAPE) == NS_POINT)
    s << "point";
  else if ((l & NODE_SHAPE) == NS_DIAMOND)
    s << "diamond";
  else if ((l & NODE_SHAPE) == NS_HEXAGON)
    s << "hexagon";
  else if ((l & NODE_SHAPE) == NS_OCTAGON)
    s << "octagon";
  else if ((l & NODE_SHAPE) == NS_PLAINTEXT)
    s << "plaintext";
  else
    s << "circle";
  if ((l & NODE_STYLE) == NS_FILLED)
    s << ",style=filled";
  else if ((l & NODE_STYLE) == NS_BOLD)
    s << ",style=bold";
  else if ((l & NODE_STYLE) == NS_DASHED)
    s << ",style=dashed";
  else if ((l & NODE_STYLE) == NS_DOTTED)
    s << ",style=dotted";
  if ((l & NS_DOUBLE) == NS_DOUBLE)
    s << ",peripheries=2";
}
void index_graph::write_edge_style
(std::ostream& s, index_type l)
{
  if ((l & EDGE_DIR) == ED_FORWARD)
    s << "dir=forward";
  else if ((l & EDGE_DIR) == ED_BACK)
    s << "dir=back";
  else if ((l & EDGE_DIR) == ED_BOTH)
    s << "dir=both";
  else
    s << "dir=none";
  if ((l & EDGE_STYLE) == ES_BOLD)
    s << ",style=bold";
  else if ((l & EDGE_STYLE) == ES_DASHED)
    s << ",style=dashed";
  else if ((l & EDGE_STYLE) == ES_DOTTED)
    s << ",style=dotted";
}
void index_graph::write_styled_digraph
(std::ostream& s,
 bool with_node_indices,
 const char* name,
 index_type c_id) const
{
  if (c_id != no_such_index) {
    s << "subgraph cluster" << c_id << " {" << std::endl;
    s << "node [width=0.5,height=0.5];" << ::std::endl;
  }
  else if (name) {
    s << "digraph \"" << name << "\" {" << std::endl;
    s << "node [width=0.5,height=0.5];" << ::std::endl;
  }
  for (index_type k = 0; k < size(); k++) {
    s << "\t" << k + (c_id != no_such_index ? c_id : 0) << " [";
    write_node_style(s, node_has_label(k) ? node_label(k) : 0);
    if (with_node_indices)
      s << ",label=\"" << k << "\"];" << std::endl;
    else
      s << ",label=\"\"];" << std::endl;
  }
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j)) {
 s << "\t" << i + (c_id != no_such_index ? c_id : 0)
   << " -> " << j + (c_id != no_such_index ? c_id : 0) << " [";
 write_edge_style(s, edge_has_label(i, j) ? edge_label(i, j) : 0);
 s << "];" << std::endl;
      }
  if ((c_id != no_such_index) || (name != 0)) {
    s << "}" << ::std::endl;
  }
}
void index_graph::write_matrix
(std::ostream& s) const
{
  for (index_type i = 0; i < size(); i++) {
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j))
 s << ' ' << (edge_has_label(i, j) ? edge_label(i, j) : 0) + 1;
      else
 s << ' ' << 0;
    s << ' ' << (node_has_label(i) ? node_label(i) : 0) << std::endl;
  }
}
void index_graph::write_MATLAB
(std::ostream& s, const char* n, const char* t) const
{
  s << "defgraph('";
  if (n)
    s << n;
  else
    s << "NONAME";
  s << "', '";
  if (t)
    s << t;
  else
    s << "NOTYPE";
  s << "',[";
  for (index_type i = 0; i < size(); i++) {
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j))
 s << ' ' << (edge_has_label(i, j) ? edge_label(i, j) : 0) + 1;
      else
 s << ' ' << 0;
    if (i + 1 < size()) s << ";";
  }
  s << "], [";
  for (index_type i = 0; i < size(); i++) {
    s << ' ' << (node_has_label(i) ? node_label(i) : 0);
    if (i + 1 < size()) s << ";";
  }
  s << "]);" << std::endl;
}
weighted_graph& weighted_graph::quotient
(weighted_graph& g, const equivalence& eq) const
{
  g.init(eq.n_classes());
  index_vec m;
  eq.make_map(m);
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) && !eq(i, j))
 g.increment_edge_weight(m[i], m[j], weight(i, j));
}
hsps::rational weighted_graph::apx_weighted_independent_set_1(index_set& set) const
{
  set.clear();
  hsps::rational w_best = NEG_INF;
  hsps::rational w_max = max_node_weight();
  index_type m = ilog(size());
  for (index_type k = 1; k <= m; k++) {
    hsps::rational w_lb = (w_max / (1 << k));
    assert(w_lb > 0);
    hsps::rational w_ub = (w_max / (1 << (k - 1)));
    index_set nodes;
    for (index_type i = 0; i < size(); i++)
      if ((w_lb < weight(i)) && (weight(i) <= w_ub))
 nodes.insert(i);
    index_set maxI;
    apx_independent_set(nodes, maxI);
    hsps::rational w = 0;
    for (index_type i = 0; i < maxI.length(); i++)
      w += weight(maxI[i]);
    if (w > w_best) {
      set.assign_copy(maxI);
      w_best = w;
    }
  }
  return w_best;
}
hsps::rational weighted_graph::apx_weighted_independent_set_2(index_set& set) const
{
  weighted_vec<index_type,hsps::rational> sorted;
  for (index_type k = 0; k < size(); k++) {
    hsps::rational wd = (weight(bidirectional(k)) / weight(k));
    sorted.insert_increasing(k, wd);
  }
  set.clear();
  bool_vec rem(true, size());
  hsps::rational w = 0;
  for (index_type k = 0; k < size(); k++) {
    index_type i = sorted[k].value;
    if (rem[i] && (weight(i) > 0)) {
      set.insert(i);
      rem.subtract(bidirectional(i));
      w += weight(i);
    }
  }
  return w;
}
hsps::rational weighted_graph::apx_weighted_independent_set(index_set& set) const
{
  hsps::rational v1 = apx_weighted_independent_set_1(set);
  hsps::rational v2 = apx_weighted_independent_set_2(set);
  return hsps::rational::max(v1,v2);
}
void weighted_graph::add_edge(index_type src, index_type dst)
{
  graph::add_edge(src, dst);
}
void weighted_graph::add_edge(index_type src, index_type dst, hsps::rational w)
{
  graph::add_edge(src, dst);
  set_weight(src, dst, w);
}
void weighted_graph::increment_edge_weight
(index_type src, index_type dst, hsps::rational w)
{
  if (!adjacent(src, dst)) graph::add_edge(src, dst);
  set_weight(src, dst, weight(src, dst) + w);
}
void weighted_graph::add_undirected_edge(index_type n0, index_type n1)
{
  graph::add_undirected_edge(n0, n1);
}
void weighted_graph::add_undirected_edge
(index_type n0, index_type n1, hsps::rational w)
{
  graph::add_undirected_edge(n0, n1);
  set_weight(n0, n1, w);
  set_weight(n1, n0, w);
}
hsps::rational weighted_graph::weight(index_type n) const
{
  if (node_has_label(n)) {
    return node_label(n);
  }
  else {
    return 0;
  }
}
hsps::rational weighted_graph::weight(const index_set& ns) const
{
  hsps::rational sw = 0;
  for (index_type k = 0; k < ns.length(); k++) {
    assert(ns[k] < size());
    sw += weight(ns[k]);
  }
  return sw;
}
hsps::rational weighted_graph::weight(index_type n0, index_type n1) const
{
  if (edge_has_label(n0, n1)) {
    return edge_label(n0, n1);
  }
  else {
    return 0;
  }
}
hsps::rational weighted_graph::max_node_weight() const
{
  hsps::rational w_max = NEG_INF;
  for (index_type k = 0; k < size(); k++)
    if (weight(k) > w_max) w_max = weight(k);
  return w_max;
}
void weighted_graph::set_weight(index_type n, hsps::rational w)
{
  node_label(n) = w;
}
void weighted_graph::set_weight(index_type n0, index_type n1, hsps::rational w)
{
  edge_label(n0, n1) = w;
}
void weighted_graph::transitive_closure()
{
  for (index_type k = 0; k < size(); k++)
    for (index_type i = 0; i < size(); i++)
      for (index_type j = 0; j < size(); j++)
 if (adjacent(i, k) && adjacent(k, j)) {
   if (!adjacent(i, j)) {
     add_edge(i, j, weight(i, k) + weight(k, j));
   }
   else if ((weight(i, k) + weight(k, j)) < weight(i, j)) {
     set_weight(i, j, weight(i, k) + weight(k, j));
   }
 }
  recalculate();
}
hsps::rational weighted_graph::critical_path(cost_vec& s)
{
  cost_vec e(POS_INF, size());
  bool done = false;
  while (!done) {
    done = true;
    for (index_type k = 0; k < size(); k++) {
      hsps::rational p = 0;
      for (index_type i = 0; i < predecessors(k).length(); i++)
 p = hsps::rational::max(p,e[predecessors(k)[i]] + weight(predecessors(k)[i], k));
      if ((p + weight(k)) < e[k]) {
 e[k] = p + weight(k);
 done = false;
      }
    }
  }
  s.set_length(size());
  for (index_type k = 0; k < size(); k++)
    s[k] = (e[k] - weight(k));
  return cost_vec_util::max(e);
}
hsps::rational weighted_graph::max_flow(index_type s, index_type t)
{
  cost_matrix f(0, size(), size());
  return max_flow(s, t, f);
}
hsps::rational weighted_graph::max_flow(index_type s, index_type t, weighted_graph& rg)
{
  cost_matrix f(0, size(), size());
  hsps::rational m = max_flow(s, t, f);
  rg.init(size());
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j) && ((weight(i, j) - f[i][j]) > 0))
 rg.add_edge(i, j, weight(i, j) - f[i][j]);
  return m;
}
hsps::rational weighted_graph::max_flow(index_type s, index_type t, cost_matrix& f)
{
  f.assign_value(0, size(), size());
  pair_vec p;
  hsps::rational m = 0;
  hsps::rational a = augmenting_path(s, t, f, p);
  while (a > 0) {
    for (index_type k = 0; k < p.length(); k++) {
      f[p[k].first][p[k].second] =
 (f[p[k].first][p[k].second] + a);
      f[p[k].second][p[k].first] =
 (f[p[k].second][p[k].first] - a);
    }
    m += a;
    a = augmenting_path(s, t, f, p);
  }
  return m;
}
hsps::rational weighted_graph::min_cut(index_type s, index_type t, bool_vec& s_set)
{
  weighted_graph rg;
  hsps::rational c = max_flow(s, t, rg);
  rg.descendants(s, s_set);
}
hsps::rational weighted_graph::min_cut(index_type s, index_type t, pair_set& e_set)
{
  weighted_graph rg;
  hsps::rational c = max_flow(s, t, rg);
  bool_vec a_set;
  descendants(s, a_set);
  bool_vec s_set;
  rg.descendants(s, s_set);
  for (index_type i = 0; i < size(); i++) if (a_set[i])
    for (index_type j = 0; j < size(); j++) if (a_set[j])
      if (adjacent(i, j) && s_set[i] && !s_set[j])
 e_set.insert(index_pair(i, j));
  return c;
}
hsps::rational weighted_graph::augmenting_path
(index_type s, index_type t, const cost_matrix& f, pair_vec& p)
{
  cost_vec m(NEG_INF, size());
  m[t] = POS_INF;
  index_vec d(no_such_index, size());
  bool done = false;
  while (!done) {
    done = true;
    for (index_type i = 0; i < size(); i++) if (m[i] > 0) {
      for (index_type j = 0; j < predecessors(i).length(); j++) {
 hsps::rational fji =
   hsps::rational::min(weight(predecessors(i)[j], i) - f[predecessors(i)[j]][i],m[i]);
 if (fji > m[predecessors(i)[j]]) {
   m[predecessors(i)[j]] = fji;
   d[predecessors(i)[j]] = i;
   done = false;
 }
      }
    }
  }
  p.set_length(0);
  if (m[s] > 0) {
    index_type k = s;
    while (k != t) {
      assert(m[k] >= m[s]);
      assert(d[k] != no_such_index);
      p.append(index_pair(k,d[k]));
      k = d[k];
    }
  }
  return m[s];
}
index_pair weighted_graph::max_weight_edge() const
{
  hsps::rational w_max = NEG_INF;
  index_type n0 = no_such_index;
  index_type n1 = no_such_index;
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i,j) && ((n0 == no_such_index) || (weight(i, j) > w_max))) {
 n0 = i;
 n1 = j;
 w_max = weight(i, j);
      }
  return index_pair(n0, n1);
}
void weighted_graph::min_and_max_edges
(const index_set& nodes,
 pair_set& e_min, hsps::rational& w_min,
 pair_set& e_max, hsps::rational& w_max) const
{
  e_min.clear();
  w_min = POS_INF;
  e_max.clear();
  w_max = NEG_INF;
  for (index_type i = 0; i < nodes.length(); i++)
    for (index_type j = 0; j < nodes.length(); j++)
      if ((i != j) && adjacent(nodes[i], nodes[j])) {
 if (weight(nodes[i], nodes[j]) < w_min) {
   w_min = weight(nodes[i], nodes[j]);
   e_min.clear();
   e_min.insert(index_pair(nodes[i], nodes[j]));
 }
 else if (weight(nodes[i], nodes[j]) == w_min) {
   e_min.insert(index_pair(nodes[i], nodes[j]));
 }
 if (weight(nodes[i], nodes[j]) > w_max) {
   w_max = weight(nodes[i], nodes[j]);
   e_max.clear();
   e_max.insert(index_pair(nodes[i], nodes[j]));
 }
 else if (weight(nodes[i], nodes[j]) == w_max) {
   e_max.insert(index_pair(nodes[i], nodes[j]));
 }
      }
}
void weighted_graph::write_node_set(::std::ostream& s) const
{
  s << '{';
  for (index_type i = 0; i < size(); i++) {
    if (i > 0) s << ',';
    s << i << "[" << weight(i) << "]";
  }
  s << '}';
}
void weighted_graph::write_edge_set(::std::ostream& s) const
{
  s << '{';
  bool first = true;
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j)) {
 if (!first) s << ',';
 first = false;
 if (edge_has_label(i, j)) {
   s << i << "-[" << weight(i, j) << "]->" << j;
 }
 else {
   s << i << "->" << j;
 }
      }
  s << '}';
}
void weighted_graph::write_compact(::std::ostream& s) const
{
  s << '(';
  write_node_set(s);
  s << ',';
  write_edge_set(s);
  s << '}';
}
void weighted_graph::write_matrix(::std::ostream& s) const
{
  s << '[';
  for (index_type i = 0; i < size(); i++) {
    if (i > 0) s << ' ';
    s << '[';
    for (index_type j = 0; j < size(); j++) {
      if (j > 0) s << ',';
      if (adjacent(i, j)) {
 if (edge_has_label(i, j)) {
   s << std::resetiosflags(std::ios::scientific) << ((edge_label(i, j)).decimal());
 }
 else {
   s << "?";
 }
      }
      else {
 s << "INF";
      }
    }
    s << ']';
    if (i + 1 < size()) {
      s << ',' << '\n';
    }
    else {
      s << ']' << '\n';
    }
  }
}
hsps::rational weighted_graph::maximal_matching(weighted_graph& matching)
{
  index_type ni = no_such_index;
  index_type nj = no_such_index;
  for (index_type i = 0; (i < size()) && (ni == no_such_index); i++)
    for (index_type j = i + 1; (j < size()) && (nj == no_such_index); j++)
      if (adjacent(i, j) && adjacent(j, i)) {
 ni = i;
 nj = j;
      }
  if ((ni != no_such_index) && (nj != no_such_index)) {
    index_set s;
    s.fill(size());
    s.subtract(ni);
    s.subtract(nj);
    weighted_graph* g1 = new weighted_graph(*this, s);
    weighted_graph* m1 = new weighted_graph();
    hsps::rational v1 = weight(ni, nj) + g1->maximal_matching(*m1);
    delete g1;
    weighted_graph* g2 = new weighted_graph(*this);
    g2->remove_edge(ni, nj);
    hsps::rational v2 = g2->maximal_matching(matching);
    delete g2;
    if (v1 > v2) {
      matching.init(size());
      for (index_type i = 0; i < m1->size(); i++)
 for (index_type j = i + 1; j < m1->size(); j++)
   if (m1->adjacent(i, j) && m1->adjacent(j, i))
     matching.add_undirected_edge(s[i], s[j], weight(s[i], s[j]));
      matching.add_undirected_edge(ni, nj, weight(ni, nj));
    }
    delete m1;
    return hsps::rational::max(v1,v2);
  }
  else {
    matching.init(size());
    return 0;
  }
}
hsps::rational weighted_graph::apx_matching(bool_vec& matched)
{
  bool_vec rem(true, size());
  matched.assign_value(false, size());
  hsps::rational val[2] = {0,0};
  index_type i = 0;
  index_type v = rem.first(true);
  while (v != no_such_index) {
    rem[v] = false;
    bool done = false;
    while (!done) {
      hsps::rational w_max = NEG_INF;
      index_type v_next = no_such_index;
      for (index_type k = 0; k < bidirectional(v).length(); k++)
 if (rem[bidirectional(v)[k]] &&
     (weight(v, bidirectional(v)[k]) > w_max)) {
   w_max = weight(v, bidirectional(v)[k]);
   v_next = bidirectional(v)[k];
 }
      if (v_next != no_such_index) {
 val[i] += w_max;
 i = ((i + 1) % 2);
 matched[v] = true;
 matched[v_next] = true;
 rem[v_next] = false;
 v = v_next;
      }
      else {
 done = true;
      }
    }
    v = rem.first(true);
  }
  return hsps::rational::max(val[0],val[1]);
}
index_set_graph::index_set_graph
(const graph& g, const equivalence& eq)
  : labeled_graph<index_set,index_set>(eq.n_classes())
{
  index_vec m;
  eq.make_map(m);
  assert(m.length() == g.size());
  for (index_type i = 0; i < g.size(); i++)
    for (index_type j = 0; j < g.size(); j++)
      if (g.adjacent(i, j) && !eq(i, j))
 add_edge(m[i], m[j]);
  index_set ce;
  eq.canonical_elements(ce);
  assert(ce.length() == size());
  for (index_type i = 0; i < size(); i++)
    eq.class_elements(ce[i], node_label(i));
}
index_set_graph::index_set_graph
(const index_set_graph& g, const equivalence& eq)
{
  g.quotient(*this, eq);
}
index_set_graph& index_set_graph::quotient
(index_set_graph& g, const equivalence& eq) const
{
  graph::quotient(g, eq);
  g.clear_node_labels();
  g.clear_edge_labels();
  index_vec m;
  eq.make_map(m);
  for (index_type i = 0; i < g.size(); i++)
    g.node_label(i) = EMPTYSET;
  for (index_type i = 0; i < size(); i++)
    g.node_label(m[i]).insert(node_label(i));
}
index_set_graph& index_set_graph::union_reachable(index_set_graph& g) const
{
  g.copy(*this);
  for (index_type k = 0; k < size(); k++) {
    index_set n;
    g.descendants(k, n);
    for (index_type i = 0; i < n.length(); i++)
      g.node_label(k).insert(node_label(n[i]));
  }
}
void index_set_graph::merge_labels(const index_set& ns)
{
  if (ns.empty()) return;
  assert(ns[0] < size());
  for (index_type i = 1; i < ns.length(); i++) {
    assert(ns[i] < size());
    node_label(ns[0]).insert(node_label(ns[i]));
  }
  for (index_type i = 1; i < ns.length(); i++) {
    node_label(ns[i]).assign_copy(node_label(ns[0]));
  }
}
void index_set_graph::merge_labels_upwards()
{
  strongly_connected_components();
  equivalence eq;
  component_partitioning(eq);
  index_set_graph cdag(*((graph*)this), eq);
  for (index_type k = 0; k < cdag.size(); k++) {
    assert(!cdag.node_label(k).empty());
    merge_labels(cdag.node_label(k));
  }
  while (!cdag.empty()) {
    index_type l = cdag.first_leaf();
    assert(l != no_such_index);
    for (index_type i = 0; i < cdag.predecessors(l).length(); i++) {
      index_type n_i = cdag.predecessors(l)[i];
      assert(n_i < size());
      for (index_type j = 0; j < cdag.node_label(n_i).length(); j++) {
 index_type n_j = cdag.node_label(n_i)[j];
 assert(n_j < size());
 assert(!cdag.node_label(l).empty());
 assert(cdag.node_label(l)[0] < size());
 node_label(n_j).insert(node_label(cdag.node_label(l)[0]));
      }
    }
    cdag.remove_node(l);
  }
}
void index_set_graph::merge_labels_downwards()
{
  strongly_connected_components();
  equivalence eq;
  component_partitioning(eq);
  index_set_graph cdag(*((graph*)this), eq);
  for (index_type k = 0; k < cdag.size(); k++) {
    assert(!cdag.node_label(k).empty());
    merge_labels(cdag.node_label(k));
  }
  while (!cdag.empty()) {
    index_type l = cdag.first_root();
    assert(l != no_such_index);
    for (index_type i = 0; i < cdag.successors(l).length(); i++) {
      index_type n_i = cdag.successors(l)[i];
      for (index_type j = 0; j < cdag.node_label(n_i).length(); j++) {
 index_type n_j = cdag.node_label(n_i)[j];
 node_label(n_j).insert(node_label(cdag.node_label(l)[0]));
      }
    }
    cdag.remove_node(l);
  }
}
index_set_graph& index_set_graph::subgraph_set_size_gt
(index_set_graph& g, index_type l)
{
  index_set r;
  for (index_type k = 0; k < size(); k++)
    if (node_has_label(k)) {
      if (node_label(k).length() > l) r.insert(k);
    }
  subgraph(g, r);
  return g;
}
void index_set_graph::write_edge_set(::std::ostream& s) const
{
  s << '{';
  bool first = true;
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j)) {
 if (!first) s << ',';
 first = false;
 s << i << ":";
 if (node_has_label(i))
   s << node_label(i);
 else
   s << "[]";
 s << "->" << j << ":";
 if (node_has_label(j))
   s << node_label(j);
 else
   s << "[]";
      }
  s << '}';
}
void index_set_graph::write_digraph(::std::ostream& s, const char* name) const
{
  if (strncmp(name, "cluster", 7) == 0)
    s << "subgraph";
  else
    s << "digraph";
  s << " \"" << name << "\"" << ::std::endl << "{" << ::std::endl;
  for (index_type k = 0; k < size(); k++) {
    s << "\t" << k << " [label=\"" << k << ":{";
    if (node_has_label(k)) {
      for (index_type i = 0; i < node_label(k).length(); i++) {
 if (i > 0) s << ",";
 s << node_label(k)[i];
      }
    }
    s << "}\"];" << ::std::endl;
  }
  for (index_type i = 0; i < size(); i++)
    for (index_type j = 0; j < size(); j++)
      if (adjacent(i, j))
 s << "\t" << i << " -> " << j << ";" << ::std::endl;
  s << "}" << ::std::endl;
}
}
