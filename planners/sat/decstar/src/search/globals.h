#ifndef GLOBALS_H
#define GLOBALS_H

#include <iosfwd>
#include <memory>
#include <string>
#include <vector>

#ifndef NDEBUG
// #define DEBUG_SEARCH    // general debugging
// #define DEBUG_FACTORING
// #define DEBUG_PRUNING
// #define DEBUG_PLAN_EXTRACTION
//#define DEBUG_SUCCESSOR_GENERATION
// #define DEBUG_NEW_SG
//#define DEBUG_ACTION_SPLITTING        // factoring of operators in SuccessorGenerator
// #define DEBUG_PRECOMPUTE_GOAL_COST
// #define DEBUG_POR
#endif

class Axiom;
class AxiomEvaluator;
class CausalGraph;
class DomainTransitionGraph;
class Factoring;
class GraphCreator;
class IntPacker;
struct LeafFactorID;
class Operator;
class RandomNumberGenerator;
class State;
class StateID;
class SuccessorGenerator;
class Timer;
class StateRegistry;

bool test_goal(const State &state);
void save_plan(const std::vector<const Operator *> &plan, bool generates_multiple_plan_files);
int calculate_plan_cost(const std::vector<const Operator *> &plan);

void read_everything(std::istream &in);
void dump_everything();

bool is_unit_cost();
bool has_axioms();
void verify_no_axioms();
bool has_conditional_effects();
void verify_no_conditional_effects();
void verify_no_axioms_no_conditional_effects();

void check_magic(std::istream &in, std::string magic);

bool are_mutex(const std::pair<int, int> &a, const std::pair<int, int> &b);

extern bool g_use_metric;
extern int g_min_action_cost;
extern std::vector<int> g_min_action_cost_per_factor;
extern int g_max_action_cost;

extern size_t MAX_DUPLICATE_COUNTER;

extern std::unique_ptr<Factoring> g_factoring;

// HACK this is used to increase the g-value of a node generated by the search
// that was created by a center operator that has preconditions on the leaf
// g-value is increased by the sum of the minimum precondition cost of each
// leaf factor that puts preconditions on the center operator
extern int g_inc_g_by;

extern std::vector<std::string> g_variable_name;
extern std::vector<int> g_variable_domain;

extern std::vector<int> g_center;
extern std::vector<std::vector<int> > g_leaves;
extern std::vector<LeafFactorID> g_belongs_to_factor;
// stores the index in g_center/g_leaves[factor] for each variable
extern std::vector<size_t> g_new_index;

extern std::vector<std::vector<std::string> > g_fact_names;
extern std::vector<int> g_axiom_layers;
extern std::vector<int> g_default_axiom_values;

extern IntPacker *g_state_packer;
extern std::vector<IntPacker*> g_leaf_factor_packers;

// This vector holds the initial values *before* the axioms have been evaluated.
// Use the state registry to obtain the real initial state.
extern std::vector<int> g_initial_state_data;
// TODO The following function returns the initial state that is registered
//      in g_state_registry. This is only a short-term solution. In the
//      medium term, we should get rid of the global registry.
extern const State &g_initial_state();

// in decoupled search, this only contains the center goals (if any)
extern std::vector<std::pair<int, int> > g_goal;
extern std::vector<std::vector<std::pair<int, int> > > g_goals_per_factor;
// contains the locally minimal goal cost per factor
extern std::vector<int> g_min_goal_cost;
extern int g_sum_min_goal_cost;

extern std::vector<Operator> g_operators;
extern std::vector<Operator> g_axioms;
extern AxiomEvaluator *g_axiom_evaluator;
extern SuccessorGenerator *g_successor_generator;
extern std::vector<SuccessorGenerator*> g_leaf_successor_generators;
extern std::vector<DomainTransitionGraph *> g_transition_graphs;
extern CausalGraph *g_causal_graph;
extern Timer g_timer;

extern std::string g_plan_filename;
extern bool g_is_part_of_anytime_portfolio;
extern int g_num_previously_generated_plans;

extern RandomNumberGenerator g_rng;

extern std::unique_ptr<GraphCreator> g_symmetry_graph;

// Only one global object for now. Could later be changed to use one instance
// for each problem in this case the method State::get_id would also have to be
// changed.
extern StateRegistry *g_state_registry;



#endif
