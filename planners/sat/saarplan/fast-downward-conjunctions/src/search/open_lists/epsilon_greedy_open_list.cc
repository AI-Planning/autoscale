#include "epsilon_greedy_open_list.h"

#include "../option_parser.h"
#include "../plugin.h"

#include "../utils/memory.h"

using namespace std;


EpsilonGreedyOpenListFactory::EpsilonGreedyOpenListFactory(
    const Options &options)
    : options(options) {
}

unique_ptr<StateOpenList>
EpsilonGreedyOpenListFactory::create_state_open_list() {
    return utils::make_unique_ptr<EpsilonGreedyOpenList<StateOpenListEntry>>(options);
}

unique_ptr<EdgeOpenList>
EpsilonGreedyOpenListFactory::create_edge_open_list() {
    return utils::make_unique_ptr<EpsilonGreedyOpenList<EdgeOpenListEntry>>(options);
}

static shared_ptr<OpenListFactory> _parse(OptionParser &parser) {
    parser.document_synopsis(
        "Epsilon-greedy open list",
        "Chooses an entry uniformly randomly with probability "
        "'epsilon', otherwise it returns the minimum entry. "
        "The algorithm is based on" + utils::format_paper_reference(
            {"Richard Valenzano", "Nathan R. Sturtevant",
             "Jonathan Schaeffer", "Fan Xie"},
            "A Comparison of Knowledge-Based GBFS Enhancements and"
            " Knowledge-Free Exploration",
            "http://www.aaai.org/ocs/index.php/ICAPS/ICAPS14/paper/view/7943/8066",
            "Proceedings of the Twenty-Fourth International Conference"
            " on Automated Planning and Scheduling (ICAPS 2014)",
            "375-379",
            "AAAI Press 2014"));
    parser.add_option<ScalarEvaluator *>("eval", "scalar evaluator");
    parser.add_option<bool>(
        "pref_only",
        "insert only nodes generated by preferred operators", "false");
    parser.add_option<double>(
        "epsilon",
        "probability for choosing the next entry randomly",
        "0.2",
        Bounds("0.0", "1.0"));

    Options opts = parser.parse();
    if (parser.dry_run()) {
        return nullptr;
    } else {
        return make_shared<EpsilonGreedyOpenListFactory>(opts);
    }
}

static PluginShared<OpenListFactory> _plugin("epsilon_greedy", _parse);
