#ifndef SEARCH_SPACE_H
#define SEARCH_SPACE_H

#include <vector>
#include <set>
#include "aras_state.h"
#include "operator.h"
#include <algorithm>
#include <climits>
#include <cassert>
#include <ext/hash_map>
#include <set>
#define LOADING_FACTOR 2
#define PER_NODE_OVERHEAD 12
using namespace std;
class Operator;
class ArasState;

class SearchNodeInfo {
    friend class SearchNode;
    friend class SearchSpace;

    enum NodeStatus {NEW = 0, OPEN = 1, CLOSED = 2, DEAD_END = 3};
    enum ExpandStatus {NOT_EXPANDED = 0, EXPANDED = 1};

    /*
     NodeStatus status;
     int g;
     int h;
     */

    unsigned int status : 2;
    unsigned int expand_status : 1;
    unsigned int reg_expand_status : 1;
    int h : 28;
    int g : 32;
    //int level;

    set<pair<unsigned short *, const Operator *> > parents;
    // vector<const Operator *> creating_operator;


public:
    SearchNodeInfo() :
        status(NEW), expand_status(NOT_EXPANDED), h(-1), g(-1){
            // cout << "size search nodeinfo: " << sizeof(SearchNodeInfo) << endl;
    }

};

class StateProxy {
    // This class is basically a pointer that can be reassigned even
    // though it is const. This is needed for the hash table below,
    // where a node may first be inserted with a pointer to a
    // temporary object as the key, which will then later be replaced
    // with a pointer to a heap-allocated object generated by
    // make_permanent below.
    // Despite the const-ness, mutating the key of a hash_map in place
    // is fine as long as the mutation does not affect the hash value
    // (which this one does not, as it only changes the address of the
    // state, whereas the contents of the state are used for hashing).

    // Update: This was changed from a ArasState* to an unsigned short*
    //         that points "inside" the state to shave off some memory.
public:
    mutable unsigned short *state_data;
    mutable bool borrowed_buffer;
    ~StateProxy() {
        if(! borrowed_buffer)
            delete[] state_data;
    }
    StateProxy() {
        state_data = 0;
        borrowed_buffer = false;
    }

    StateProxy(unsigned short *state_data_) {
        state_data = state_data_;
        borrowed_buffer = true;
    }

    explicit StateProxy(const ArasState *state) {
        state_data = const_cast<unsigned short *>(state->get_buffer());
        borrowed_buffer = true;
    }

    const StateProxy &operator=(const StateProxy &other) const {
        borrowed_buffer = true;
        state_data = other.state_data;
        return *this;
    }
    bool operator==(const StateProxy &other) const {
        return ArasState(state_data) == ArasState(other.state_data);
    }
    void make_permanent() const {
        borrowed_buffer = false;
        unsigned short *new_buffer = new unsigned short[g_variable_domain.size()];
        for (int i = 0; i < g_variable_domain.size(); i++)
            new_buffer[i] = state_data[i];
        state_data = new_buffer;
    }
};

namespace __gnu_cxx {
template<> struct hash<StateProxy> {
    size_t operator()(const StateProxy &state_proxy) const {
        return ArasState(state_proxy.state_data).hash();
    }
};
}

class SearchNode {
    unsigned short *state_buffer;
    SearchNodeInfo &info;
    size_t* parents_num;

public:
    SearchNode(unsigned short *state_buffer_, SearchNodeInfo &info_, size_t* parents_num_byte);

    unsigned short *get_state_buffer() {
      return state_buffer;
    }
    ArasState get_state() const;

    bool is_goal() const;
    bool is_open() const;
    bool is_closed() const;
    bool is_dead_end() const;
    bool is_expanded() const;
    bool is_reg_expanded() const;
    bool is_new() const;

    int get_f() const;
    int get_g() const;
    int get_h() const;
    int get_level() const;
    int get_parent_num() const;

    void set_level(int  l);

	void add_parent(const SearchNode &parent_node, const Operator *parent_op);
	void make_permanent();
	void make_reg_permanent();


	void lazy_open(int h, const SearchNode &parent_node, const Operator *parent_op);
	void lazy_reopen(const SearchNode &parent_node, const Operator *parent_op);

	void update_and_open(int h, int g, int op_cost);
	void update_and_reopen(int g, int op_cost);

    void open_initial(int h);
    void open(int h, const SearchNode &parent_node, const Operator *parent_op);
    void reopen(const SearchNode &parent_node, const Operator *parent_op);

    void open(int h, const SearchNode &parent_node, const Operator *parent_op, int op_cost);
    void reopen(const SearchNode &parent_node, const Operator *parent_op, int op_cost);

    void close();
    void mark_as_dead_end();
    /*const vector<unsigned short *>& get_parent_states();
    const vector<const Operator *>& get_creating_operator();*/
    const vector<pair<unsigned short *, const Operator *> > get_parents();


    void dump();
};

//class BoostingNode : public SearchNode{
	
// };

class SearchSpace {
public:

private:
    friend class HashTable;

    class HashTable : public __gnu_cxx::hash_map<StateProxy, SearchNodeInfo> {
    // This is more like a typedef really, but we need a proper class
    // so that we can hide the information in the header file by using
    // a forward declaration. This is also the reason why the hash
    // table is allocated dynamically in the constructor.
    };

public:
    HashTable *nodes;
    bool keep_shallow_copy;
    size_t parents_num;
public:
    SearchSpace();
    ~SearchSpace();
    int size() const;
    size_t memory_usage() const;
    
    SearchNode get_node(const ArasState &state);
    // SearchNode get_itsa_node(const ArasState &state);
    void trace_path(const ArasState &goal_state,
		    std::vector<const Operator *> &path) const;

    void set_shallow(){
    	keep_shallow_copy = true;
    }
    void dump();
    void statistics() const;


    //These two functions are used to check whether
    //the state or search node is in the search space
    bool InSearchSpace(const SearchNode &node) const;
    bool InSearchSpace(const ArasState &state) const;

public:
    friend class SearchNodeIterator;

    class SearchNodeIterator
    {
    public:
        SearchNodeIterator(SearchSpace& ss);

        /** Advance the state of the iteration to the next stone. */
        void operator++();

        /** Return the current stone. */
        SearchNode operator*();

        /** Return true if iteration is valid, otherwise false. */
        operator bool();

    private:
        SearchSpace& m_searchSpace;
        SearchSpace::HashTable::iterator m_it;
    };

};



#endif
